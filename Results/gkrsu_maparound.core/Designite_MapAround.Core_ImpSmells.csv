Implementation smell,Namespace,Class,File,Method,Description
Long Method,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolygonOverlay,The method has 112 lines of code.
Long Method,MapAround.Geometry,PlanimetryAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,DeterminantSign,The method has 170 lines of code.
Long Method,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculteInternalInternal,The method has 119 lines of code.
Long Method,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The method has 147 lines of code.
Long Method,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalExternal,The method has 168 lines of code.
Long Method,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The method has 113 lines of code.
Long Method,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,processLinePath,The method has 121 lines of code.
Long Method,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,BuildFaces,The method has 105 lines of code.
Long Method,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,processContour,The method has 104 lines of code.
Long Method,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,processContour,The method has 123 lines of code.
Long Method,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPrismPolygon,The method has 101 lines of code.
Long Method,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The method has 113 lines of code.
Long Method,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The method has 208 lines of code.
Long Method,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPolylineWithIntersectCalculation,The method has 125 lines of code.
Long Method,MapAround.MathUtils,SvdDecomposer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\MathUtils\MathUtils.cs,CalcDecomposition,The method has 286 lines of code.
Long Method,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The method has 119 lines of code.
Long Method,MapAround.Rendering,SpanGenerator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,addSpans,The method has 113 lines of code.
Long Method,MapAround.Web,MapServerBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,GetImage,The method has 119 lines of code.
Long Method,MapAround.Web,MapServerBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,GetVectorInfo,The method has 112 lines of code.
Long Method,MapAround.Web,JSONMpHelper,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,drawPolylineWithIntersectCalculation,The method has 113 lines of code.
Long Method,MapAround.Web.Wms,WMSServer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsServer.cs,GetFeatureInfo,The method has 183 lines of code.
Long Method,MapAround.Web.Wms,WMSServer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsServer.cs,GetMap,The method has 247 lines of code.
Long Method,MapAround.Web.Wms,WMSServer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsServer.cs,CheckRequestParams,The method has 100 lines of code.
Long Method,MapAround.Web.Wmts,WMTSServer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WMTSServer.cs,GetFeatureInfo,The method has 179 lines of code.
Long Method,MapAround.Web.Wmts,WMTSServer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WMTSServer.cs,GetTile,The method has 207 lines of code.
Complex Method,MapAround.CoordinateSystems,GeographicCoordinateSystem,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,EqualParams,Cyclomatic complexity of the method is 12
Complex Method,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,AlbersProjection,Cyclomatic complexity of the method is 10
Complex Method,MapAround.CoordinateSystems.Projections,LambertConformalConic2SP,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LambertConformalConic2SP,Cyclomatic complexity of the method is 9
Complex Method,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,adjustLon,Cyclomatic complexity of the method is 8
Complex Method,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,calculateOptimalAffineTransformPoints,Cyclomatic complexity of the method is 9
Complex Method,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,Transform,Cyclomatic complexity of the method is 8
Complex Method,MapAround.CoordinateSystems.Transformations,GeocentricTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,MetersToDegrees,Cyclomatic complexity of the method is 9
Complex Method,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,CreateFromCoordinateSystems,Cyclomatic complexity of the method is 8
Complex Method,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,Cyclomatic complexity of the method is 12
Complex Method,MapAround.DataProviders,ShapeFileSpatialDataProvider,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\ShapeFileDataProvider.cs,internalQueryFeatures,Cyclomatic complexity of the method is 11
Complex Method,MapAround.DataProviders,ShapeFileSpatialDataProvider,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\ShapeFileDataProvider.cs,geometryFromShapeRecord,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Extensions.Surfaces,IsolineBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,getIsoline,Cyclomatic complexity of the method is 12
Complex Method,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPolylineStyle,Cyclomatic complexity of the method is 15
Complex Method,MapAround.Geometry,PolygonBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PolygonBuilding.cs,markDangles,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,GetBuffer,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,MonotoneChain,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\DataStructures.cs,Split,Cyclomatic complexity of the method is 13
Complex Method,MapAround.Geometry,DistanceCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\DataStructures.cs,calculateDistanceBrutForce,Cyclomatic complexity of the method is 15
Complex Method,MapAround.Geometry,Contour,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,ReduceSegments,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Geometry,Contour,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,GetSelfIntersectionPoint,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,SplitToConnectedDomains,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,getShellPointInHole,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,getHolePointInShell,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,getHolesIntersectionError,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,hasCycles,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,processCycle,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,hasNonSinglePointTouch,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,GetBoundingRectangle,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,getInteriorPoint,Cyclomatic complexity of the method is 11
Complex Method,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,PointOnSurface,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,ContourLayoutElement,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,TryAddFromList,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,LinePath,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,ReduceSegments,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Geometry,Polyline,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,GetBoundingRectangle,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Geometry,Polyline,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,getWrongSelfIntersectionError,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,BoundingRectangle,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Intersects,Cyclomatic complexity of the method is 17
Complex Method,MapAround.Geometry,BoundingRectangle,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Intersects,Cyclomatic complexity of the method is 18
Complex Method,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,CalculateOverlay,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,calculateNonIntersectedObjectsOverlay,Cyclomatic complexity of the method is 11
Complex Method,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPointOverlay,Cyclomatic complexity of the method is 11
Complex Method,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolygonPolygonOverlay,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolylinePolylineOverlay,Cyclomatic complexity of the method is 17
Complex Method,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolylineOverlay,Cyclomatic complexity of the method is 17
Complex Method,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolygonOverlay,Cyclomatic complexity of the method is 19
Complex Method,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolylinePolygonOverlay,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,calculateOverlay,Cyclomatic complexity of the method is 20
Complex Method,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,isAreaEdgeEnabled,Cyclomatic complexity of the method is 20
Complex Method,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,init,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,translateGeometry,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Geometry,PlanimetryAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,RobustSegmentsIntersection,Cyclomatic complexity of the method is 13
Complex Method,MapAround.Geometry,PlanimetryAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,GetConvexHull,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Geometry,PlanimetryAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,filterPointsForConvexHull,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,PlanimetryAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,SnapToGrid,Cyclomatic complexity of the method is 13
Complex Method,MapAround.Geometry,PlanimetryAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,DeterminantSign,Cyclomatic complexity of the method is 33
Complex Method,MapAround.Geometry,GeometrySimplifier,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,getCrossPointsIndex,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,GeometrySimplifier,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,checkWeightedVertex,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateValue,Cyclomatic complexity of the method is 11
Complex Method,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculteInternalInternal,Cyclomatic complexity of the method is 32
Complex Method,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsBounds,Cyclomatic complexity of the method is 22
Complex Method,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,Cyclomatic complexity of the method is 39
Complex Method,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalExternal,Cyclomatic complexity of the method is 36
Complex Method,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,Cyclomatic complexity of the method is 24
Complex Method,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,Matches,Cyclomatic complexity of the method is 14
Complex Method,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,addVerticesAsNodes,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,addSourceSegments,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,addOrMergeNode,Cyclomatic complexity of the method is 13
Complex Method,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegmentByNodes,Cyclomatic complexity of the method is 13
Complex Method,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegmentBySegments,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegmentsByCrossPoints,Cyclomatic complexity of the method is 15
Complex Method,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,addSplittedSegment,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,getNodeAt,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,processLinePath,Cyclomatic complexity of the method is 24
Complex Method,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,BuildFaces,Cyclomatic complexity of the method is 16
Complex Method,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitContour,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,processContour,Cyclomatic complexity of the method is 20
Complex Method,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,processContour,Cyclomatic complexity of the method is 24
Complex Method,MapAround.IO,DbaseFieldDescriptor,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseFieldDescriptor.cs,GetDbaseType,Cyclomatic complexity of the method is 14
Complex Method,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,AddColumn,Cyclomatic complexity of the method is 14
Complex Method,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,RecountColumnLength,Cyclomatic complexity of the method is 12
Complex Method,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,Cyclomatic complexity of the method is 30
Complex Method,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,Cyclomatic complexity of the method is 68
Complex Method,MapAround.IO,DbaseWriter,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseWriter.cs,Write,Cyclomatic complexity of the method is 13
Complex Method,MapAround.IO,DbaseWriter,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseWriter.cs,Write,Cyclomatic complexity of the method is 9
Complex Method,MapAround.IO,DbaseWriter,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseWriter.cs,Write,Cyclomatic complexity of the method is 9
Complex Method,MapAround.IO,StreamTokenizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\CommonWktClasses.cs,NextTokenAny,Cyclomatic complexity of the method is 12
Complex Method,MapAround.IO,DbaseReader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseReader.cs,readDbfValue,Cyclomatic complexity of the method is 15
Complex Method,MapAround.Mapping,Map,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,CalculateBoundingRectangle,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Mapping,Map,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,Render,Cyclomatic complexity of the method is 15
Complex Method,MapAround.Mapping,RasterLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,LoadRasterPreview,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,BuildPointsIndex,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderFeaturesSample,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,Cyclomatic complexity of the method is 16
Complex Method,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,Cyclomatic complexity of the method is 17
Complex Method,MapAround.Mapping,Feature,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,Clone,Cyclomatic complexity of the method is 11
Complex Method,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,setXml,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPolylineStyle,Cyclomatic complexity of the method is 15
Complex Method,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processLayer,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateOptimalAffineTransformPoints,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateRubberSheetTransform,Cyclomatic complexity of the method is 11
Complex Method,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,fillPixel,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,BindRaster,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPrismPolygon,Cyclomatic complexity of the method is 17
Complex Method,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,Cyclomatic complexity of the method is 21
Complex Method,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolygon,Cyclomatic complexity of the method is 15
Complex Method,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,addTitleBufferElement,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,Cyclomatic complexity of the method is 34
Complex Method,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPolylineWithIntersectCalculation,Cyclomatic complexity of the method is 17
Complex Method,MapAround.MathUtils,SvdDecomposer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\MathUtils\MathUtils.cs,CalcDecomposition,Cyclomatic complexity of the method is 61
Complex Method,MapAround.MathUtils,Matrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\MathUtils\MathUtils.cs,GetInverseMatrix,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geography,GeoContour,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,ReduceSegments,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Geography,EllipticOverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticOverlays.cs,CalculateOverlay,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geography,GeoBufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeoBuffer.cs,getPolylineBuffer,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geography,GeoBufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeoBuffer.cs,GetBuffer,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Geometry.Tessellations,FortuneShoreLine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,FindArc,Cyclomatic complexity of the method is 14
Complex Method,MapAround.Geometry.Tessellations,FortuneShoreLine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,removeArcRecursive,Cyclomatic complexity of the method is 18
Complex Method,MapAround.Geometry.Tessellations,FortuneShoreLine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,Finish,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Geometry.Tessellations,VoronoiBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,handlePointEvent,Cyclomatic complexity of the method is 11
Complex Method,MapAround.Geometry.Tessellations,VoronoiBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,handleCircleEvent,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Geometry.Tessellations,VoronoiBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,init,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry.Tessellations,VoronoiBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,Build,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Indexing,KDTreeNode,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\KDTree.cs,Insert,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Indexing,KDTreeNode,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\KDTree.cs,BuildUnbalanced,Cyclomatic complexity of the method is 11
Complex Method,MapAround.Indexing,QuadTreeNode,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\QuadTree.cs,insertIntoChild,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Indexing,QuadTreeNode,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\QuadTree.cs,canAddingToChildCell,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Indexing,QuadTreeNode,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\QuadTree.cs,Remove,Cyclomatic complexity of the method is 13
Complex Method,MapAround.Indexing,QuadTreeNode,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\QuadTree.cs,QueryObjectsInRectangle,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Indexing,QuadTreeNode,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\QuadTree.cs,QueryObjectsContainingPoint,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Rendering,LineTransformationSequence,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\LineTransformations.cs,GetLines,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Rendering,StrokeGenerator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\LineTransformations.cs,GetLines,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addJoin,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Rendering,SpanGenerator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,addSpans,Cyclomatic complexity of the method is 25
Complex Method,MapAround.Rendering,Region,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,fillEdgeTableForHorizontalScanning,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Rendering,Region,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,fillEdgeTableForVerticalScanning,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Rendering,Region,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeHorizontalProperCrossesWinding,Cyclomatic complexity of the method is 13
Complex Method,MapAround.Rendering,Region,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeHorizontalProperCrossesAlternate,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Rendering,Region,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeVerticalProperCrossesAlternate,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Rendering,Region,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeVerticalProperCrossesWinding,Cyclomatic complexity of the method is 13
Complex Method,MapAround.Rendering,Region,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeHorizontalWindingIntersections,Cyclomatic complexity of the method is 13
Complex Method,MapAround.Rendering,Region,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeVerticalWindingIntersections,Cyclomatic complexity of the method is 13
Complex Method,MapAround.Serialization,WKTGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,GetPolylineWKT,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Serialization,WKTGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,GetPolygonWKT,Cyclomatic complexity of the method is 14
Complex Method,MapAround.Serialization,WKBGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,SerializePolygon,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Serialization,CoordinateSystemWktDeserializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\SpatialReferenceSerializers.cs,ReadAxis,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Web,MapServerBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,GetImage,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Web,MapServerBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,WriteLayer,Cyclomatic complexity of the method is 13
Complex Method,MapAround.Web,MapServerBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,GetVectorInfo,Cyclomatic complexity of the method is 14
Complex Method,MapAround.Web,MapServerBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,ParseBbox,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Web,JSONMpHelper,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,drawPolylineWithIntersectCalculation,Cyclomatic complexity of the method is 13
Complex Method,MapAround.Web,JSONMpHelper,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,DrawPolygon,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Web.Wms,WmsCapabilities,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsCapabilities.cs,GenerateServiceNode,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Web.Wms,WmsCapabilities,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsCapabilities.cs,GenerateContactInfoElement,Cyclomatic complexity of the method is 15
Complex Method,MapAround.Web.Wms,WMSServer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsServer.cs,GetFeatureInfo,Cyclomatic complexity of the method is 25
Complex Method,MapAround.Web.Wms,WMSServer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsServer.cs,GetMap,Cyclomatic complexity of the method is 28
Complex Method,MapAround.Web.Wms,WMSServer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsServer.cs,CheckRequestParams,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Web.Wmts,WmtsCapabilities,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,GenerateServiceNode,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Web.Wmts,WmtsCapabilities,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,GenerateContactInfoElement,Cyclomatic complexity of the method is 15
Complex Method,MapAround.Web.Wmts,WMTSServer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WMTSServer.cs,GetFeatureInfo,Cyclomatic complexity of the method is 24
Complex Method,MapAround.Web.Wmts,WMTSServer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WMTSServer.cs,GetTile,Cyclomatic complexity of the method is 23
Complex Method,MapAround.Web.Wmts,WMTSServer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WMTSServer.cs,CheckRequestParams,Cyclomatic complexity of the method is 10
Long Parameter List,MapAround.Caching,ITileCacheAccessor,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Caching\TileCaching.cs,SaveTileBytes,The method has 5 parameters. Parameters: layer' area' key' tile' contentType
Long Parameter List,MapAround.CoordinateSystems,Unit,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,Unit,The method has 7 parameters. Parameters: conversionFactor' name' authority' authorityCode' alias' abbreviation' remarks
Long Parameter List,MapAround.CoordinateSystems,LinearUnit,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,LinearUnit,The method has 7 parameters. Parameters: metersPerUnit' name' authority' authorityCode' alias' abbreviation' remarks
Long Parameter List,MapAround.CoordinateSystems,AngularUnit,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,AngularUnit,The method has 7 parameters. Parameters: radiansPerUnit' name' authority' authorityCode' alias' abbreviation' remarks
Long Parameter List,MapAround.CoordinateSystems,Ellipsoid,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,Ellipsoid,The method has 11 parameters. Parameters: semiMajorAxis' semiMinorAxis' inverseFlattening' isIvfDefinitive' axisUnit' name' authority' code' alias' abbreviation' remarks
Long Parameter List,MapAround.CoordinateSystems,PrimeMeridian,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,PrimeMeridian,The method has 8 parameters. Parameters: longitude' angularUnit' name' authority' authorityCode' alias' abbreviation' remarks
Long Parameter List,MapAround.CoordinateSystems,Datum,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,Datum,The method has 7 parameters. Parameters: type' name' authority' code' alias' remarks' abbreviation
Long Parameter List,MapAround.CoordinateSystems,HorizontalDatum,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,HorizontalDatum,The method has 9 parameters. Parameters: ellipsoid' toWgs84' type' name' authority' code' alias' remarks' abbreviation
Long Parameter List,MapAround.CoordinateSystems,SpatialReferenceInfo,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,SpatialReferenceInfo,The method has 6 parameters. Parameters: name' authority' code' alias' abbreviation' remarks
Long Parameter List,MapAround.CoordinateSystems,ICoordinateSystemFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateGeographicCoordinateSystem,The method has 6 parameters. Parameters: name' angularUnit' datum' primeMeridian' axis0' axis1
Long Parameter List,MapAround.CoordinateSystems,ICoordinateSystemFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateProjectedCoordinateSystem,The method has 6 parameters. Parameters: name' gcs' projection' linearUnit' axis0' axis1
Long Parameter List,MapAround.CoordinateSystems,CoordinateSystem,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CoordinateSystem,The method has 6 parameters. Parameters: name' authority' authorityCode' alias' abbreviation' remarks
Long Parameter List,MapAround.CoordinateSystems,CoordinateSystemFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateProjectedCoordinateSystem,The method has 6 parameters. Parameters: name' gcs' projection' linearUnit' axis0' axis1
Long Parameter List,MapAround.CoordinateSystems,CoordinateSystemFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateGeographicCoordinateSystem,The method has 6 parameters. Parameters: name' angularUnit' datum' primeMeridian' axis0' axis1
Long Parameter List,MapAround.CoordinateSystems,GeocentricCoordinateSystem,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,GeocentricCoordinateSystem,The method has 10 parameters. Parameters: datum' linearUnit' primeMeridian' axisinfo' name' authority' code' alias' remarks' abbreviation
Long Parameter List,MapAround.CoordinateSystems,GeographicCoordinateSystem,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,GeographicCoordinateSystem,The method has 10 parameters. Parameters: angularUnit' horizontalDatum' primeMeridian' axisInfo' name' authority' authorityCode' alias' abbreviation' remarks
Long Parameter List,MapAround.CoordinateSystems,HorizontalCoordinateSystem,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,HorizontalCoordinateSystem,The method has 8 parameters. Parameters: datum' axisInfo' name' authority' code' alias' remarks' abbreviation
Long Parameter List,MapAround.CoordinateSystems,ProjectedCoordinateSystem,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,ProjectedCoordinateSystem,The method has 11 parameters. Parameters: datum' geographicCoordinateSystem' linearUnit' projection' axisInfo' name' authority' code' alias' remarks' abbreviation
Long Parameter List,MapAround.CoordinateSystems,Wgs84ConversionInfo,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\WGS84ConversionInfo.cs,Wgs84ConversionInfo,The method has 7 parameters. Parameters: dx' dy' dz' ex' ey' ez' ppm
Long Parameter List,MapAround.CoordinateSystems,Wgs84ConversionInfo,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\WGS84ConversionInfo.cs,Wgs84ConversionInfo,The method has 8 parameters. Parameters: dx' dy' dz' ex' ey' ez' ppm' areaOfUse
Long Parameter List,MapAround.CoordinateSystems.Projections,Projection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,Projection,The method has 8 parameters. Parameters: className' parameters' name' authority' code' alias' remarks' abbreviation
Long Parameter List,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,mlfn,The method has 5 parameters. Parameters: e0' e1' e2' e3' phi
Long Parameter List,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,getAffineTransformMatrix,The method has 6 parameters. Parameters: p01' p02' p03' p11' p12' p13
Long Parameter List,MapAround.CoordinateSystems.Transformations,CoordinateTransformation,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,CoordinateTransformation,The method has 9 parameters. Parameters: sourceCS' targetCS' transformType' mathTransform' name' authority' authorityCode' areaOfUse' remarks
Long Parameter List,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Affine,The method has 6 parameters. Parameters: m11' m12' m21' m22' dx' dy
Long Parameter List,MapAround.DataProviders,IRasterProvider,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\RasterProviders.cs,QueryRaster,The method has 8 parameters. Parameters: srcX' srcY' srcWidth' srcHeight' maxDestWidth' maxDestHeight' bounds' receiver
Long Parameter List,MapAround.DataProviders,InMemoryRasterProvider,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\RasterProviders.cs,QueryRaster,The method has 8 parameters. Parameters: srcX' srcY' srcWidth' srcHeight' maxDestWidth' maxDestHeight' bounds' receiver
Long Parameter List,MapAround.DataProviders,ShapeFileSpatialDataProvider,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\ShapeFileDataProvider.cs,processFeature,The method has 6 parameters. Parameters: feature' fr' points' multiPoints' polylines' polygons
Long Parameter List,MapAround.DataProviders,ShapeFileSpatialDataProvider,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\ShapeFileDataProvider.cs,addFeaturesToCache,The method has 5 parameters. Parameters: fr' points' multiPoints' polylines' polygons
Long Parameter List,MapAround.Extensions.Surfaces,ShadedReliefBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\ShadedReliefBuilder.cs,GetLuminosity,The method has 5 parameters. Parameters: triangle' lightX' lightY' lightZ' zFactor
Long Parameter List,MapAround.Extensions.Surfaces,ShadedReliefBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\ShadedReliefBuilder.cs,BuildShadedRelief,The method has 6 parameters. Parameters: triangles' lightX' lightY' lightZ' zFactor' luminosityLevelNumber
Long Parameter List,MapAround.Extensions.Surfaces,ShadedReliefBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\ShadedReliefBuilder.cs,BuildShadedRelief,The method has 6 parameters. Parameters: surfacePoints' lightX' lightY' lightZ' zFactor' luminosityLevelNumber
Long Parameter List,MapAround.Extensions.Surfaces,IsolineBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,assignLevelsToPolygons,The method has 5 parameters. Parameters: surfacePoints' polygons' triangles' zLevels' bounds
Long Parameter List,MapAround.Extensions.Surfaces,IsolineBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,assignLevelsToPolygons,The method has 6 parameters. Parameters: surfaceMin' surfaceMax' polygons' triangles' zLevels' bounds
Long Parameter List,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getArcPoints,The method has 5 parameters. Parameters: point' startAngle' endAngle' distance' pointsPerCircle
Long Parameter List,MapAround.Geometry,DistanceCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\DataStructures.cs,calculateDistanceBrutForce,The method has 5 parameters. Parameters: geometry1' geometry2' points1' points2' threshold
Long Parameter List,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,addPoints,The method has 5 parameters. Parameters: graph' operation' p1' p2' collection
Long Parameter List,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,addPolyline,The method has 5 parameters. Parameters: graph' operation' p1' p2' collection
Long Parameter List,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,addPolygon,The method has 5 parameters. Parameters: graph' operation' p1' p2' collection
Long Parameter List,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolygonPolygonOverlay,The method has 5 parameters. Parameters: polygon1' polygon2' operation' result' performSnapping
Long Parameter List,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolylinePolylineOverlay,The method has 5 parameters. Parameters: polyline1' polyline2' operation' result' performSnapping
Long Parameter List,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolylineOverlay,The method has 6 parameters. Parameters: mp' polyline' operation' result' performSnapping' inverseArgs
Long Parameter List,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolygonOverlay,The method has 6 parameters. Parameters: mp' polygon' operation' result' performSnapping' inverseArgs
Long Parameter List,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolylinePolygonOverlay,The method has 6 parameters. Parameters: polyline' polygon' operation' result' performSnapping' inverseArgs
Long Parameter List,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,isNodeEnabled,The method has 5 parameters. Parameters: node' operation' polyline' polygon' inverseArgs
Long Parameter List,MapAround.Geometry,SDMinVertexWeightNeededEventArgs,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,SDMinVertexWeightNeededEventArgs,The method has 5 parameters. Parameters: previousPoint' point' nextPoint' pathIndex' pointIndex
Long Parameter List,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,AddColumn,The method has 5 parameters. Parameters: fieldName' fieldType' DataType' fieldLength' decimalCount
Long Parameter List,MapAround.Mapping,IRasterRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterRendering.cs,RenderRaster,The method has 6 parameters. Parameters: g' bitmap' style' viewBox' bitmapBounds' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultRasterRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterRendering.cs,RenderRaster,The method has 6 parameters. Parameters: g' bitmap' style' viewBox' bitmapBounds' scaleFactor
Long Parameter List,MapAround.Mapping,RasterBinding,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RasterBinding,The method has 5 parameters. Parameters: rasterX' rasterY' mapPoint' pixelWidth' pixelHeight
Long Parameter List,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,renderPolygons,The method has 5 parameters. Parameters: g' viewBox' mapCoordsViewBox' titlesVisible' scaleFactor
Long Parameter List,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,renderPolylines,The method has 5 parameters. Parameters: g' viewBox' mapCoordsViewBox' titlesVisible' scaleFactor
Long Parameter List,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,renderPointFeatureCollection,The method has 6 parameters. Parameters: points' g' viewBox' mapCoordsViewBox' titlesVisible' scaleFactor
Long Parameter List,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,renderPoints,The method has 5 parameters. Parameters: g' viewBox' mapCoordsViewBox' titlesVisible' scaleFactor
Long Parameter List,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The method has 5 parameters. Parameters: coordinate' width' height' contentAlignment' selectedFeature
Long Parameter List,MapAround.Mapping,LayerLegendSettings,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,LayerLegendSettings,The method has 6 parameters. Parameters: displayPointSample' displayPolylineSample' displayPolygonSample' pointSampleTitle' polylineSampleTitle' polygonSampleTitle
Long Parameter List,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,getAffineTransformMatrix,The method has 6 parameters. Parameters: p01' p02' p03' p11' p12' p13
Long Parameter List,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateRubberSheetTransform,The method has 7 parameters. Parameters: width' height' source' result' sourceNodes' destNodesShifts' progress
Long Parameter List,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,fillPixel,The method has 6 parameters. Parameters: x' y' bmp' fillCount' width' height
Long Parameter List,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateAffinneTransform,The method has 6 parameters. Parameters: width' height' affinneTransformResult' sourceNodes' destNodes' progress
Long Parameter List,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,notifyProgessListenerIfNeeded,The method has 6 parameters. Parameters: progress' startProgressPercent' endProgressPercent' completed' previousPercent' sourceWidth
Long Parameter List,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,BindRaster,The method has 5 parameters. Parameters: source' sourceControlPoints' destinationControlPoints' rectangle' progress
Long Parameter List,MapAround.Mapping,IFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The method has 7 parameters. Parameters: feature' g' style' titleStyle' viewBox' titleVisible' scaleFactor
Long Parameter List,MapAround.Mapping,IFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolyline,The method has 7 parameters. Parameters: feature' g' style' titleStyle' viewBox' titleVisible' scaleFactor
Long Parameter List,MapAround.Mapping,IFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolygon,The method has 7 parameters. Parameters: feature' g' style' titleStyle' viewBox' titleVisible' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The method has 7 parameters. Parameters: feature' g' style' titleStyle' viewBox' titleVisible' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolyline,The method has 7 parameters. Parameters: feature' g' style' titleStyle' viewBox' titleVisible' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolygon,The method has 7 parameters. Parameters: feature' g' style' titleStyle' viewBox' titleVisible' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The method has 7 parameters. Parameters: feature' g' style' titleStyle' viewBox' titleVisible' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolyline,The method has 7 parameters. Parameters: feature' g' style' titleStyle' viewBox' titleVisible' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolygon,The method has 7 parameters. Parameters: feature' g' style' titleStyle' viewBox' titleVisible' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,addTitleBufferElement,The method has 5 parameters. Parameters: g' feature' titleStyle' viewBox' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,addTitleBufferElement,The method has 5 parameters. Parameters: titleStyle' targetPoint' size' scaleFactor' feature
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The method has 7 parameters. Parameters: g' part' length' label' titleStyle' viewBox' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getLeftPoints,The method has 6 parameters. Parameters: points' firstPoint' targetDistance' vertexNumber' halfFontHeight' rotationDeltas
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRightPoints,The method has 6 parameters. Parameters: points' firstPoint' targetDistance' vertexNumber' halfFontHeight' rotationDeltas
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawVisiblePolylinePart,The method has 5 parameters. Parameters: g' path' pen' viewBox' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawVisiblePolylinePartWithStyleDetection,The method has 9 parameters. Parameters: g' path' style' defaultPen' annexPen' selected' viewBox' scaleFactor' lengthFromBegining
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPolylineWithIntersectCalculation,The method has 5 parameters. Parameters: g' feature' style' viewBox' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPolylineSimple,The method has 5 parameters. Parameters: g' feature' style' viewBox' scaleFactor
Long Parameter List,MapAround.Mapping,FollowingTitleElement,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,FollowingTitleElement,The method has 8 parameters. Parameters: translationPoint' rotationAngle' titleOrigin' substring' v1' v2' v3' v4
Long Parameter List,MapAround.MathUtils,SvdDecomposer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\MathUtils\MathUtils.cs,svdLeastSquares,The method has 7 parameters. Parameters: U' w' V' m' n' b' x
Long Parameter List,MapAround.MathUtils,SvdDecomposer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\MathUtils\MathUtils.cs,CalcDecomposition,The method has 9 parameters. Parameters: A' m' n' w' matu' U' matv' V' ierr
Long Parameter List,MapAround.Geography,GeoBufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeoBuffer.cs,getArcPoints,The method has 5 parameters. Parameters: point' startAngle' endAngle' distance' pointsPerCircle
Long Parameter List,MapAround.Geography,GeoBufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeoBuffer.cs,getBoundsBuffer,The method has 5 parameters. Parameters: polygon' projection' distance' pointsPerCircle' allowParallels
Long Parameter List,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The method has 5 parameters. Parameters: ellipsoid' start' startBearing' distance' endBearing
Long Parameter List,MapAround.Rendering,HatchFill,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Fills.cs,HatchFill,The method has 5 parameters. Parameters: pattern' color1' color2' originX' originY
Long Parameter List,MapAround.Rendering,StrokeGenerator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\LineTransformations.cs,getStrokePoints,The method has 5 parameters. Parameters: points' startLength' strokeLength' segmentIndex' traversedLength
Long Parameter List,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getCirclePoints,The method has 5 parameters. Parameters: point' startAngle' endAngle' distance' pointsPerCircle
Long Parameter List,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The method has 7 parameters. Parameters: cap' vertexList' capLocation' x1' y1' x2' y2
Long Parameter List,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addInteriorJoin,The method has 7 parameters. Parameters: vertexList' x1' y1' x2' y2' x3' y3
Long Parameter List,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addJoin,The method has 8 parameters. Parameters: join' vertexList' x1' y1' x2' y2' x3' y3
Long Parameter List,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,SetPixel,The method has 6 parameters. Parameters: x' y' r' g' b' a
Long Parameter List,MapAround.Rendering,PixelSpan,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,GetSolid,The method has 5 parameters. Parameters: orientation' x' y' pixelData' length
Long Parameter List,MapAround.Rendering,IScannable,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,InitScaning,The method has 5 parameters. Parameters: minX' maxX' minY' maxY' orientation
Long Parameter List,MapAround.Rendering,SpanGenerator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,GetHorizontalSpans,The method has 6 parameters. Parameters: sourceGeometry' minX' minY' maxX' maxY' fill
Long Parameter List,MapAround.Rendering,SpanGenerator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,GetVerticalSpans,The method has 6 parameters. Parameters: sourceGeometry' minX' minY' maxX' maxY' fill
Long Parameter List,MapAround.Rendering,SpanGenerator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,addSpans,The method has 5 parameters. Parameters: orientation' spans' pixelScanIntersections' scanPosition' fill
Long Parameter List,MapAround.Rendering,SimpleCircle,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,InitScaning,The method has 5 parameters. Parameters: minX' maxX' minY' maxY' orientation
Long Parameter List,MapAround.Rendering,Region,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,InitScaning,The method has 5 parameters. Parameters: minX' maxX' minY' maxY' orientation
Long Parameter List,MapAround.Web,MapServerBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,GetImage,The method has 5 parameters. Parameters: width' height' backColor' useLayers' bboxWithGutters
Long Parameter List,MapAround.Web,MapServerBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,WriteLayer,The method has 6 parameters. Parameters: json' layer' bboxWithGutters' mapViewBox' scaleFactor' requestParams
Long Parameter List,MapAround.Web,MapServerBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,GetVector,The method has 6 parameters. Parameters: layerNumber' width' height' useLayers' bboxWithGutters' requestParams
Long Parameter List,MapAround.Web,MapServerBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,CheckRequestParams,The method has 6 parameters. Parameters: requestParams' responseOutputStream' responseContentType' originalBbox' width' height
Long Parameter List,MapAround.Web.Wms,WmsCapabilities,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsCapabilities.cs,createElement,The method has 5 parameters. Parameters: name' value' doc' IsXml' namespaceURI
Long Parameter List,MapAround.Web.Wms,WMSServer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsServer.cs,CheckRequestParams,The method has 6 parameters. Parameters: requestParams' responseOutputStream' responseContentType' originalBbox' width' height
Long Parameter List,MapAround.Web.Wmts,WmtsCapabilities,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,createElement,The method has 5 parameters. Parameters: name' value' doc' IsXml' namespaceURI
Long Parameter List,MapAround.Web.Wmts,WMTSServer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WMTSServer.cs,CheckRequestParams,The method has 6 parameters. Parameters: requestParams' responseOutputStream' responseContentType' originalBbox' width' height
Long Identifier,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,,The length of the parameter _affineTransformPointsIndicies is 30.
Long Identifier,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,,The length of the parameter _defaultPolylinesIndexSettings is 30.
Long Identifier,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,,The length of the parameter _invalidFeatureAdditionErrorMessage is 35.
Long Identifier,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,,The length of the parameter _invalidFeatureDeletionErrorMessage is 35.
Long Identifier,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,,The length of the parameter _invalidFeaturesDeletionErrorMessage is 36.
Long Statement,MapAround.CoordinateSystems,HorizontalDatum,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,EqualParams,The length of the statement  "                datum.Ellipsoid.EqualParams(this.Ellipsoid) || datum == null && this.Ellipsoid == null) && this.DatumType == datum.DatumType; " is 125.
Long Statement,MapAround.CoordinateSystems,CoordinateSystem,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,GetAxis,The length of the statement  "				throw new ArgumentException("AxisInfo not available for dimension " + dimension.ToString(CultureInfo.InvariantCulture)); " is 120.
Long Statement,MapAround.CoordinateSystems,CoordinateSystemFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateEllipsoid,The length of the statement  "            return new Ellipsoid(semiMajorAxis' semiMinorAxis' 1.0' false' linearUnit' name' String.Empty' -1' String.Empty' string.Empty' string.Empty); " is 141.
Long Statement,MapAround.CoordinateSystems,CoordinateSystemFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateFlattenedSphere,The length of the statement  "            return new Ellipsoid(semiMajorAxis' -1' inverseFlattening' true' linearUnit' name' String.Empty' -1' String.Empty' String.Empty' String.Empty); " is 143.
Long Statement,MapAround.CoordinateSystems,CoordinateSystemFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateProjectedCoordinateSystem,The length of the statement  "            return new ProjectedCoordinateSystem(null' gcs' linearUnit' projection' info' name' String.Empty' -1' String.Empty' String.Empty' String.Empty); " is 144.
Long Statement,MapAround.CoordinateSystems,CoordinateSystemFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateProjection,The length of the statement  "            return new Projection(wktProjectionClass' parameters' name' String.Empty' -1' String.Empty' String.Empty' String.Empty); " is 120.
Long Statement,MapAround.CoordinateSystems,CoordinateSystemFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateHorizontalDatum,The length of the statement  "            return new HorizontalDatum(ellipsoid' toWgs84' datumType' name' String.Empty' -1' String.Empty' String.Empty' String.Empty); " is 124.
Long Statement,MapAround.CoordinateSystems,CoordinateSystemFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateGeographicCoordinateSystem,The length of the statement  "            return new GeographicCoordinateSystem(angularUnit' datum' primeMeridian' info' name' String.Empty' -1' String.Empty' String.Empty' String.Empty); " is 145.
Long Statement,MapAround.CoordinateSystems,CoordinateSystemFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateGeocentricCoordinateSystem,The length of the statement  "            return new GeocentricCoordinateSystem(datum' linearUnit' primeMeridian' info' name' String.Empty' -1' String.Empty' String.Empty' String.Empty); " is 144.
Long Statement,MapAround.CoordinateSystems.Projections,Projection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,EqualParams,The length of the statement  "                ProjectionParameter param = _parameters.Find(delegate(ProjectionParameter par) { return par.Name.Equals(proj.GetParameter(i).Name' StringComparison.OrdinalIgnoreCase); }); " is 171.
Long Statement,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The length of the statement  "            double ro = Math.Sqrt(Math.Pow(p[0] * _metersPerUnit - _falseEasting' 2) + Math.Pow(ro0 - (p[1] * _metersPerUnit - _falseNorthing)' 2)); " is 136.
Long Statement,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The length of the statement  "                lat += (Math.Pow(1 - e2sin2' 2) / (2 * Math.Cos(lat))) * ((q / (1 - e_sq)) - sin / (1 - e2sin2) + 1 / (2 * e) * Math.Log((1 - e * sin) / (1 + e * sin))); " is 153.
Long Statement,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The length of the statement  "                double y = _falseNorthing + this._semiMajor * k0 * Math.Log(Math.Tan(PI * 0.25 + dLatitude * 0.5) * Math.Pow((1 - esinphi) / (1 + esinphi)' e * 0.5)); " is 150.
Long Statement,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,EqualParams,The length of the statement  "                ProjectionParameter param = _parameters.Find(delegate(ProjectionParameter par) { return par.Name.Equals(proj.GetParameter(i).Name' StringComparison.OrdinalIgnoreCase); }); " is 171.
Long Statement,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LongitudeToRadians,The length of the statement  "            throw new ArgumentOutOfRangeException("x"' x.ToString(CultureInfo.InvariantCulture) + " not a valid longitude in degrees."); " is 124.
Long Statement,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LatitudeToRadians,The length of the statement  "            throw new ArgumentOutOfRangeException("y"' y.ToString(CultureInfo.InvariantCulture) + " not a valid latitude in degrees."); " is 123.
Long Statement,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,calculateOptimalAffineTransformPoints,The length of the statement  "                                currentNorm += PlanimetryAlgorithms.Distance(_destinationControlPoints[i]' PlanimetryEnvironment.NewCoordinate(tempPoints[i].X' tempPoints[i].Y)); " is 146.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,Geog2Geoc,The length of the statement  "            return new CoordinateTransformation(source' target' TransformType.Conversion' geocMathTransform' String.Empty' String.Empty' -1' String.Empty' String.Empty); " is 157.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,Geoc2Geog,The length of the statement  "            return new CoordinateTransformation(source' target' TransformType.Conversion' geocMathTransform' String.Empty' String.Empty' -1' String.Empty' String.Empty); " is 157.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,Proj2Proj,The length of the statement  "            ct.CoordinateTransformationList.Add(ctFac.CreateFromCoordinateSystems(source.GeographicCoordinateSystem' target.GeographicCoordinateSystem)); " is 141.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,Geog2Proj,The length of the statement  "                IMathTransform mathTransform = CreateCoordinateOperation(target.Projection' target.GeographicCoordinateSystem.HorizontalDatum.Ellipsoid' target.LinearUnit); " is 156.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,Proj2Geog,The length of the statement  "                IMathTransform mathTransform = CreateCoordinateOperation(source.Projection' source.GeographicCoordinateSystem.HorizontalDatum.Ellipsoid' source.LinearUnit).Inverse(); " is 166.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,CreateGeog2Geog,The length of the statement  "                IGeocentricCoordinateSystem sourceCentric = cFac.CreateGeocentricCoordinateSystem(source.HorizontalDatum.Name + " Geocentric"' " is 126.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,CreateGeog2Geog,The length of the statement  "                IGeocentricCoordinateSystem targetCentric = cFac.CreateGeocentricCoordinateSystem(target.HorizontalDatum.Name + " Geocentric"' " is 126.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,CreateGeoc2Geoc,The length of the statement  "                    ((target.HorizontalDatum.Wgs84Parameters == null || target.HorizontalDatum.Wgs84Parameters.HasZeroValuesOnly) ? target : GeocentricCoordinateSystem.WGS84)' " is 155.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,CreateGeoc2Geoc,The length of the statement  "                    ((source.HorizontalDatum.Wgs84Parameters == null || source.HorizontalDatum.Wgs84Parameters.HasZeroValuesOnly) ? source : GeocentricCoordinateSystem.WGS84)' " is 155.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,CreateGeoc2Geoc,The length of the statement  "            if (ct.CoordinateTransformationList.Count == 1) //Since we only have one shift' lets just return the datumshift from/to wgs84 " is 125.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,CreateGeoc2Geoc,The length of the statement  "                return new CoordinateTransformation(source' target' TransformType.ConversionAndTransformation' ct.CoordinateTransformationList[0].MathTransform' ""' ""' -1' ""' ""); " is 165.
Long Statement,MapAround.CoordinateSystems.Transformations,GeometryTransformer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformers.cs,TransformBoundingRectangle,The length of the statement  "            corners[2] = PlanimetryEnvironment.NewCoordinate(transform.Transform(PlanimetryEnvironment.NewCoordinate(box.MinX' box.MaxY).Values())); " is 136.
Long Statement,MapAround.CoordinateSystems.Transformations,GeometryTransformer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformers.cs,TransformBoundingRectangle,The length of the statement  "            corners[3] = PlanimetryEnvironment.NewCoordinate(transform.Transform(PlanimetryEnvironment.NewCoordinate(box.MaxX' box.MinY).Values()));  " is 136.
Long Statement,MapAround.Extensions.Surfaces,ShadedReliefBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\ShadedReliefBuilder.cs,GetLuminosity,The length of the statement  "            double D = -(p1.X * (p2.Y * p3.Z - p3.Y * p2.Z) + p2.X * (p3.Y * p1.Z - p1.Y * p3.Z) + p3.X * (p1.Y * p2.Z - p2.Y * p1.Z)); " is 123.
Long Statement,MapAround.Extensions.Surfaces,IsolineBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,BuildPolygonsForLevelRanges,The length of the statement  "                assignLevelsToPolygons(surfacePoints' polygons' triangles' zLevels' PlanimetryAlgorithms.GetPointsBoundingRectangle(coonvexHull)); " is 130.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addTitleStyleElement,The length of the statement  "            addAttribute( titleStyleElement' "render_priority"' ((int)TitleStyle.RenderPriority).ToString(CultureInfo.InvariantCulture)); " is 125.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addPolygonStyleElement,The length of the statement  "            addAttribute( polygonStyleElement' "border_dash_style"' ((int)PolygonStyle.BorderDashStyle).ToString(CultureInfo.InvariantCulture)); " is 132.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addPolygonStyleElement,The length of the statement  "            addAttribute( polygonStyleElement' "border_dash_cap"' ((int)PolygonStyle.BorderDashCap).ToString(CultureInfo.InvariantCulture)); " is 128.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addPolygonStyleElement,The length of the statement  "            addAttribute( polygonStyleElement' "hatch_style"' ((int)PolygonStyle.HatchStyle).ToString(CultureInfo.InvariantCulture)); " is 121.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addPolygonStyleElement,The length of the statement  "            addAttribute( polygonStyleElement' "fill_pattern"' ((int)PolygonStyle.FillPattern).ToString(CultureInfo.InvariantCulture)); " is 123.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addPolygonStyleElement,The length of the statement  "            addAttribute( polygonStyleElement' "fill_transparent"' PolygonStyle.FillBackColor.A.ToString(CultureInfo.InvariantCulture)); " is 124.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addPolylineStyleElement,The length of the statement  "            addAttribute( polylineStyleElement' "dash_style"' ((int)PolylineStyle.DashStyle).ToString(CultureInfo.InvariantCulture)); " is 121.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addPolylineStyleElement,The length of the statement  "            addAttribute( polylineStyleElement' "annex_dash_style"' ((int)PolylineStyle.AnnexDashStyle).ToString(CultureInfo.InvariantCulture)); " is 132.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addPolylineStyleElement,The length of the statement  "            addAttribute( polylineStyleElement' "annex_dash_cap"' ((int)PolylineStyle.AnnexDashCap).ToString(CultureInfo.InvariantCulture)); " is 128.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addPolylineStyleElement,The length of the statement  "            addAttribute( polylineStyleElement' "outline_width"' PolylineStyle.OutlineWidth.ToString(CultureInfo.InvariantCulture)); " is 120.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addPolylineStyleElement,The length of the statement  "            addAttribute( polylineStyleElement' "outline_transparent"' PolylineStyle.OutlineColor.A.ToString(CultureInfo.InvariantCulture)); " is 128.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPolygonStyle,The length of the statement  "                PolygonStyle.BorderDashStyle = (DashStyle)int.Parse(polygonStyle.Attributes["border_dash_style"].Value' CultureInfo.InvariantCulture); " is 134.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPolygonStyle,The length of the statement  "                PolygonStyle.HatchStyle = (HatchStyle)int.Parse(polygonStyle.Attributes["hatch_style"].Value' CultureInfo.InvariantCulture); " is 124.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPolygonStyle,The length of the statement  "                    PolygonStyle.BorderDashCap = (DashCap)int.Parse(polygonStyle.Attributes["border_dash_cap"].Value' CultureInfo.InvariantCulture); " is 128.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPolygonStyle,The length of the statement  "                    PolygonStyle.FillBackColor = Color.FromArgb(int.Parse(polygonStyle.Attributes["fill_transparent"].Value' CultureInfo.InvariantCulture)' PolygonStyle.FillBackColor); " is 164.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPolygonStyle,The length of the statement  "                    PolygonStyle.FillPattern = (BuiltInFillPatterns)int.Parse(polygonStyle.Attributes["fill_pattern"].Value' CultureInfo.InvariantCulture); " is 135.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPolylineStyle,The length of the statement  "                PolylineStyle.DashStyle = (DashStyle)int.Parse(polylineStyle.Attributes["dash_style"].Value' CultureInfo.InvariantCulture); " is 123.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPolylineStyle,The length of the statement  "                    PolylineStyle.AnnexDashStyle = (DashStyle)int.Parse(polylineStyle.Attributes["annex_dash_style"].Value' CultureInfo.InvariantCulture); " is 134.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPolylineStyle,The length of the statement  "                        PolylineStyle.AnnexDashCap = (DashCap)int.Parse(polylineStyle.Attributes["annex_dash_cap"].Value' CultureInfo.InvariantCulture); " is 128.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPolylineStyle,The length of the statement  "                    PolylineStyle.OutlineColor = Color.FromArgb(int.Parse(polylineStyle.Attributes["outline_transparent"].Value' CultureInfo.InvariantCulture)' PolylineStyle.OutlineColor); " is 168.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPointStyle,The length of the statement  "                    PointStyle.DisplayKind = (PointDisplayKind)(int.Parse(pointStyle.Attributes["display_kind"].Value' CultureInfo.InvariantCulture)); " is 130.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPointStyle,The length of the statement  "                if ( (pointStyle.Attributes["contentAlignment"]!=null) && (Enum.TryParse(pointStyle.Attributes["contentAlignment"].Value'true'out contentAlignment))) " is 149.
Long Statement,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getArcPoints,The length of the statement  "                result[i] = PlanimetryEnvironment.NewCoordinate(point.X + distance * Math.Cos(angle)' point.Y + distance * Math.Sin(angle)); " is 124.
Long Statement,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getArcPoints,The length of the statement  "            result[n] = PlanimetryEnvironment.NewCoordinate(point.X + distance * Math.Cos(endAngle)' point.Y + distance * Math.Sin(endAngle)); " is 130.
Long Statement,MapAround.Geometry,MonotoneChain,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\DataStructures.cs,ReplaceLabel,The length of the statement  "                throw new ArgumentOutOfRangeException("The index should not be negative and smaller than the size of the collection"' "index"); " is 127.
Long Statement,MapAround.Geometry,PointD,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,GetBoundingRectangle,The length of the statement  "            return new BoundingRectangle(PlanimetryEnvironment.NewCoordinate(_coordinate.X' _coordinate.Y)' PlanimetryEnvironment.NewCoordinate(_coordinate.X' _coordinate.Y)); " is 163.
Long Statement,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,calcContourNestingList,The length of the statement  "                            testPoint = (new Segment(singleContourPolygons[i].Contours[0].Vertices[0]' singleContourPolygons[i].Contours[0].Vertices[1])).Center(); " is 135.
Long Statement,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,hasNonSinglePointTouch,The length of the statement  "            Segment segmentStub = new Segment(PlanimetryEnvironment.NewCoordinate(0' 0)' PlanimetryEnvironment.NewCoordinate(0' 0)); " is 120.
Long Statement,MapAround.Geometry,Polyline,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,getWrongSelfIntersectionError,The length of the statement  "                        if (PlanimetryAlgorithms.SegmentsIntersection(s1' s2' out pointStub' out segmentStub) == MapAround.Geometry.Dimension.One) " is 122.
Long Statement,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,CalculateOverlay,The length of the statement  "                            throw new NotSupportedException(string.Format("Overlay calculation for \"{0}\" is not supported"' geometry1.GetType().FullName)); " is 129.
Long Statement,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,CalculateOverlay,The length of the statement  "                            throw new NotSupportedException(string.Format("Overlay calculation for \"{0}\" is not supported"' geometry2.GetType().FullName)); " is 129.
Long Statement,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolygonPolygonOverlay,The length of the statement  "                        throw new InvalidOperationException("Unable to complete operation correctly with this value of tolerance (PlanimertyAlgorithms.Tolerance)"); " is 140.
Long Statement,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolylinePolylineOverlay,The length of the statement  "                        throw new InvalidOperationException("Unable to complete operation correctly with this value of tolerance (PlanimertyAlgorithms.Tolerance)"); " is 140.
Long Statement,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolylineOverlay,The length of the statement  "                        throw new InvalidOperationException("Unable to complete operation correctly with this value of tolerance (PlanimertyAlgorithms.Tolerance)"); " is 140.
Long Statement,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolygonOverlay,The length of the statement  "                        throw new InvalidOperationException("Unable to complete operation correctly with this value of tolerance (PlanimertyAlgorithms.Tolerance)"); " is 140.
Long Statement,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolylinePolygonOverlay,The length of the statement  "                        throw new InvalidOperationException("Unable to complete operation correctly with this value of tolerance (PlanimertyAlgorithms.Tolerance)"); " is 140.
Long Statement,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,simplifyLinePaths,The length of the statement  "                        throw new InvalidOperationException("Unable to complete operation correctly with this value of tolerance (PlanimertyAlgorithms.Tolerance)"); " is 140.
Long Statement,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,simplifyContours,The length of the statement  "                        throw new InvalidOperationException("Unable to complete operation correctly with this value of tolerance (PlanimertyAlgorithms.Tolerance)"); " is 140.
Long Statement,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The length of the statement  "                        if ((!inverseArgs && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2 && !polygon2.ContainsPoint(edge.CenterPoint())) || " is 125.
Long Statement,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,addVerticesAsNodes,The length of the statement  "            throw new NotSupportedException(string.Format("Planar graph building for \"{0}\" is not supported."' g.GetType().FullName)); " is 124.
Long Statement,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,addSourceSegments,The length of the statement  "            throw new NotSupportedException(string.Format("Planar graph building for \"{0}\" is not supported."' g.GetType().FullName)); " is 124.
Long Statement,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitContour,The length of the statement  "                segments.Add(new Segment(contour.Vertices[i]' i == contour.Vertices.Count - 1 ? contour.Vertices[0] : contour.Vertices[i + 1])); " is 128.
Long Statement,MapAround.IO,StreamTokenizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\CommonWktClasses.cs,GetNumericValue,The length of the statement  "            throw new InvalidDataException(String.Format(CultureInfo.InvariantCulture.NumberFormat' "Lexem '{0}' is not a number. Line {1} position {2}."' " is 142.
Long Statement,MapAround.IO,WktStreamTokenizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\CommonWktClasses.cs,ReadToken,The length of the statement  "                throw new ArgumentException(String.Format(CultureInfo.InvariantCulture.NumberFormat' "Expected ('{3}')' but goes '{0}'. Line {1}' position {2}."' this.GetStringValue()' this.LineNumber' this.Column' expectedToken)); " is 215.
Long Statement,MapAround.IO,DbaseReader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseReader.cs,readDbfValue,The length of the statement  "                    throw (new NotSupportedException("Unable to process field '" + dbf.Name + "' (data type '" + dbf.DataType.ToString() + "')")); " is 126.
Long Statement,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadHeader,The length of the statement  "                string msg = String.Format(System.Globalization.CultureInfo.InvariantCulture' "Invalid FileCode encountered. Expecting {0}."' ShapeFile._expectedFileCode); " is 155.
Long Statement,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadRecord,The length of the statement  "                //            string msg = String.Format(System.Globalization.CultureInfo.InvariantCulture' "ShapeType {0} is not supported."' (int)record.ShapeType); " is 150.
Long Statement,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteShapes,The length of the statement  "                throw new ArgumentException("Geometries in the shape file should be the instances of the same type."' "geometryCollection"); " is 124.
Long Statement,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteShapes,The length of the statement  "                    Handlers.ShapeHandler handler = ShapeFile.GetShapeHandler(ShapeFile.GetShapeType(geometryCollection[0]));//.Geometries[0])); " is 124.
Long Statement,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,GetShapeHandler,The length of the statement  "                    string msg = String.Format(System.Globalization.CultureInfo.InvariantCulture' "ShapeType {0} is not supported."' (int)type); " is 124.
Long Statement,MapAround.IO.Handlers,MultiLineHandler,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiLineHandler.cs,GetLength,The length of the statement  "            return (22 + (2 * numParts) + geometry.CoordinateCount/*.NumPoints*/ * 8); // 22 => shapetype(2) + bbox(4*4) + numparts(2) + numpoints(2) " is 137.
Long Statement,MapAround.IO.Handlers,MultiPointHandler,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiPointHandler.cs,Write,The length of the statement  "                throw new ArgumentException("Geometry Type error: MultiPoint expected' but the type retrieved is " + geometry.GetType().Name); " is 126.
Long Statement,MapAround.IO.Handlers,MultiPointHandler,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiPointHandler.cs,Write,The length of the statement  "            BoundingRectangle bounds = geometry.GetBoundingRectangle();//GetEnvelopeExternal(/*geometryFactory.PrecisionModel'*/ box); " is 122.
Long Statement,MapAround.IO.Handlers,PolygonHandler,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\PolygonHandler.cs,Write,The length of the statement  "            BoundingRectangle bounds = geometry.GetBoundingRectangle(); // GetEnvelopeExternal(/*geometryFactory.PrecisionModel'*/  box); " is 125.
Long Statement,MapAround.IO.Handlers,PolygonHandler,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\PolygonHandler.cs,GetLength,The length of the statement  "            return (22 + (2 * numParts) + (geometry.CoordinateCount + numParts) * 8); // 22 => shapetype(2) + bbox(4*4) + numparts(2) + numpoints(2) " is 136.
Long Statement,MapAround.Mapping,PolygonStyle,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,brushPatternParamsChanged,The length of the statement  "            _brushPattern = new Bitmap(_originalBrushPattern.Width' _originalBrushPattern.Height' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 138.
Long Statement,MapAround.Mapping,Map,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderPolylineSampleInternal,The length of the statement  "            feature.Polyline = new Polyline(new ICoordinate[] { PlanimetryEnvironment.NewCoordinate(viewBox.MinX + margin' viewBox.MinY + margin)'  " is 134.
Long Statement,MapAround.Mapping,Map,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderPolygonSampleInternal,The length of the statement  "            feature.Polygon = new Polygon(new ICoordinate[] { PlanimetryEnvironment.NewCoordinate(viewBox.MinX + margin' viewBox.MinY + margin)'  " is 132.
Long Statement,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderFeaturesSample,The length of the statement  "                    Map.RenderPolygonSampleInternal(g' new BoundingRectangle((sampleCount - 1) * image.Width / sampleCount' 0' image.Width' image.Height)' PolygonStyle' margin); " is 157.
Long Statement,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The length of the statement  "                BoundingRectangle box = new BoundingRectangle(coordinate.X - Map.SelectionPointRadius' coordinate.Y - Map.SelectionPointRadius' " is 127.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addTitleStyleElement,The length of the statement  "            addAttribute(doc' titleStyleElement' "render_priority"' ((int)TitleStyle.RenderPriority).ToString(CultureInfo.InvariantCulture)); " is 129.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolygonStyleElement,The length of the statement  "            addAttribute(doc' polygonStyleElement' "border_width"' PolygonStyle.BorderWidth.ToString(CultureInfo.InvariantCulture)); " is 120.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolygonStyleElement,The length of the statement  "            addAttribute(doc' polygonStyleElement' "border_dash_style"' ((int)PolygonStyle.BorderDashStyle).ToString(CultureInfo.InvariantCulture)); " is 136.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolygonStyleElement,The length of the statement  "            addAttribute(doc' polygonStyleElement' "border_dash_cap"' ((int)PolygonStyle.BorderDashCap).ToString(CultureInfo.InvariantCulture)); " is 132.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolygonStyleElement,The length of the statement  "            addAttribute(doc' polygonStyleElement' "hatch_style"' ((int)PolygonStyle.HatchStyle).ToString(CultureInfo.InvariantCulture)); " is 125.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolygonStyleElement,The length of the statement  "            addAttribute(doc' polygonStyleElement' "fill_pattern"' ((int)PolygonStyle.FillPattern).ToString(CultureInfo.InvariantCulture)); " is 127.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolygonStyleElement,The length of the statement  "            addAttribute(doc' polygonStyleElement' "fill_transparent"' PolygonStyle.FillBackColor.A.ToString(CultureInfo.InvariantCulture)); " is 128.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolylineStyleElement,The length of the statement  "            addAttribute(doc' polylineStyleElement' "dash_style"' ((int)PolylineStyle.DashStyle).ToString(CultureInfo.InvariantCulture)); " is 125.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolylineStyleElement,The length of the statement  "            addAttribute(doc' polylineStyleElement' "dash_cap"' ((int)PolylineStyle.DashCap).ToString(CultureInfo.InvariantCulture)); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolylineStyleElement,The length of the statement  "            addAttribute(doc' polylineStyleElement' "annex_dash_style"' ((int)PolylineStyle.AnnexDashStyle).ToString(CultureInfo.InvariantCulture)); " is 136.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolylineStyleElement,The length of the statement  "            addAttribute(doc' polylineStyleElement' "annex_dash_cap"' ((int)PolylineStyle.AnnexDashCap).ToString(CultureInfo.InvariantCulture)); " is 132.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolylineStyleElement,The length of the statement  "            addAttribute(doc' polylineStyleElement' "outline_width"' PolylineStyle.OutlineWidth.ToString(CultureInfo.InvariantCulture)); " is 124.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolylineStyleElement,The length of the statement  "            addAttribute(doc' polylineStyleElement' "outline_transparent"' PolylineStyle.OutlineColor.A.ToString(CultureInfo.InvariantCulture)); " is 132.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPointStyleElement,The length of the statement  "            addAttribute(doc' pointStyleElement' "display_kind"' ((int)PointStyle.DisplayKind).ToString(CultureInfo.InvariantCulture)); " is 123.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterbindingElement,The length of the statement  "            addAttribute(doc' bindingElement' "pixel_width"' ((double)layer.Binding.PixelWidth).ToString(CultureInfo.InvariantCulture)); " is 124.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterbindingElement,The length of the statement  "            addAttribute(doc' bindingElement' "pixel_height"' ((double)layer.Binding.PixelHeight).ToString(CultureInfo.InvariantCulture)); " is 126.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "interpolation_mode"' ((int)layer.Style.InterpolationMode).ToString(CultureInfo.InvariantCulture)); " is 137.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm00"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix00).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm01"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix01).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm02"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix02).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm03"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix03).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm04"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix04).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm10"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix10).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm11"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix11).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm12"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix12).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm13"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix13).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm14"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix14).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm20"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix20).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm21"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix21).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm22"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix22).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm23"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix23).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm24"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix24).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm30"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix30).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm31"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix31).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm32"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix32).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm33"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix33).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm34"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix34).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm40"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix40).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm41"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix41).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm42"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix42).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm43"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix43).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm44"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix44).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addIndiciesElements,The length of the statement  "            addAttribute(doc' pointsIndexElement' "box_square_threshold"' layer.DefaultPointsIndexSettings.BoxSquareThreshold.ToString(CultureInfo.InvariantCulture)); " is 154.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addIndiciesElements,The length of the statement  "            addAttribute(doc' pointsIndexElement' "max_depth"' layer.DefaultPointsIndexSettings.MaxDepth.ToString(CultureInfo.InvariantCulture)); " is 133.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addIndiciesElements,The length of the statement  "            addAttribute(doc' pointsIndexElement' "min_shape_count"' layer.DefaultPointsIndexSettings.MinFeatureCount.ToString(CultureInfo.InvariantCulture)); " is 146.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addIndiciesElements,The length of the statement  "            addAttribute(doc' polylinesIndexElement' "box_square_threshold"' layer.DefaultPolylinesIndexSettings.BoxSquareThreshold.ToString(CultureInfo.InvariantCulture)); " is 160.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addIndiciesElements,The length of the statement  "            addAttribute(doc' polylinesIndexElement' "max_depth"' layer.DefaultPolylinesIndexSettings.MaxDepth.ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addIndiciesElements,The length of the statement  "            addAttribute(doc' polylinesIndexElement' "min_shape_count"' layer.DefaultPolylinesIndexSettings.MinFeatureCount.ToString(CultureInfo.InvariantCulture)); " is 152.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addIndiciesElements,The length of the statement  "            addAttribute(doc' polygonsIndexElement' "box_square_threshold"' layer.DefaultPolygonsIndexSettings.BoxSquareThreshold.ToString(CultureInfo.InvariantCulture)); " is 158.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addIndiciesElements,The length of the statement  "            addAttribute(doc' polygonsIndexElement' "max_depth"' layer.DefaultPolygonsIndexSettings.MaxDepth.ToString(CultureInfo.InvariantCulture)); " is 137.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addIndiciesElements,The length of the statement  "            addAttribute(doc' polygonsIndexElement' "min_shape_count"' layer.DefaultPolygonsIndexSettings.MinFeatureCount.ToString(CultureInfo.InvariantCulture)); " is 150.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addAutoTitleSettingsElement,The length of the statement  "                addAttribute(doc' autoTitlesSettings' "attribute_index"' layer.AutoTitleSettings.AttributeIndex.ToString(CultureInfo.InvariantCulture)); " is 136.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPolygonStyle,The length of the statement  "                PolygonStyle.BorderDashStyle = (DashStyle)int.Parse(polygonStyle.Attributes["border_dash_style"].Value' CultureInfo.InvariantCulture); " is 134.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPolygonStyle,The length of the statement  "                PolygonStyle.HatchStyle = (HatchStyle)int.Parse(polygonStyle.Attributes["hatch_style"].Value' CultureInfo.InvariantCulture); " is 124.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPolygonStyle,The length of the statement  "                    PolygonStyle.BorderDashCap = (DashCap)int.Parse(polygonStyle.Attributes["border_dash_cap"].Value' CultureInfo.InvariantCulture); " is 128.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPolygonStyle,The length of the statement  "                    PolygonStyle.FillBackColor = Color.FromArgb(int.Parse(polygonStyle.Attributes["fill_transparent"].Value' CultureInfo.InvariantCulture)' PolygonStyle.FillBackColor); " is 164.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPolygonStyle,The length of the statement  "                    PolygonStyle.FillPattern = (BuiltInFillPatterns)int.Parse(polygonStyle.Attributes["fill_pattern"].Value' CultureInfo.InvariantCulture); " is 135.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPolylineStyle,The length of the statement  "                PolylineStyle.DashStyle = (DashStyle)int.Parse(polylineStyle.Attributes["dash_style"].Value' CultureInfo.InvariantCulture); " is 123.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPolylineStyle,The length of the statement  "                    PolylineStyle.AnnexDashStyle = (DashStyle)int.Parse(polylineStyle.Attributes["annex_dash_style"].Value' CultureInfo.InvariantCulture); " is 134.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPolylineStyle,The length of the statement  "                        PolylineStyle.AnnexDashCap = (DashCap)int.Parse(polylineStyle.Attributes["annex_dash_cap"].Value' CultureInfo.InvariantCulture); " is 128.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPolylineStyle,The length of the statement  "                    PolylineStyle.OutlineColor = Color.FromArgb(int.Parse(polylineStyle.Attributes["outline_transparent"].Value' CultureInfo.InvariantCulture)' PolylineStyle.OutlineColor); " is 168.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.InterpolationMode = (InterpolationMode)int.Parse(rasterStyle.Attributes["interpolation_mode"].Value' CultureInfo.InvariantCulture); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix00 = float.Parse(rasterStyle.Attributes["cm00"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix01 = float.Parse(rasterStyle.Attributes["cm01"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix02 = float.Parse(rasterStyle.Attributes["cm02"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix03 = float.Parse(rasterStyle.Attributes["cm03"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix04 = float.Parse(rasterStyle.Attributes["cm04"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix10 = float.Parse(rasterStyle.Attributes["cm10"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix11 = float.Parse(rasterStyle.Attributes["cm11"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix12 = float.Parse(rasterStyle.Attributes["cm12"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix13 = float.Parse(rasterStyle.Attributes["cm13"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix14 = float.Parse(rasterStyle.Attributes["cm14"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix20 = float.Parse(rasterStyle.Attributes["cm20"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix21 = float.Parse(rasterStyle.Attributes["cm21"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix22 = float.Parse(rasterStyle.Attributes["cm22"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix23 = float.Parse(rasterStyle.Attributes["cm23"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix24 = float.Parse(rasterStyle.Attributes["cm24"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix30 = float.Parse(rasterStyle.Attributes["cm30"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix31 = float.Parse(rasterStyle.Attributes["cm31"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix32 = float.Parse(rasterStyle.Attributes["cm32"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix33 = float.Parse(rasterStyle.Attributes["cm33"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix34 = float.Parse(rasterStyle.Attributes["cm34"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix40 = float.Parse(rasterStyle.Attributes["cm40"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix41 = float.Parse(rasterStyle.Attributes["cm41"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix42 = float.Parse(rasterStyle.Attributes["cm42"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix43 = float.Parse(rasterStyle.Attributes["cm43"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix44 = float.Parse(rasterStyle.Attributes["cm44"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPointStyle,The length of the statement  "                    PointStyle.DisplayKind = (PointDisplayKind)(int.Parse(pointStyle.Attributes["display_kind"].Value' CultureInfo.InvariantCulture)); " is 130.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPointStyle,The length of the statement  "                if ((pointStyle.Attributes["contentAlignment"] != null) && (Enum.TryParse(pointStyle.Attributes["contentAlignment"].Value' true' out contentAlignment))) " is 152.
Long Statement,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processLayer,The length of the statement  "                    fl.DataSourceType = (LayerDataSourceType)int.Parse(node.Attributes["datasource_type"].Value' CultureInfo.InvariantCulture); " is 123.
Long Statement,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateOptimalAffineTransformPoints,The length of the statement  "                                currentNorm += PlanimetryAlgorithms.Distance(destNodes[i]' PlanimetryEnvironment.NewCoordinate(tempPoints[i].X' tempPoints[i].Y)); " is 130.
Long Statement,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateRubberSheetTransform,The length of the statement  "                notifyProgessListenerIfNeeded(progress' startProgressPercent' endProgressPercent' ref completed' ref previousPercent' width); " is 125.
Long Statement,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,The length of the statement  "                notifyProgessListenerIfNeeded(progress' startProgressPercent' endProgressPercent' ref completed' ref previousPercent' source.Width); " is 132.
Long Statement,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,The length of the statement  "                notifyProgessListenerIfNeeded(progress' startProgressPercent' endProgressPercent' ref completed' ref previousPercent' source.Width); " is 132.
Long Statement,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,The length of the statement  "                notifyProgessListenerIfNeeded(progress' startProgressPercent' endProgressPercent' ref completed' ref previousPercent' source.Width); " is 132.
Long Statement,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,BindRaster,The length of the statement  "            calculateAffinneTransform(source.Width' source.Height' affinneTransformResult' sourceControlPoints' destinationControlPoints' progress); " is 136.
Long Statement,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,BindRaster,The length of the statement  "                shifts[i] = PlanimetryEnvironment.NewCoordinate(destinationControlPoints[i].X - p.X' destinationControlPoints[i].Y - p.Y); " is 122.
Long Statement,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,BindRaster,The length of the statement  "            calculateRubberSheetTransform(source.Width' source.Height' affinneTransformResult' warpTransformResult' destinationControlPoints' shifts' progress); " is 148.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,createSelectionTexture,The length of the statement  "                _selectionTexture = new Bitmap(originalPattern.Width' originalPattern.Height' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 130.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawTitle,The length of the statement  "                                        path.AddString(element.Substring' f.FontFamily' (int)f.Style' f.Size' element.TitleOrigin' StringFormat.GenericTypographic); " is 124.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawTitle,The length of the statement  "                                    path.AddString(element.Substring' f.FontFamily' (int)f.Style' f.Size' element.TitleOrigin' StringFormat.GenericTypographic); " is 124.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The length of the statement  "                            float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)' " is 123.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getLeftPoints,The length of the statement  "                        double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle < 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin); " is 122.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getLeftPoints,The length of the statement  "                    double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle < 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin); " is 122.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRightPoints,The length of the statement  "                        double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle > 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin); " is 122.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRightPoints,The length of the statement  "                    double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle > 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin); " is 122.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawVisiblePolylinePartWithStyleDetection,The length of the statement  "            // Necessary to calculate the displacement pattern of the pen before drawing a polyline' or generated images will not be used for cross-linking. " is 144.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawVisiblePolylinePartWithStyleDetection,The length of the statement  "            // Knowing the length of the zero-vertex to the portion of the polyline' you can calculate the shift pattern at the beginning of the portion. " is 141.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPolylineWithIntersectCalculation,The length of the statement  "                                drawVisiblePolylinePartWithStyleDetection(g' currentPath' style' pen' annexPen' feature.Selected' viewBox' scaleFactor' currentLength); " is 135.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPolylineWithIntersectCalculation,The length of the statement  "                                        drawVisiblePolylinePartWithStyleDetection(g' currentPath' style' pen' annexPen' feature.Selected' viewBox' scaleFactor' currentLength); " is 135.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPolylineWithIntersectCalculation,The length of the statement  "                        drawVisiblePolylinePartWithStyleDetection(g' currentPath' style' pen' annexPen' feature.Selected' viewBox' scaleFactor' currentLength); " is 135.
Long Statement,MapAround.Mapping,TitleBufferElement,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,intersectsWithComplexTitle,The length of the statement  "                        if (PlanimetryAlgorithms.SegmentsIntersection(segment1' segments[i]' out pointStub' out segmentStub) != Dimension.None || " is 121.
Long Statement,MapAround.Geography,GeoPath,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,ReduceSegments,The length of the statement  "            v1 = UnitSphere.LatLonToGeocentric(path.Vertices[path.Vertices.Count - 1].Phi' path.Vertices[path.Vertices.Count - 1].L); " is 121.
Long Statement,MapAround.Geography,GeoPath,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,ReduceSegments,The length of the statement  "            v2 = UnitSphere.LatLonToGeocentric(this.Vertices[this.Vertices.Count - 1].Phi' this.Vertices[this.Vertices.Count - 1].L); " is 121.
Long Statement,MapAround.Geography,GeoContour,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,ReduceSegments,The length of the statement  "                    v2 = UnitSphere.LatLonToGeocentric(contour.Vertices[contour.Vertices.Count - 1].Phi' contour.Vertices[contour.Vertices.Count - 1].L); " is 133.
Long Statement,MapAround.Geography,EllipticOverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticOverlays.cs,CalculateOverlay,The length of the statement  "                            throw new NotSupportedException(string.Format("Overlay calculations for \"{0}\" is not supported."' geography1.GetType().FullName)); " is 132.
Long Statement,MapAround.Geography,EllipticOverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticOverlays.cs,CalculateOverlay,The length of the statement  "                            throw new NotSupportedException(string.Format("Overlay calculations for \"{0}\" is not supported."' geography2.GetType().FullName)); " is 132.
Long Statement,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The length of the statement  "            double L = lambda - (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cosSigmaM2 + C * cosSigma * (-1 + 2 * cos2SigmaM2))); " is 123.
Long Statement,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The length of the statement  "                deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2))); " is 156.
Long Statement,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The length of the statement  "                lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2))); " is 120.
Long Statement,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticMeasurement,The length of the statement  "            Ellipsoid ellipsoid = new Ellipsoid(a' f == 0 ? a : 0' f == 0 ? 0 : 1 / f' f != 0' LinearUnit.Metre' string.Empty' string.Empty' 0' string.Empty' string.Empty' string.Empty); " is 174.
Long Statement,MapAround.Indexing,KDTree,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\KDTree.cs,Insert,The length of the statement  "                throw new ArgumentException("Bounding rectangle of the object is outside of the indexed space. Need to rebuild index."' "obj"); " is 127.
Long Statement,MapAround.Indexing,QuadTree,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\QuadTree.cs,Insert,The length of the statement  "                throw new ArgumentException("Bounding rectangle of the object outside the indexed space. Need to rebuild index."' "obj"); " is 121.
Long Statement,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getCirclePoints,The length of the statement  "                result[i] = PlanimetryEnvironment.NewCoordinate(point.X + distance * Math.Cos(angle)' point.Y + distance * Math.Sin(angle)); " is 124.
Long Statement,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getCirclePoints,The length of the statement  "            result[n] = PlanimetryEnvironment.NewCoordinate(point.X + distance * Math.Cos(endAngle)' point.Y + distance * Math.Sin(endAngle)); " is 130.
Long Statement,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addJoin,The length of the statement  "            double angleBetweenSegments = getAngle(PlanimetryEnvironment.NewCoordinate(x1' y1)' PlanimetryEnvironment.NewCoordinate(x2' y2)' PlanimetryEnvironment.NewCoordinate(x3' y3)' true); " is 180.
Long Statement,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,GetBitmap,The length of the statement  "                    bmp.LockBits(new Rectangle(0' 0' _width' _height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 151.
Long Statement,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,FromBitmap,The length of the statement  "                    bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 166.
Long Statement,MapAround.Rendering,RenderingPipeline,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The length of the statement  "                    _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height }); " is 135.
Long Statement,MapAround.Rendering,RenderingPipeline,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The length of the statement  "                    _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 }); " is 122.
Long Statement,MapAround.Rendering,RenderingPipeline,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The length of the statement  "                    _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2}); " is 137.
Long Statement,MapAround.Rendering,RenderingPipeline,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The length of the statement  "                    _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height}); " is 138.
Long Statement,MapAround.Rendering,RenderingPipeline,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The length of the statement  "                    _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height }); " is 155.
Long Statement,MapAround.Serialization,WKBGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,readMultiPoint,The length of the statement  "                multiPoint.Points.Add(PlanimetryEnvironment.NewCoordinate(readDouble(stream' byteOrder)' readDouble(stream' byteOrder))); " is 121.
Long Statement,MapAround.Serialization,WKBGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,readMultiLineString,The length of the statement  "                    result.Paths[i].Vertices.Add(PlanimetryEnvironment.NewCoordinate(readDouble(stream' byteOrder)' readDouble(stream' byteOrder))); " is 128.
Long Statement,MapAround.Serialization,CoordinateSystemWktDeserializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\SpatialReferenceSerializers.cs,ReadAuthority,The length of the statement  "			try { authorityCode = long.Parse(tokenizer.ReadDoubleQuotedWord()' System.Globalization.NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture.NumberFormat); } " is 172.
Long Statement,MapAround.Serialization,CoordinateSystemWktDeserializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\SpatialReferenceSerializers.cs,ReadEllipsoid,The length of the statement  "            IEllipsoid ellipsoid = new Ellipsoid(majorAxis' 0.0' e' true' LinearUnit.Metre' name' authority' authorityCode' String.Empty' string.Empty' string.Empty); " is 154.
Long Statement,MapAround.Serialization,CoordinateSystemWktDeserializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\SpatialReferenceSerializers.cs,ReadProjection,The length of the statement  "            IProjection projection = new Projection(projectionName' paramList' projectionName' authority' authorityCode' String.Empty' String.Empty' string.Empty); " is 151.
Long Statement,MapAround.Serialization,CoordinateSystemWktDeserializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\SpatialReferenceSerializers.cs,ReadProjectedCoordinateSystem,The length of the statement  "            IProjectedCoordinateSystem projectedCS = new ProjectedCoordinateSystem(geographicCS.HorizontalDatum' geographicCS' unit as LinearUnit' projection' axes' name' authority' authorityCode' String.Empty' String.Empty' String.Empty); " is 227.
Long Statement,MapAround.Serialization,CoordinateSystemWktDeserializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\SpatialReferenceSerializers.cs,ReadHorizontalDatum,The length of the statement  "            IHorizontalDatum horizontalDatum = new HorizontalDatum(ellipsoid' wgsInfo' DatumType.HD_Geocentric' name' authority' authorityCode' String.Empty' String.Empty' String.Empty); " is 174.
Long Statement,MapAround.Serialization,CoordinateSystemWktDeserializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\SpatialReferenceSerializers.cs,ReadPrimeMeridian,The length of the statement  "            IPrimeMeridian primeMeridian = new PrimeMeridian(longitude' AngularUnit.Degrees' name' authority' authorityCode' String.Empty' String.Empty' String.Empty); " is 155.
Long Statement,MapAround.UI,ImageLegend,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,DrawLegend,The length of the statement  "                g.DrawString(Caption' _captionFont' new SolidBrush(_captionColor)' new PointF(_width / 2 - captionSize.Width / 2' _margin)); " is 124.
Long Statement,MapAround.Web,MapServerBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,GetVectorInfo,The length of the statement  "            CheckRequestParams(requestParams' responseOutputStream' ref responseContentType' out originalBbox' out width' out height); " is 122.
Long Statement,MapAround.Web,MapServerBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,GetImageFromChach,The length of the statement  "                byte[] tileBytes = _tileCacheAccessor.ExtractTileBytes(layer.Alias'bboxWithGutters' getTileString(bboxWithGutters)'"png"); " is 122.
Long Statement,MapAround.Web,MapServerBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,WmsException,The length of the statement  "            sb.Append("<ServiceExceptionReport version=\"1.1.1\" xmlns=\"http://www.opengis.net/ogc\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n"); " is 151.
Long Statement,MapAround.Web,MapServerBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,WmtsException,The length of the statement  "            sb.Append("<ServiceExceptionReport version=\"1.1.1\" xmlns=\"http://www.opengis.net/ogc\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n"); " is 151.
Long Statement,MapAround.Web.Wms,WmsCapabilities,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsCapabilities.cs,GenerateServiceNode,The length of the statement  "                serviceNode.AppendChild(createElement("LayerLimit"' serviceDescription.LayerLimit.ToString(CultureInfo.InvariantCulture)' " is 121.
Long Statement,MapAround.Web.Wms,WmsCapabilities,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsCapabilities.cs,GenerateServiceNode,The length of the statement  "                serviceNode.AppendChild(createElement("MaxWidth"' serviceDescription.MaxWidth.ToString(CultureInfo.InvariantCulture)' capabilities' " is 131.
Long Statement,MapAround.Web.Wms,WmsCapabilities,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsCapabilities.cs,GenerateServiceNode,The length of the statement  "                serviceNode.AppendChild(createElement("MaxHeight"' serviceDescription.MaxHeight.ToString(CultureInfo.InvariantCulture)' capabilities' " is 133.
Long Statement,MapAround.Web.Wmts,WmtsCapabilities,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,GenerateServiceNode,The length of the statement  "                serviceNode.AppendChild(createElement("LayerLimit"' serviceDescription.LayerLimit.ToString(CultureInfo.InvariantCulture)' " is 121.
Long Statement,MapAround.Web.Wmts,WmtsCapabilities,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,GenerateServiceNode,The length of the statement  "                serviceNode.AppendChild(createElement("MaxWidth"' serviceDescription.MaxWidth.ToString(CultureInfo.InvariantCulture)' capabilities' " is 131.
Long Statement,MapAround.Web.Wmts,WmtsCapabilities,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,GenerateServiceNode,The length of the statement  "                serviceNode.AppendChild(createElement("MaxHeight"' serviceDescription.MaxHeight.ToString(CultureInfo.InvariantCulture)' capabilities' " is 133.
Long Statement,MapAround.Web.Wmts,WmtsCapabilities,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,GenerateTileMatrixInfo,The length of the statement  "            matrixInfo.AppendChild(createElement("ows:Identifier"' serviceDescription.ZoomLevel.Keys.ToList()[i].ToString()' capabilities' false' wmtsNamespaceURI)); " is 153.
Long Statement,MapAround.Web.Wmts,WmtsCapabilities,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,GenerateTileMatrixInfo,The length of the statement  "            matrixInfo.AppendChild(createElement("ScaleDenominator"' serviceDescription.GetScaleDenominator(i).ToString()' capabilities' false' wmtsNamespaceURI)); " is 151.
Long Statement,MapAround.Web.Wmts,WmtsCapabilities,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,GenerateTileMatrixInfo,The length of the statement  "            matrixInfo.AppendChild(createElement("MatrixHeight"' Math.Pow(2' i).ToString()' capabilities' false' wmtsNamespaceURI)); " is 120.
Long Statement,MapAround.Web.Wmts,WMTSServer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WMTSServer.cs,CheckRequestParams,The length of the statement  "            tile.PixelSize = (_description as WmtsServiceDescription).GetPixelSize((_description as WmtsServiceDescription).ZoomLevel[tileMatrixName]); // Attention!! " is 154.
Complex Conditional,MapAround.DataProviders,ShapeFileSpatialDataProvider,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\ShapeFileDataProvider.cs,internalQueryFeatures,The conditional expression  "!checkBounds ||                      (record.MaxX >= bounds.MinX && record.MaxY >= bounds.MinY &&                       record.MinX <= bounds.MaxX && record.MinY <= bounds.MaxY)"  is complex.
Complex Conditional,MapAround.Extensions.Surfaces,IsolineBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,getIsoline,The conditional expression  "(z == tz[0] && z == tz[1]) ||                      (z == tz[1] && z == tz[2])"  is complex.
Complex Conditional,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,GetBuffer,The conditional expression  "!(geometry is PointD) && !(geometry is Polyline) && !(geometry is Polygon) && !(geometry is MultiPoint)"  is complex.
Complex Conditional,MapAround.Geometry,DistanceCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\DataStructures.cs,checkGeometry,The conditional expression  "!(geometry is PointD) &&                   !(geometry is Polyline) &&                   !(geometry is Polygon) &&                   !(geometry is MultiPoint)"  is complex.
Complex Conditional,MapAround.Geometry,DistanceCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\DataStructures.cs,calculateDistanceBrutForce,The conditional expression  "(geometry1 is Polygon || geometry1 is Polyline) &&                  (geometry2 is Polygon || geometry2 is Polyline)"  is complex.
Complex Conditional,MapAround.Geometry,PointD,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Intersects,The conditional expression  "matrix.Matches("T********") ||                 matrix.Matches("*T*******") ||                 matrix.Matches("***T*****") ||                 matrix.Matches("****T****")"  is complex.
Complex Conditional,MapAround.Geometry,MultiPoint,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Intersects,The conditional expression  "matrix.Matches("T********") ||                 matrix.Matches("*T*******") ||                 matrix.Matches("***T*****") ||                 matrix.Matches("****T****")"  is complex.
Complex Conditional,MapAround.Geometry,Contour,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,PointLiesInside,The conditional expression  "(p1y > y) && (p2y <= y) || (p1y <= y) && (p2y > y)"  is complex.
Complex Conditional,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,hasCycles,The conditional expression  "(touchedContourPairs[k].Key == touchedContourIndices[i] &&                               touchedContourPairs[k].Value == touchedContourIndices[j]) ||                              (touchedContourPairs[k].Key == touchedContourIndices[j] &&                               touchedContourPairs[k].Value == touchedContourIndices[i])"  is complex.
Complex Conditional,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Intersects,The conditional expression  "matrix.Matches("T********") ||                 matrix.Matches("*T*******") ||                 matrix.Matches("***T*****") ||                 matrix.Matches("****T****")"  is complex.
Complex Conditional,MapAround.Geometry,Polyline,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Intersects,The conditional expression  "matrix.Matches("T********") ||                 matrix.Matches("*T*******") ||                 matrix.Matches("***T*****") ||                 matrix.Matches("****T****")"  is complex.
Complex Conditional,MapAround.Geometry,BoundingRectangle,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Intersects,The conditional expression  "polygon.ContainsPoint(Min) || polygon.ContainsPoint(Max) ||                  polygon.ContainsPoint(PlanimetryEnvironment.NewCoordinate(MinX' MaxY)) ||                  polygon.ContainsPoint(PlanimetryEnvironment.NewCoordinate(MaxX' MinY))"  is complex.
Complex Conditional,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolygonOverlay,The conditional expression  "operation == OverlayType.Union || operation == OverlayType.SymmetricDifference ||                         (operation == OverlayType.Difference && inverseArgs)"  is complex.
Complex Conditional,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolylinePolygonOverlay,The conditional expression  "operation == OverlayType.SymmetricDifference || operation == OverlayType.Union ||                          (operation == OverlayType.Difference && inverseArgs)"  is complex.
Complex Conditional,MapAround.Geometry,PlanimetryAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,RobustSegmentsIntersection,The conditional expression  "p11 == 0 && p12 == 0 && p21 == 0 && p22 == 0"  is complex.
Complex Conditional,MapAround.Geometry,PlanimetryAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,filterPointsForConvexHull,The conditional expression  "current.X > bounds.MinX && current.X < bounds.MaxX &&                     current.Y > bounds.MinY && current.Y < bounds.MaxY"  is complex.
Complex Conditional,MapAround.Geometry,GeometrySimplifier,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,simplifyPolylineSDMin,The conditional expression  "currentVertex.Deleted ||                       currentVertex.IsCrossSegmentVertex ||                      currentVertex.Previous == null ||                       currentVertex.Next == null"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculteInternalInternal,The conditional expression  "((flag && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1) ||                                (!flag && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2)) && polygon.ContainsPoint(edge.CenterPoint())"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The conditional expression  "(isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The conditional expression  "(isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The conditional expression  "(!inverseArgs && usageCount1 % 2 == 0 && usageCount2 % 2 == 1) ||                                 (inverseArgs && usageCount1 % 2 == 1 && usageCount2 % 2 == 0)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The conditional expression  "(isFirstGeometryPolyline && inverseArgs) ||                          (!isFirstGeometryPolyline && !inverseArgs)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The conditional expression  "(isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                  (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The conditional expression  "(inverseArgs && edge.Label.UsedByObject1 && p2.ContainsPoint(edge.CenterPoint())) ||                                  (!inverseArgs && edge.Label.UsedByObject2 && p1.ContainsPoint(edge.CenterPoint()))"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalExternal,The conditional expression  "(isFirstGeometryPolyline && !inverseArgs) ||                          (!isFirstGeometryPolyline && inverseArgs)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalExternal,The conditional expression  "(isFirstGeometryPoint && node.Label.UsedByObject1) ||                                      (!isFirstGeometryPoint && node.Label.UsedByObject2)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalExternal,The conditional expression  "(inverseArgs && isFirstGeometryPoint) ||                         (!inverseArgs && !isFirstGeometryPoint)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalExternal,The conditional expression  "(!inverseArgs && edge.Label.UsedByObject1) ||                                 (inverseArgs && edge.Label.UsedByObject2)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalExternal,The conditional expression  "(inverseArgs && isFirstGeometryPolyline) ||                          (!inverseArgs && !isFirstGeometryPolyline)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalExternal,The conditional expression  "(!inverseArgs && edge.Label.UsedByObject1) ||                                      (inverseArgs && edge.Label.UsedByObject2)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalExternal,The conditional expression  "(inverseArgs && edge.Label.UsedByObject2 && !polygon1.ContainsPoint(edge.CenterPoint())) ||                                 (!inverseArgs && edge.Label.UsedByObject1 && !polygon2.ContainsPoint(edge.CenterPoint()))"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalExternal,The conditional expression  "(inverseArgs && edge.Label.UsedByObject1 && polygon2.ContainsPoint(edge.CenterPoint())) ||                                 (!inverseArgs && edge.Label.UsedByObject2 && polygon1.ContainsPoint(edge.CenterPoint()))"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The conditional expression  "(inverseArgs && !isFirstGeometryPoint) ||                          (!inverseArgs && isFirstGeometryPoint)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The conditional expression  "(inverseArgs && isFirstGeometryPoint) ||                          (!inverseArgs && !isFirstGeometryPoint)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The conditional expression  "(!inverseArgs && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                              (inverseArgs && node.Label.UsedByObject2 && !node.Label.UsedByObject1)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The conditional expression  "(inverseArgs && isFirstGeometryPolyline) ||                          (!inverseArgs && !isFirstGeometryPolyline)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The conditional expression  "(isFirstGeometryPolyline && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1) ||                                 (!isFirstGeometryPolyline && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The conditional expression  "(isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                 (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The conditional expression  "(!inverseArgs && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2 && !polygon2.ContainsPoint(edge.CenterPoint())) ||                              (inverseArgs && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1 && !polygon1.ContainsPoint(edge.CenterPoint()))"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,checkGeometry,The conditional expression  "!(geometry is PointD) && !(geometry is Polyline) && !(geometry is Polygon) && !(geometry is MultiPoint)"  is complex.
Complex Conditional,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,addOrMergeNode,The conditional expression  "(_performSnapping && p.ExactEquals(coordinate)) ||                          (!_performSnapping && p.Equals(coordinate))"  is complex.
Complex Conditional,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,updateSplittedSegment,The conditional expression  "(_performSnapping && ss.Segment.ExactEquals(segment.Segment)) ||                      (!_performSnapping && ss.Segment == segment.Segment)"  is complex.
Complex Conditional,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,AddColumn,The conditional expression  "dataType == typeof(short) || dataType == typeof(ushort) ||                           dataType == typeof(int) || dataType == typeof(uint) ||                           dataType == typeof(long) || dataType == typeof(ulong)"  is complex.
Complex Conditional,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,RecountColumnLength,The conditional expression  "field.DataType == typeof(Double) ||field.DataType == typeof(Single) || field.DataType == typeof(Decimal) ||                           field.DataType == typeof(Int16) || field.DataType == typeof(Int32) || field.DataType == typeof(Int64)                           || field.DataType == typeof(UInt16) || field.DataType == typeof(UInt32) || field.DataType == typeof(UInt64)"  is complex.
Complex Conditional,MapAround.Mapping,Map,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectTopObject,The conditional expression  "l.Visible && l.FeaturesSelectable &&                          (l.MaxVisibleScale >= scale && l.MinVisibleScale <= scale)"  is complex.
Complex Conditional,MapAround.Mapping,Map,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObjects,The conditional expression  "l.Visible && l.FeaturesSelectable &&                          (_layers[i].MaxVisibleScale >= scale && _layers[i].MinVisibleScale <= scale)"  is complex.
Complex Conditional,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The conditional expression  "coordinate.X > bounds.MinX && coordinate.Y > bounds.MinY &&                      coordinate.X < bounds.MaxX && coordinate.Y < bounds.MaxY"  is complex.
Complex Conditional,MapAround.Mapping,MapWorkspace,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processViewBox,The conditional expression  "viewBox.Attributes["min_x"].Value.Length != 0 &&                      viewBox.Attributes["min_y"].Value.Length != 0 &&                      viewBox.Attributes["max_x"].Value.Length != 0 &&                      viewBox.Attributes["max_y"].Value.Length != 0"  is complex.
Complex Conditional,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,The conditional expression  "!double.IsNaN(warpTransformResult[i' j].X) && !double.IsNaN(warpTransformResult[i' j].Y) &&                          x >= 0 && y >= 0"  is complex.
Complex Conditional,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,checkControlPoints,The conditional expression  "p.X < 0 || p.Y < 0 || p.X >= sourceWidth || p.Y >= sourceHeight"  is complex.
Complex Conditional,MapAround.Mapping,TitleBufferElement,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,contoursIntersect,The conditional expression  "PlanimetryAlgorithms.SegmentsIntersection(segment1' segment3' out pointStub' out segmentStub) != Dimension.None ||                      PlanimetryAlgorithms.SegmentsIntersection(segment1' segment4' out pointStub' out segmentStub) != Dimension.None ||                      PlanimetryAlgorithms.SegmentsIntersection(segment2' segment3' out pointStub' out segmentStub) != Dimension.None ||                      PlanimetryAlgorithms.SegmentsIntersection(segment2' segment4' out pointStub' out segmentStub) != Dimension.None"  is complex.
Complex Conditional,MapAround.Geometry.Tessellations,FortuneShoreLine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,FindArc,The conditional expression  "(currentArc.Left == null || pointsPrev[0].X <= eventX) &&                      (currentArc.Right == null || pointsNext[0].X >= eventX)"  is complex.
Complex Conditional,MapAround.Indexing,QuadTreeNode,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\QuadTree.cs,Remove,The conditional expression  "this._geometriesRectangle.MinX == obj.BoundingRectangle.MinX ||                          this._geometriesRectangle.MinY == obj.BoundingRectangle.MinY ||                          this._geometriesRectangle.MaxX == obj.BoundingRectangle.MaxX ||                          this._geometriesRectangle.MaxY == obj.BoundingRectangle.MaxY"  is complex.
Complex Conditional,MapAround.Rendering,Region,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,containsPoint,The conditional expression  "(p1y > y) && (p2y <= y) || (p1y <= y) && (p2y > y)"  is complex.
Complex Conditional,MapAround.UI,LegendBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,AddElementsForLayer,The conditional expression  "(l.LegendSettings.DisplayPointSample ||                     l.LegendSettings.DisplayPolylineSample ||                     l.LegendSettings.DisplayPolygonSample) &&                     l.FeatureRenderer == null"  is complex.
Empty Catch Block,MapAround.Mapping,Map,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,MapViewBoxFromPresentationViewBox,The method has an empty catch block.
Empty Catch Block,MapAround.Mapping,Map,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,tryJoinWithTransformedPoint,The method has an empty catch block.
Magic Number,MapAround.CoordinateSystems,Ellipsoid,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,SurfaceArea,The following statement contains a magic number: return 2.0 * Math.PI * a * (a + b * b / ab * Math.Log((a + ab) / b));
Magic Number,MapAround.CoordinateSystems,CoordinateSystemFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateProjectedCoordinateSystem,The following statement contains a magic number: List<AxisInfo> info = new List<AxisInfo>(2);
Magic Number,MapAround.CoordinateSystems,CoordinateSystemFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateGeographicCoordinateSystem,The following statement contains a magic number: List<AxisInfo> info = new List<AxisInfo>(2);
Magic Number,MapAround.CoordinateSystems,CoordinateSystemFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateGeocentricCoordinateSystem,The following statement contains a magic number: List<AxisInfo> info = new List<AxisInfo>(3);
Magic Number,MapAround.CoordinateSystems,GeocentricCoordinateSystem,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,GeocentricCoordinateSystem,The following statement contains a magic number: axisinfo.Count != 3
Magic Number,MapAround.CoordinateSystems,HorizontalCoordinateSystem,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,HorizontalCoordinateSystem,The following statement contains a magic number: axisInfo.Count != 2
Magic Number,MapAround.CoordinateSystems,Wgs84ConversionInfo,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\WGS84ConversionInfo.cs,GetAffineTransform,The following statement contains a magic number: double RS = 1 + Ppm * 0.000001;
Magic Number,MapAround.CoordinateSystems,Wgs84ConversionInfo,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\WGS84ConversionInfo.cs,GetAffineTransform,The following statement contains a magic number: return new double[7] { RS' Ex * SEC_TO_RAD * RS' Ey * SEC_TO_RAD * RS' Ez * SEC_TO_RAD * RS' Dx' Dy' Dz };
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,AlbersProjection,The following statement contains a magic number: e_sq = 1.0 - Math.Pow(this._semiMinor / this._semiMajor' 2);
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,AlbersProjection,The following statement contains a magic number: double m1 = Math.Cos(lat1) / Math.Sqrt(1 - e_sq * Math.Pow(Math.Sin(lat1)' 2));
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,AlbersProjection,The following statement contains a magic number: double m2 = Math.Cos(lat2) / Math.Sqrt(1 - e_sq * Math.Pow(Math.Sin(lat2)' 2));
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,AlbersProjection,The following statement contains a magic number: n = (Math.Pow(m1' 2) - Math.Pow(m2' 2)) / (alpha2 - alpha1);
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,AlbersProjection,The following statement contains a magic number: n = (Math.Pow(m1' 2) - Math.Pow(m2' 2)) / (alpha2 - alpha1);
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,AlbersProjection,The following statement contains a magic number: C = Math.Pow(m1' 2) + (n * alpha1);
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: lonlat.Length == 2
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double ro = Math.Sqrt(Math.Pow(p[0] * _metersPerUnit - _falseEasting' 2) + Math.Pow(ro0 - (p[1] * _metersPerUnit - _falseNorthing)' 2));
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double ro = Math.Sqrt(Math.Pow(p[0] * _metersPerUnit - _falseEasting' 2) + Math.Pow(ro0 - (p[1] * _metersPerUnit - _falseNorthing)' 2));
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double q = (C - Math.Pow(ro' 2) * Math.Pow(n' 2) / Math.Pow(this._semiMajor' 2)) / n;
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double q = (C - Math.Pow(ro' 2) * Math.Pow(n' 2) / Math.Pow(this._semiMajor' 2)) / n;
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double q = (C - Math.Pow(ro' 2) * Math.Pow(n' 2) / Math.Pow(this._semiMajor' 2)) / n;
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double b = Math.Sin(q / (1 - ((1 - e_sq) / (2 * e)) * Math.Log((1 - e) / (1 + e))));
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lat = Math.Asin(q * 0.5);
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double e2sin2 = e_sq * Math.Pow(sin' 2);
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: lat += (Math.Pow(1 - e2sin2' 2) / (2 * Math.Cos(lat))) * ((q / (1 - e_sq)) - sin / (1 - e2sin2) + 1 / (2 * e) * Math.Log((1 - e * sin) / (1 + e * sin)));
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: lat += (Math.Pow(1 - e2sin2' 2) / (2 * Math.Cos(lat))) * ((q / (1 - e_sq)) - sin / (1 - e2sin2) + 1 / (2 * e) * Math.Log((1 - e * sin) / (1 + e * sin)));
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: lat += (Math.Pow(1 - e2sin2' 2) / (2 * Math.Cos(lat))) * ((q / (1 - e_sq)) - sin / (1 - e2sin2) + 1 / (2 * e) * Math.Log((1 - e * sin) / (1 + e * sin)));
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: iterationCounter > 25
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: Math.Abs(lat - preLat) > 0.000001
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: p.Length < 3
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,alpha,The following statement contains a magic number: double sinsq = Math.Pow(sin' 2);
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,alpha,The following statement contains a magic number: return (1 - e_sq) * (((sin / (1 - e_sq * sinsq)) - 1 / (2 * e) * Math.Log((1 - e * sin) / (1 + e * sin))));
Magic Number,MapAround.CoordinateSystems.Projections,LambertConformalConic2SP,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LambertConformalConic2SP,The following statement contains a magic number: this.AuthorityCode = 9802;
Magic Number,MapAround.CoordinateSystems.Projections,LambertConformalConic2SP,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LambertConformalConic2SP,The following statement contains a magic number: es = 1.0 - Math.Pow(this._semiMinor / this._semiMajor' 2);
Magic Number,MapAround.CoordinateSystems.Projections,LambertConformalConic2SP,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: lonlat.Length == 2
Magic Number,MapAround.CoordinateSystems.Projections,LambertConformalConic2SP,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: p.Length == 2
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,Mercator,The following statement contains a magic number: this.AuthorityCode = 9805;
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double chi = HALF_PI - 2 * Math.Atan(ts);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double e4 = Math.Pow(e' 4);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double e6 = Math.Pow(e' 6);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double e8 = Math.Pow(e' 8);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: p.Length < 3
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,TransverseMercator,The following statement contains a magic number: this.AuthorityCode = 9807;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,TransverseMercator,The following statement contains a magic number: es = 1.0 - Math.Pow(this._semiMinor / this._semiMajor' 2);
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: als = Math.Pow(al' 2);
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: c = esp * Math.Pow(cosPhi' 2);
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: t = Math.Pow(tq' 2);
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: con = 1.0 - es * Math.Pow(sinPhi' 2);
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double x =                  _scaleFactor * n * al * (1.0 + als / 6.0 * (1.0 - t + c + als / 20.0 *                  (5.0 - 18.0 * t + Math.Pow(t' 2) + 72.0 * c - 58.0 * esp))) + _falseEasting;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double x =                  _scaleFactor * n * al * (1.0 + als / 6.0 * (1.0 - t + c + als / 20.0 *                  (5.0 - 18.0 * t + Math.Pow(t' 2) + 72.0 * c - 58.0 * esp))) + _falseEasting;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double x =                  _scaleFactor * n * al * (1.0 + als / 6.0 * (1.0 - t + c + als / 20.0 *                  (5.0 - 18.0 * t + Math.Pow(t' 2) + 72.0 * c - 58.0 * esp))) + _falseEasting;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double x =                  _scaleFactor * n * al * (1.0 + als / 6.0 * (1.0 - t + c + als / 20.0 *                  (5.0 - 18.0 * t + Math.Pow(t' 2) + 72.0 * c - 58.0 * esp))) + _falseEasting;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double x =                  _scaleFactor * n * al * (1.0 + als / 6.0 * (1.0 - t + c + als / 20.0 *                  (5.0 - 18.0 * t + Math.Pow(t' 2) + 72.0 * c - 58.0 * esp))) + _falseEasting;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double x =                  _scaleFactor * n * al * (1.0 + als / 6.0 * (1.0 - t + c + als / 20.0 *                  (5.0 - 18.0 * t + Math.Pow(t' 2) + 72.0 * c - 58.0 * esp))) + _falseEasting;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double x =                  _scaleFactor * n * al * (1.0 + als / 6.0 * (1.0 - t + c + als / 20.0 *                  (5.0 - 18.0 * t + Math.Pow(t' 2) + 72.0 * c - 58.0 * esp))) + _falseEasting;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: lonlat.Length < 3
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: long maxIterCount = 6;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: deltaPhi = ((con + e1 * Math.Sin(2.0 * phi) - e2 * Math.Sin(4.0 * phi) + e3 * Math.Sin(6.0 * phi))                      / e0) - phi;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: deltaPhi = ((con + e1 * Math.Sin(2.0 * phi) - e2 * Math.Sin(4.0 * phi) + e3 * Math.Sin(6.0 * phi))                      / e0) - phi;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: deltaPhi = ((con + e1 * Math.Sin(2.0 * phi) - e2 * Math.Sin(4.0 * phi) + e3 * Math.Sin(6.0 * phi))                      / e0) - phi;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: c = esp * Math.Pow(cosPhi' 2);
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: cs = Math.Pow(c' 2);
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: t = Math.Pow(tanPhi' 2);
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: ts = Math.Pow(t' 2);
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: con = 1.0 - es * Math.Pow(sinPhi' 2);
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: ds = Math.Pow(d' 2);
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: p.Length < 3
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,CUBE,The following statement contains a magic number: return Math.Pow(x' 3);
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,QUAD,The following statement contains a magic number: return Math.Pow(x' 4);
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,qsfnz,The following statement contains a magic number: return ((1 - eccent * eccent) * (sinPhi / (1 - con * con) - (0.5 / eccent) *                      Math.Log((1 - con) / (1 + con))));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,qsfnz,The following statement contains a magic number: eccent > 1.0e-7
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,tsfnz,The following statement contains a magic number: com = 0.5 * eccent;
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,tsfnz,The following statement contains a magic number: return (Math.Tan(.5 * (HALF_PI - phi)) / con);
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,phi1z,The following statement contains a magic number: phi = asinz(0.5 * qs);
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,phi1z,The following statement contains a magic number: dphi = 0.5 * com * com / cospi * (qs / (1 - eccnts) - sinpi / com +                      0.5 / eccent * Math.Log((1 - con) / (1 + con)));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,phi1z,The following statement contains a magic number: dphi = 0.5 * com * com / cospi * (qs / (1 - eccnts) - sinpi / com +                      0.5 / eccent * Math.Log((1 - con) / (1 + con)));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,phi1z,The following statement contains a magic number: Math.Abs(dphi) <= 1e-7
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,phi1z,The following statement contains a magic number: i <= 25
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,phi2z,The following statement contains a magic number: double eccnth = .5 * eccent;
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,phi2z,The following statement contains a magic number: double chi = HALF_PI - 2 * Math.Atan(ts);
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,phi2z,The following statement contains a magic number: dphi = HALF_PI - 2 * Math.Atan(ts * (Math.Pow(((1.0 - con) / (1.0 + con))' eccnth))) - chi;
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,phi2z,The following statement contains a magic number: Math.Abs(dphi) <= 0.0000000001
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,phi2z,The following statement contains a magic number: i <= 15
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e0fn,The following statement contains a magic number: return (1.0 - 0.25 * x * (1.0 + x / 16.0 * (3.0 + 1.25 * x)));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e0fn,The following statement contains a magic number: return (1.0 - 0.25 * x * (1.0 + x / 16.0 * (3.0 + 1.25 * x)));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e0fn,The following statement contains a magic number: return (1.0 - 0.25 * x * (1.0 + x / 16.0 * (3.0 + 1.25 * x)));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e0fn,The following statement contains a magic number: return (1.0 - 0.25 * x * (1.0 + x / 16.0 * (3.0 + 1.25 * x)));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e1fn,The following statement contains a magic number: return (0.375 * x * (1.0 + 0.25 * x * (1.0 + 0.46875 * x)));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e1fn,The following statement contains a magic number: return (0.375 * x * (1.0 + 0.25 * x * (1.0 + 0.46875 * x)));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e1fn,The following statement contains a magic number: return (0.375 * x * (1.0 + 0.25 * x * (1.0 + 0.46875 * x)));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e2fn,The following statement contains a magic number: return (0.05859375 * x * x * (1.0 + 0.75 * x));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e2fn,The following statement contains a magic number: return (0.05859375 * x * x * (1.0 + 0.75 * x));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e3fn,The following statement contains a magic number: return (x * x * x * (35.0 / 3072.0));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e3fn,The following statement contains a magic number: return (x * x * x * (35.0 / 3072.0));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,mlfn,The following statement contains a magic number: return (e0 * phi - e1 * Math.Sin(2.0 * phi) + e2 * Math.Sin(4.0 * phi) - e3 * Math.Sin(6.0 * phi));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,mlfn,The following statement contains a magic number: return (e0 * phi - e1 * Math.Sin(2.0 * phi) + e2 * Math.Sin(4.0 * phi) - e3 * Math.Sin(6.0 * phi));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,mlfn,The following statement contains a magic number: return (e0 * phi - e1 * Math.Sin(2.0 * phi) + e2 * Math.Sin(4.0 * phi) - e3 * Math.Sin(6.0 * phi));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,calcUtmZone,The following statement contains a magic number: return ((long)(((lon + 180.0) / 6.0) + 1.0));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,calcUtmZone,The following statement contains a magic number: return ((long)(((lon + 180.0) / 6.0) + 1.0));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LongitudeToRadians,The following statement contains a magic number: edge ? (x >= -180 && x <= 180) : (x > -180 && x < 180)
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LongitudeToRadians,The following statement contains a magic number: edge ? (x >= -180 && x <= 180) : (x > -180 && x < 180)
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LongitudeToRadians,The following statement contains a magic number: edge ? (x >= -180 && x <= 180) : (x > -180 && x < 180)
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LongitudeToRadians,The following statement contains a magic number: edge ? (x >= -180 && x <= 180) : (x > -180 && x < 180)
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LatitudeToRadians,The following statement contains a magic number: edge ? (y >= -90 && y <= 90) : (y > -90 && y < 90)
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LatitudeToRadians,The following statement contains a magic number: edge ? (y >= -90 && y <= 90) : (y > -90 && y < 90)
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LatitudeToRadians,The following statement contains a magic number: edge ? (y >= -90 && y <= 90) : (y > -90 && y < 90)
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LatitudeToRadians,The following statement contains a magic number: edge ? (y >= -90 && y <= 90) : (y > -90 && y < 90)
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,getAffineTransformMatrix,The following statement contains a magic number: a[0' 2] = 0;
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,getAffineTransformMatrix,The following statement contains a magic number: a[1' 2] = 0;
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,getAffineTransformMatrix,The following statement contains a magic number: a[2' 2] = 1;
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,getAffineTransformMatrix,The following statement contains a magic number: a[2' 2] = 1;
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,calculateOptimalAffineTransformPoints,The following statement contains a magic number: int[] result = new int[3];
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,calculateOptimalAffineTransformPoints,The following statement contains a magic number: result[2] = i3;
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,calculateOptimalAffineTransformPoints,The following statement contains a magic number: i1 < _sourceControlPoints.Length - 2
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,Transform,The following statement contains a magic number: sum += Math.Pow(temp' 2);
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,Transform,The following statement contains a magic number: w[k] = Math.Pow(temp' 2) / sum;
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,RubberSheetingTransform,The following statement contains a magic number: sourceControlPoints.Length < 3
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,RubberSheetingTransform,The following statement contains a magic number: destinationControlPoints.Length < 3
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,RubberSheetingTransform,The following statement contains a magic number: _optimalAffineTransform = new Affine(                  getAffineTransformMatrix(                  _sourceControlPoints[_affineTransformPointsIndicies[0]]'                  _sourceControlPoints[_affineTransformPointsIndicies[1]]'                  _sourceControlPoints[_affineTransformPointsIndicies[2]]'                  _destinationControlPoints[_affineTransformPointsIndicies[0]]'                  _destinationControlPoints[_affineTransformPointsIndicies[1]]'                  _destinationControlPoints[_affineTransformPointsIndicies[2]]                  ));
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,RubberSheetingTransform,The following statement contains a magic number: _optimalAffineTransform = new Affine(                  getAffineTransformMatrix(                  _sourceControlPoints[_affineTransformPointsIndicies[0]]'                  _sourceControlPoints[_affineTransformPointsIndicies[1]]'                  _sourceControlPoints[_affineTransformPointsIndicies[2]]'                  _destinationControlPoints[_affineTransformPointsIndicies[0]]'                  _destinationControlPoints[_affineTransformPointsIndicies[1]]'                  _destinationControlPoints[_affineTransformPointsIndicies[2]]                  ));
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,GeocentricTransform,The following statement contains a magic number: ses = (Math.Pow(semiMajor' 2) - Math.Pow(semiMinor' 2)) / Math.Pow(semiMinor' 2);
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,GeocentricTransform,The following statement contains a magic number: ses = (Math.Pow(semiMajor' 2) - Math.Pow(semiMinor' 2)) / Math.Pow(semiMinor' 2);
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,GeocentricTransform,The following statement contains a magic number: ses = (Math.Pow(semiMajor' 2) - Math.Pow(semiMinor' 2)) / Math.Pow(semiMinor' 2);
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,DegreesToMeters,The following statement contains a magic number: double h = lonlat.Length < 3 ? 0 : lonlat[2].Equals(Double.NaN) ? 0 : lonlat[2];
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,DegreesToMeters,The following statement contains a magic number: double h = lonlat.Length < 3 ? 0 : lonlat[2].Equals(Double.NaN) ? 0 : lonlat[2];
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,DegreesToMeters,The following statement contains a magic number: double h = lonlat.Length < 3 ? 0 : lonlat[2].Equals(Double.NaN) ? 0 : lonlat[2];
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,DegreesToMeters,The following statement contains a magic number: double v = semiMajor / Math.Sqrt(1 - es * Math.Pow(Math.Sin(lat)' 2));
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,MetersToDegrees,The following statement contains a magic number: double Z = pnt.Length < 3 ? 0 : pnt[2].Equals(Double.NaN) ? 0 : pnt[2];
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,MetersToDegrees,The following statement contains a magic number: double Z = pnt.Length < 3 ? 0 : pnt[2].Equals(Double.NaN) ? 0 : pnt[2];
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,MetersToDegrees,The following statement contains a magic number: double Z = pnt.Length < 3 ? 0 : pnt[2].Equals(Double.NaN) ? 0 : pnt[2];
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,MetersToDegrees,The following statement contains a magic number: double Sin3_B0 = Math.Pow(Sin_B0' 3);
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,apply,The following statement contains a magic number: return new double[] {  				v[0] * p[0] - v[3] * p[1] + v[2] * p[2] + v[4]'  				v[3] * p[0] + v[0] * p[1] - v[1] * p[2] + v[5]'  			   -v[2] * p[0] + v[1] * p[1] + v[0] * p[2] + v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,apply,The following statement contains a magic number: return new double[] {  				v[0] * p[0] - v[3] * p[1] + v[2] * p[2] + v[4]'  				v[3] * p[0] + v[0] * p[1] - v[1] * p[2] + v[5]'  			   -v[2] * p[0] + v[1] * p[1] + v[0] * p[2] + v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,apply,The following statement contains a magic number: return new double[] {  				v[0] * p[0] - v[3] * p[1] + v[2] * p[2] + v[4]'  				v[3] * p[0] + v[0] * p[1] - v[1] * p[2] + v[5]'  			   -v[2] * p[0] + v[1] * p[1] + v[0] * p[2] + v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,apply,The following statement contains a magic number: return new double[] {  				v[0] * p[0] - v[3] * p[1] + v[2] * p[2] + v[4]'  				v[3] * p[0] + v[0] * p[1] - v[1] * p[2] + v[5]'  			   -v[2] * p[0] + v[1] * p[1] + v[0] * p[2] + v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,apply,The following statement contains a magic number: return new double[] {  				v[0] * p[0] - v[3] * p[1] + v[2] * p[2] + v[4]'  				v[3] * p[0] + v[0] * p[1] - v[1] * p[2] + v[5]'  			   -v[2] * p[0] + v[1] * p[1] + v[0] * p[2] + v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,apply,The following statement contains a magic number: return new double[] {  				v[0] * p[0] - v[3] * p[1] + v[2] * p[2] + v[4]'  				v[3] * p[0] + v[0] * p[1] - v[1] * p[2] + v[5]'  			   -v[2] * p[0] + v[1] * p[1] + v[0] * p[2] + v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,apply,The following statement contains a magic number: return new double[] {  				v[0] * p[0] - v[3] * p[1] + v[2] * p[2] + v[4]'  				v[3] * p[0] + v[0] * p[1] - v[1] * p[2] + v[5]'  			   -v[2] * p[0] + v[1] * p[1] + v[0] * p[2] + v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,apply,The following statement contains a magic number: return new double[] {  				v[0] * p[0] - v[3] * p[1] + v[2] * p[2] + v[4]'  				v[3] * p[0] + v[0] * p[1] - v[1] * p[2] + v[5]'  			   -v[2] * p[0] + v[1] * p[1] + v[0] * p[2] + v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,apply,The following statement contains a magic number: return new double[] {  				v[0] * p[0] - v[3] * p[1] + v[2] * p[2] + v[4]'  				v[3] * p[0] + v[0] * p[1] - v[1] * p[2] + v[5]'  			   -v[2] * p[0] + v[1] * p[1] + v[0] * p[2] + v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,apply,The following statement contains a magic number: return new double[] {  				v[0] * p[0] - v[3] * p[1] + v[2] * p[2] + v[4]'  				v[3] * p[0] + v[0] * p[1] - v[1] * p[2] + v[5]'  			   -v[2] * p[0] + v[1] * p[1] + v[0] * p[2] + v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,applyInverted,The following statement contains a magic number: return new double[] {  				v[0] * p[0] + v[3] * p[1] - v[2] * p[2] - v[4]'  			   -v[3] * p[0] + v[0] * p[1] + v[1] * p[2] - v[5]'  			    v[2] * p[0] - v[1] * p[1] + v[0] * p[2] - v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,applyInverted,The following statement contains a magic number: return new double[] {  				v[0] * p[0] + v[3] * p[1] - v[2] * p[2] - v[4]'  			   -v[3] * p[0] + v[0] * p[1] + v[1] * p[2] - v[5]'  			    v[2] * p[0] - v[1] * p[1] + v[0] * p[2] - v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,applyInverted,The following statement contains a magic number: return new double[] {  				v[0] * p[0] + v[3] * p[1] - v[2] * p[2] - v[4]'  			   -v[3] * p[0] + v[0] * p[1] + v[1] * p[2] - v[5]'  			    v[2] * p[0] - v[1] * p[1] + v[0] * p[2] - v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,applyInverted,The following statement contains a magic number: return new double[] {  				v[0] * p[0] + v[3] * p[1] - v[2] * p[2] - v[4]'  			   -v[3] * p[0] + v[0] * p[1] + v[1] * p[2] - v[5]'  			    v[2] * p[0] - v[1] * p[1] + v[0] * p[2] - v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,applyInverted,The following statement contains a magic number: return new double[] {  				v[0] * p[0] + v[3] * p[1] - v[2] * p[2] - v[4]'  			   -v[3] * p[0] + v[0] * p[1] + v[1] * p[2] - v[5]'  			    v[2] * p[0] - v[1] * p[1] + v[0] * p[2] - v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,applyInverted,The following statement contains a magic number: return new double[] {  				v[0] * p[0] + v[3] * p[1] - v[2] * p[2] - v[4]'  			   -v[3] * p[0] + v[0] * p[1] + v[1] * p[2] - v[5]'  			    v[2] * p[0] - v[1] * p[1] + v[0] * p[2] - v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,applyInverted,The following statement contains a magic number: return new double[] {  				v[0] * p[0] + v[3] * p[1] - v[2] * p[2] - v[4]'  			   -v[3] * p[0] + v[0] * p[1] + v[1] * p[2] - v[5]'  			    v[2] * p[0] - v[1] * p[1] + v[0] * p[2] - v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,applyInverted,The following statement contains a magic number: return new double[] {  				v[0] * p[0] + v[3] * p[1] - v[2] * p[2] - v[4]'  			   -v[3] * p[0] + v[0] * p[1] + v[1] * p[2] - v[5]'  			    v[2] * p[0] - v[1] * p[1] + v[0] * p[2] - v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,applyInverted,The following statement contains a magic number: return new double[] {  				v[0] * p[0] + v[3] * p[1] - v[2] * p[2] - v[4]'  			   -v[3] * p[0] + v[0] * p[1] + v[1] * p[2] - v[5]'  			    v[2] * p[0] - v[1] * p[1] + v[0] * p[2] - v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,applyInverted,The following statement contains a magic number: return new double[] {  				v[0] * p[0] + v[3] * p[1] - v[2] * p[2] - v[4]'  			   -v[3] * p[0] + v[0] * p[1] + v[1] * p[2] - v[5]'  			    v[2] * p[0] - v[1] * p[1] + v[0] * p[2] - v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,CreateCoordinateOperation,The following statement contains a magic number: List<ProjectionParameter> parameterList = new List<ProjectionParameter>(2);
Magic Number,MapAround.CoordinateSystems.Transformations,GeometryTransformer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformers.cs,TransformBoundingRectangle,The following statement contains a magic number: ICoordinate[] corners = new ICoordinate[4];
Magic Number,MapAround.CoordinateSystems.Transformations,GeometryTransformer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformers.cs,TransformBoundingRectangle,The following statement contains a magic number: corners[2] = PlanimetryEnvironment.NewCoordinate(transform.Transform(PlanimetryEnvironment.NewCoordinate(box.MinX' box.MaxY).Values()));
Magic Number,MapAround.CoordinateSystems.Transformations,GeometryTransformer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformers.cs,TransformBoundingRectangle,The following statement contains a magic number: corners[3] = PlanimetryEnvironment.NewCoordinate(transform.Transform(PlanimetryEnvironment.NewCoordinate(box.MaxX' box.MinY).Values()));
Magic Number,MapAround.CoordinateSystems.Transformations,GeometryTransformer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformers.cs,TransformBoundingRectangle,The following statement contains a magic number: i < 4
Magic Number,MapAround.CoordinateSystems.Transformations,GeometryTransformer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformers.cs,TransformMultiPoint,The following statement contains a magic number: points.Add(new double[2] { multiPoint.Points[i].X' multiPoint.Points[i].Y });
Magic Number,MapAround.CoordinateSystems.Transformations,GeometryTransformer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformers.cs,TransformContour,The following statement contains a magic number: points.Add(new double[2] { contour.Vertices[i].X' contour.Vertices[i].Y });
Magic Number,MapAround.CoordinateSystems.Transformations,GeometryTransformer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformers.cs,TransformLinePath,The following statement contains a magic number: points.Add(new double[2] { linePath.Vertices[i].X' linePath.Vertices[i].Y });
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: int delta = 2;
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: p.Length % 3 == 0
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: result[i + 2] = p[i + 2];
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: result[i + 2] = p[i + 2];
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: delta == 3
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: i < p.Length / 2
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: int delta = 2;
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: p.Length % 3 == 0
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: result[i + 2] = p[i + 2];
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: result[i + 2] = p[i + 2];
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: delta == 3
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: i < p.Length / 2
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: int delta = 2;
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: p.Length % 3 == 0
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: result[i + 2] = p[i + 2];
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: result[i + 2] = p[i + 2];
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: delta == 3
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: result[i] = V(_x' nodeIndex * 4' dphi) * _fxc * p1;
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: result[i + 1] = V(_y' nodeIndex * 4' dphi) * _fyc;
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: i < p.Length / 2
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: int delta = 2;
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: p.Length % 3 == 0
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: result[i + 2] = p[i + 2];
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: result[i + 2] = p[i + 2];
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: delta == 3
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: double[] T = new double[4];
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: result[i + 1] =                          p[i + 1] < 0 ? -Math.PI * 0.5 : Math.PI * 0.5;
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: result[i + 1] =                          p[i + 1] < 0 ? -Math.PI * 0.5 : Math.PI * 0.5;
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: result[i] /= _x[_nodes * 4];
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: i < p.Length / 2
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,V,The following statement contains a magic number: return C[iStart] + z * (C[iStart + 1] + z * (C[iStart + 2] + z * C[iStart + 3]));
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,V,The following statement contains a magic number: return C[iStart] + z * (C[iStart + 1] + z * (C[iStart + 2] + z * C[iStart + 3]));
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,DV,The following statement contains a magic number: return C[iStart + 1] + z * (C[iStart + 2] + C[iStart + 2] + z * 3 * C[iStart + 3]);
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,DV,The following statement contains a magic number: return C[iStart + 1] + z * (C[iStart + 2] + C[iStart + 2] + z * 3 * C[iStart + 3]);
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,DV,The following statement contains a magic number: return C[iStart + 1] + z * (C[iStart + 2] + C[iStart + 2] + z * 3 * C[iStart + 3]);
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,DV,The following statement contains a magic number: return C[iStart + 1] + z * (C[iStart + 2] + C[iStart + 2] + z * 3 * C[iStart + 3]);
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,getMinEntryIndex,The following statement contains a magic number: i = 2;
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,getMinEntryIndex,The following statement contains a magic number: Math.Abs(values[2]) < Math.Abs(values[i])
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Gnomonic,The following statement contains a magic number: double[] vector = new double[3];
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Gnomonic,The following statement contains a magic number: int j = (k + 2) % 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Gnomonic,The following statement contains a magic number: int j = (k + 2) % 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Gnomonic,The following statement contains a magic number: int i = (j + 2) % 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Gnomonic,The following statement contains a magic number: int i = (j + 2) % 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Gnomonic,The following statement contains a magic number: _xAxis = (new Vector3(vector[0]' vector[1]' vector[2])).Unitize();
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: int delta = 2;
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: p.Length % 3 == 0
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: result[i + 2] = p[i + 2];
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: result[i + 2] = p[i + 2];
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: delta == 3
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: r < 1e-8
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: i < p.Length / 2
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: int delta = 2;
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: p.Length % 3 == 0
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: result[i + 2] = p[i + 2];
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: result[i + 2] = p[i + 2];
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: delta == 3
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: i < p.Length / 2
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Affine,The following statement contains a magic number: matrix.Size != 3
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Affine,The following statement contains a magic number: matrix[0' 2] != 0 || matrix[1' 2] != 0 || matrix[2' 2] != 1
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Affine,The following statement contains a magic number: matrix[0' 2] != 0 || matrix[1' 2] != 0 || matrix[2' 2] != 1
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Affine,The following statement contains a magic number: matrix[0' 2] != 0 || matrix[1' 2] != 0 || matrix[2' 2] != 1
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Affine,The following statement contains a magic number: matrix[0' 2] != 0 || matrix[1' 2] != 0 || matrix[2' 2] != 1
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Inverse,The following statement contains a magic number: _inverseMatrix[0' 2] = 0;
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Inverse,The following statement contains a magic number: _inverseMatrix[1' 2] = 0;
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Inverse,The following statement contains a magic number: _inverseMatrix[2' 2] = 1;
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Inverse,The following statement contains a magic number: _inverseMatrix[2' 2] = 1;
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: int delta = 2;
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: p.Length % 3 == 0
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: result[i] = p[i] * _matrix[0' 0] + p[i + 1] * _matrix[1' 0] + _matrix[2' 0];
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: result[i + 1] = p[i] * _matrix[0' 1] + p[i + 1] * _matrix[1' 1] + _matrix[2' 1];
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: result[i + 2] = p[i + 2];
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: result[i + 2] = p[i + 2];
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: delta == 3
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: i < p.Length / 2
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: int delta = 2;
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: p.Length % 3 == 0
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: result[i] = p[i] * _inverseMatrix[0' 0] + p[i + 1] * _inverseMatrix[1' 0] + _inverseMatrix[2' 0];
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: result[i + 1] = p[i] * _inverseMatrix[0' 1] + p[i + 1] * _inverseMatrix[1' 1] + _inverseMatrix[2' 1];
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: result[i + 2] = p[i + 2];
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: result[i + 2] = p[i + 2];
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: delta == 3
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: i < p.Length / 2
Magic Number,MapAround.DataProviders,ShapeFileSpatialDataProvider,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\ShapeFileDataProvider.cs,geometryFromShapeRecord,The following statement contains a magic number: switch (record.ShapeType)              {                  // point                  case 1:                      return new PointD(record.Points[0].X' record.Points[0].Y);                  // polyline                  case 3:                      Polyline polyline = new Polyline();                      for (int i = 0; i < record.Parts.Count; i++)                      {                          LinePath path = new LinePath();                          int j;                          for (j = record.Parts[i]; j < (i == record.Parts.Count - 1 ? record.Points.Count : record.Parts[i + 1]); j++)                              path.Vertices.Add(PlanimetryEnvironment.NewCoordinate(record.Points[j].X' record.Points[j].Y));                            polyline.Paths.Add(path);                      }                      return polyline;                  // ground                  case 5:                      Polygon p = new Polygon();                      for (int i = 0; i < record.Parts.Count; i++)                      {                          Contour contour = new Contour();                          int j;                          for (j = record.Parts[i]; j < (i == record.Parts.Count - 1 ? record.Points.Count : record.Parts[i + 1]); j++)                              contour.Vertices.Add(PlanimetryEnvironment.NewCoordinate(record.Points[j].X' record.Points[j].Y));                            contour.Vertices.RemoveAt(contour.Vertices.Count - 1);                          p.Contours.Add(contour);                      }                      if (p.CoordinateCount > 0)                          return p;                      else                          return null;                  // set of points                  case 8:                      MultiPoint mp = new MultiPoint();                      for (int i = 0; i < record.Points.Count; i++)                          mp.Points.Add(PlanimetryEnvironment.NewCoordinate(record.Points[i].X' record.Points[i].Y));                      return mp;              }
Magic Number,MapAround.DataProviders,ShapeFileSpatialDataProvider,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\ShapeFileDataProvider.cs,geometryFromShapeRecord,The following statement contains a magic number: switch (record.ShapeType)              {                  // point                  case 1:                      return new PointD(record.Points[0].X' record.Points[0].Y);                  // polyline                  case 3:                      Polyline polyline = new Polyline();                      for (int i = 0; i < record.Parts.Count; i++)                      {                          LinePath path = new LinePath();                          int j;                          for (j = record.Parts[i]; j < (i == record.Parts.Count - 1 ? record.Points.Count : record.Parts[i + 1]); j++)                              path.Vertices.Add(PlanimetryEnvironment.NewCoordinate(record.Points[j].X' record.Points[j].Y));                            polyline.Paths.Add(path);                      }                      return polyline;                  // ground                  case 5:                      Polygon p = new Polygon();                      for (int i = 0; i < record.Parts.Count; i++)                      {                          Contour contour = new Contour();                          int j;                          for (j = record.Parts[i]; j < (i == record.Parts.Count - 1 ? record.Points.Count : record.Parts[i + 1]); j++)                              contour.Vertices.Add(PlanimetryEnvironment.NewCoordinate(record.Points[j].X' record.Points[j].Y));                            contour.Vertices.RemoveAt(contour.Vertices.Count - 1);                          p.Contours.Add(contour);                      }                      if (p.CoordinateCount > 0)                          return p;                      else                          return null;                  // set of points                  case 8:                      MultiPoint mp = new MultiPoint();                      for (int i = 0; i < record.Points.Count; i++)                          mp.Points.Add(PlanimetryEnvironment.NewCoordinate(record.Points[i].X' record.Points[i].Y));                      return mp;              }
Magic Number,MapAround.DataProviders,ShapeFileSpatialDataProvider,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\ShapeFileDataProvider.cs,geometryFromShapeRecord,The following statement contains a magic number: switch (record.ShapeType)              {                  // point                  case 1:                      return new PointD(record.Points[0].X' record.Points[0].Y);                  // polyline                  case 3:                      Polyline polyline = new Polyline();                      for (int i = 0; i < record.Parts.Count; i++)                      {                          LinePath path = new LinePath();                          int j;                          for (j = record.Parts[i]; j < (i == record.Parts.Count - 1 ? record.Points.Count : record.Parts[i + 1]); j++)                              path.Vertices.Add(PlanimetryEnvironment.NewCoordinate(record.Points[j].X' record.Points[j].Y));                            polyline.Paths.Add(path);                      }                      return polyline;                  // ground                  case 5:                      Polygon p = new Polygon();                      for (int i = 0; i < record.Parts.Count; i++)                      {                          Contour contour = new Contour();                          int j;                          for (j = record.Parts[i]; j < (i == record.Parts.Count - 1 ? record.Points.Count : record.Parts[i + 1]); j++)                              contour.Vertices.Add(PlanimetryEnvironment.NewCoordinate(record.Points[j].X' record.Points[j].Y));                            contour.Vertices.RemoveAt(contour.Vertices.Count - 1);                          p.Contours.Add(contour);                      }                      if (p.CoordinateCount > 0)                          return p;                      else                          return null;                  // set of points                  case 8:                      MultiPoint mp = new MultiPoint();                      for (int i = 0; i < record.Points.Count; i++)                          mp.Points.Add(PlanimetryEnvironment.NewCoordinate(record.Points[i].X' record.Points[i].Y));                      return mp;              }
Magic Number,MapAround.DataProviders,SpatialDataProviderBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\SpatialDataProviders.cs,readInt,The following statement contains a magic number: i < 4
Magic Number,MapAround.DataProviders,SpatialDataProviderBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\SpatialDataProviders.cs,writeInt,The following statement contains a magic number: i < 4
Magic Number,MapAround.Extensions.Surfaces,ShadedReliefBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\ShadedReliefBuilder.cs,BuildShadedRelief,The following statement contains a magic number: result[i] = new LightenedPolygon(mergeTriangles(collector)' minL + luminosityRange * i + luminosityRange * 0.5);
Magic Number,MapAround.Extensions.Surfaces,IsolineBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,getIsoline,The following statement contains a magic number: z > tz[2]
Magic Number,MapAround.Extensions.Surfaces,IsolineBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,getIsoline,The following statement contains a magic number: z == tz[0] && z == tz[1] && z == tz[2]
Magic Number,MapAround.Extensions.Surfaces,IsolineBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,getIsoline,The following statement contains a magic number: (z == tz[0] && z == tz[1]) ||                      (z == tz[1] && z == tz[2])
Magic Number,MapAround.Extensions.Surfaces,IsolineBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,assignLevelsToPolygons,The following statement contains a magic number: index.MinObjectCount = 10;
Magic Number,MapAround.Extensions.Surfaces,IsolineBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,assignLevelsToPolygons,The following statement contains a magic number: index.MaxDepth = 20;
Magic Number,MapAround.Extensions.Surfaces,IsolineBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,assignLevelsToPolygons,The following statement contains a magic number: index.BoxSquareThreshold = index.IndexedSpace.Width * index.IndexedSpace.Height / 10000;
Magic Number,MapAround.Extensions.Surfaces,IsolineBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,assignLevelsToPolygons,The following statement contains a magic number: double z =                              getZ(c'                                   new Coordinate3D(triangle.Contours[0].Vertices[0].Values())'                                   new Coordinate3D(triangle.Contours[0].Vertices[1].Values())'                                   new Coordinate3D(triangle.Contours[0].Vertices[2].Values()));
Magic Number,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: points1 = getArcPoints(downToUp ? segment.V1 : segment.V2'                                          Math.PI'                                          2 * Math.PI'                                          distance'                                          downToUp && !bothSides ? 2 : pointsPerCircle);
Magic Number,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: points1 = getArcPoints(downToUp ? segment.V1 : segment.V2'                                          Math.PI'                                          2 * Math.PI'                                          distance'                                          downToUp && !bothSides ? 2 : pointsPerCircle);
Magic Number,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: points2 = getArcPoints(downToUp ? segment.V2 : segment.V1'                                          0'                                          Math.PI'                                          distance'                                         !downToUp && !bothSides ? 2 : pointsPerCircle);
Magic Number,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: points1 = getArcPoints(leftToRight ? segment.V1 : segment.V2'                                          0.5 * Math.PI'                                          1.5 * Math.PI'                                          distance'                                          leftToRight && !bothSides ? 2 : pointsPerCircle);
Magic Number,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: points1 = getArcPoints(leftToRight ? segment.V1 : segment.V2'                                          0.5 * Math.PI'                                          1.5 * Math.PI'                                          distance'                                          leftToRight && !bothSides ? 2 : pointsPerCircle);
Magic Number,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: points1 = getArcPoints(leftToRight ? segment.V1 : segment.V2'                                          0.5 * Math.PI'                                          1.5 * Math.PI'                                          distance'                                          leftToRight && !bothSides ? 2 : pointsPerCircle);
Magic Number,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: points2 = getArcPoints(leftToRight ? segment.V2 : segment.V1'                                          1.5 * Math.PI'                                          2.5 * Math.PI'                                          distance'                                         !leftToRight && !bothSides ? 2 : pointsPerCircle);
Magic Number,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: points2 = getArcPoints(leftToRight ? segment.V2 : segment.V1'                                          1.5 * Math.PI'                                          2.5 * Math.PI'                                          distance'                                         !leftToRight && !bothSides ? 2 : pointsPerCircle);
Magic Number,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: points2 = getArcPoints(leftToRight ? segment.V2 : segment.V1'                                          1.5 * Math.PI'                                          2.5 * Math.PI'                                          distance'                                         !leftToRight && !bothSides ? 2 : pointsPerCircle);
Magic Number,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: points1 = getArcPoints(segment.V1'                                          angle + 0.5 * Math.PI'                                          angle + 1.5 * Math.PI'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);
Magic Number,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: points1 = getArcPoints(segment.V1'                                          angle + 0.5 * Math.PI'                                          angle + 1.5 * Math.PI'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);
Magic Number,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: points1 = getArcPoints(segment.V1'                                          angle + 0.5 * Math.PI'                                          angle + 1.5 * Math.PI'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);
Magic Number,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: points2 = getArcPoints(segment.V2'                                          angle - 0.5 * Math.PI'                                          angle + 0.5 * Math.PI'                                          distance'                                          !bothSides && wasSwapped ? 2 : pointsPerCircle);
Magic Number,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: points2 = getArcPoints(segment.V2'                                          angle - 0.5 * Math.PI'                                          angle + 0.5 * Math.PI'                                          distance'                                          !bothSides && wasSwapped ? 2 : pointsPerCircle);
Magic Number,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: points2 = getArcPoints(segment.V2'                                          angle - 0.5 * Math.PI'                                          angle + 0.5 * Math.PI'                                          distance'                                          !bothSides && wasSwapped ? 2 : pointsPerCircle);
Magic Number,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,mergePartialBuffers,The following statement contains a magic number: !allowParallels || buffers.Count < 20
Magic Number,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getBoundsBuffer,The following statement contains a magic number: c == 3
Magic Number,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getPolylineBuffer,The following statement contains a magic number: c == 3
Magic Number,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getMultiPointBuffer,The following statement contains a magic number: c == 3
Magic Number,MapAround.Geometry,BufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,GetBuffer,The following statement contains a magic number: pointsPerCircle <= 2
Magic Number,MapAround.Geometry,MonotoneChain,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\DataStructures.cs,isPointInSegmentsBounds,The following statement contains a magic number: int middleIndex = minIndex + (maxIndex - minIndex) / 2;
Magic Number,MapAround.Geometry,Coordinate,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,Values,The following statement contains a magic number: return new double[2] { _x' _y };
Magic Number,MapAround.Geometry,Coordinate,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,Coordinate,The following statement contains a magic number: coords.Length != 2
Magic Number,MapAround.Geometry,Coordinate3D,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,Values,The following statement contains a magic number: return new double[3] { _x' _y' _z };
Magic Number,MapAround.Geometry,Coordinate3D,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,Coordinate3D,The following statement contains a magic number: coords.Length == 2
Magic Number,MapAround.Geometry,Coordinate3D,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,Coordinate3D,The following statement contains a magic number: _z = coords[2];
Magic Number,MapAround.Geometry,Coordinate3D,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,Coordinate3D,The following statement contains a magic number: coords.Length == 3
Magic Number,MapAround.Geometry,ReadOnlyCoordinate,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,Values,The following statement contains a magic number: return new double[2] { _x' _y };
Magic Number,MapAround.Geometry,ReadOnlyCoordinate,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,ReadOnlyCoordinate,The following statement contains a magic number: coords.Length != 2
Magic Number,MapAround.Geometry,ReadOnlyCoordinate3D,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,Values,The following statement contains a magic number: return new double[3] { _x' _y' _z };
Magic Number,MapAround.Geometry,ReadOnlyCoordinate3D,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,ReadOnlyCoordinate3D,The following statement contains a magic number: coords.Length == 2
Magic Number,MapAround.Geometry,ReadOnlyCoordinate3D,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,ReadOnlyCoordinate3D,The following statement contains a magic number: _z = coords[2];
Magic Number,MapAround.Geometry,ReadOnlyCoordinate3D,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,ReadOnlyCoordinate3D,The following statement contains a magic number: coords.Length == 3
Magic Number,MapAround.Geometry,Coordinate3DFactory,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,Create,The following statement contains a magic number: values.Length == 2
Magic Number,MapAround.Geometry,Segment,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Center,The following statement contains a magic number: return PlanimetryEnvironment.NewCoordinate((V1.X + V2.X) / 2' (V1.Y + V2.Y) / 2);
Magic Number,MapAround.Geometry,Segment,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Center,The following statement contains a magic number: return PlanimetryEnvironment.NewCoordinate((V1.X + V2.X) / 2' (V1.Y + V2.Y) / 2);
Magic Number,MapAround.Geometry,Contour,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,weedSection,The following statement contains a magic number: endIndex - startIndex < 2
Magic Number,MapAround.Geometry,Contour,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,SignedArea,The following statement contains a magic number: Vertices.Count < 3
Magic Number,MapAround.Geometry,Contour,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,SignedArea,The following statement contains a magic number: result += (Vertices[i].X + Vertices[j].X - delta.X * 2) * (Vertices[i].Y - Vertices[j].Y) / 2;
Magic Number,MapAround.Geometry,Contour,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,SignedArea,The following statement contains a magic number: result += (Vertices[i].X + Vertices[j].X - delta.X * 2) * (Vertices[i].Y - Vertices[j].Y) / 2;
Magic Number,MapAround.Geometry,Contour,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,PointLiesInside,The following statement contains a magic number: return crossCount % 2 == 1;
Magic Number,MapAround.Geometry,Contour,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Reverse,The following statement contains a magic number: i < Vertices.Count / 2
Magic Number,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,processCycle,The following statement contains a magic number: i != chain[chain.Count - 2]
Magic Number,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,processCycle,The following statement contains a magic number: chain.Count > 2
Magic Number,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,ContainsPoint,The following statement contains a magic number: return crossCount % 2 == 1;
Magic Number,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,getInteriorPoint,The following statement contains a magic number: double newY = (besector.V1.Y + minY) / 2;
Magic Number,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,getInteriorPoint,The following statement contains a magic number: double newY = (besector.V1.Y + minY) / 2;
Magic Number,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,PointOnSurface,The following statement contains a magic number: c.Vertices.Count > 2
Magic Number,MapAround.Geometry,LinePath,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,weedSection,The following statement contains a magic number: endIndex - startIndex < 2
Magic Number,MapAround.Geometry,LinePath,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Reverse,The following statement contains a magic number: i < Vertices.Count / 2
Magic Number,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,calculateOverlay,The following statement contains a magic number: minDim == 2 && maxDim == 2
Magic Number,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,calculateOverlay,The following statement contains a magic number: minDim == 2 && maxDim == 2
Magic Number,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,calculateOverlay,The following statement contains a magic number: minDim == 0 && maxDim == 2
Magic Number,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,calculateOverlay,The following statement contains a magic number: minDim == 1 && maxDim == 2
Magic Number,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,init,The following statement contains a magic number: reduceGeometrySegments(_geometry1' PlanimetryAlgorithms.Tolerance * 1.42);
Magic Number,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,init,The following statement contains a magic number: reduceGeometrySegments(_geometry2' PlanimetryAlgorithms.Tolerance * 1.42);
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,SignedDistanceToLine,The following statement contains a magic number: double mx = (v1x + v2x + x) / 3;
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,SignedDistanceToLine,The following statement contains a magic number: double my = (v1y + v2y + y) / 3;
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,RobustSegmentsIntersection,The following statement contains a magic number: intersectionSegment = new Segment(list[2]' list[1]);
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,RobustSegmentsIntersection,The following statement contains a magic number: intersectionPoint = list[2];
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,SegmentsIntersection,The following statement contains a magic number: intersectionSegment = new Segment(list[2]' list[1]);
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,SegmentsIntersection,The following statement contains a magic number: intersectionPoint = list[2];
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,OrderPointsOverAxis,The following statement contains a magic number: coordinates.Count < 2
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,GetConvexHull,The following statement contains a magic number: result.Count <= 2
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,GetConvexHull,The following statement contains a magic number: result.Count > 200
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,GetConvexHull,The following statement contains a magic number: pointStack.Push(result[2]);
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,SnapToGrid,The following statement contains a magic number: double unitGridExtent = 1e15;
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,SnapToGrid,The following statement contains a magic number: coordinate.X = Math.Floor((coordinate.X - origin.X) / cellSize + 0.5) * cellSize + origin.X;
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,SnapToGrid,The following statement contains a magic number: coordinate.Y = Math.Floor((coordinate.Y - origin.Y) / cellSize + 0.5) * cellSize + origin.Y;
Magic Number,MapAround.Geometry,GeometrySimplifier,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,getCrossPointsIndex,The following statement contains a magic number: result.MaxDepth = 10;
Magic Number,MapAround.Geometry,GeometrySimplifier,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,getCrossPointsIndex,The following statement contains a magic number: result.MinObjectCount = 10;
Magic Number,MapAround.Geometry,GeometrySimplifier,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,getCrossPointsIndex,The following statement contains a magic number: result.BoxSquareThreshold = br.Width * br.Height / 10000;
Magic Number,MapAround.Geometry,GeometrySimplifier,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,buildVertexIndex,The following statement contains a magic number: result.MaxDepth = 14;
Magic Number,MapAround.Geometry,GeometrySimplifier,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,buildVertexIndex,The following statement contains a magic number: result.MinObjectCount = 10;
Magic Number,MapAround.Geometry,GeometrySimplifier,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,buildVertexIndex,The following statement contains a magic number: result.BoxSquareThreshold = br.Width * br.Height / 10000;
Magic Number,MapAround.Geometry,GeometrySimplifier,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,checkWeightedVertex,The following statement contains a magic number: p.ExactEquals(triangle.Contours[0].Vertices[0]) ||                     p.ExactEquals(triangle.Contours[0].Vertices[1]) ||                     p.ExactEquals(triangle.Contours[0].Vertices[2])
Magic Number,MapAround.Geometry,GeometrySimplifier,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,getPolygonFromBounds,The following statement contains a magic number: path.Vertices.Count <= 2
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,elementToChar,The following statement contains a magic number: x < 0 || x > 2
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,elementToChar,The following statement contains a magic number: y < 0 || y > 2
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateValue,The following statement contains a magic number: _values[2' 2] = ElementValue.Two;
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateValue,The following statement contains a magic number: _values[2' 2] = ElementValue.Two;
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateValue,The following statement contains a magic number: x == 2 && y == 2
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateValue,The following statement contains a magic number: x == 2 && y == 2
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculteInternalInternal,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ---------------------------- the intersection of the interior of the two points                  case DimensionPair.ZeroZero:                        this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                              break;                          }                      break;                  // ---------------------------- the intersection of the interior of a point and a polyline                  case DimensionPair.ZeroOne:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2 && node.IncidentEdges.Count % 2 != 1)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                              break;                          }                      break;                  // ---------------------------- crossing point' and the interior of the polygon                  case DimensionPair.ZeroTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        Polygon polygon = _sourceGeometry1 is Polygon ? (Polygon)_sourceGeometry1 : (Polygon)_sourceGeometry2;                        foreach (PlanarGraphNode node in _graph.Nodes)                      {                          if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                              //node is used by one of the objects                              if (isFirstGeometryPoint ^ node.Label.UsedByObject2)                                  //not a polygon. need to check whether it is inside the polygon.                                  if (polygon.ContainsPoint(node.Point))                                  {                                      this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                                      break;                                  }                      }                      break;                  // ---------------------------- the intersection of the interior of polylines                  case DimensionPair.OneOne:                      this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      // lines may intersect at a point' then the graph has a node used by both                       // lines and does not coincide with their boundaries                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              // node was found' make sure that it does not limit:                              // at the boundary points of an odd number of edges used line                              int use1Count = 0;                              int use2Count = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) use1Count++;                                  if (edge.Label.UsedByObject2) use2Count++;                              }                              if (use1Count % 2 != 1 && use2Count % 2 != 1)                              {                                  // polylines intersect at least at                                  this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                                  break;                              }                          }                        // possible intersection of the one-dimensional'                      // then they should be shared at least one edge of the graph                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.One;                              return;                          }                      break;                  // ---------------------------- the intersection of the interior of the polyline and polygon                  case DimensionPair.OneTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      polygon = _sourceGeometry1 is Polygon ? (Polygon)_sourceGeometry1 : (Polygon)_sourceGeometry2;                      bool flag = _sourceGeometry1 is Polygon;                        // perhaps one-dimensional intersection' then the edge must lie                       // within the polygon' and used only the line                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (((flag && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1) ||                                (!flag && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2)) && polygon.ContainsPoint(edge.CenterPoint()))                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.One;                              return;                          }                      break;                  // ---------------------------- the intersection of the interior of polygons                  case DimensionPair.TwoTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        // possible two-dimensional intersection' in which case at least one edge only                      // have one ground should lie within the other' or at least one edge of the polygon                       // is used both on the same side of the two polygons to mark up orientation                       // of the edges of polygons along the bypass                      markPolygonsOrientation();                        foreach (PlanarGraphEdge edge in _graph.Edges)                      {                          flag = false;                          if (edge.Label.UsedByObject1 && !edge.Label.UsedByObject2)                              if (((Polygon)_sourceGeometry2).ContainsPoint(edge.CenterPoint()))                                  flag = true;                            if (edge.Label.UsedByObject2 && !edge.Label.UsedByObject1)                              if (((Polygon)_sourceGeometry1).ContainsPoint(edge.CenterPoint()))                                  flag = true;                            if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              if (edge.OrientationInObject1 == edge.OrientationInObject2)                                  flag = true;                            if(flag)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Two;                              return;                          }                      }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculteInternalInternal,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ---------------------------- the intersection of the interior of the two points                  case DimensionPair.ZeroZero:                        this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                              break;                          }                      break;                  // ---------------------------- the intersection of the interior of a point and a polyline                  case DimensionPair.ZeroOne:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2 && node.IncidentEdges.Count % 2 != 1)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                              break;                          }                      break;                  // ---------------------------- crossing point' and the interior of the polygon                  case DimensionPair.ZeroTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        Polygon polygon = _sourceGeometry1 is Polygon ? (Polygon)_sourceGeometry1 : (Polygon)_sourceGeometry2;                        foreach (PlanarGraphNode node in _graph.Nodes)                      {                          if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                              //node is used by one of the objects                              if (isFirstGeometryPoint ^ node.Label.UsedByObject2)                                  //not a polygon. need to check whether it is inside the polygon.                                  if (polygon.ContainsPoint(node.Point))                                  {                                      this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                                      break;                                  }                      }                      break;                  // ---------------------------- the intersection of the interior of polylines                  case DimensionPair.OneOne:                      this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      // lines may intersect at a point' then the graph has a node used by both                       // lines and does not coincide with their boundaries                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              // node was found' make sure that it does not limit:                              // at the boundary points of an odd number of edges used line                              int use1Count = 0;                              int use2Count = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) use1Count++;                                  if (edge.Label.UsedByObject2) use2Count++;                              }                              if (use1Count % 2 != 1 && use2Count % 2 != 1)                              {                                  // polylines intersect at least at                                  this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                                  break;                              }                          }                        // possible intersection of the one-dimensional'                      // then they should be shared at least one edge of the graph                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.One;                              return;                          }                      break;                  // ---------------------------- the intersection of the interior of the polyline and polygon                  case DimensionPair.OneTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      polygon = _sourceGeometry1 is Polygon ? (Polygon)_sourceGeometry1 : (Polygon)_sourceGeometry2;                      bool flag = _sourceGeometry1 is Polygon;                        // perhaps one-dimensional intersection' then the edge must lie                       // within the polygon' and used only the line                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (((flag && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1) ||                                (!flag && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2)) && polygon.ContainsPoint(edge.CenterPoint()))                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.One;                              return;                          }                      break;                  // ---------------------------- the intersection of the interior of polygons                  case DimensionPair.TwoTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        // possible two-dimensional intersection' in which case at least one edge only                      // have one ground should lie within the other' or at least one edge of the polygon                       // is used both on the same side of the two polygons to mark up orientation                       // of the edges of polygons along the bypass                      markPolygonsOrientation();                        foreach (PlanarGraphEdge edge in _graph.Edges)                      {                          flag = false;                          if (edge.Label.UsedByObject1 && !edge.Label.UsedByObject2)                              if (((Polygon)_sourceGeometry2).ContainsPoint(edge.CenterPoint()))                                  flag = true;                            if (edge.Label.UsedByObject2 && !edge.Label.UsedByObject1)                              if (((Polygon)_sourceGeometry1).ContainsPoint(edge.CenterPoint()))                                  flag = true;                            if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              if (edge.OrientationInObject1 == edge.OrientationInObject2)                                  flag = true;                            if(flag)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Two;                              return;                          }                      }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculteInternalInternal,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ---------------------------- the intersection of the interior of the two points                  case DimensionPair.ZeroZero:                        this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                              break;                          }                      break;                  // ---------------------------- the intersection of the interior of a point and a polyline                  case DimensionPair.ZeroOne:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2 && node.IncidentEdges.Count % 2 != 1)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                              break;                          }                      break;                  // ---------------------------- crossing point' and the interior of the polygon                  case DimensionPair.ZeroTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        Polygon polygon = _sourceGeometry1 is Polygon ? (Polygon)_sourceGeometry1 : (Polygon)_sourceGeometry2;                        foreach (PlanarGraphNode node in _graph.Nodes)                      {                          if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                              //node is used by one of the objects                              if (isFirstGeometryPoint ^ node.Label.UsedByObject2)                                  //not a polygon. need to check whether it is inside the polygon.                                  if (polygon.ContainsPoint(node.Point))                                  {                                      this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                                      break;                                  }                      }                      break;                  // ---------------------------- the intersection of the interior of polylines                  case DimensionPair.OneOne:                      this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      // lines may intersect at a point' then the graph has a node used by both                       // lines and does not coincide with their boundaries                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              // node was found' make sure that it does not limit:                              // at the boundary points of an odd number of edges used line                              int use1Count = 0;                              int use2Count = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) use1Count++;                                  if (edge.Label.UsedByObject2) use2Count++;                              }                              if (use1Count % 2 != 1 && use2Count % 2 != 1)                              {                                  // polylines intersect at least at                                  this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                                  break;                              }                          }                        // possible intersection of the one-dimensional'                      // then they should be shared at least one edge of the graph                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.One;                              return;                          }                      break;                  // ---------------------------- the intersection of the interior of the polyline and polygon                  case DimensionPair.OneTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      polygon = _sourceGeometry1 is Polygon ? (Polygon)_sourceGeometry1 : (Polygon)_sourceGeometry2;                      bool flag = _sourceGeometry1 is Polygon;                        // perhaps one-dimensional intersection' then the edge must lie                       // within the polygon' and used only the line                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (((flag && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1) ||                                (!flag && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2)) && polygon.ContainsPoint(edge.CenterPoint()))                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.One;                              return;                          }                      break;                  // ---------------------------- the intersection of the interior of polygons                  case DimensionPair.TwoTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        // possible two-dimensional intersection' in which case at least one edge only                      // have one ground should lie within the other' or at least one edge of the polygon                       // is used both on the same side of the two polygons to mark up orientation                       // of the edges of polygons along the bypass                      markPolygonsOrientation();                        foreach (PlanarGraphEdge edge in _graph.Edges)                      {                          flag = false;                          if (edge.Label.UsedByObject1 && !edge.Label.UsedByObject2)                              if (((Polygon)_sourceGeometry2).ContainsPoint(edge.CenterPoint()))                                  flag = true;                            if (edge.Label.UsedByObject2 && !edge.Label.UsedByObject1)                              if (((Polygon)_sourceGeometry1).ContainsPoint(edge.CenterPoint()))                                  flag = true;                            if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              if (edge.OrientationInObject1 == edge.OrientationInObject2)                                  flag = true;                            if(flag)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Two;                              return;                          }                      }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsBounds,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ---------------------------- two border crossing points                  case DimensionPair.ZeroZero:                      // border points - the empty set' and their intersection is also                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ---------------------------- border crossing points and polylines                  case DimensionPair.ZeroOne:                      // border points - the empty set' the intersection of the boundary polyline too                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ----------------------------border crossing point and polygon                  case DimensionPair.ZeroTwo:                      //border points - the empty set' the intersection of the boundary of the landfill' too                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ---------------------------- border crossing polylines                  case DimensionPair.OneOne:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possible boundary lines coincide' in this case in the graph'                       // there must exist a node incident to the edges of which are used an odd number of times both lines                      foreach (PlanarGraphNode node in _graph.Nodes)                      {                          int use1count = 0;                          int use2count = 0;                          foreach (PlanarGraphEdge edge in node.IncidentEdges)                          {                              if (edge.Label.UsedByObject1) use1count++;                              if (edge.Label.UsedByObject2) use2count++;                          }                          if (use1count % 2 == 1 && use2count % 2 == 1)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                              return;                          }                      }                      break;                  // ---------------------------- border crossing polyline and polygon                  case DimensionPair.OneTwo:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node used polygon and polyline' and the number of edges                       // incident to a node used polyline' must be odd                                         bool flag = _sourceGeometry1 is Polygon;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usedEdgesCount = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (flag && edge.Label.UsedByObject2) usedEdgesCount++;                                  if (!flag && edge.Label.UsedByObject1) usedEdgesCount++;                              }                              if (usedEdgesCount % 2 == 1)                              {                                  this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ----------------------------intersection polygon boundaries                  case DimensionPair.TwoTwo:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possibly zero-dimensional intersection' in this case in the graph' there must exist a node used by both polygons                      flag = false;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                              flag = true;                              break;                          }                        if (!flag) return;                        // perhaps there is a one-dimensional intersection' in which case the graph must find at least one shared edge                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.One;                              return;                          }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsBounds,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ---------------------------- two border crossing points                  case DimensionPair.ZeroZero:                      // border points - the empty set' and their intersection is also                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ---------------------------- border crossing points and polylines                  case DimensionPair.ZeroOne:                      // border points - the empty set' the intersection of the boundary polyline too                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ----------------------------border crossing point and polygon                  case DimensionPair.ZeroTwo:                      //border points - the empty set' the intersection of the boundary of the landfill' too                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ---------------------------- border crossing polylines                  case DimensionPair.OneOne:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possible boundary lines coincide' in this case in the graph'                       // there must exist a node incident to the edges of which are used an odd number of times both lines                      foreach (PlanarGraphNode node in _graph.Nodes)                      {                          int use1count = 0;                          int use2count = 0;                          foreach (PlanarGraphEdge edge in node.IncidentEdges)                          {                              if (edge.Label.UsedByObject1) use1count++;                              if (edge.Label.UsedByObject2) use2count++;                          }                          if (use1count % 2 == 1 && use2count % 2 == 1)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                              return;                          }                      }                      break;                  // ---------------------------- border crossing polyline and polygon                  case DimensionPair.OneTwo:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node used polygon and polyline' and the number of edges                       // incident to a node used polyline' must be odd                                         bool flag = _sourceGeometry1 is Polygon;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usedEdgesCount = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (flag && edge.Label.UsedByObject2) usedEdgesCount++;                                  if (!flag && edge.Label.UsedByObject1) usedEdgesCount++;                              }                              if (usedEdgesCount % 2 == 1)                              {                                  this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ----------------------------intersection polygon boundaries                  case DimensionPair.TwoTwo:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possibly zero-dimensional intersection' in this case in the graph' there must exist a node used by both polygons                      flag = false;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                              flag = true;                              break;                          }                        if (!flag) return;                        // perhaps there is a one-dimensional intersection' in which case the graph must find at least one shared edge                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.One;                              return;                          }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsBounds,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ---------------------------- two border crossing points                  case DimensionPair.ZeroZero:                      // border points - the empty set' and their intersection is also                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ---------------------------- border crossing points and polylines                  case DimensionPair.ZeroOne:                      // border points - the empty set' the intersection of the boundary polyline too                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ----------------------------border crossing point and polygon                  case DimensionPair.ZeroTwo:                      //border points - the empty set' the intersection of the boundary of the landfill' too                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ---------------------------- border crossing polylines                  case DimensionPair.OneOne:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possible boundary lines coincide' in this case in the graph'                       // there must exist a node incident to the edges of which are used an odd number of times both lines                      foreach (PlanarGraphNode node in _graph.Nodes)                      {                          int use1count = 0;                          int use2count = 0;                          foreach (PlanarGraphEdge edge in node.IncidentEdges)                          {                              if (edge.Label.UsedByObject1) use1count++;                              if (edge.Label.UsedByObject2) use2count++;                          }                          if (use1count % 2 == 1 && use2count % 2 == 1)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                              return;                          }                      }                      break;                  // ---------------------------- border crossing polyline and polygon                  case DimensionPair.OneTwo:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node used polygon and polyline' and the number of edges                       // incident to a node used polyline' must be odd                                         bool flag = _sourceGeometry1 is Polygon;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usedEdgesCount = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (flag && edge.Label.UsedByObject2) usedEdgesCount++;                                  if (!flag && edge.Label.UsedByObject1) usedEdgesCount++;                              }                              if (usedEdgesCount % 2 == 1)                              {                                  this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ----------------------------intersection polygon boundaries                  case DimensionPair.TwoTwo:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possibly zero-dimensional intersection' in this case in the graph' there must exist a node used by both polygons                      flag = false;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                              flag = true;                              break;                          }                        if (!flag) return;                        // perhaps there is a one-dimensional intersection' in which case the graph must find at least one shared edge                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.One;                              return;                          }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ----------------------------the interior of the intersection points with the boundary point - always empty                  case DimensionPair.ZeroZero:                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and the interior of the points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                           return;                        // possibly zero-dimensional intersection' in this case' there must exist a node count of incident edges is odd                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                        break;                  // ---------------------------- crossing the border and the interior of the point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                          return;                        // possibly zero-dimensional intersection' in this case' there must exist a shared graph node                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[xPos' yPos] = ElementValue.Zero;                              return;                          }                      break;                  // ---------------------------- crossing the border and the interior of the polyline                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node for which the number of incident edges'                      // used a polyline - odd' the other used a polyline - even                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usageCount1 = 0;                              int usageCount2 = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) usageCount1++;                                  if (edge.Label.UsedByObject2) usageCount2++;                              }                              if ((!inverseArgs && usageCount1 % 2 == 0 && usageCount2 % 2 == 1) ||                                 (inverseArgs && usageCount1 % 2 == 1 && usageCount2 % 2 == 0))                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ---------------------------- crossing the border and the interior of the polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                      if ((isFirstGeometryPolyline && inverseArgs) ||                          (!isFirstGeometryPolyline && !inverseArgs))                      {                          // boundary polyline must be inside the polygon                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                  (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (inverseArgs && edge.Label.UsedByObject1) count++;                                      if (!inverseArgs && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 1 && polygon.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                              }                      }                      else                      {                          bool flag = false;                          // boundary of the polygon can intersect the interior of the polyline at                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (isFirstGeometryPolyline && edge.Label.UsedByObject1) count++;                                      if (!isFirstGeometryPolyline && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 0)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      flag = true;                                      break;                                  }                              }                            if (!flag) return;                            // perhaps also one-dimensional intersection' in which                           // case the graph must find at least one shared edge                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      break;                  // ---------------------------- crossing the border and the interior of the polygon                  case DimensionPair.TwoTwo:                      Polygon p1 = (Polygon)_sourceGeometry1;                      Polygon p2 = (Polygon)_sourceGeometry2;                      this[xPos' yPos] = ElementValue.Empty;                        // perhaps one-dimensional intersection' in which case the                      // graph must be some edge' used by one of the sites and are inside other                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                              if ((inverseArgs && edge.Label.UsedByObject1 && p2.ContainsPoint(edge.CenterPoint())) ||                                  (!inverseArgs && edge.Label.UsedByObject2 && p1.ContainsPoint(edge.CenterPoint())))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ----------------------------the interior of the intersection points with the boundary point - always empty                  case DimensionPair.ZeroZero:                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and the interior of the points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                           return;                        // possibly zero-dimensional intersection' in this case' there must exist a node count of incident edges is odd                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                        break;                  // ---------------------------- crossing the border and the interior of the point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                          return;                        // possibly zero-dimensional intersection' in this case' there must exist a shared graph node                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[xPos' yPos] = ElementValue.Zero;                              return;                          }                      break;                  // ---------------------------- crossing the border and the interior of the polyline                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node for which the number of incident edges'                      // used a polyline - odd' the other used a polyline - even                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usageCount1 = 0;                              int usageCount2 = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) usageCount1++;                                  if (edge.Label.UsedByObject2) usageCount2++;                              }                              if ((!inverseArgs && usageCount1 % 2 == 0 && usageCount2 % 2 == 1) ||                                 (inverseArgs && usageCount1 % 2 == 1 && usageCount2 % 2 == 0))                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ---------------------------- crossing the border and the interior of the polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                      if ((isFirstGeometryPolyline && inverseArgs) ||                          (!isFirstGeometryPolyline && !inverseArgs))                      {                          // boundary polyline must be inside the polygon                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                  (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (inverseArgs && edge.Label.UsedByObject1) count++;                                      if (!inverseArgs && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 1 && polygon.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                              }                      }                      else                      {                          bool flag = false;                          // boundary of the polygon can intersect the interior of the polyline at                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (isFirstGeometryPolyline && edge.Label.UsedByObject1) count++;                                      if (!isFirstGeometryPolyline && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 0)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      flag = true;                                      break;                                  }                              }                            if (!flag) return;                            // perhaps also one-dimensional intersection' in which                           // case the graph must find at least one shared edge                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      break;                  // ---------------------------- crossing the border and the interior of the polygon                  case DimensionPair.TwoTwo:                      Polygon p1 = (Polygon)_sourceGeometry1;                      Polygon p2 = (Polygon)_sourceGeometry2;                      this[xPos' yPos] = ElementValue.Empty;                        // perhaps one-dimensional intersection' in which case the                      // graph must be some edge' used by one of the sites and are inside other                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                              if ((inverseArgs && edge.Label.UsedByObject1 && p2.ContainsPoint(edge.CenterPoint())) ||                                  (!inverseArgs && edge.Label.UsedByObject2 && p1.ContainsPoint(edge.CenterPoint())))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ----------------------------the interior of the intersection points with the boundary point - always empty                  case DimensionPair.ZeroZero:                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and the interior of the points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                           return;                        // possibly zero-dimensional intersection' in this case' there must exist a node count of incident edges is odd                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                        break;                  // ---------------------------- crossing the border and the interior of the point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                          return;                        // possibly zero-dimensional intersection' in this case' there must exist a shared graph node                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[xPos' yPos] = ElementValue.Zero;                              return;                          }                      break;                  // ---------------------------- crossing the border and the interior of the polyline                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node for which the number of incident edges'                      // used a polyline - odd' the other used a polyline - even                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usageCount1 = 0;                              int usageCount2 = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) usageCount1++;                                  if (edge.Label.UsedByObject2) usageCount2++;                              }                              if ((!inverseArgs && usageCount1 % 2 == 0 && usageCount2 % 2 == 1) ||                                 (inverseArgs && usageCount1 % 2 == 1 && usageCount2 % 2 == 0))                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ---------------------------- crossing the border and the interior of the polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                      if ((isFirstGeometryPolyline && inverseArgs) ||                          (!isFirstGeometryPolyline && !inverseArgs))                      {                          // boundary polyline must be inside the polygon                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                  (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (inverseArgs && edge.Label.UsedByObject1) count++;                                      if (!inverseArgs && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 1 && polygon.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                              }                      }                      else                      {                          bool flag = false;                          // boundary of the polygon can intersect the interior of the polyline at                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (isFirstGeometryPolyline && edge.Label.UsedByObject1) count++;                                      if (!isFirstGeometryPolyline && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 0)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      flag = true;                                      break;                                  }                              }                            if (!flag) return;                            // perhaps also one-dimensional intersection' in which                           // case the graph must find at least one shared edge                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      break;                  // ---------------------------- crossing the border and the interior of the polygon                  case DimensionPair.TwoTwo:                      Polygon p1 = (Polygon)_sourceGeometry1;                      Polygon p2 = (Polygon)_sourceGeometry2;                      this[xPos' yPos] = ElementValue.Empty;                        // perhaps one-dimensional intersection' in which case the                      // graph must be some edge' used by one of the sites and are inside other                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                              if ((inverseArgs && edge.Label.UsedByObject1 && p2.ContainsPoint(edge.CenterPoint())) ||                                  (!inverseArgs && edge.Label.UsedByObject2 && p1.ContainsPoint(edge.CenterPoint())))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ----------------------------the interior of the intersection points with the boundary point - always empty                  case DimensionPair.ZeroZero:                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and the interior of the points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                           return;                        // possibly zero-dimensional intersection' in this case' there must exist a node count of incident edges is odd                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                        break;                  // ---------------------------- crossing the border and the interior of the point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                          return;                        // possibly zero-dimensional intersection' in this case' there must exist a shared graph node                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[xPos' yPos] = ElementValue.Zero;                              return;                          }                      break;                  // ---------------------------- crossing the border and the interior of the polyline                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node for which the number of incident edges'                      // used a polyline - odd' the other used a polyline - even                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usageCount1 = 0;                              int usageCount2 = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) usageCount1++;                                  if (edge.Label.UsedByObject2) usageCount2++;                              }                              if ((!inverseArgs && usageCount1 % 2 == 0 && usageCount2 % 2 == 1) ||                                 (inverseArgs && usageCount1 % 2 == 1 && usageCount2 % 2 == 0))                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ---------------------------- crossing the border and the interior of the polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                      if ((isFirstGeometryPolyline && inverseArgs) ||                          (!isFirstGeometryPolyline && !inverseArgs))                      {                          // boundary polyline must be inside the polygon                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                  (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (inverseArgs && edge.Label.UsedByObject1) count++;                                      if (!inverseArgs && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 1 && polygon.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                              }                      }                      else                      {                          bool flag = false;                          // boundary of the polygon can intersect the interior of the polyline at                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (isFirstGeometryPolyline && edge.Label.UsedByObject1) count++;                                      if (!isFirstGeometryPolyline && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 0)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      flag = true;                                      break;                                  }                              }                            if (!flag) return;                            // perhaps also one-dimensional intersection' in which                           // case the graph must find at least one shared edge                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      break;                  // ---------------------------- crossing the border and the interior of the polygon                  case DimensionPair.TwoTwo:                      Polygon p1 = (Polygon)_sourceGeometry1;                      Polygon p2 = (Polygon)_sourceGeometry2;                      this[xPos' yPos] = ElementValue.Empty;                        // perhaps one-dimensional intersection' in which case the                      // graph must be some edge' used by one of the sites and are inside other                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                              if ((inverseArgs && edge.Label.UsedByObject1 && p2.ContainsPoint(edge.CenterPoint())) ||                                  (!inverseArgs && edge.Label.UsedByObject2 && p1.ContainsPoint(edge.CenterPoint())))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ----------------------------the interior of the intersection points with the boundary point - always empty                  case DimensionPair.ZeroZero:                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and the interior of the points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                           return;                        // possibly zero-dimensional intersection' in this case' there must exist a node count of incident edges is odd                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                        break;                  // ---------------------------- crossing the border and the interior of the point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                          return;                        // possibly zero-dimensional intersection' in this case' there must exist a shared graph node                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[xPos' yPos] = ElementValue.Zero;                              return;                          }                      break;                  // ---------------------------- crossing the border and the interior of the polyline                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node for which the number of incident edges'                      // used a polyline - odd' the other used a polyline - even                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usageCount1 = 0;                              int usageCount2 = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) usageCount1++;                                  if (edge.Label.UsedByObject2) usageCount2++;                              }                              if ((!inverseArgs && usageCount1 % 2 == 0 && usageCount2 % 2 == 1) ||                                 (inverseArgs && usageCount1 % 2 == 1 && usageCount2 % 2 == 0))                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ---------------------------- crossing the border and the interior of the polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                      if ((isFirstGeometryPolyline && inverseArgs) ||                          (!isFirstGeometryPolyline && !inverseArgs))                      {                          // boundary polyline must be inside the polygon                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                  (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (inverseArgs && edge.Label.UsedByObject1) count++;                                      if (!inverseArgs && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 1 && polygon.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                              }                      }                      else                      {                          bool flag = false;                          // boundary of the polygon can intersect the interior of the polyline at                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (isFirstGeometryPolyline && edge.Label.UsedByObject1) count++;                                      if (!isFirstGeometryPolyline && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 0)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      flag = true;                                      break;                                  }                              }                            if (!flag) return;                            // perhaps also one-dimensional intersection' in which                           // case the graph must find at least one shared edge                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      break;                  // ---------------------------- crossing the border and the interior of the polygon                  case DimensionPair.TwoTwo:                      Polygon p1 = (Polygon)_sourceGeometry1;                      Polygon p2 = (Polygon)_sourceGeometry2;                      this[xPos' yPos] = ElementValue.Empty;                        // perhaps one-dimensional intersection' in which case the                      // graph must be some edge' used by one of the sites and are inside other                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                              if ((inverseArgs && edge.Label.UsedByObject1 && p2.ContainsPoint(edge.CenterPoint())) ||                                  (!inverseArgs && edge.Label.UsedByObject2 && p1.ContainsPoint(edge.CenterPoint())))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ----------------------------the interior of the intersection points with the boundary point - always empty                  case DimensionPair.ZeroZero:                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and the interior of the points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                           return;                        // possibly zero-dimensional intersection' in this case' there must exist a node count of incident edges is odd                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                        break;                  // ---------------------------- crossing the border and the interior of the point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                          return;                        // possibly zero-dimensional intersection' in this case' there must exist a shared graph node                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[xPos' yPos] = ElementValue.Zero;                              return;                          }                      break;                  // ---------------------------- crossing the border and the interior of the polyline                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node for which the number of incident edges'                      // used a polyline - odd' the other used a polyline - even                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usageCount1 = 0;                              int usageCount2 = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) usageCount1++;                                  if (edge.Label.UsedByObject2) usageCount2++;                              }                              if ((!inverseArgs && usageCount1 % 2 == 0 && usageCount2 % 2 == 1) ||                                 (inverseArgs && usageCount1 % 2 == 1 && usageCount2 % 2 == 0))                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ---------------------------- crossing the border and the interior of the polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                      if ((isFirstGeometryPolyline && inverseArgs) ||                          (!isFirstGeometryPolyline && !inverseArgs))                      {                          // boundary polyline must be inside the polygon                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                  (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (inverseArgs && edge.Label.UsedByObject1) count++;                                      if (!inverseArgs && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 1 && polygon.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                              }                      }                      else                      {                          bool flag = false;                          // boundary of the polygon can intersect the interior of the polyline at                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (isFirstGeometryPolyline && edge.Label.UsedByObject1) count++;                                      if (!isFirstGeometryPolyline && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 0)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      flag = true;                                      break;                                  }                              }                            if (!flag) return;                            // perhaps also one-dimensional intersection' in which                           // case the graph must find at least one shared edge                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      break;                  // ---------------------------- crossing the border and the interior of the polygon                  case DimensionPair.TwoTwo:                      Polygon p1 = (Polygon)_sourceGeometry1;                      Polygon p2 = (Polygon)_sourceGeometry2;                      this[xPos' yPos] = ElementValue.Empty;                        // perhaps one-dimensional intersection' in which case the                      // graph must be some edge' used by one of the sites and are inside other                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                              if ((inverseArgs && edge.Label.UsedByObject1 && p2.ContainsPoint(edge.CenterPoint())) ||                                  (!inverseArgs && edge.Label.UsedByObject2 && p1.ContainsPoint(edge.CenterPoint())))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ----------------------------the interior of the intersection points with the boundary point - always empty                  case DimensionPair.ZeroZero:                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and the interior of the points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                           return;                        // possibly zero-dimensional intersection' in this case' there must exist a node count of incident edges is odd                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                        break;                  // ---------------------------- crossing the border and the interior of the point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                          return;                        // possibly zero-dimensional intersection' in this case' there must exist a shared graph node                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[xPos' yPos] = ElementValue.Zero;                              return;                          }                      break;                  // ---------------------------- crossing the border and the interior of the polyline                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node for which the number of incident edges'                      // used a polyline - odd' the other used a polyline - even                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usageCount1 = 0;                              int usageCount2 = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) usageCount1++;                                  if (edge.Label.UsedByObject2) usageCount2++;                              }                              if ((!inverseArgs && usageCount1 % 2 == 0 && usageCount2 % 2 == 1) ||                                 (inverseArgs && usageCount1 % 2 == 1 && usageCount2 % 2 == 0))                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ---------------------------- crossing the border and the interior of the polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                      if ((isFirstGeometryPolyline && inverseArgs) ||                          (!isFirstGeometryPolyline && !inverseArgs))                      {                          // boundary polyline must be inside the polygon                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                  (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (inverseArgs && edge.Label.UsedByObject1) count++;                                      if (!inverseArgs && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 1 && polygon.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                              }                      }                      else                      {                          bool flag = false;                          // boundary of the polygon can intersect the interior of the polyline at                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (isFirstGeometryPolyline && edge.Label.UsedByObject1) count++;                                      if (!isFirstGeometryPolyline && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 0)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      flag = true;                                      break;                                  }                              }                            if (!flag) return;                            // perhaps also one-dimensional intersection' in which                           // case the graph must find at least one shared edge                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      break;                  // ---------------------------- crossing the border and the interior of the polygon                  case DimensionPair.TwoTwo:                      Polygon p1 = (Polygon)_sourceGeometry1;                      Polygon p2 = (Polygon)_sourceGeometry2;                      this[xPos' yPos] = ElementValue.Empty;                        // perhaps one-dimensional intersection' in which case the                      // graph must be some edge' used by one of the sites and are inside other                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                              if ((inverseArgs && edge.Label.UsedByObject1 && p2.ContainsPoint(edge.CenterPoint())) ||                                  (!inverseArgs && edge.Label.UsedByObject2 && p1.ContainsPoint(edge.CenterPoint())))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ---------------------------- border crossing point with the addition of a point                  case DimensionPair.ZeroZero:                      // always empty                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and add points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      if ((inverseArgs && !isFirstGeometryPoint) ||                          (!inverseArgs && isFirstGeometryPoint))                          // always empty                          this[xPos' yPos] = ElementValue.Empty;                      else                      {                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                                  if (node.IncidentEdges.Count % 2 == 1)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                      }                      break;                  // ---------------------------- crossing the border and add a point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      if ((inverseArgs && isFirstGeometryPoint) ||                          (!inverseArgs && !isFirstGeometryPoint))                      {                          // one-dimensional intersection in the nondegenerate case                          if (_graph.Edges.Count > 0)                              this[xPos' yPos] = ElementValue.One;                      }                      // otherwise empty                      break;                  // ---------------------------- crossing the border and add polylines                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node that is used only a polyline with an odd number of edges incident                      foreach (PlanarGraphNode node in _graph.Nodes)                          if ((!inverseArgs && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                              (inverseArgs && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                      break;                  // ---------------------------- crossing the border and add polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                                            if ((inverseArgs && isFirstGeometryPolyline) ||                          (!inverseArgs && !isFirstGeometryPolyline))                      {                          //perhaps one-dimensional intersection' if there is at least one edge ispolzeumoe only ground                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if ((isFirstGeometryPolyline && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1) ||                                 (!isFirstGeometryPolyline && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      else                      {                          //possibly zero-dimensional intersection' if there is at least one node'                           // use only the line that has an odd number of incident edges and lying within the polygon                          Polygon p1 = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                 (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                                  if(node.IncidentEdges.Count % 2 == 1 && !p1.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                      }                      break;                  // ---------------------------- crossing the border and add polygons                  case DimensionPair.TwoTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon1 = (Polygon)_sourceGeometry1;                       Polygon polygon2 = (Polygon)_sourceGeometry2;                        // perhaps one-dimensional intersection' if there is at least one edge                       // belongs to only one polygon and not contained within another                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if ((!inverseArgs && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2 && !polygon2.ContainsPoint(edge.CenterPoint())) ||                              (inverseArgs && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1 && !polygon1.ContainsPoint(edge.CenterPoint())))                          {                              this[xPos' yPos] = ElementValue.One;                              return;                          }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ---------------------------- border crossing point with the addition of a point                  case DimensionPair.ZeroZero:                      // always empty                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and add points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      if ((inverseArgs && !isFirstGeometryPoint) ||                          (!inverseArgs && isFirstGeometryPoint))                          // always empty                          this[xPos' yPos] = ElementValue.Empty;                      else                      {                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                                  if (node.IncidentEdges.Count % 2 == 1)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                      }                      break;                  // ---------------------------- crossing the border and add a point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      if ((inverseArgs && isFirstGeometryPoint) ||                          (!inverseArgs && !isFirstGeometryPoint))                      {                          // one-dimensional intersection in the nondegenerate case                          if (_graph.Edges.Count > 0)                              this[xPos' yPos] = ElementValue.One;                      }                      // otherwise empty                      break;                  // ---------------------------- crossing the border and add polylines                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node that is used only a polyline with an odd number of edges incident                      foreach (PlanarGraphNode node in _graph.Nodes)                          if ((!inverseArgs && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                              (inverseArgs && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                      break;                  // ---------------------------- crossing the border and add polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                                            if ((inverseArgs && isFirstGeometryPolyline) ||                          (!inverseArgs && !isFirstGeometryPolyline))                      {                          //perhaps one-dimensional intersection' if there is at least one edge ispolzeumoe only ground                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if ((isFirstGeometryPolyline && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1) ||                                 (!isFirstGeometryPolyline && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      else                      {                          //possibly zero-dimensional intersection' if there is at least one node'                           // use only the line that has an odd number of incident edges and lying within the polygon                          Polygon p1 = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                 (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                                  if(node.IncidentEdges.Count % 2 == 1 && !p1.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                      }                      break;                  // ---------------------------- crossing the border and add polygons                  case DimensionPair.TwoTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon1 = (Polygon)_sourceGeometry1;                       Polygon polygon2 = (Polygon)_sourceGeometry2;                        // perhaps one-dimensional intersection' if there is at least one edge                       // belongs to only one polygon and not contained within another                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if ((!inverseArgs && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2 && !polygon2.ContainsPoint(edge.CenterPoint())) ||                              (inverseArgs && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1 && !polygon1.ContainsPoint(edge.CenterPoint())))                          {                              this[xPos' yPos] = ElementValue.One;                              return;                          }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ---------------------------- border crossing point with the addition of a point                  case DimensionPair.ZeroZero:                      // always empty                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and add points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      if ((inverseArgs && !isFirstGeometryPoint) ||                          (!inverseArgs && isFirstGeometryPoint))                          // always empty                          this[xPos' yPos] = ElementValue.Empty;                      else                      {                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                                  if (node.IncidentEdges.Count % 2 == 1)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                      }                      break;                  // ---------------------------- crossing the border and add a point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      if ((inverseArgs && isFirstGeometryPoint) ||                          (!inverseArgs && !isFirstGeometryPoint))                      {                          // one-dimensional intersection in the nondegenerate case                          if (_graph.Edges.Count > 0)                              this[xPos' yPos] = ElementValue.One;                      }                      // otherwise empty                      break;                  // ---------------------------- crossing the border and add polylines                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node that is used only a polyline with an odd number of edges incident                      foreach (PlanarGraphNode node in _graph.Nodes)                          if ((!inverseArgs && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                              (inverseArgs && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                      break;                  // ---------------------------- crossing the border and add polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                                            if ((inverseArgs && isFirstGeometryPolyline) ||                          (!inverseArgs && !isFirstGeometryPolyline))                      {                          //perhaps one-dimensional intersection' if there is at least one edge ispolzeumoe only ground                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if ((isFirstGeometryPolyline && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1) ||                                 (!isFirstGeometryPolyline && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      else                      {                          //possibly zero-dimensional intersection' if there is at least one node'                           // use only the line that has an odd number of incident edges and lying within the polygon                          Polygon p1 = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                 (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                                  if(node.IncidentEdges.Count % 2 == 1 && !p1.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                      }                      break;                  // ---------------------------- crossing the border and add polygons                  case DimensionPair.TwoTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon1 = (Polygon)_sourceGeometry1;                       Polygon polygon2 = (Polygon)_sourceGeometry2;                        // perhaps one-dimensional intersection' if there is at least one edge                       // belongs to only one polygon and not contained within another                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if ((!inverseArgs && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2 && !polygon2.ContainsPoint(edge.CenterPoint())) ||                              (inverseArgs && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1 && !polygon1.ContainsPoint(edge.CenterPoint())))                          {                              this[xPos' yPos] = ElementValue.One;                              return;                          }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateValues,The following statement contains a magic number: i < 3
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateValuesPartial,The following statement contains a magic number: i < 3
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,initSourceGeometries,The following statement contains a magic number: reduceGeometrySegments(_sourceGeometry1' PlanimetryAlgorithms.Tolerance * 1.42);
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,initSourceGeometries,The following statement contains a magic number: reduceGeometrySegments(_sourceGeometry2' PlanimetryAlgorithms.Tolerance * 1.42);
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,Matches,The following statement contains a magic number: template.Length != 9
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,Matches,The following statement contains a magic number: i == 3
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,ToString,The following statement contains a magic number: i < 3
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,CalculatePartial,The following statement contains a magic number: template.Length != 9
Magic Number,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,IntersectionMatrix,The following statement contains a magic number: i < 3
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,addOrMergeNode,The following statement contains a magic number: int index = startIndex + (endIndex - startIndex) / 2;
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,init,The following statement contains a magic number: _sourceBounds.Grow(PlanimetryAlgorithms.Tolerance * 10);
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,init,The following statement contains a magic number: _splittedSegmentIndex.MaxDepth = 20;
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,init,The following statement contains a magic number: _splittedSegmentIndex.BoxSquareThreshold = _sourceBounds.Width * _sourceBounds.Height / 10000;
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,init,The following statement contains a magic number: pointCount > 800
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,build,The following statement contains a magic number: addSourceSegments(_sourceGeometry2' 2);
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,updateSplittedSegment,The following statement contains a magic number: ss.UsedByObject2 = ss.UsedByObject2 ^ segment.ObjectNumber == 2;
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegmentByNodes,The following statement contains a magic number: int index = startNodesIndex + (endNodesIndex - startNodesIndex) / 2;
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegmentByNodes,The following statement contains a magic number: PlanimetryAlgorithms.DistanceToSegment(node.Point' segment.Segment) < tolerance / 1.45
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegmentBySegments,The following statement contains a magic number: _segmentStub.Length() / PlanimetryAlgorithms.Tolerance > 1.42
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegmentsByCrossPoints,The following statement contains a magic number: s.ObjectNumber = 2;
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegmentsByCrossPoints,The following statement contains a magic number: s.ObjectNumber = 2;
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegmentsByCrossPoints,The following statement contains a magic number: currentSegment.ObjectNumber == 2
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegments,The following statement contains a magic number: ss.UsedByObject2 = currentSegment.ObjectNumber == 2;
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegments,The following statement contains a magic number: ss.Object2OccurrencesCount = currentSegment.ObjectNumber == 2 ? 1 : 0;
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,getNodeAt,The following statement contains a magic number: int index = startNodesIndex + (endNodesIndex - startNodesIndex) / 2;
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,translateAngleQuadrant,The following statement contains a magic number: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return _twoPi - angle; }              }
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,translateAngleQuadrant,The following statement contains a magic number: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return _twoPi - angle; }              }
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,translateAngleQuadrant,The following statement contains a magic number: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return _twoPi - angle; }              }
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,processLinePath,The following statement contains a magic number: sideNumber > 2
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,processLinePath,The following statement contains a magic number: double l = PlanimetryAlgorithms.Tolerance * 1e10;
Magic Number,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,processContour,The following statement contains a magic number: double l = PlanimetryAlgorithms.Tolerance * 1e10;
Magic Number,MapAround.IO,BigEndianBinaryWriter,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\BigEndianBinaryWriter.cs,WriteIntBE,The following statement contains a magic number: Debug.Assert(bytes.Length == 4);
Magic Number,MapAround.IO,BigEndianBinaryWriter,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\BigEndianBinaryWriter.cs,WriteIntBE,The following statement contains a magic number: Array.Reverse(bytes' 0' 4);
Magic Number,MapAround.IO,BigEndianBinaryWriter,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\BigEndianBinaryWriter.cs,WriteDoubleBE,The following statement contains a magic number: Debug.Assert(bytes.Length == 8);
Magic Number,MapAround.IO,BigEndianBinaryWriter,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\BigEndianBinaryWriter.cs,WriteDoubleBE,The following statement contains a magic number: Array.Reverse(bytes' 0' 8);
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,AddColumn,The following statement contains a magic number: tempFieldName = tempFieldName.Substring(0' 11);
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,AddColumn,The following statement contains a magic number: tempFieldName.Length > 11
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,AddColumn,The following statement contains a magic number: _headerLength = 33 + 32 * _dbaseColumns.Length;
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,AddColumn,The following statement contains a magic number: _headerLength = 33 + 32 * _dbaseColumns.Length;
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,RemoveColumn,The following statement contains a magic number: _headerLength = 33 + 32 * _dbaseColumns.Length;
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,RemoveColumn,The following statement contains a magic number: _headerLength = 33 + 32 * _dbaseColumns.Length;
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Read,The following statement contains a magic number: _updateDate = new DateTime(year + 1900' month' day);
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Read,The following statement contains a magic number: reader.BaseStream.Seek(29' SeekOrigin.Begin);
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Read,The following statement contains a magic number: reader.BaseStream.Seek(32' SeekOrigin.Begin);
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Read,The following statement contains a magic number: byte[] buffer = reader.ReadBytes(11);
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Read,The following statement contains a magic number: tempLength = tempLength + 256;
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Read,The following statement contains a magic number: reader.ReadBytes(14);
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Write,The following statement contains a magic number: writer.Write((byte)(_updateDate.Year - 1900));
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Write,The following statement contains a magic number: writer.BaseStream.Seek(29' SeekOrigin.Begin);
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Write,The following statement contains a magic number: writer.BaseStream.Seek(32' SeekOrigin.Begin);
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Write,The following statement contains a magic number: j < 11
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Write,The following statement contains a magic number: writer.BaseStream.Seek(14' SeekOrigin.Current);
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,RecountColumnLength,The following statement contains a magic number: size += 3;
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,RecountColumnLength,The following statement contains a magic number: decimalCount = 2;
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseWriter,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseWriter.cs,Write,The following statement contains a magic number: date.Year < 10
Magic Number,MapAround.IO,DbaseWriter,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseWriter.cs,Write,The following statement contains a magic number: date.Year < 100
Magic Number,MapAround.IO,DbaseWriter,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseWriter.cs,Write,The following statement contains a magic number: date.Year < 1000
Magic Number,MapAround.IO,DbaseWriter,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseWriter.cs,Write,The following statement contains a magic number: date.Month < 10
Magic Number,MapAround.IO,DbaseWriter,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseWriter.cs,Write,The following statement contains a magic number: date.Day < 10
Magic Number,MapAround.IO,StreamExtensions,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\StreamExtensions.cs,ReadDoubleBE,The following statement contains a magic number: byte[] byteArray = new byte[8];
Magic Number,MapAround.IO,StreamExtensions,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\StreamExtensions.cs,ReadDoubleBE,The following statement contains a magic number: int iBytesRead = stream.Read(byteArray' 0' 8);
Magic Number,MapAround.IO,StreamExtensions,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\StreamExtensions.cs,ReadDouble,The following statement contains a magic number: byte[] doubleBytes = new byte[8];
Magic Number,MapAround.IO,StreamExtensions,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\StreamExtensions.cs,ReadDouble,The following statement contains a magic number: i < 8
Magic Number,MapAround.IO,StreamExtensions,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\StreamExtensions.cs,ReadInt32BE,The following statement contains a magic number: byte[] byteArray = new byte[4];
Magic Number,MapAround.IO,StreamExtensions,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\StreamExtensions.cs,ReadInt32BE,The following statement contains a magic number: int iBytesRead = stream.Read(byteArray' 0' 4);
Magic Number,MapAround.IO,StreamExtensions,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\StreamExtensions.cs,ReadInt32,The following statement contains a magic number: byte[] intBytes = new byte[4];
Magic Number,MapAround.IO,StreamExtensions,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\StreamExtensions.cs,ReadInt32,The following statement contains a magic number: i < 4
Magic Number,MapAround.IO,ShapeFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,Write,The following statement contains a magic number: pos += 4;
Magic Number,MapAround.IO,ShapeFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,Write,The following statement contains a magic number: pos += 4;
Magic Number,MapAround.IO,ShapeFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,Write,The following statement contains a magic number: i < 5
Magic Number,MapAround.IO,ShapeFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,Write,The following statement contains a magic number: pos += 4;
Magic Number,MapAround.IO,ShapeFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,Write,The following statement contains a magic number: pos += 4;
Magic Number,MapAround.IO,ShapeFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,Write,The following statement contains a magic number: pos += 4;
Magic Number,MapAround.IO,ShapeFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,Write,The following statement contains a magic number: pos += 8 * 4;
Magic Number,MapAround.IO,ShapeFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,Write,The following statement contains a magic number: pos += 8 * 4;
Magic Number,MapAround.IO,ShapeFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,Write,The following statement contains a magic number: pos += 8;
Magic Number,MapAround.IO,ShapeFileHeader,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,Write,The following statement contains a magic number: i < 4
Magic Number,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadIndex,The following statement contains a magic number: int featureCount = (2 * this._fileHeader.FileLength - 100) / 8;
Magic Number,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadIndex,The following statement contains a magic number: int featureCount = (2 * this._fileHeader.FileLength - 100) / 8;
Magic Number,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadIndex,The following statement contains a magic number: int featureCount = (2 * this._fileHeader.FileLength - 100) / 8;
Magic Number,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadIndex,The following statement contains a magic number: stream.Seek(100' 0);
Magic Number,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadIndex,The following statement contains a magic number: offsets[x] = 2 * stream.ReadInt32BE();
Magic Number,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadIndex,The following statement contains a magic number: stream.Seek(stream.Position + 4' 0);
Magic Number,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadHeader,The following statement contains a magic number: this._fileHeader.MinX -= 5;
Magic Number,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadHeader,The following statement contains a magic number: this._fileHeader.MaxX += 5;
Magic Number,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadHeader,The following statement contains a magic number: this._fileHeader.MinY -= 5;
Magic Number,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadHeader,The following statement contains a magic number: this._fileHeader.MaxY += 5;
Magic Number,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadHeader,The following statement contains a magic number: stream.Seek(100' SeekOrigin.Begin);
Magic Number,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteAttributes,The following statement contains a magic number: dbaseWriter.Write((byte)26);
Magic Number,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteShapes,The following statement contains a magic number: int shpLength = 50;
Magic Number,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteShapes,The following statement contains a magic number: shpLength += 4;
Magic Number,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteShapes,The following statement contains a magic number: int shxLength = 50 + (4 * numShapes);
Magic Number,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteShapes,The following statement contains a magic number: int shxLength = 50 + (4 * numShapes);
Magic Number,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteShapes,The following statement contains a magic number: shpHeader.FileCode = 9994;
Magic Number,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteShapes,The following statement contains a magic number: shxHeader.FileCode = 9994;
Magic Number,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteShapes,The following statement contains a magic number: int _pos = 50;
Magic Number,MapAround.IO,ShapeFile,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteShapes,The following statement contains a magic number: _pos += 4;
Magic Number,MapAround.IO.Handlers,MultiLineHandler,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiLineHandler.cs,Read,The following statement contains a magic number: file.Seek((long)numPoints * 16 + numParts * 4' SeekOrigin.Current);
Magic Number,MapAround.IO.Handlers,MultiLineHandler,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiLineHandler.cs,Read,The following statement contains a magic number: file.Seek((long)numPoints * 16 + numParts * 4' SeekOrigin.Current);
Magic Number,MapAround.IO.Handlers,MultiLineHandler,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiLineHandler.cs,GetLength,The following statement contains a magic number: return (22 + (2 * numParts) + geometry.CoordinateCount/*.NumPoints*/ * 8);
Magic Number,MapAround.IO.Handlers,MultiLineHandler,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiLineHandler.cs,GetLength,The following statement contains a magic number: return (22 + (2 * numParts) + geometry.CoordinateCount/*.NumPoints*/ * 8);
Magic Number,MapAround.IO.Handlers,MultiLineHandler,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiLineHandler.cs,GetLength,The following statement contains a magic number: return (22 + (2 * numParts) + geometry.CoordinateCount/*.NumPoints*/ * 8);
Magic Number,MapAround.IO.Handlers,MultiPointHandler,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiPointHandler.cs,Read,The following statement contains a magic number: file.Seek((long)numPoints * 16' SeekOrigin.Current);
Magic Number,MapAround.IO.Handlers,MultiPointHandler,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiPointHandler.cs,GetLength,The following statement contains a magic number: return (20 + geometry.ExtractCoordinates().Length /*.NumPoints*/ * 8);
Magic Number,MapAround.IO.Handlers,MultiPointHandler,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiPointHandler.cs,GetLength,The following statement contains a magic number: return (20 + geometry.ExtractCoordinates().Length /*.NumPoints*/ * 8);
Magic Number,MapAround.IO.Handlers,PointHandler,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\PointHandler.cs,GetLength,The following statement contains a magic number: return 10;
Magic Number,MapAround.IO.Handlers,PolygonHandler,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\PolygonHandler.cs,Read,The following statement contains a magic number: file.Seek((long)numPoints * 16 + numParts * 4' SeekOrigin.Current);
Magic Number,MapAround.IO.Handlers,PolygonHandler,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\PolygonHandler.cs,Read,The following statement contains a magic number: file.Seek((long)numPoints * 16 + numParts * 4' SeekOrigin.Current);
Magic Number,MapAround.IO.Handlers,PolygonHandler,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\PolygonHandler.cs,GetLength,The following statement contains a magic number: return (22 + (2 * numParts) + (geometry.CoordinateCount + numParts) * 8);
Magic Number,MapAround.IO.Handlers,PolygonHandler,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\PolygonHandler.cs,GetLength,The following statement contains a magic number: return (22 + (2 * numParts) + (geometry.CoordinateCount + numParts) * 8);
Magic Number,MapAround.IO.Handlers,PolygonHandler,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\PolygonHandler.cs,GetLength,The following statement contains a magic number: return (22 + (2 * numParts) + (geometry.CoordinateCount + numParts) * 8);
Magic Number,MapAround.Mapping,PolygonStyle,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,brushPatternParamsChanged,The following statement contains a magic number: Color blendedColor =                           Color.FromArgb(                              RenderingUtils.BlendPixels(_fillBackColor.ToArgb()' Color.FromArgb(255 - c.R' _fillForeColor).ToArgb()));
Magic Number,MapAround.Mapping,PolygonStyle,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,checkBrushPattern,The following statement contains a magic number: bmp.Width > 32 || bmp.Height > 32
Magic Number,MapAround.Mapping,PolygonStyle,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,checkBrushPattern,The following statement contains a magic number: bmp.Width > 32 || bmp.Height > 32
Magic Number,MapAround.Mapping,PolylineStyle,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,GetPen,The following statement contains a magic number: p.MiterLimit = 3f;
Magic Number,MapAround.Mapping,PolylineStyle,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,GetAnnexPen,The following statement contains a magic number: p.MiterLimit = 3f;
Magic Number,MapAround.Mapping,PolylineStyle,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,GetOutlinePen,The following statement contains a magic number: Pen p = new Pen(_outlineColor' _width + _outlineWidth * 2);
Magic Number,MapAround.Mapping,PolylineStyle,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,GetOutlinePen,The following statement contains a magic number: p.MiterLimit = 3f;
Magic Number,MapAround.Mapping,HatchFillPatternsAcccessor,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,HatchFillPatternsAcccessor,The following statement contains a magic number: Bitmap bmp = new Bitmap(8' 8);
Magic Number,MapAround.Mapping,HatchFillPatternsAcccessor,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,HatchFillPatternsAcccessor,The following statement contains a magic number: Bitmap bmp = new Bitmap(8' 8);
Magic Number,MapAround.Mapping,HatchFillPatternsAcccessor,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,HatchFillPatternsAcccessor,The following statement contains a magic number: g.FillRectangle(brush' 0' 0' 8' 8);
Magic Number,MapAround.Mapping,HatchFillPatternsAcccessor,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,HatchFillPatternsAcccessor,The following statement contains a magic number: g.FillRectangle(brush' 0' 0' 8' 8);
Magic Number,MapAround.Mapping,HatchFillPatternsAcccessor,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,HatchFillPatternsAcccessor,The following statement contains a magic number: i < 53
Magic Number,MapAround.Mapping,Map,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,Render,The following statement contains a magic number: Math.Abs((viewBox.Width / viewBox.Height) -                  ((double)image.Width / (double)image.Height)) > 0.02
Magic Number,MapAround.Mapping,Map,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,transformViewBox,The following statement contains a magic number: int segmentCount = 10;
Magic Number,MapAround.Mapping,Map,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderPointSampleInternal,The following statement contains a magic number: feature.Point = new PointD(viewBox.Width / 2' viewBox.Height / 2);
Magic Number,MapAround.Mapping,Map,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderPointSampleInternal,The following statement contains a magic number: feature.Point = new PointD(viewBox.Width / 2' viewBox.Height / 2);
Magic Number,MapAround.Mapping,Map,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderTitleSampleInternal,The following statement contains a magic number: feature.Point = new PointD(viewBox.Width / 2' viewBox.Height / 2 - size.Height / 2);
Magic Number,MapAround.Mapping,Map,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderTitleSampleInternal,The following statement contains a magic number: feature.Point = new PointD(viewBox.Width / 2' viewBox.Height / 2 - size.Height / 2);
Magic Number,MapAround.Mapping,Map,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderTitleSampleInternal,The following statement contains a magic number: feature.Point = new PointD(viewBox.Width / 2' viewBox.Height / 2 - size.Height / 2);
Magic Number,MapAround.Mapping,Map,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderPolylineSample,The following statement contains a magic number: RenderPolylineSampleInternal(g' new BoundingRectangle(0' 0' image.Width' image.Height)' polylineStyle' 2);
Magic Number,MapAround.Mapping,Map,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderPolygonSample,The following statement contains a magic number: RenderPolygonSampleInternal(g' new BoundingRectangle(0' 0' image.Width' image.Height)' polygonStyle' 2);
Magic Number,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderFeaturesSample,The following statement contains a magic number: int margin = 2;
Magic Number,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderFeaturesSample,The following statement contains a magic number: switch (sampleCount)                      {                           case 3:                              minX = image.Width / 3;                              maxX = 2 * image.Width / 3;                              break;                          case 2:                              if (drawPoint)                              {                                  minX = image.Width / 2;                                  maxX = image.Width;                              }                              else                                  maxX = image.Width / 2;                              break;                          case 1:                              maxX = image.Width;                              break;                      }
Magic Number,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderFeaturesSample,The following statement contains a magic number: switch (sampleCount)                      {                           case 3:                              minX = image.Width / 3;                              maxX = 2 * image.Width / 3;                              break;                          case 2:                              if (drawPoint)                              {                                  minX = image.Width / 2;                                  maxX = image.Width;                              }                              else                                  maxX = image.Width / 2;                              break;                          case 1:                              maxX = image.Width;                              break;                      }
Magic Number,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderFeaturesSample,The following statement contains a magic number: switch (sampleCount)                      {                           case 3:                              minX = image.Width / 3;                              maxX = 2 * image.Width / 3;                              break;                          case 2:                              if (drawPoint)                              {                                  minX = image.Width / 2;                                  maxX = image.Width;                              }                              else                                  maxX = image.Width / 2;                              break;                          case 1:                              maxX = image.Width;                              break;                      }
Magic Number,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderFeaturesSample,The following statement contains a magic number: switch (sampleCount)                      {                           case 3:                              minX = image.Width / 3;                              maxX = 2 * image.Width / 3;                              break;                          case 2:                              if (drawPoint)                              {                                  minX = image.Width / 2;                                  maxX = image.Width;                              }                              else                                  maxX = image.Width / 2;                              break;                          case 1:                              maxX = image.Width;                              break;                      }
Magic Number,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderFeaturesSample,The following statement contains a magic number: switch (sampleCount)                      {                           case 3:                              minX = image.Width / 3;                              maxX = 2 * image.Width / 3;                              break;                          case 2:                              if (drawPoint)                              {                                  minX = image.Width / 2;                                  maxX = image.Width;                              }                              else                                  maxX = image.Width / 2;                              break;                          case 1:                              maxX = image.Width;                              break;                      }
Magic Number,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderFeaturesSample,The following statement contains a magic number: switch (sampleCount)                      {                           case 3:                              minX = image.Width / 3;                              maxX = 2 * image.Width / 3;                              break;                          case 2:                              if (drawPoint)                              {                                  minX = image.Width / 2;                                  maxX = image.Width;                              }                              else                                  maxX = image.Width / 2;                              break;                          case 1:                              maxX = image.Width;                              break;                      }
Magic Number,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderFeaturesSample,The following statement contains a magic number: switch (sampleCount)                      {                           case 3:                              minX = image.Width / 3;                              maxX = 2 * image.Width / 3;                              break;                          case 2:                              if (drawPoint)                              {                                  minX = image.Width / 2;                                  maxX = image.Width;                              }                              else                                  maxX = image.Width / 2;                              break;                          case 1:                              maxX = image.Width;                              break;                      }
Magic Number,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateOptimalAffineTransformPoints,The following statement contains a magic number: int[] result = new int[3];
Magic Number,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateOptimalAffineTransformPoints,The following statement contains a magic number: result[2] = i3;
Magic Number,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateOptimalAffineTransformPoints,The following statement contains a magic number: i1 < sourceNodes.Length - 2
Magic Number,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateRubberSheetTransform,The following statement contains a magic number: int startProgressPercent = 30;
Magic Number,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateRubberSheetTransform,The following statement contains a magic number: int endProgressPercent = 70;
Magic Number,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateRubberSheetTransform,The following statement contains a magic number: sum += Math.Pow(temp' 2);
Magic Number,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateRubberSheetTransform,The following statement contains a magic number: w[k] = Math.Pow(temp' 2) / sum;
Magic Number,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateAffinneTransform,The following statement contains a magic number: PointF p03 = new PointF(sourceNodes[r[2]].X' sourceNodes[r[2]].Y);
Magic Number,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateAffinneTransform,The following statement contains a magic number: PointF p03 = new PointF(sourceNodes[r[2]].X' sourceNodes[r[2]].Y);
Magic Number,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateAffinneTransform,The following statement contains a magic number: PointF p13 = new PointF((float)destNodes[r[2]].X' (float)destNodes[r[2]].Y);
Magic Number,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateAffinneTransform,The following statement contains a magic number: PointF p13 = new PointF((float)destNodes[r[2]].X' (float)destNodes[r[2]].Y);
Magic Number,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateAffinneTransform,The following statement contains a magic number: int endProgressPercent = 30;
Magic Number,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,The following statement contains a magic number: int startProgressPercent = 70;
Magic Number,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,The following statement contains a magic number: int endProgressPercent = 80;
Magic Number,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,The following statement contains a magic number: startProgressPercent = 80;
Magic Number,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,The following statement contains a magic number: endProgressPercent = 90;
Magic Number,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,The following statement contains a magic number: startProgressPercent = 90;
Magic Number,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,The following statement contains a magic number: endProgressPercent = 100;
Magic Number,MapAround.Mapping,RasterAlgorithms,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,BindRaster,The following statement contains a magic number: sourceControlPoints.Length < 3
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,createSelectionTexture,The following statement contains a magic number: Color blendedColor =                              Color.FromArgb(                                  RenderingUtils.BlendPixels(Color.Transparent.ToArgb()' Color.FromArgb((255 - c.R) / 2' _selectionColor).ToArgb()));
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,createSelectionTexture,The following statement contains a magic number: Color blendedColor =                              Color.FromArgb(                                  RenderingUtils.BlendPixels(Color.Transparent.ToArgb()' Color.FromArgb((255 - c.R) / 2' _selectionColor).ToArgb()));
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPrismPolygon,The following statement contains a magic number: points[contourIndex].Length > 2
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPrismPolygon,The following statement contains a magic number: int prismHeight = 4;
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: offset = new SizeF(size.Width/2'size.Height/2);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: offset = new SizeF(size.Width/2'size.Height/2);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: switch (style.ContentAlignment)                      {                          case ContentAlignment.TopLeft: offset = new SizeF(0' 0); break;                          case ContentAlignment.TopCenter: offset = new SizeF(size.Width / 2'0); break;                          case ContentAlignment.TopRight: offset = new SizeF(size.Width' 0); break;                                case ContentAlignment.BottomLeft: offset = new SizeF(0' size.Height ); break;                          case ContentAlignment.BottomCenter: offset = new SizeF(size.Width / 2' size.Height); break;                          case ContentAlignment.BottomRight: offset = new SizeF(size.Width' size.Height); break;                                case ContentAlignment.MiddleLeft: offset = new SizeF(0' size.Height / 2); break;                          case ContentAlignment.MiddleCenter: offset = new SizeF(size.Width / 2' size.Height / 2); break;                          case ContentAlignment.MiddleRight: offset = new SizeF(size.Width' size.Height / 2); break;                                default:                              throw new NotSupportedException();                        }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: switch (style.ContentAlignment)                      {                          case ContentAlignment.TopLeft: offset = new SizeF(0' 0); break;                          case ContentAlignment.TopCenter: offset = new SizeF(size.Width / 2'0); break;                          case ContentAlignment.TopRight: offset = new SizeF(size.Width' 0); break;                                case ContentAlignment.BottomLeft: offset = new SizeF(0' size.Height ); break;                          case ContentAlignment.BottomCenter: offset = new SizeF(size.Width / 2' size.Height); break;                          case ContentAlignment.BottomRight: offset = new SizeF(size.Width' size.Height); break;                                case ContentAlignment.MiddleLeft: offset = new SizeF(0' size.Height / 2); break;                          case ContentAlignment.MiddleCenter: offset = new SizeF(size.Width / 2' size.Height / 2); break;                          case ContentAlignment.MiddleRight: offset = new SizeF(size.Width' size.Height / 2); break;                                default:                              throw new NotSupportedException();                        }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: switch (style.ContentAlignment)                      {                          case ContentAlignment.TopLeft: offset = new SizeF(0' 0); break;                          case ContentAlignment.TopCenter: offset = new SizeF(size.Width / 2'0); break;                          case ContentAlignment.TopRight: offset = new SizeF(size.Width' 0); break;                                case ContentAlignment.BottomLeft: offset = new SizeF(0' size.Height ); break;                          case ContentAlignment.BottomCenter: offset = new SizeF(size.Width / 2' size.Height); break;                          case ContentAlignment.BottomRight: offset = new SizeF(size.Width' size.Height); break;                                case ContentAlignment.MiddleLeft: offset = new SizeF(0' size.Height / 2); break;                          case ContentAlignment.MiddleCenter: offset = new SizeF(size.Width / 2' size.Height / 2); break;                          case ContentAlignment.MiddleRight: offset = new SizeF(size.Width' size.Height / 2); break;                                default:                              throw new NotSupportedException();                        }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: switch (style.ContentAlignment)                      {                          case ContentAlignment.TopLeft: offset = new SizeF(0' 0); break;                          case ContentAlignment.TopCenter: offset = new SizeF(size.Width / 2'0); break;                          case ContentAlignment.TopRight: offset = new SizeF(size.Width' 0); break;                                case ContentAlignment.BottomLeft: offset = new SizeF(0' size.Height ); break;                          case ContentAlignment.BottomCenter: offset = new SizeF(size.Width / 2' size.Height); break;                          case ContentAlignment.BottomRight: offset = new SizeF(size.Width' size.Height); break;                                case ContentAlignment.MiddleLeft: offset = new SizeF(0' size.Height / 2); break;                          case ContentAlignment.MiddleCenter: offset = new SizeF(size.Width / 2' size.Height / 2); break;                          case ContentAlignment.MiddleRight: offset = new SizeF(size.Width' size.Height / 2); break;                                default:                              throw new NotSupportedException();                        }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: switch (style.ContentAlignment)                      {                          case ContentAlignment.TopLeft: offset = new SizeF(0' 0); break;                          case ContentAlignment.TopCenter: offset = new SizeF(size.Width / 2'0); break;                          case ContentAlignment.TopRight: offset = new SizeF(size.Width' 0); break;                                case ContentAlignment.BottomLeft: offset = new SizeF(0' size.Height ); break;                          case ContentAlignment.BottomCenter: offset = new SizeF(size.Width / 2' size.Height); break;                          case ContentAlignment.BottomRight: offset = new SizeF(size.Width' size.Height); break;                                case ContentAlignment.MiddleLeft: offset = new SizeF(0' size.Height / 2); break;                          case ContentAlignment.MiddleCenter: offset = new SizeF(size.Width / 2' size.Height / 2); break;                          case ContentAlignment.MiddleRight: offset = new SizeF(size.Width' size.Height / 2); break;                                default:                              throw new NotSupportedException();                        }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: switch (style.ContentAlignment)                      {                          case ContentAlignment.TopLeft: offset = new SizeF(0' 0); break;                          case ContentAlignment.TopCenter: offset = new SizeF(size.Width / 2'0); break;                          case ContentAlignment.TopRight: offset = new SizeF(size.Width' 0); break;                                case ContentAlignment.BottomLeft: offset = new SizeF(0' size.Height ); break;                          case ContentAlignment.BottomCenter: offset = new SizeF(size.Width / 2' size.Height); break;                          case ContentAlignment.BottomRight: offset = new SizeF(size.Width' size.Height); break;                                case ContentAlignment.MiddleLeft: offset = new SizeF(0' size.Height / 2); break;                          case ContentAlignment.MiddleCenter: offset = new SizeF(size.Width / 2' size.Height / 2); break;                          case ContentAlignment.MiddleRight: offset = new SizeF(size.Width' size.Height / 2); break;                                default:                              throw new NotSupportedException();                        }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: g.DrawRectangle(p'                                                  (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width + 1)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height + 1)'                                                  size.Width - 2' size.Height - 2);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: g.DrawRectangle(p'                                                  (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width + 1)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height + 1)'                                                  size.Width - 2' size.Height - 2);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: shp.Point = new PointD(feature.Point.X' feature.Point.Y + size.Height/2/scaleFactor);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolyline,The following statement contains a magic number: Math.Min(viewBox.Width/(feature.BoundingRectangle.Width)'                               viewBox.Height/(feature.BoundingRectangle.Height)) < 2
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolygon,The following statement contains a magic number: c.Vertices.Count <= 2
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolygon,The following statement contains a magic number: points.Length > 2
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolygon,The following statement contains a magic number: ((TextureBrush) b).TranslateTransform(g.RenderingOrigin.X%8' g.RenderingOrigin.Y%8);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolygon,The following statement contains a magic number: ((TextureBrush) b).TranslateTransform(g.RenderingOrigin.X%8' g.RenderingOrigin.Y%8);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawTitle,The following statement contains a magic number: ICoordinate originPoint = PlanimetryEnvironment.NewCoordinate((title.Box.V1.X + title.Box.V2.X) / 2' title.Box.V2.Y);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,addTitleBufferElement,The following statement contains a magic number: switch (feature.FeatureType)              {                  case FeatureType.Polyline:                      if (!titleStyle.LeadAlong)                      {                          foreach (LinePath path in feature.Polyline.Paths)                          {                              if (path.Vertices.Count > 2)                                  targetCoordinate = path.Vertices[path.Vertices.Count / 2 - 1];                              else                              {                                  s = new Segment(path.Vertices[0].X' path.Vertices[0].Y'                                                  path.Vertices[1].X' path.Vertices[1].Y);                                    targetCoordinate = s.Center();                              }                              addTitleBufferElement(titleStyle' targetCoordinate' size' scaleFactor' feature);                          }                      }                      else                      {                          int i = 0;                          foreach (LinePath path in feature.Polyline.Paths)                          {                              FollowingTitle followingTitle =                                   getFollowingTitle(g' path' feature.PolylinePartLengths[i]' feature.Title' titleStyle' viewBox' scaleFactor);                              if (followingTitle != null)                                  _titleBuffer.Add(new TitleBufferElement(followingTitle' titleStyle' _titleCount++));                              i++;                          }                      }                      return;                  case FeatureType.Polygon:                      //if (feature.Polygon.Contours.Count > 0)                      //    targetPoint = feature.Polygon.Contours[0].RibsCentroid();                      //else                      //    return;                      //break;                        if (feature.Polygon.Contours.Count > 0)                          try                          {                              targetCoordinate = feature.Polygon.PointOnSurface();                          }                          catch(InvalidOperationException)                          {                              //interior point of the polygon for some reason (usually singular) can not be found                              return;                          }                      else                          return;                      break;                                        case FeatureType.Point:                      targetCoordinate = feature.Point.Coordinate;                      //targetPoint.Y += size.Height / scaleFactor / 2;                      break;                  case FeatureType.MultiPoint:                      if (titleStyle.LeadAlong)                      {                          foreach (ICoordinate p in feature.MultiPoint.Points)                          {                              targetCoordinate = p;                              targetCoordinate.Y += size.Height / scaleFactor / 2;                              addTitleBufferElement(titleStyle' targetCoordinate' size' scaleFactor' feature);                          }                          return;                      }                      else                          targetCoordinate = PlanimetryAlgorithms.GetCentroid(feature.MultiPoint.Points);                      break;              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,addTitleBufferElement,The following statement contains a magic number: switch (feature.FeatureType)              {                  case FeatureType.Polyline:                      if (!titleStyle.LeadAlong)                      {                          foreach (LinePath path in feature.Polyline.Paths)                          {                              if (path.Vertices.Count > 2)                                  targetCoordinate = path.Vertices[path.Vertices.Count / 2 - 1];                              else                              {                                  s = new Segment(path.Vertices[0].X' path.Vertices[0].Y'                                                  path.Vertices[1].X' path.Vertices[1].Y);                                    targetCoordinate = s.Center();                              }                              addTitleBufferElement(titleStyle' targetCoordinate' size' scaleFactor' feature);                          }                      }                      else                      {                          int i = 0;                          foreach (LinePath path in feature.Polyline.Paths)                          {                              FollowingTitle followingTitle =                                   getFollowingTitle(g' path' feature.PolylinePartLengths[i]' feature.Title' titleStyle' viewBox' scaleFactor);                              if (followingTitle != null)                                  _titleBuffer.Add(new TitleBufferElement(followingTitle' titleStyle' _titleCount++));                              i++;                          }                      }                      return;                  case FeatureType.Polygon:                      //if (feature.Polygon.Contours.Count > 0)                      //    targetPoint = feature.Polygon.Contours[0].RibsCentroid();                      //else                      //    return;                      //break;                        if (feature.Polygon.Contours.Count > 0)                          try                          {                              targetCoordinate = feature.Polygon.PointOnSurface();                          }                          catch(InvalidOperationException)                          {                              //interior point of the polygon for some reason (usually singular) can not be found                              return;                          }                      else                          return;                      break;                                        case FeatureType.Point:                      targetCoordinate = feature.Point.Coordinate;                      //targetPoint.Y += size.Height / scaleFactor / 2;                      break;                  case FeatureType.MultiPoint:                      if (titleStyle.LeadAlong)                      {                          foreach (ICoordinate p in feature.MultiPoint.Points)                          {                              targetCoordinate = p;                              targetCoordinate.Y += size.Height / scaleFactor / 2;                              addTitleBufferElement(titleStyle' targetCoordinate' size' scaleFactor' feature);                          }                          return;                      }                      else                          targetCoordinate = PlanimetryAlgorithms.GetCentroid(feature.MultiPoint.Points);                      break;              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,addTitleBufferElement,The following statement contains a magic number: switch (feature.FeatureType)              {                  case FeatureType.Polyline:                      if (!titleStyle.LeadAlong)                      {                          foreach (LinePath path in feature.Polyline.Paths)                          {                              if (path.Vertices.Count > 2)                                  targetCoordinate = path.Vertices[path.Vertices.Count / 2 - 1];                              else                              {                                  s = new Segment(path.Vertices[0].X' path.Vertices[0].Y'                                                  path.Vertices[1].X' path.Vertices[1].Y);                                    targetCoordinate = s.Center();                              }                              addTitleBufferElement(titleStyle' targetCoordinate' size' scaleFactor' feature);                          }                      }                      else                      {                          int i = 0;                          foreach (LinePath path in feature.Polyline.Paths)                          {                              FollowingTitle followingTitle =                                   getFollowingTitle(g' path' feature.PolylinePartLengths[i]' feature.Title' titleStyle' viewBox' scaleFactor);                              if (followingTitle != null)                                  _titleBuffer.Add(new TitleBufferElement(followingTitle' titleStyle' _titleCount++));                              i++;                          }                      }                      return;                  case FeatureType.Polygon:                      //if (feature.Polygon.Contours.Count > 0)                      //    targetPoint = feature.Polygon.Contours[0].RibsCentroid();                      //else                      //    return;                      //break;                        if (feature.Polygon.Contours.Count > 0)                          try                          {                              targetCoordinate = feature.Polygon.PointOnSurface();                          }                          catch(InvalidOperationException)                          {                              //interior point of the polygon for some reason (usually singular) can not be found                              return;                          }                      else                          return;                      break;                                        case FeatureType.Point:                      targetCoordinate = feature.Point.Coordinate;                      //targetPoint.Y += size.Height / scaleFactor / 2;                      break;                  case FeatureType.MultiPoint:                      if (titleStyle.LeadAlong)                      {                          foreach (ICoordinate p in feature.MultiPoint.Points)                          {                              targetCoordinate = p;                              targetCoordinate.Y += size.Height / scaleFactor / 2;                              addTitleBufferElement(titleStyle' targetCoordinate' size' scaleFactor' feature);                          }                          return;                      }                      else                          targetCoordinate = PlanimetryAlgorithms.GetCentroid(feature.MultiPoint.Points);                      break;              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,addTitleBufferElement,The following statement contains a magic number: _titleBuffer.Add(new TitleBufferElement(titleStyle'                                          new Segment(targetPoint.X - size.Width / scaleFactor / 2'                                                      targetPoint.Y - size.Height / scaleFactor / 2'                                                      targetPoint.X + size.Width / scaleFactor / 2'                                                      targetPoint.Y + size.Height / scaleFactor / 2)'                                          feature.Title'                                          _titleCount++));
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,addTitleBufferElement,The following statement contains a magic number: _titleBuffer.Add(new TitleBufferElement(titleStyle'                                          new Segment(targetPoint.X - size.Width / scaleFactor / 2'                                                      targetPoint.Y - size.Height / scaleFactor / 2'                                                      targetPoint.X + size.Width / scaleFactor / 2'                                                      targetPoint.Y + size.Height / scaleFactor / 2)'                                          feature.Title'                                          _titleCount++));
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,addTitleBufferElement,The following statement contains a magic number: _titleBuffer.Add(new TitleBufferElement(titleStyle'                                          new Segment(targetPoint.X - size.Width / scaleFactor / 2'                                                      targetPoint.Y - size.Height / scaleFactor / 2'                                                      targetPoint.X + size.Width / scaleFactor / 2'                                                      targetPoint.Y + size.Height / scaleFactor / 2)'                                          feature.Title'                                          _titleCount++));
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,addTitleBufferElement,The following statement contains a magic number: _titleBuffer.Add(new TitleBufferElement(titleStyle'                                          new Segment(targetPoint.X - size.Width / scaleFactor / 2'                                                      targetPoint.Y - size.Height / scaleFactor / 2'                                                      targetPoint.X + size.Width / scaleFactor / 2'                                                      targetPoint.Y + size.Height / scaleFactor / 2)'                                          feature.Title'                                          _titleCount++));
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: tempPart.Weed(sizeF.Height / scaleFactor / 2);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: quadNumber == 1 || quadNumber == 4
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: deltas.Add(0.5 * (width1 - currentDistance));
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: PointF[] v = new PointF[4];
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: v[0].Y = -size.Height / 2;
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: v[1].Y = -size.Height / 2;
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: v[2].X = size.Width + x0;
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: v[2].Y = size.Height / 2;
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: v[2].Y = size.Height / 2;
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: v[3].X = x0;
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: v[3].Y = size.Height / 2;
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: v[3].Y = size.Height / 2;
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: angleDelta > 45 && 360 - angleDelta > 45
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: angleDelta > 45 && 360 - angleDelta > 45
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: angleDelta > 45 && 360 - angleDelta > 45
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: g.RotateTransform(-(angle % 360));
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: j < 4
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: label.Length > points.Count - 2
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getLeftPoints,The following statement contains a magic number: rotationDeltas[rotationDeltas.Count - 2] = delta;
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getLeftPoints,The following statement contains a magic number: rotationDeltas[rotationDeltas.Count - 2] = delta;
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getLeftPoints,The following statement contains a magic number: currentDistance -= delta * 2;
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRightPoints,The following statement contains a magic number: rotationDeltas[rotationDeltas.Count - 2] = delta;
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRightPoints,The following statement contains a magic number: rotationDeltas.Count > 2
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRightPoints,The following statement contains a magic number: rotationDeltas[rotationDeltas.Count - 2] = delta;
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRightPoints,The following statement contains a magic number: rotationDeltas.Count > 2
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRightPoints,The following statement contains a magic number: currentDistance -= delta * 2;
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getAngle,The following statement contains a magic number: double alpha = p1.X != 0 ? Math.Atan(Math.Abs(p1.Y / p1.X)) : 0.5 * Math.PI;
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getAngle,The following statement contains a magic number: double betta = p3.X != 0 ? Math.Atan(Math.Abs(p3.Y / p3.X)) : 0.5 * Math.PI;
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getAngle,The following statement contains a magic number: return alpha < betta ? (betta - alpha) : (2 * Math.PI - alpha + betta);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,translateAngleQuadrant,The following statement contains a magic number: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return 2 * Math.PI - angle; }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,translateAngleQuadrant,The following statement contains a magic number: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return 2 * Math.PI - angle; }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,translateAngleQuadrant,The following statement contains a magic number: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return 2 * Math.PI - angle; }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,translateAngleQuadrant,The following statement contains a magic number: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return 2 * Math.PI - angle; }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRelativeDashSize,The following statement contains a magic number: switch (pen.DashStyle)              {                  case DashStyle.Dot:                      relativeDashSize = 2;                      break;                    case DashStyle.Dash:                      relativeDashSize = 4;                      break;                    case DashStyle.DashDot:                      relativeDashSize = 6;                      break;                    case DashStyle.DashDotDot:                      relativeDashSize = 8;                      break;                    case DashStyle.Custom:                      relativeDashSize = 0;                      foreach (float d in pen.DashPattern)                          relativeDashSize += d;                      break;              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRelativeDashSize,The following statement contains a magic number: switch (pen.DashStyle)              {                  case DashStyle.Dot:                      relativeDashSize = 2;                      break;                    case DashStyle.Dash:                      relativeDashSize = 4;                      break;                    case DashStyle.DashDot:                      relativeDashSize = 6;                      break;                    case DashStyle.DashDotDot:                      relativeDashSize = 8;                      break;                    case DashStyle.Custom:                      relativeDashSize = 0;                      foreach (float d in pen.DashPattern)                          relativeDashSize += d;                      break;              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRelativeDashSize,The following statement contains a magic number: switch (pen.DashStyle)              {                  case DashStyle.Dot:                      relativeDashSize = 2;                      break;                    case DashStyle.Dash:                      relativeDashSize = 4;                      break;                    case DashStyle.DashDot:                      relativeDashSize = 6;                      break;                    case DashStyle.DashDotDot:                      relativeDashSize = 8;                      break;                    case DashStyle.Custom:                      relativeDashSize = 0;                      foreach (float d in pen.DashPattern)                          relativeDashSize += d;                      break;              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRelativeDashSize,The following statement contains a magic number: switch (pen.DashStyle)              {                  case DashStyle.Dot:                      relativeDashSize = 2;                      break;                    case DashStyle.Dash:                      relativeDashSize = 4;                      break;                    case DashStyle.DashDot:                      relativeDashSize = 6;                      break;                    case DashStyle.DashDotDot:                      relativeDashSize = 8;                      break;                    case DashStyle.Custom:                      relativeDashSize = 0;                      foreach (float d in pen.DashPattern)                          relativeDashSize += d;                      break;              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawLinePathSelectionAndOutline,The following statement contains a magic number: float w = style.Width + (style.UseOutline ? style.OutlineWidth * 2 + 2 : 3);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawLinePathSelectionAndOutline,The following statement contains a magic number: float w = style.Width + (style.UseOutline ? style.OutlineWidth * 2 + 2 : 3);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawLinePathSelectionAndOutline,The following statement contains a magic number: float w = style.Width + (style.UseOutline ? style.OutlineWidth * 2 + 2 : 3);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawLinePathSelectionAndOutline,The following statement contains a magic number: p.MiterLimit = 3;
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPolylineSimple,The following statement contains a magic number: path.Vertices.Count < 2
Magic Number,MapAround.Mapping,TitleBufferElement,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,intersectsWithComplexTitle,The following statement contains a magic number: Segment[] segments = new Segment[4]                  {                      new Segment(_box.V1' PlanimetryEnvironment.NewCoordinate(_box.V1.X' _box.V2.Y))'                      new Segment(PlanimetryEnvironment.NewCoordinate(_box.V1.X' _box.V2.Y)' _box.V2)'                      new Segment(_box.V2' PlanimetryEnvironment.NewCoordinate(_box.V2.X' _box.V1.Y))'                      new Segment(PlanimetryEnvironment.NewCoordinate(_box.V2.X' _box.V1.Y)' _box.V1)                  };
Magic Number,MapAround.Mapping,TitleBufferElement,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,intersectsWithComplexTitle,The following statement contains a magic number: Segment segment2 = new Segment(c.Vertices[2]' c.Vertices[3]);
Magic Number,MapAround.Mapping,TitleBufferElement,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,intersectsWithComplexTitle,The following statement contains a magic number: Segment segment2 = new Segment(c.Vertices[2]' c.Vertices[3]);
Magic Number,MapAround.Mapping,TitleBufferElement,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,intersectsWithComplexTitle,The following statement contains a magic number: i < 4
Magic Number,MapAround.Mapping,TitleBufferElement,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,contoursIntersect,The following statement contains a magic number: Segment segment2 = new Segment(c1.Vertices[2]' c1.Vertices[3]);
Magic Number,MapAround.Mapping,TitleBufferElement,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,contoursIntersect,The following statement contains a magic number: Segment segment2 = new Segment(c1.Vertices[2]' c1.Vertices[3]);
Magic Number,MapAround.Mapping,TitleBufferElement,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,contoursIntersect,The following statement contains a magic number: Segment segment4 = new Segment(c2.Vertices[3]' c2.Vertices[3]);
Magic Number,MapAround.Mapping,TitleBufferElement,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,contoursIntersect,The following statement contains a magic number: Segment segment4 = new Segment(c2.Vertices[3]' c2.Vertices[3]);
Magic Number,MapAround.Mapping,RenderingUtils,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: byte alpha = (byte)(pixelData2 >> 24 & 0xFF);
Magic Number,MapAround.Mapping,RenderingUtils,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: alpha == 255
Magic Number,MapAround.Mapping,RenderingUtils,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: byte oldAlpha = (byte)((oldPixelData >> 24 & 0xFF));
Magic Number,MapAround.Mapping,RenderingUtils,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: byte newAlpha = (byte)(alpha + oldAlpha - alpha * oldAlpha / 255f);
Magic Number,MapAround.Mapping,RenderingUtils,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: float a1 = alpha / 255f;
Magic Number,MapAround.Mapping,RenderingUtils,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: float a0 = (1 - a1) * oldAlpha / 255f;
Magic Number,MapAround.Mapping,RenderingUtils,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: Int32 b1 = newAlpha << 24;
Magic Number,MapAround.Mapping,RenderingUtils,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData2 >> 16 & 0xFF) * a1) << 16;
Magic Number,MapAround.Mapping,RenderingUtils,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData2 >> 16 & 0xFF) * a1) << 16;
Magic Number,MapAround.Mapping,RenderingUtils,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData2 >> 16 & 0xFF) * a1) << 16;
Magic Number,MapAround.Mapping,RenderingUtils,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData2 >> 8 & 0xFF) * a1) << 8;
Magic Number,MapAround.Mapping,RenderingUtils,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData2 >> 8 & 0xFF) * a1) << 8;
Magic Number,MapAround.Mapping,RenderingUtils,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData2 >> 8 & 0xFF) * a1) << 8;
Magic Number,MapAround.MathUtils,Radians,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\MathUtils\MathUtils.cs,ToDegrees,The following statement contains a magic number: return radians * 57.295779513082320876798154814105;
Magic Number,MapAround.MathUtils,Degrees,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\MathUtils\MathUtils.cs,ToRadians,The following statement contains a magic number: return degrees / 57.295779513082320876798154814105;
Magic Number,MapAround.MathUtils,SvdDecomposer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\MathUtils\MathUtils.cs,svdLeastSquares,The following statement contains a magic number: Math.Abs(w[j]) > 1e-7
Magic Number,MapAround.MathUtils,SvdDecomposer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\MathUtils\MathUtils.cs,CalcDecomposition,The following statement contains a magic number: its == 30
Magic Number,MapAround.MathUtils,SvdDecomposer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\MathUtils\MathUtils.cs,CalcDecomposition,The following statement contains a magic number: f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);
Magic Number,MapAround.Geography,UnitSphere,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,LatLonToGeocentric,The following statement contains a magic number: Math.Abs(latRad) > Math.PI / 2
Magic Number,MapAround.Geography,GnomonicProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,getMinEntryIndex,The following statement contains a magic number: i = 2;
Magic Number,MapAround.Geography,GnomonicProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,getMinEntryIndex,The following statement contains a magic number: Math.Abs(values[2]) < Math.Abs(values[i])
Magic Number,MapAround.Geography,GnomonicProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,Project,The following statement contains a magic number: r < 1e-8
Magic Number,MapAround.Geography,GnomonicProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,GetCenter,The following statement contains a magic number: latLonSequence.Length % 2 != 0
Magic Number,MapAround.Geography,GnomonicProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,GetCenter,The following statement contains a magic number: int n = latLonSequence.Length / 2;
Magic Number,MapAround.Geography,GnomonicProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,GetCenter,The following statement contains a magic number: double[] latLonSequence = new double[count * 2];
Magic Number,MapAround.Geography,GnomonicProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,GnomonicProjection,The following statement contains a magic number: double[] vector = new double[3];
Magic Number,MapAround.Geography,GnomonicProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,GnomonicProjection,The following statement contains a magic number: int j = (k + 2) % 3;
Magic Number,MapAround.Geography,GnomonicProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,GnomonicProjection,The following statement contains a magic number: int j = (k + 2) % 3;
Magic Number,MapAround.Geography,GnomonicProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,GnomonicProjection,The following statement contains a magic number: int i = (j + 2) % 3;
Magic Number,MapAround.Geography,GnomonicProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,GnomonicProjection,The following statement contains a magic number: int i = (j + 2) % 3;
Magic Number,MapAround.Geography,GnomonicProjection,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,GnomonicProjection,The following statement contains a magic number: _xAxis = (new Vector3(vector[0]' vector[1]' vector[2])).Unitize();
Magic Number,MapAround.Geography,Vector3,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,Angle,The following statement contains a magic number: return 2 * Math.Asin(this.Distance(a) / (2 * a.Length()));
Magic Number,MapAround.Geography,Vector3,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,Angle,The following statement contains a magic number: return 2 * Math.Asin(this.Distance(a) / (2 * a.Length()));
Magic Number,MapAround.Geography,GeoPath,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,Reverse,The following statement contains a magic number: i < Vertices.Count / 2
Magic Number,MapAround.Geography,GeoContour,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,Reverse,The following statement contains a magic number: i < Vertices.Count / 2
Magic Number,MapAround.Geography,GeoContour,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,PlaneAreaInLambertProjection,The following statement contains a magic number: double qp = 1 + 0.5 * (1 - e * e) / e * Math.Log((1 + e) / (1 - e));
Magic Number,MapAround.Geography,GeoContour,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,PlaneAreaInLambertProjection,The following statement contains a magic number: double q = (1 - e * e) *                       (sinPhi / (1 - e * e * sinPhi * sinPhi) -                        0.5 / e * Math.Log((1 - e * sinPhi) / (1 + e * sinPhi)));
Magic Number,MapAround.Geography,GeoContour,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,PlaneAreaInLambertProjection,The following statement contains a magic number: double rq = a * Math.Sqrt(0.5 * qp);
Magic Number,MapAround.Geography,GeoContour,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,PlaneAreaInLambertProjection,The following statement contains a magic number: double f = Math.Sqrt(2 / (1 + sign * v.Z));
Magic Number,MapAround.Geography,GeoContour,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,Area,The following statement contains a magic number: return EllipticAlgorithms.Ellipsoid.SurfaceArea() / (4 * Math.PI * aa) * planeArea;
Magic Number,MapAround.Geography,GeoPolygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,Area,The following statement contains a magic number: return EllipticAlgorithms.Ellipsoid.SurfaceArea() / (4 * Math.PI * aa) * planeArea;
Magic Number,MapAround.Geography,GeoBufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeoBuffer.cs,mergePartialBuffers,The following statement contains a magic number: !allowParallels || buffers.Count < 20
Magic Number,MapAround.Geography,GeoBufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeoBuffer.cs,getBoundsBuffer,The following statement contains a magic number: c == 3
Magic Number,MapAround.Geography,GeoBufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeoBuffer.cs,getPolylineBuffer,The following statement contains a magic number: c == 3
Magic Number,MapAround.Geography,GeoBufferBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeoBuffer.cs,GetBuffer,The following statement contains a magic number: pointsPerCircle <= 2
Magic Number,MapAround.Geography,Angle,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Angle,The following statement contains a magic number: _degrees = minutes / 60.0;
Magic Number,MapAround.Geography,Angle,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Angle,The following statement contains a magic number: _degrees = (seconds / 3600.0) + (minutes / 60.0);
Magic Number,MapAround.Geography,Angle,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Angle,The following statement contains a magic number: _degrees = (seconds / 3600.0) + (minutes / 60.0);
Magic Number,MapAround.Geography,Angle,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,GetHashCode,The following statement contains a magic number: return (int)(_degrees * 1000033);
Magic Number,MapAround.Geography,GlobalCoordinates,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: latitude = (latitude + 180) % 360;
Magic Number,MapAround.Geography,GlobalCoordinates,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: latitude = (latitude + 180) % 360;
Magic Number,MapAround.Geography,GlobalCoordinates,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: latitude += 360;
Magic Number,MapAround.Geography,GlobalCoordinates,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: latitude -= 180;
Magic Number,MapAround.Geography,GlobalCoordinates,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: latitude = 180 - latitude;
Magic Number,MapAround.Geography,GlobalCoordinates,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: longitude += 180;
Magic Number,MapAround.Geography,GlobalCoordinates,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: latitude > 90
Magic Number,MapAround.Geography,GlobalCoordinates,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: longitude = ((longitude + 180) % 360);
Magic Number,MapAround.Geography,GlobalCoordinates,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: longitude = ((longitude + 180) % 360);
Magic Number,MapAround.Geography,GlobalCoordinates,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: longitude += 360;
Magic Number,MapAround.Geography,GlobalCoordinates,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: longitude -= 180;
Magic Number,MapAround.Geography,GlobalCoordinates,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,GetHashCode,The following statement contains a magic number: return ((int)(_longitude.GetHashCode() * (_latitude.GetHashCode() + 1021))) * 1000033;
Magic Number,MapAround.Geography,GlobalCoordinates,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,GetHashCode,The following statement contains a magic number: return ((int)(_longitude.GetHashCode() * (_latitude.GetHashCode() + 1021))) * 1000033;
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double A = 1 + (uSquared / 16384) * (4096 + uSquared * (-768 + uSquared * (320 - 175 * uSquared)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double A = 1 + (uSquared / 16384) * (4096 + uSquared * (-768 + uSquared * (320 - 175 * uSquared)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double A = 1 + (uSquared / 16384) * (4096 + uSquared * (-768 + uSquared * (320 - 175 * uSquared)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double A = 1 + (uSquared / 16384) * (4096 + uSquared * (-768 + uSquared * (320 - 175 * uSquared)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double A = 1 + (uSquared / 16384) * (4096 + uSquared * (-768 + uSquared * (320 - 175 * uSquared)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double B = (uSquared / 1024) * (256 + uSquared * (-128 + uSquared * (74 - 47 * uSquared)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double B = (uSquared / 1024) * (256 + uSquared * (-128 + uSquared * (74 - 47 * uSquared)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double B = (uSquared / 1024) * (256 + uSquared * (-128 + uSquared * (74 - 47 * uSquared)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double B = (uSquared / 1024) * (256 + uSquared * (-128 + uSquared * (74 - 47 * uSquared)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double B = (uSquared / 1024) * (256 + uSquared * (-128 + uSquared * (74 - 47 * uSquared)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: sigmaM2 = 2.0 * sigma1 + sigma;
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: deltaSigma = B * sinSigma * (cosSigmaM2 + (B / 4.0) * (cosSignma * (-1 + 2 * cos2SigmaM2)                      - (B / 6.0) * cosSigmaM2 * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: deltaSigma = B * sinSigma * (cosSigmaM2 + (B / 4.0) * (cosSignma * (-1 + 2 * cos2SigmaM2)                      - (B / 6.0) * cosSigmaM2 * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: deltaSigma = B * sinSigma * (cosSigmaM2 + (B / 4.0) * (cosSignma * (-1 + 2 * cos2SigmaM2)                      - (B / 6.0) * cosSigmaM2 * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: deltaSigma = B * sinSigma * (cosSigmaM2 + (B / 4.0) * (cosSignma * (-1 + 2 * cos2SigmaM2)                      - (B / 6.0) * cosSigmaM2 * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: deltaSigma = B * sinSigma * (cosSigmaM2 + (B / 4.0) * (cosSignma * (-1 + 2 * cos2SigmaM2)                      - (B / 6.0) * cosSigmaM2 * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: deltaSigma = B * sinSigma * (cosSigmaM2 + (B / 4.0) * (cosSignma * (-1 + 2 * cos2SigmaM2)                      - (B / 6.0) * cosSigmaM2 * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: deltaSigma = B * sinSigma * (cosSigmaM2 + (B / 4.0) * (cosSignma * (-1 + 2 * cos2SigmaM2)                      - (B / 6.0) * cosSigmaM2 * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: Math.Abs(sigma - prevSigma) < 1e-13
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: sigmaM2 = 2.0 * sigma1 + sigma;
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double phi2 = Math.Atan2(sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1'                                       (1.0 - f) * Math.Sqrt(sin2Alpha + Math.Pow(sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1' 2.0)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double C = (f / 16) * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double C = (f / 16) * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double C = (f / 16) * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double C = (f / 16) * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double L = lambda - (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cosSigmaM2 + C * cosSigma * (-1 + 2 * cos2SigmaM2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: (i > 1) && (change < 1e-13)
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: i < 20
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: alpha1 -= 360.0;
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: alpha1 >= 360.0
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: alpha2 -= 360.0;
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: alpha2 >= 360.0
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticMeasurement,The following statement contains a magic number: double elev12 = (elev1 + elev2) / 2.0;
Magic Number,MapAround.Geography,GeodeticCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticMeasurement,The following statement contains a magic number: double phi12 = (phi1 + phi2) / 2.0;
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getArcIntersections,The following statement contains a magic number: return new ICoordinate[] { PlanimetryEnvironment.NewCoordinate((p1.X + p2.X) / 2' double.PositiveInfinity) };
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getArcIntersections,The following statement contains a magic number: double x = 0.5 * (p1.X + p2.X);
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getArcIntersections,The following statement contains a magic number: double y = (yn - x * x + 2 * p2.X * x) / (ly - p2.Y);
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getArcIntersections,The following statement contains a magic number: double b = 2 * (p2.X * f - p1.X);
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getArcIntersections,The following statement contains a magic number: double d = b * b - 4 * a * c;
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getDistanceToArc,The following statement contains a magic number: double qy = ly + arcPoint.Y + (arcPoint.X - x) * 0.5 * (arcPoint.X - x) / (ly - arcPoint.Y);
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,FindArc,The following statement contains a magic number: pointsPrev.Length == 2
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,FindArc,The following statement contains a magic number: pointsNext.Length == 2
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,Finish,The following statement contains a magic number: ICoordinate[] points =                          getArcIntersections(arc.Site.Cell.DataPoint' rn.Site.Cell.DataPoint' 2 * l);
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,Finish,The following statement contains a magic number: points.Length == 2
Magic Number,MapAround.Geometry.Tessellations,VoronoiBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getCircleCenter,The following statement contains a magic number: double x = 0.5 * (ma * mb * (p1.Y - p3.Y) + mb * (p1.X + p2.X) - ma * (p2.X + p3.X)) / (mb - ma);
Magic Number,MapAround.Geometry.Tessellations,VoronoiBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getCircleCenter,The following statement contains a magic number: y = -1 / ma * (x - 0.5 * (p1.X + p2.X)) + 0.5 * (p1.Y + p2.Y);
Magic Number,MapAround.Geometry.Tessellations,VoronoiBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getCircleCenter,The following statement contains a magic number: y = -1 / ma * (x - 0.5 * (p1.X + p2.X)) + 0.5 * (p1.Y + p2.Y);
Magic Number,MapAround.Geometry.Tessellations,VoronoiBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,handleCircleEvent,The following statement contains a magic number: edge.Node2 = new VoronoiNode((ln.Site.Cell.DataPoint.X + rn.Site.Cell.DataPoint.X) / 2'                                           (ln.Site.Cell.DataPoint.Y + rn.Site.Cell.DataPoint.Y) / 2);
Magic Number,MapAround.Geometry.Tessellations,VoronoiBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,handleCircleEvent,The following statement contains a magic number: edge.Node2 = new VoronoiNode((ln.Site.Cell.DataPoint.X + rn.Site.Cell.DataPoint.X) / 2'                                           (ln.Site.Cell.DataPoint.Y + rn.Site.Cell.DataPoint.Y) / 2);
Magic Number,MapAround.Geometry.Tessellations,VoronoiBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,init,The following statement contains a magic number: double middleX = (cells[i].DataPoint.X + cells[i + 1].DataPoint.X) / 2;
Magic Number,MapAround.Geometry.Tessellations,VoronoiBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,Build,The following statement contains a magic number: sourcePoints.Count < 3
Magic Number,MapAround.Indexing,KDTreeNode,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\KDTree.cs,ClearChildren,The following statement contains a magic number: _parent._nodeCount -= 2;
Magic Number,MapAround.Indexing,QuadTree,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\QuadTree.cs,getMinBoundingQuad,The following statement contains a magic number: double maxHalfSize = Math.Max(rectangle.Width' rectangle.Height) / 2;
Magic Number,MapAround.Rendering,LineTransformationSequence,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\LineTransformations.cs,GetLines,The following statement contains a magic number: g.CoordinateCount < 2
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getSegmentAngle,The following statement contains a magic number: result = y1 < y2 ? Math.PI / 2 : 1.5 * Math.PI;
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getSegmentAngle,The following statement contains a magic number: result = y1 < y2 ? Math.PI / 2 : 1.5 * Math.PI;
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The following statement contains a magic number: switch (capLocation)              {                   case CapLocation.Start:                      angle += Math.PI / 2;                      startPoint.X = x1;                      startPoint.Y = y1;                      break;                  case CapLocation.End:                      angle -= Math.PI / 2;                      startPoint.X = x2;                      startPoint.Y = y2;                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The following statement contains a magic number: switch (capLocation)              {                   case CapLocation.Start:                      angle += Math.PI / 2;                      startPoint.X = x1;                      startPoint.Y = y1;                      break;                  case CapLocation.End:                      angle -= Math.PI / 2;                      startPoint.X = x2;                      startPoint.Y = y2;                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The following statement contains a magic number: switch (cap)              {                   case LineCap.Flat:                      ICoordinate[] points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' 2);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Round:                      int pointsPerCircle = (int)(Math.Round(Width * Math.PI) / 2);                      points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' pointsPerCircle);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Square:                      double r = _width * _sqrt2 / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle + _squareCapAngle)'                                                startPoint.Y + r * Math.Sin(angle + _squareCapAngle)));                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle - _squareCapAngle + Math.PI)'                                                startPoint.Y + r * Math.Sin(angle - _squareCapAngle + Math.PI)));                      break;                  case LineCap.Triangle:                      double halfWidth = _width / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle)'                            startPoint.Y + halfWidth * Math.Sin(angle)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + _halfPI)'                            startPoint.Y + halfWidth * Math.Sin(angle + _halfPI)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + Math.PI)'                            startPoint.Y + halfWidth * Math.Sin(angle + Math.PI)));                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The following statement contains a magic number: switch (cap)              {                   case LineCap.Flat:                      ICoordinate[] points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' 2);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Round:                      int pointsPerCircle = (int)(Math.Round(Width * Math.PI) / 2);                      points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' pointsPerCircle);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Square:                      double r = _width * _sqrt2 / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle + _squareCapAngle)'                                                startPoint.Y + r * Math.Sin(angle + _squareCapAngle)));                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle - _squareCapAngle + Math.PI)'                                                startPoint.Y + r * Math.Sin(angle - _squareCapAngle + Math.PI)));                      break;                  case LineCap.Triangle:                      double halfWidth = _width / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle)'                            startPoint.Y + halfWidth * Math.Sin(angle)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + _halfPI)'                            startPoint.Y + halfWidth * Math.Sin(angle + _halfPI)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + Math.PI)'                            startPoint.Y + halfWidth * Math.Sin(angle + Math.PI)));                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The following statement contains a magic number: switch (cap)              {                   case LineCap.Flat:                      ICoordinate[] points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' 2);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Round:                      int pointsPerCircle = (int)(Math.Round(Width * Math.PI) / 2);                      points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' pointsPerCircle);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Square:                      double r = _width * _sqrt2 / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle + _squareCapAngle)'                                                startPoint.Y + r * Math.Sin(angle + _squareCapAngle)));                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle - _squareCapAngle + Math.PI)'                                                startPoint.Y + r * Math.Sin(angle - _squareCapAngle + Math.PI)));                      break;                  case LineCap.Triangle:                      double halfWidth = _width / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle)'                            startPoint.Y + halfWidth * Math.Sin(angle)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + _halfPI)'                            startPoint.Y + halfWidth * Math.Sin(angle + _halfPI)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + Math.PI)'                            startPoint.Y + halfWidth * Math.Sin(angle + Math.PI)));                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The following statement contains a magic number: switch (cap)              {                   case LineCap.Flat:                      ICoordinate[] points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' 2);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Round:                      int pointsPerCircle = (int)(Math.Round(Width * Math.PI) / 2);                      points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' pointsPerCircle);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Square:                      double r = _width * _sqrt2 / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle + _squareCapAngle)'                                                startPoint.Y + r * Math.Sin(angle + _squareCapAngle)));                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle - _squareCapAngle + Math.PI)'                                                startPoint.Y + r * Math.Sin(angle - _squareCapAngle + Math.PI)));                      break;                  case LineCap.Triangle:                      double halfWidth = _width / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle)'                            startPoint.Y + halfWidth * Math.Sin(angle)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + _halfPI)'                            startPoint.Y + halfWidth * Math.Sin(angle + _halfPI)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + Math.PI)'                            startPoint.Y + halfWidth * Math.Sin(angle + Math.PI)));                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The following statement contains a magic number: switch (cap)              {                   case LineCap.Flat:                      ICoordinate[] points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' 2);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Round:                      int pointsPerCircle = (int)(Math.Round(Width * Math.PI) / 2);                      points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' pointsPerCircle);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Square:                      double r = _width * _sqrt2 / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle + _squareCapAngle)'                                                startPoint.Y + r * Math.Sin(angle + _squareCapAngle)));                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle - _squareCapAngle + Math.PI)'                                                startPoint.Y + r * Math.Sin(angle - _squareCapAngle + Math.PI)));                      break;                  case LineCap.Triangle:                      double halfWidth = _width / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle)'                            startPoint.Y + halfWidth * Math.Sin(angle)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + _halfPI)'                            startPoint.Y + halfWidth * Math.Sin(angle + _halfPI)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + Math.PI)'                            startPoint.Y + halfWidth * Math.Sin(angle + Math.PI)));                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The following statement contains a magic number: switch (cap)              {                   case LineCap.Flat:                      ICoordinate[] points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' 2);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Round:                      int pointsPerCircle = (int)(Math.Round(Width * Math.PI) / 2);                      points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' pointsPerCircle);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Square:                      double r = _width * _sqrt2 / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle + _squareCapAngle)'                                                startPoint.Y + r * Math.Sin(angle + _squareCapAngle)));                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle - _squareCapAngle + Math.PI)'                                                startPoint.Y + r * Math.Sin(angle - _squareCapAngle + Math.PI)));                      break;                  case LineCap.Triangle:                      double halfWidth = _width / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle)'                            startPoint.Y + halfWidth * Math.Sin(angle)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + _halfPI)'                            startPoint.Y + halfWidth * Math.Sin(angle + _halfPI)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + Math.PI)'                            startPoint.Y + halfWidth * Math.Sin(angle + Math.PI)));                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,translateAngleQuadrant,The following statement contains a magic number: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return _twoPi - angle; }              }
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,translateAngleQuadrant,The following statement contains a magic number: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return _twoPi - angle; }              }
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,translateAngleQuadrant,The following statement contains a magic number: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return _twoPi - angle; }              }
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addInteriorJoin,The following statement contains a magic number: double distance = _width / 2;
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addJoin,The following statement contains a magic number: join == LineJoin.Round && _width <= 2
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addJoin,The following statement contains a magic number: double halfWidth = _width / 2;
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addJoin,The following statement contains a magic number: switch (join)              {                   case LineJoin.Bevel:                      vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                      vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                      break;                  case LineJoin.Round:                      ICoordinate[] points =                          getCirclePoints(PlanimetryEnvironment.NewCoordinate(x2' y2)'                          angle1'                          angle1 - Math.PI + angleBetweenSegments'                           halfWidth'                          (int)(Math.Round(_width * Math.PI) / 2));                        foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineJoin.Miter:                  case LineJoin.MiterClipped:                        Segment s1 = new Segment(pointOnCircle(x1' y1' halfWidth' angle1)' pointOnCircle(x2' y2' halfWidth' angle1));                      Segment s2 = new Segment(pointOnCircle(x3' y3' halfWidth' angle2)' pointOnCircle(x2' y2' halfWidth' angle2));                        ICoordinate miterPoint = null;                        if (PlanimetryAlgorithms.DirectsIntersection(s1' s2' ref miterPoint) == Dimension.Zero)                      {                          double miterDistance2 = PlanimetryAlgorithms.Distance(miterPoint' PlanimetryEnvironment.NewCoordinate(x2' y2));                          if (miterDistance2 < _miterLimit * _width / 2)                              vertexList.Add(miterPoint);                          else                          {                              if (join == LineJoin.MiterClipped)                              {                                  vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                                  vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                              }                              else                              {                                  double l = _miterLimit * _width * 0.5;                                  double miterDistance1 = PlanimetryAlgorithms.Distance(s1.V2' miterPoint);                                  double clipDistance = ((miterDistance2 - l) * (miterDistance2 - l) + l) / miterDistance1;                                    double f = clipDistance / (miterDistance1 - clipDistance);                                  vertexList.Add(PlanimetryEnvironment.NewCoordinate((f * s1.V2.X + miterPoint.X) / (1 + f)'                                                            (f * s1.V2.Y + miterPoint.Y) / (1 + f)));                                  vertexList.Add(PlanimetryEnvironment.NewCoordinate((f * s2.V2.X + miterPoint.X) / (1 + f)'                                                            (f * s2.V2.Y + miterPoint.Y) / (1 + f)));                              }                          }                      }                      else                      {                          if (join == LineJoin.MiterClipped)                          {                              vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                              vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                          }                          else                          {                              double d = Math.Sqrt(_width * _width / 4 + _miterLimit * _miterLimit);                              double alpha = Math.Atan(1 / _miterLimit);                              vertexList.Add(pointOnCircle(x2' y2' d' angle1 - alpha));                              vertexList.Add(pointOnCircle(x2' y2' d' angle1 + alpha));                          }                      }                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addJoin,The following statement contains a magic number: switch (join)              {                   case LineJoin.Bevel:                      vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                      vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                      break;                  case LineJoin.Round:                      ICoordinate[] points =                          getCirclePoints(PlanimetryEnvironment.NewCoordinate(x2' y2)'                          angle1'                          angle1 - Math.PI + angleBetweenSegments'                           halfWidth'                          (int)(Math.Round(_width * Math.PI) / 2));                        foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineJoin.Miter:                  case LineJoin.MiterClipped:                        Segment s1 = new Segment(pointOnCircle(x1' y1' halfWidth' angle1)' pointOnCircle(x2' y2' halfWidth' angle1));                      Segment s2 = new Segment(pointOnCircle(x3' y3' halfWidth' angle2)' pointOnCircle(x2' y2' halfWidth' angle2));                        ICoordinate miterPoint = null;                        if (PlanimetryAlgorithms.DirectsIntersection(s1' s2' ref miterPoint) == Dimension.Zero)                      {                          double miterDistance2 = PlanimetryAlgorithms.Distance(miterPoint' PlanimetryEnvironment.NewCoordinate(x2' y2));                          if (miterDistance2 < _miterLimit * _width / 2)                              vertexList.Add(miterPoint);                          else                          {                              if (join == LineJoin.MiterClipped)                              {                                  vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                                  vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                              }                              else                              {                                  double l = _miterLimit * _width * 0.5;                                  double miterDistance1 = PlanimetryAlgorithms.Distance(s1.V2' miterPoint);                                  double clipDistance = ((miterDistance2 - l) * (miterDistance2 - l) + l) / miterDistance1;                                    double f = clipDistance / (miterDistance1 - clipDistance);                                  vertexList.Add(PlanimetryEnvironment.NewCoordinate((f * s1.V2.X + miterPoint.X) / (1 + f)'                                                            (f * s1.V2.Y + miterPoint.Y) / (1 + f)));                                  vertexList.Add(PlanimetryEnvironment.NewCoordinate((f * s2.V2.X + miterPoint.X) / (1 + f)'                                                            (f * s2.V2.Y + miterPoint.Y) / (1 + f)));                              }                          }                      }                      else                      {                          if (join == LineJoin.MiterClipped)                          {                              vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                              vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                          }                          else                          {                              double d = Math.Sqrt(_width * _width / 4 + _miterLimit * _miterLimit);                              double alpha = Math.Atan(1 / _miterLimit);                              vertexList.Add(pointOnCircle(x2' y2' d' angle1 - alpha));                              vertexList.Add(pointOnCircle(x2' y2' d' angle1 + alpha));                          }                      }                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addJoin,The following statement contains a magic number: switch (join)              {                   case LineJoin.Bevel:                      vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                      vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                      break;                  case LineJoin.Round:                      ICoordinate[] points =                          getCirclePoints(PlanimetryEnvironment.NewCoordinate(x2' y2)'                          angle1'                          angle1 - Math.PI + angleBetweenSegments'                           halfWidth'                          (int)(Math.Round(_width * Math.PI) / 2));                        foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineJoin.Miter:                  case LineJoin.MiterClipped:                        Segment s1 = new Segment(pointOnCircle(x1' y1' halfWidth' angle1)' pointOnCircle(x2' y2' halfWidth' angle1));                      Segment s2 = new Segment(pointOnCircle(x3' y3' halfWidth' angle2)' pointOnCircle(x2' y2' halfWidth' angle2));                        ICoordinate miterPoint = null;                        if (PlanimetryAlgorithms.DirectsIntersection(s1' s2' ref miterPoint) == Dimension.Zero)                      {                          double miterDistance2 = PlanimetryAlgorithms.Distance(miterPoint' PlanimetryEnvironment.NewCoordinate(x2' y2));                          if (miterDistance2 < _miterLimit * _width / 2)                              vertexList.Add(miterPoint);                          else                          {                              if (join == LineJoin.MiterClipped)                              {                                  vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                                  vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                              }                              else                              {                                  double l = _miterLimit * _width * 0.5;                                  double miterDistance1 = PlanimetryAlgorithms.Distance(s1.V2' miterPoint);                                  double clipDistance = ((miterDistance2 - l) * (miterDistance2 - l) + l) / miterDistance1;                                    double f = clipDistance / (miterDistance1 - clipDistance);                                  vertexList.Add(PlanimetryEnvironment.NewCoordinate((f * s1.V2.X + miterPoint.X) / (1 + f)'                                                            (f * s1.V2.Y + miterPoint.Y) / (1 + f)));                                  vertexList.Add(PlanimetryEnvironment.NewCoordinate((f * s2.V2.X + miterPoint.X) / (1 + f)'                                                            (f * s2.V2.Y + miterPoint.Y) / (1 + f)));                              }                          }                      }                      else                      {                          if (join == LineJoin.MiterClipped)                          {                              vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                              vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                          }                          else                          {                              double d = Math.Sqrt(_width * _width / 4 + _miterLimit * _miterLimit);                              double alpha = Math.Atan(1 / _miterLimit);                              vertexList.Add(pointOnCircle(x2' y2' d' angle1 - alpha));                              vertexList.Add(pointOnCircle(x2' y2' d' angle1 + alpha));                          }                      }                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addJoin,The following statement contains a magic number: switch (join)              {                   case LineJoin.Bevel:                      vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                      vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                      break;                  case LineJoin.Round:                      ICoordinate[] points =                          getCirclePoints(PlanimetryEnvironment.NewCoordinate(x2' y2)'                          angle1'                          angle1 - Math.PI + angleBetweenSegments'                           halfWidth'                          (int)(Math.Round(_width * Math.PI) / 2));                        foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineJoin.Miter:                  case LineJoin.MiterClipped:                        Segment s1 = new Segment(pointOnCircle(x1' y1' halfWidth' angle1)' pointOnCircle(x2' y2' halfWidth' angle1));                      Segment s2 = new Segment(pointOnCircle(x3' y3' halfWidth' angle2)' pointOnCircle(x2' y2' halfWidth' angle2));                        ICoordinate miterPoint = null;                        if (PlanimetryAlgorithms.DirectsIntersection(s1' s2' ref miterPoint) == Dimension.Zero)                      {                          double miterDistance2 = PlanimetryAlgorithms.Distance(miterPoint' PlanimetryEnvironment.NewCoordinate(x2' y2));                          if (miterDistance2 < _miterLimit * _width / 2)                              vertexList.Add(miterPoint);                          else                          {                              if (join == LineJoin.MiterClipped)                              {                                  vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                                  vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                              }                              else                              {                                  double l = _miterLimit * _width * 0.5;                                  double miterDistance1 = PlanimetryAlgorithms.Distance(s1.V2' miterPoint);                                  double clipDistance = ((miterDistance2 - l) * (miterDistance2 - l) + l) / miterDistance1;                                    double f = clipDistance / (miterDistance1 - clipDistance);                                  vertexList.Add(PlanimetryEnvironment.NewCoordinate((f * s1.V2.X + miterPoint.X) / (1 + f)'                                                            (f * s1.V2.Y + miterPoint.Y) / (1 + f)));                                  vertexList.Add(PlanimetryEnvironment.NewCoordinate((f * s2.V2.X + miterPoint.X) / (1 + f)'                                                            (f * s2.V2.Y + miterPoint.Y) / (1 + f)));                              }                          }                      }                      else                      {                          if (join == LineJoin.MiterClipped)                          {                              vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                              vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                          }                          else                          {                              double d = Math.Sqrt(_width * _width / 4 + _miterLimit * _miterLimit);                              double alpha = Math.Atan(1 / _miterLimit);                              vertexList.Add(pointOnCircle(x2' y2' d' angle1 - alpha));                              vertexList.Add(pointOnCircle(x2' y2' d' angle1 + alpha));                          }                      }                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getPathContour,The following statement contains a magic number: addJoin(_lineJoin'                          c.Vertices'                          pv[i].X' pv[i].Y'                          pv[i + 1].X' pv[i + 1].Y'                          pv[i + 2].X' pv[i + 2].Y);
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getPathContour,The following statement contains a magic number: addJoin(_lineJoin'                          c.Vertices'                          pv[i].X' pv[i].Y'                          pv[i + 1].X' pv[i + 1].Y'                          pv[i + 2].X' pv[i + 2].Y);
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getPathContour,The following statement contains a magic number: i < cnt - 2
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getPathContour,The following statement contains a magic number: addCap(_lineEndCap'                      c.Vertices'                      CapLocation.End'                      pv[cnt - 2].X' pv[cnt - 2].Y'                      pv[cnt - 1].X' pv[cnt - 1].Y);
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getPathContour,The following statement contains a magic number: addCap(_lineEndCap'                      c.Vertices'                      CapLocation.End'                      pv[cnt - 2].X' pv[cnt - 2].Y'                      pv[cnt - 1].X' pv[cnt - 1].Y);
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getPathContour,The following statement contains a magic number: addJoin(_lineJoin'                          c.Vertices'                          pv[i].X' pv[i].Y'                          pv[i - 1].X' pv[i - 1].Y'                          pv[i - 2].X' pv[i - 2].Y);
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getPathContour,The following statement contains a magic number: addJoin(_lineJoin'                          c.Vertices'                          pv[i].X' pv[i].Y'                          pv[i - 1].X' pv[i - 1].Y'                          pv[i - 2].X' pv[i - 2].Y);
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,geContourContour,The following statement contains a magic number: int ii = 2;
Magic Number,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,geContourContour,The following statement contains a magic number: cv.Count > 2
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,SetPixel,The following statement contains a magic number: _buffer[shift] =                  (int)a << 24 |                           (int)r << 16 |                           (int)g << 8 |                           (int)b;
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,SetPixel,The following statement contains a magic number: _buffer[shift] =                  (int)a << 24 |                           (int)r << 16 |                           (int)g << 8 |                           (int)b;
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,SetPixel,The following statement contains a magic number: _buffer[shift] =                  (int)a << 24 |                           (int)r << 16 |                           (int)g << 8 |                           (int)b;
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: byte alpha = (byte)(pixelData >> 24 & 0xFF);
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: alpha == 255
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: byte oldAlpha = (byte)((oldPixelData >> 24 & 0xFF));
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: byte newAlpha = (byte)(alpha + oldAlpha - alpha * oldAlpha / 255f);
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: float a1 = alpha / 255f;
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: float a0 = (1 - a1) * oldAlpha / 255f;
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: Int32 b1 = newAlpha << 24;
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData >> 16 & 0xFF) * a1) << 16;
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData >> 16 & 0xFF) * a1) << 16;
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData >> 16 & 0xFF) * a1) << 16;
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData >> 8 & 0xFF) * a1) << 8;
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData >> 8 & 0xFF) * a1) << 8;
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData >> 8 & 0xFF) * a1) << 8;
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: byte alpha = (byte)(pixelData >> 24 & 0xFF);
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: alpha == 255
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: byte oldAlpha = (byte)((oldPixelData >> 24 & 0xFF));
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: byte newAlpha = (byte)(alpha + oldAlpha - alpha * oldAlpha / 255f);
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: float a1 = alpha / 255f;
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: float a0 = (1 - a1) * oldAlpha / 255f;
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: Int32 b1 = newAlpha << 24;
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData >> 16 & 0xFF) * a1) << 16;
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData >> 16 & 0xFF) * a1) << 16;
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData >> 16 & 0xFF) * a1) << 16;
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData >> 8 & 0xFF) * a1) << 8;
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData >> 8 & 0xFF) * a1) << 8;
Magic Number,MapAround.Rendering,RasterData,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData >> 8 & 0xFF) * a1) << 8;
Magic Number,MapAround.Rendering,RenderingPipeline,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following statement contains a magic number: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Magic Number,MapAround.Rendering,RenderingPipeline,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following statement contains a magic number: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Magic Number,MapAround.Rendering,RenderingPipeline,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following statement contains a magic number: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Magic Number,MapAround.Rendering,RenderingPipeline,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following statement contains a magic number: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Magic Number,MapAround.Rendering,RenderingPipeline,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following statement contains a magic number: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Magic Number,MapAround.Rendering,RenderingPipeline,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following statement contains a magic number: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Magic Number,MapAround.Rendering,RenderingPipeline,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following statement contains a magic number: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Magic Number,MapAround.Rendering,RenderingPipeline,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following statement contains a magic number: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Magic Number,MapAround.Rendering,RenderingPipeline,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following statement contains a magic number: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Magic Number,MapAround.Rendering,RenderingPipeline,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following statement contains a magic number: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Magic Number,MapAround.Rendering,SpanGenerator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,addSpans,The following statement contains a magic number: float[] pixelCoverage = new float[(int)(max + 2) - (int)min];
Magic Number,MapAround.Rendering,SpanGenerator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,addSpans,The following statement contains a magic number: float alphaStep = 255f / _subPixelLevel;
Magic Number,MapAround.Rendering,Region,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,containsPoint,The following statement contains a magic number: return crossCount % 2 == 1;
Magic Number,MapAround.Rendering,Region,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeHorizontalWindingIntersections,The following statement contains a magic number: crosses.Count % 2 == 1
Magic Number,MapAround.Rendering,Region,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeHorizontalAlternateIntersections,The following statement contains a magic number: crosses.Count % 2 == 1
Magic Number,MapAround.Rendering,Region,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeVerticalWindingIntersections,The following statement contains a magic number: crosses.Count % 2 == 1
Magic Number,MapAround.Rendering,Region,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeVerticalAlternateIntersections,The following statement contains a magic number: crosses.Count % 2 == 1
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,readDouble,The following statement contains a magic number: byte[] doubleBytes = new byte[8];
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,readDouble,The following statement contains a magic number: i < 8
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,writeDouble,The following statement contains a magic number: byte[] doubleBytes = new byte[8];
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,writeDouble,The following statement contains a magic number: i < 8
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,readInt,The following statement contains a magic number: byte[] intBytes = new byte[4];
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,readInt,The following statement contains a magic number: i < 4
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,writeInt,The following statement contains a magic number: byte[] intBytes = new byte[4];
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,writeInt,The following statement contains a magic number: i < 4
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,DeserializeGeometry,The following statement contains a magic number: switch (featureType)              {                  case 1: //Point                      return BinaryGeometrySerializer.DeserializePoint(stream);                  case 2: //Polyline                      return BinaryGeometrySerializer.DeserializePolyline(stream);                  case 3: //Polygon                      return BinaryGeometrySerializer.DeserializePolygon(stream);                  case 4: //MultiPoint                      return BinaryGeometrySerializer.DeserializeMultiPoint(stream);              }
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,DeserializeGeometry,The following statement contains a magic number: switch (featureType)              {                  case 1: //Point                      return BinaryGeometrySerializer.DeserializePoint(stream);                  case 2: //Polyline                      return BinaryGeometrySerializer.DeserializePolyline(stream);                  case 3: //Polygon                      return BinaryGeometrySerializer.DeserializePolygon(stream);                  case 4: //MultiPoint                      return BinaryGeometrySerializer.DeserializeMultiPoint(stream);              }
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,DeserializeGeometry,The following statement contains a magic number: switch (featureType)              {                  case 1: //Point                      return BinaryGeometrySerializer.DeserializePoint(stream);                  case 2: //Polyline                      return BinaryGeometrySerializer.DeserializePolyline(stream);                  case 3: //Polygon                      return BinaryGeometrySerializer.DeserializePolygon(stream);                  case 4: //MultiPoint                      return BinaryGeometrySerializer.DeserializeMultiPoint(stream);              }
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,SerializeGeometry,The following statement contains a magic number: writeInt(stream' 2);
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,SerializeGeometry,The following statement contains a magic number: writeInt(stream' 3);
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,SerializeGeometry,The following statement contains a magic number: writeInt(stream' 4);
Magic Number,MapAround.Serialization,WKTGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,GetPolylineWKT,The following statement contains a magic number: cnt < 2
Magic Number,MapAround.Serialization,WKTGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,contourString,The following statement contains a magic number: contour.Vertices.Count <= 2
Magic Number,MapAround.Serialization,CoordinateSystemWktDeserializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\SpatialReferenceSerializers.cs,ReadProjectedCoordinateSystem,The following statement contains a magic number: List<AxisInfo> axes = new List<AxisInfo>(2);
Magic Number,MapAround.Serialization,CoordinateSystemWktDeserializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\SpatialReferenceSerializers.cs,ReadGeographicCoordinateSystem,The following statement contains a magic number: List<AxisInfo> info = new List<AxisInfo>(2);
Magic Number,MapAround.UI,ImageLegend,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,checkElementWidth,The following statement contains a magic number: int width = element.Image.Width + _margin * 2 + _elementHorizontalSpacing;
Magic Number,MapAround.UI,ImageLegend,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,checkElementHeight,The following statement contains a magic number: int currentHeight = _margin * 2 + (int)getCaptionSize().Height + _elementsVerticalSpacing;
Magic Number,MapAround.UI,ImageLegend,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,CheckCaption,The following statement contains a magic number: _width = Math.Max((int)captionSize.Width + _margin * 2' _width);
Magic Number,MapAround.UI,ImageLegend,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,CheckCaption,The following statement contains a magic number: _height = Math.Max((int)captionSize.Height + _margin * 2' _height);
Magic Number,MapAround.UI,ImageLegend,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,drawElement,The following statement contains a magic number: imageHeightSpacing = (int)labelSize.Height / 2 - element.Image.Height / 2;
Magic Number,MapAround.UI,ImageLegend,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,drawElement,The following statement contains a magic number: imageHeightSpacing = (int)labelSize.Height / 2 - element.Image.Height / 2;
Magic Number,MapAround.UI,ImageLegend,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,drawElement,The following statement contains a magic number: labelHeightSpacing = element.Image.Height / 2 - (int)labelSize.Height / 2;
Magic Number,MapAround.UI,ImageLegend,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,drawElement,The following statement contains a magic number: labelHeightSpacing = element.Image.Height / 2 - (int)labelSize.Height / 2;
Magic Number,MapAround.UI,ImageLegend,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,DrawLegend,The following statement contains a magic number: g.DrawString(Caption' _captionFont' new SolidBrush(_captionColor)' new PointF(_width / 2 - captionSize.Width / 2' _margin));
Magic Number,MapAround.UI,ImageLegend,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,DrawLegend,The following statement contains a magic number: g.DrawString(Caption' _captionFont' new SolidBrush(_captionColor)' new PointF(_width / 2 - captionSize.Width / 2' _margin));
Magic Number,MapAround.Web,MapServerBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,GetImage,The following statement contains a magic number: do                          {                              IFeatureRenderer _oldFeatureRender = null;                              try                              {                                    //Íà÷èíàåì ðèñîâàòü íîâûé ñëîé.                                  wmsFeatureRender.BeginLayerRender();                                    //Äåëàåì ñëîé âèäèìûì. Âñå îñòàëüíûå ñëîè ìû îòêëþ÷èëè âûøå.                                  useLayers[i].Visible = true;                                    //Íàñòðîéêà ñëîÿ ïåðåä ðåíäåðèíãîì.                                  if (useLayers[i] is FeatureLayer)                                      OnPrepareRenderFeatureLayer(new PrepareRenderFeatureLayerArgs((FeatureLayer)useLayers[i]));                                    //Óñòàíàâëèâàåì ñâîé ðåíäåð' ÷òî áû ïåðåêðûòü îòðèñîâêó íàçâàíèé                                  if (useLayers[i] is FeatureLayer)                                  {                                      _oldFeatureRender = (useLayers[i] as FeatureLayer).FeatureRenderer;                                      (useLayers[i] as FeatureLayer).FeatureRenderer = wmsFeatureRender;                                  }                                    byte[] titleInfo = null;                                    //Ñìîòðèì â êýøå.                                  using (Image bmpLayer = GetImageFromChach(useLayers[i]' out titleInfo' bboxWithGutters))                                  {                                      if (!ReferenceEquals(bmpLayer' null))                                      {                                          //Äîáàâëÿåì äàííûå î íàçâàíèÿõ â wmsFeatureRender.                                          wmsFeatureRender.AddTitleInfo(titleInfo);                                          //Êîïèðóåì êàðòèíêó â ðåçóëüòèðóþùèé òàéë.                                          CopyImage(bmpLayer' bmpWithGutters);                                          continue;                                      }                                  }                                    //Åñëè ïðîìàõ ïî êýø                                  using (                                      Image bmpLayer = new Bitmap(width + _gutterSize * 2' height + _gutterSize * 2'                                                                  PixelFormat.Format32bppArgb))                                  {                                      //Çàãðóæàåì äàííûå (ïî÷åìó ýòî äåëàåòñÿ âíå WMS ñàì íå ïîíèìàþ).                                        OnBeforeRenderNewImage(new RenderNewImageEventArgs(bboxWithGutters'useLayers[i]));                                      //MapAround çàãðóçèò òîëüêî âèäèìûå ñëîè' ïî ýòîìó íå çàìîðà÷èâàåìñÿ íà çàãðóçêè ñëîåâ ïî îòäåëüíîñòè.                                             // ðèñóåì êàðòó                                      //MapAround îòðåíäåðèò òîëüêî âèäèìûå ñëîè.                                      //Òàêæå îí ïîïûòàåòñÿ îòðåíäåðèòü êîñìåòè÷åñêèé ñëîé' ïî ýòîé ïðè÷èíå ìû ïðîâåðÿåì âûøå' ÷òî áû îí íå áûë çàäàí.                                      _map.Render(bmpLayer' bboxWithGutters);                                        //Êîïèðóåì ðåçóëüòàò íà ðåçóëüòèðóþùèé ðàñòð.                                      CopyImage(bmpLayer' bmpWithGutters);                                        // Êëàäåì â êýø ðàñòð ñëîÿ + èíôîðìàöèþ î íàçâàíèÿõ.                                      SetImageToChach(useLayers[i]' bmpLayer' wmsFeatureRender.CurrentTitleInfo' bboxWithGutters);                                    }                              }                              finally                              {                                    i++;                                  //Äåëàåì ñëîé íå âèäèìûì.                                  useLayers[i - 1].Visible = false;                                    if (useLayers[i - 1] is FeatureLayer)                                  {                                      //Ìåíÿåì ðåíäåð íà ñòàðûé                                      (useLayers[i - 1] as FeatureLayer).FeatureRenderer = _oldFeatureRender;                                  }                              }                          } while (i < useLayers.Length);
Magic Number,MapAround.Web,MapServerBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,GetImage,The following statement contains a magic number: do                          {                              IFeatureRenderer _oldFeatureRender = null;                              try                              {                                    //Íà÷èíàåì ðèñîâàòü íîâûé ñëîé.                                  wmsFeatureRender.BeginLayerRender();                                    //Äåëàåì ñëîé âèäèìûì. Âñå îñòàëüíûå ñëîè ìû îòêëþ÷èëè âûøå.                                  useLayers[i].Visible = true;                                    //Íàñòðîéêà ñëîÿ ïåðåä ðåíäåðèíãîì.                                  if (useLayers[i] is FeatureLayer)                                      OnPrepareRenderFeatureLayer(new PrepareRenderFeatureLayerArgs((FeatureLayer)useLayers[i]));                                    //Óñòàíàâëèâàåì ñâîé ðåíäåð' ÷òî áû ïåðåêðûòü îòðèñîâêó íàçâàíèé                                  if (useLayers[i] is FeatureLayer)                                  {                                      _oldFeatureRender = (useLayers[i] as FeatureLayer).FeatureRenderer;                                      (useLayers[i] as FeatureLayer).FeatureRenderer = wmsFeatureRender;                                  }                                    byte[] titleInfo = null;                                    //Ñìîòðèì â êýøå.                                  using (Image bmpLayer = GetImageFromChach(useLayers[i]' out titleInfo' bboxWithGutters))                                  {                                      if (!ReferenceEquals(bmpLayer' null))                                      {                                          //Äîáàâëÿåì äàííûå î íàçâàíèÿõ â wmsFeatureRender.                                          wmsFeatureRender.AddTitleInfo(titleInfo);                                          //Êîïèðóåì êàðòèíêó â ðåçóëüòèðóþùèé òàéë.                                          CopyImage(bmpLayer' bmpWithGutters);                                          continue;                                      }                                  }                                    //Åñëè ïðîìàõ ïî êýø                                  using (                                      Image bmpLayer = new Bitmap(width + _gutterSize * 2' height + _gutterSize * 2'                                                                  PixelFormat.Format32bppArgb))                                  {                                      //Çàãðóæàåì äàííûå (ïî÷åìó ýòî äåëàåòñÿ âíå WMS ñàì íå ïîíèìàþ).                                        OnBeforeRenderNewImage(new RenderNewImageEventArgs(bboxWithGutters'useLayers[i]));                                      //MapAround çàãðóçèò òîëüêî âèäèìûå ñëîè' ïî ýòîìó íå çàìîðà÷èâàåìñÿ íà çàãðóçêè ñëîåâ ïî îòäåëüíîñòè.                                             // ðèñóåì êàðòó                                      //MapAround îòðåíäåðèò òîëüêî âèäèìûå ñëîè.                                      //Òàêæå îí ïîïûòàåòñÿ îòðåíäåðèòü êîñìåòè÷åñêèé ñëîé' ïî ýòîé ïðè÷èíå ìû ïðîâåðÿåì âûøå' ÷òî áû îí íå áûë çàäàí.                                      _map.Render(bmpLayer' bboxWithGutters);                                        //Êîïèðóåì ðåçóëüòàò íà ðåçóëüòèðóþùèé ðàñòð.                                      CopyImage(bmpLayer' bmpWithGutters);                                        // Êëàäåì â êýø ðàñòð ñëîÿ + èíôîðìàöèþ î íàçâàíèÿõ.                                      SetImageToChach(useLayers[i]' bmpLayer' wmsFeatureRender.CurrentTitleInfo' bboxWithGutters);                                    }                              }                              finally                              {                                    i++;                                  //Äåëàåì ñëîé íå âèäèìûì.                                  useLayers[i - 1].Visible = false;                                    if (useLayers[i - 1] is FeatureLayer)                                  {                                      //Ìåíÿåì ðåíäåð íà ñòàðûé                                      (useLayers[i - 1] as FeatureLayer).FeatureRenderer = _oldFeatureRender;                                  }                              }                          } while (i < useLayers.Length);
Magic Number,MapAround.Web,MapServerBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,ParseBbox,The following statement contains a magic number: strVals.Length != 4
Magic Number,MapAround.Web,MapServerBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,ParseBbox,The following statement contains a magic number: !double.TryParse(strVals[2]' NumberStyles.Float' CultureInfo.InvariantCulture' out maxx)
Magic Number,MapAround.Web,MapServerBase,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,ParseBbox,The following statement contains a magic number: !double.TryParse(strVals[3]' NumberStyles.Float' CultureInfo.InvariantCulture' out maxy)
Magic Number,MapAround.Web,JSONMpHelper,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,drawVisiblePolylinePart,The following statement contains a magic number: points[k] = new double[2];
Magic Number,MapAround.Web,JSONMpHelper,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,drawPolylineWithIntersectCalculation,The following statement contains a magic number: path.Vertices.Count < 2
Magic Number,MapAround.Web,JSONMpHelper,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,drawPolylineSimple,The following statement contains a magic number: path.Vertices.Count < 2
Magic Number,MapAround.Web,JSONMpHelper,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,drawPolylineSimple,The following statement contains a magic number: points[j] = new double[2];
Magic Number,MapAround.Web,JSONMpHelper,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,DrawPoint,The following statement contains a magic number: _points[i] = new double[2];
Magic Number,MapAround.Web,JSONMpHelper,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,DrawPolyline,The following statement contains a magic number: Math.Min(viewBox.Width/(feature.BoundingRectangle.Width)'                               viewBox.Height/(feature.BoundingRectangle.Height)) < 2
Magic Number,MapAround.Web,JSONMpHelper,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,DrawPolygon,The following statement contains a magic number: c.Vertices.Count <= 2
Magic Number,MapAround.Web,JSONMpHelper,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,DrawPolygon,The following statement contains a magic number: points[j] = new double[2];
Magic Number,MapAround.Web,JSONMpHelper,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,DrawPolygon,The following statement contains a magic number: points.Length > 2
Magic Number,MapAround.Web.Wmts,WmtsCapabilities,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,GenerateTileMatrixInfo,The following statement contains a magic number: matrixInfo.AppendChild(createElement("MatrixWidth"' Math.Pow(2' i).ToString()' capabilities' false' wmtsNamespaceURI));
Magic Number,MapAround.Web.Wmts,WmtsCapabilities,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,GenerateTileMatrixInfo,The following statement contains a magic number: matrixInfo.AppendChild(createElement("MatrixHeight"' Math.Pow(2' i).ToString()' capabilities' false' wmtsNamespaceURI));
Missing Default,MapAround.Caching,SimpleCacheAccessor,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Caching\FeatureCaching.cs,featureTypeSubKey,The following switch statement is missing a default case: switch (featureType)              {                  case FeatureType.Point:                  case FeatureType.MultiPoint:                      return "points";                  case FeatureType.Polyline:                      return "polylines";                  case FeatureType.Polygon:                      return "polygons";              }
Missing Default,MapAround.CoordinateSystems.Transformations,FeatureTransformer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformers.cs,TransformFeatureInPlace,The following switch statement is missing a default case: switch (feature.FeatureType)              {                   case FeatureType.Point:                      feature.Point = GeometryTransformer.TransformPoint(feature.Point' transform);                      break;                  case FeatureType.Polyline:                      feature.Polyline = GeometryTransformer.TransformPolyline(feature.Polyline' transform);                      break;                  case FeatureType.Polygon:                      feature.Polygon = GeometryTransformer.TransformPolygon(feature.Polygon' transform);                      break;                  case FeatureType.MultiPoint:                      feature.MultiPoint = GeometryTransformer.TransformMultiPoint(feature.MultiPoint' transform);                      break;              }
Missing Default,MapAround.DataProviders,ShapeFileSpatialDataProvider,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\ShapeFileDataProvider.cs,geometryFromShapeRecord,The following switch statement is missing a default case: switch (record.ShapeType)              {                  // point                  case 1:                      return new PointD(record.Points[0].X' record.Points[0].Y);                  // polyline                  case 3:                      Polyline polyline = new Polyline();                      for (int i = 0; i < record.Parts.Count; i++)                      {                          LinePath path = new LinePath();                          int j;                          for (j = record.Parts[i]; j < (i == record.Parts.Count - 1 ? record.Points.Count : record.Parts[i + 1]); j++)                              path.Vertices.Add(PlanimetryEnvironment.NewCoordinate(record.Points[j].X' record.Points[j].Y));                            polyline.Paths.Add(path);                      }                      return polyline;                  // ground                  case 5:                      Polygon p = new Polygon();                      for (int i = 0; i < record.Parts.Count; i++)                      {                          Contour contour = new Contour();                          int j;                          for (j = record.Parts[i]; j < (i == record.Parts.Count - 1 ? record.Points.Count : record.Parts[i + 1]); j++)                              contour.Vertices.Add(PlanimetryEnvironment.NewCoordinate(record.Points[j].X' record.Points[j].Y));                            contour.Vertices.RemoveAt(contour.Vertices.Count - 1);                          p.Contours.Add(contour);                      }                      if (p.CoordinateCount > 0)                          return p;                      else                          return null;                  // set of points                  case 8:                      MultiPoint mp = new MultiPoint();                      for (int i = 0; i < record.Points.Count; i++)                          mp.Points.Add(PlanimetryEnvironment.NewCoordinate(record.Points[i].X' record.Points[i].Y));                      return mp;              }
Missing Default,MapAround.DataProviders,ShapeFileSpatialDataProvider,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\ShapeFileDataProvider.cs,processFeature,The following switch statement is missing a default case: switch (feature.FeatureType)              {                  case FeatureType.Point: points.Add(feature); break;                  case FeatureType.MultiPoint: multiPoints.Add(feature); break;                  case FeatureType.Polyline: polylines.Add(feature); break;                  case FeatureType.Polygon: polygons.Add(feature); break;              }
Missing Default,MapAround.Geometry,MonotoneChain,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\DataStructures.cs,getSubChainBounds,The following switch statement is missing a default case: switch (_orientation)              {                   case Orientation.RightUp:                      return new BoundingRectangle(s1.V1' s2.V2);                  case Orientation.RightDown:                      return new BoundingRectangle(s1.V1.X' s2.V2.Y' s2.V2.X' s1.V1.Y);                  case Orientation.LeftUp:                      return new BoundingRectangle(s2.V2.X' s1.V1.Y' s1.V1.X' s2.V2.Y);                  case Orientation.LeftDown:                      return new BoundingRectangle(s2.V2' s1.V1);              }
Missing Default,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,checkContoursOrientation,The following switch statement is missing a default case: switch (or)                              {                                  case Contour.Orientation.Undefined:                                      ICoordinate p = Contours[i].GetSelfIntersectionPoint();                                      return new ValidationError(InvalidityCase.SelfIntersection' p' i);                                  case Contour.Orientation.CCW:                                      return new ValidationError(InvalidityCase.WrongOrientation' null' i);                              }
Missing Default,MapAround.Geometry,Polygon,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,checkContoursOrientation,The following switch statement is missing a default case: switch (or)                      {                          case Contour.Orientation.Undefined:                              ICoordinate p = Contours[0].GetSelfIntersectionPoint();                              return new ValidationError(InvalidityCase.SelfIntersection' p' 0);                          case Contour.Orientation.CW:                              return new ValidationError(InvalidityCase.WrongOrientation' null' 0);                      }
Missing Default,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPointOverlay,The following switch statement is missing a default case: switch (operation)              {                  case OverlayType.Intersection:                      foreach (PlanarGraphNode node in graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              result.Add(new PointD(node.Point));                      break;                  case OverlayType.Union:                      foreach (PlanarGraphNode node in graph.Nodes)                          result.Add(new PointD(node.Point));                      break;                  case OverlayType.Difference:                      foreach (PlanarGraphNode node in graph.Nodes)                          if (node.Label.UsedByObject1 && !node.Label.UsedByObject2)                              result.Add(new PointD(node.Point));                      break;                  case OverlayType.SymmetricDifference:                      foreach (PlanarGraphNode node in graph.Nodes)                          if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                              result.Add(new PointD(node.Point));                      break;              }
Missing Default,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolylinePolylineOverlay,The following switch statement is missing a default case: switch (operation)                          {                              case OverlayType.Intersection:                                  edge.Enabled = edge.Label.UsedByObject1 && edge.Label.UsedByObject2;                                  break;                              case OverlayType.Union:                                  edge.Enabled = edge.Label.UsedByObject1 || edge.Label.UsedByObject2;                                  break;                              case OverlayType.Difference:                                  edge.Enabled = edge.Label.UsedByObject1 && !edge.Label.UsedByObject2;                                  break;                              case OverlayType.SymmetricDifference:                                  edge.Enabled = edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2;                                  break;                          }
Missing Default,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolylinePolylineOverlay,The following switch statement is missing a default case: switch (operation)                              {                                  case OverlayType.Intersection:                                      node.Enabled = node.Label.UsedByObject1 && node.Label.UsedByObject2;                                      break;                                  case OverlayType.Union:                                      node.Enabled = node.Label.UsedByObject1 || node.Label.UsedByObject2;                                      break;                                  case OverlayType.Difference:                                      node.Enabled = node.Label.UsedByObject1 && !node.Label.UsedByObject2;                                      break;                                  case OverlayType.SymmetricDifference:                                      node.Enabled = node.Label.UsedByObject1 ^ node.Label.UsedByObject2;                                      break;                              }
Missing Default,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolylineOverlay,The following switch statement is missing a default case: switch (operation)                          {                              case OverlayType.Intersection:                                  edge.Enabled = false;                                  break;                              case OverlayType.Union:                                  edge.Enabled = edge.Label.UsedByObject2;                                  break;                              case OverlayType.Difference:                                  edge.Enabled = inverseArgs ? edge.Label.UsedByObject2 : false;                                  break;                              case OverlayType.SymmetricDifference:                                  edge.Enabled = edge.Label.UsedByObject2;                                  break;                          }
Missing Default,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolylineOverlay,The following switch statement is missing a default case: switch (operation)                              {                                  case OverlayType.Intersection:                                      node.Enabled = node.Label.UsedByObject1 && node.Label.UsedByObject2;                                      break;                                  case OverlayType.Union:                                      node.Enabled = node.Label.UsedByObject1;                                      break;                                  case OverlayType.Difference:                                      node.Enabled = inverseArgs ? false : !node.Label.UsedByObject2;                                      break;                                  case OverlayType.SymmetricDifference:                                      node.Enabled = true;                                      break;                              }
Missing Default,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolygonOverlay,The following switch statement is missing a default case: switch (operation)                          {                              case OverlayType.Intersection:                                  edge.Enabled = false;                                  break;                              case OverlayType.Union:                                  edge.Enabled = edge.Label.UsedByObject2;                                  break;                              case OverlayType.Difference:                                  edge.Enabled = inverseArgs ? edge.Label.UsedByObject2 : false;                                  break;                              case OverlayType.SymmetricDifference:                                  edge.Enabled = edge.Label.UsedByObject2;                                  break;                          }
Missing Default,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolygonOverlay,The following switch statement is missing a default case: switch (operation)                              {                                  case OverlayType.Intersection:                                      node.Enabled = (pg.ContainsPoint(node.Point) && !node.Label.UsedByObject2) ||                                                     (node.Label.UsedByObject2 && node.Label.UsedByObject1);                                      break;                                  case OverlayType.Union:                                      node.Enabled = !pg.ContainsPoint(node.Point) && !node.Label.UsedByObject2;                                      break;                                  case OverlayType.Difference:                                      node.Enabled = inverseArgs ? false : !pg.ContainsPoint(node.Point) && !node.Label.UsedByObject2;                                      break;                                  case OverlayType.SymmetricDifference:                                      node.Enabled = !pg.ContainsPoint(node.Point) && !node.Label.UsedByObject2;                                      break;                              }
Missing Default,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,isNodeEnabled,The following switch statement is missing a default case: switch (operation)              {                  case OverlayType.Intersection:                      if (!node.Label.UsedByObject1 || !node.Label.UsedByObject2)                          return false;                      break;                  case OverlayType.Union:                      return false;                  case OverlayType.Difference:                      return false;                  case OverlayType.SymmetricDifference:                      return false;              }
Missing Default,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,isLinearEdgeEnabled,The following switch statement is missing a default case: switch (operation)              {                  case OverlayType.Intersection:                      return edge.Label.UsedByObject1 && edge.Label.UsedByObject2;                  case OverlayType.Union:                      return false;                  case OverlayType.Difference:                      return false;                  case OverlayType.SymmetricDifference:                      return false;              }
Missing Default,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,isAreaEdgeEnabled,The following switch statement is missing a default case: switch (operation)              {                  case OverlayType.Intersection:                      if (usebyPolygon1 && usebyPolygon2 && edge.OrientationInObject1 == edge.OrientationInObject2)                          return true;                        if ((usebyPolygon1 ^ usebyPolygon2))                          if (usebyPolygon1)                          {                              if (p2.ContainsPoint(edge.CenterPoint()))                                  return true;                          }                          else                          {                              if (p1.ContainsPoint(edge.CenterPoint()))                                  return true;                          }                      break;                  case OverlayType.Union:                      if (usebyPolygon1 && usebyPolygon2 && edge.OrientationInObject1 == edge.OrientationInObject2)                          return true;                        if ((usebyPolygon1 ^ usebyPolygon2))                          if (usebyPolygon1)                          {                              if (!p2.ContainsPoint(edge.CenterPoint()))                                  return true;                          }                          else                          {                              if (!p1.ContainsPoint(edge.CenterPoint()))                                  return true;                          }                      break;                  case OverlayType.Difference:                      if (usebyPolygon1 && usebyPolygon2 && edge.OrientationInObject1 != edge.OrientationInObject2)                          return true;                        if ((usebyPolygon1 ^ usebyPolygon2))                          if (usebyPolygon1)                          {                              if (!p2.ContainsPoint(edge.CenterPoint()))                                  return true;                          }                          else                          {                              if (p1.ContainsPoint(edge.CenterPoint()))                                  return true;                          }                      break;                  case OverlayType.SymmetricDifference:                      if ((usebyPolygon1 ^ usebyPolygon2))                          return true;                      break;              }
Missing Default,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,isNodeEnabled,The following switch statement is missing a default case: switch (operation)              {                  case OverlayType.Intersection:                      if (!node.Label.UsedByObject1 || !node.Label.UsedByObject2)                          return false;                      break;                  case OverlayType.Union:                      return false;                  case OverlayType.Difference:                  case OverlayType.SymmetricDifference:                      return false;              }
Missing Default,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,isLinearEdgeEnabled,The following switch statement is missing a default case: switch (operation)              {                  case OverlayType.Intersection:                      return edge.Label.UsedByObject1 && (edge.Label.UsedByObject2 || polygon.ContainsPoint(edge.CenterPoint()));                  case OverlayType.Union:                      return edge.Label.UsedByObject1 && !polygon.ContainsPoint(edge.CenterPoint());                  case OverlayType.Difference:                      return inverseArgs ? false :                                            edge.Label.UsedByObject1 &&                                            !polygon.ContainsPoint(edge.CenterPoint()) &&                                           !edge.Label.UsedByObject2;                  case OverlayType.SymmetricDifference:                      return edge.Label.UsedByObject1 &&                             !polygon.ContainsPoint(edge.CenterPoint()) &&                             !edge.Label.UsedByObject2;              }
Missing Default,MapAround.Geometry,OverlayCalculator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,isAreaEdgeEnabled,The following switch statement is missing a default case: switch (operation)              {                  case OverlayType.Intersection:                      return false;                  case OverlayType.Union:                      if (usebyPolygon) return true;                      break;                  case OverlayType.Difference:                      return inverseArgs;                  case OverlayType.SymmetricDifference:                      if (usebyPolygon) return true;                      break;              }
Missing Default,MapAround.Geometry,GeometrySimplifier,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,getVertexWeight,The following switch statement is missing a default case: switch (_vertexWeighting)              {                  case VertexWeightingType.NormalizedLinear:                  case VertexWeightingType.AngleCube:                      // length of the segments                      double s1 = PlanimetryAlgorithms.Distance(p1' p2);                      double s2 = PlanimetryAlgorithms.Distance(p2' p3);                        double s1s2 = s1 * s2;                        //   angle of rotation                      double angle = Math.PI - Math.Abs(Math.Acos(((p1.X - p2.X) * (p3.X - p2.X) + (p1.Y - p2.Y) * (p3.Y - p2.Y)) / s1s2));                        if (_vertexWeighting == VertexWeightingType.SquareDifference)                          return s1s2 * angle / (s1 + s2);                      else                          return s1s2 * angle * angle * angle;                  case VertexWeightingType.SquareDifference:                      return Math.Abs((p2.X - p1.X) * (p3.Y - p1.Y) - (p3.X - p1.X) * (p2.Y - p1.Y));                  case VertexWeightingType.Custom:                      if (SDMinVertexWeightNeeded != null)                      {                          SDMinVertexWeightNeededEventArgs args =                               new SDMinVertexWeightNeededEventArgs(p1' p2' p3' pathIndex' pointIndex);                          SDMinVertexWeightNeeded(this' args);                          return args.Weight;                      }                      break;              }
Missing Default,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,getDimensionPair,The following switch statement is missing a default case: switch (minDim)                  {                      case 0: _sourceDimensions = DimensionPair.ZeroTwo;                          break;                      case 1: _sourceDimensions = DimensionPair.OneTwo;                          break;                      case 2: _sourceDimensions = DimensionPair.TwoTwo;                          break;                  }
Missing Default,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,elementToChar,The following switch statement is missing a default case: switch (_values[x' y])              {                   case ElementValue.Empty: return 'F';                  case ElementValue.Zero: return '0';                  case ElementValue.One: return '1';                  case ElementValue.Two: return '2';              }
Missing Default,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculteInternalInternal,The following switch statement is missing a default case: switch (_sourceDimensions)              {                  // ---------------------------- the intersection of the interior of the two points                  case DimensionPair.ZeroZero:                        this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                              break;                          }                      break;                  // ---------------------------- the intersection of the interior of a point and a polyline                  case DimensionPair.ZeroOne:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2 && node.IncidentEdges.Count % 2 != 1)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                              break;                          }                      break;                  // ---------------------------- crossing point' and the interior of the polygon                  case DimensionPair.ZeroTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        Polygon polygon = _sourceGeometry1 is Polygon ? (Polygon)_sourceGeometry1 : (Polygon)_sourceGeometry2;                        foreach (PlanarGraphNode node in _graph.Nodes)                      {                          if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                              //node is used by one of the objects                              if (isFirstGeometryPoint ^ node.Label.UsedByObject2)                                  //not a polygon. need to check whether it is inside the polygon.                                  if (polygon.ContainsPoint(node.Point))                                  {                                      this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                                      break;                                  }                      }                      break;                  // ---------------------------- the intersection of the interior of polylines                  case DimensionPair.OneOne:                      this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      // lines may intersect at a point' then the graph has a node used by both                       // lines and does not coincide with their boundaries                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              // node was found' make sure that it does not limit:                              // at the boundary points of an odd number of edges used line                              int use1Count = 0;                              int use2Count = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) use1Count++;                                  if (edge.Label.UsedByObject2) use2Count++;                              }                              if (use1Count % 2 != 1 && use2Count % 2 != 1)                              {                                  // polylines intersect at least at                                  this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                                  break;                              }                          }                        // possible intersection of the one-dimensional'                      // then they should be shared at least one edge of the graph                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.One;                              return;                          }                      break;                  // ---------------------------- the intersection of the interior of the polyline and polygon                  case DimensionPair.OneTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      polygon = _sourceGeometry1 is Polygon ? (Polygon)_sourceGeometry1 : (Polygon)_sourceGeometry2;                      bool flag = _sourceGeometry1 is Polygon;                        // perhaps one-dimensional intersection' then the edge must lie                       // within the polygon' and used only the line                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (((flag && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1) ||                                (!flag && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2)) && polygon.ContainsPoint(edge.CenterPoint()))                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.One;                              return;                          }                      break;                  // ---------------------------- the intersection of the interior of polygons                  case DimensionPair.TwoTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        // possible two-dimensional intersection' in which case at least one edge only                      // have one ground should lie within the other' or at least one edge of the polygon                       // is used both on the same side of the two polygons to mark up orientation                       // of the edges of polygons along the bypass                      markPolygonsOrientation();                        foreach (PlanarGraphEdge edge in _graph.Edges)                      {                          flag = false;                          if (edge.Label.UsedByObject1 && !edge.Label.UsedByObject2)                              if (((Polygon)_sourceGeometry2).ContainsPoint(edge.CenterPoint()))                                  flag = true;                            if (edge.Label.UsedByObject2 && !edge.Label.UsedByObject1)                              if (((Polygon)_sourceGeometry1).ContainsPoint(edge.CenterPoint()))                                  flag = true;                            if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              if (edge.OrientationInObject1 == edge.OrientationInObject2)                                  flag = true;                            if(flag)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Two;                              return;                          }                      }                      break;              }
Missing Default,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsBounds,The following switch statement is missing a default case: switch (_sourceDimensions)              {                  // ---------------------------- two border crossing points                  case DimensionPair.ZeroZero:                      // border points - the empty set' and their intersection is also                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ---------------------------- border crossing points and polylines                  case DimensionPair.ZeroOne:                      // border points - the empty set' the intersection of the boundary polyline too                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ----------------------------border crossing point and polygon                  case DimensionPair.ZeroTwo:                      //border points - the empty set' the intersection of the boundary of the landfill' too                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ---------------------------- border crossing polylines                  case DimensionPair.OneOne:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possible boundary lines coincide' in this case in the graph'                       // there must exist a node incident to the edges of which are used an odd number of times both lines                      foreach (PlanarGraphNode node in _graph.Nodes)                      {                          int use1count = 0;                          int use2count = 0;                          foreach (PlanarGraphEdge edge in node.IncidentEdges)                          {                              if (edge.Label.UsedByObject1) use1count++;                              if (edge.Label.UsedByObject2) use2count++;                          }                          if (use1count % 2 == 1 && use2count % 2 == 1)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                              return;                          }                      }                      break;                  // ---------------------------- border crossing polyline and polygon                  case DimensionPair.OneTwo:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node used polygon and polyline' and the number of edges                       // incident to a node used polyline' must be odd                                         bool flag = _sourceGeometry1 is Polygon;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usedEdgesCount = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (flag && edge.Label.UsedByObject2) usedEdgesCount++;                                  if (!flag && edge.Label.UsedByObject1) usedEdgesCount++;                              }                              if (usedEdgesCount % 2 == 1)                              {                                  this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ----------------------------intersection polygon boundaries                  case DimensionPair.TwoTwo:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possibly zero-dimensional intersection' in this case in the graph' there must exist a node used by both polygons                      flag = false;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                              flag = true;                              break;                          }                        if (!flag) return;                        // perhaps there is a one-dimensional intersection' in which case the graph must find at least one shared edge                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.One;                              return;                          }                      break;              }
Missing Default,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The following switch statement is missing a default case: switch (_sourceDimensions)              {                  // ----------------------------the interior of the intersection points with the boundary point - always empty                  case DimensionPair.ZeroZero:                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and the interior of the points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                           return;                        // possibly zero-dimensional intersection' in this case' there must exist a node count of incident edges is odd                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                        break;                  // ---------------------------- crossing the border and the interior of the point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                          return;                        // possibly zero-dimensional intersection' in this case' there must exist a shared graph node                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[xPos' yPos] = ElementValue.Zero;                              return;                          }                      break;                  // ---------------------------- crossing the border and the interior of the polyline                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node for which the number of incident edges'                      // used a polyline - odd' the other used a polyline - even                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usageCount1 = 0;                              int usageCount2 = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) usageCount1++;                                  if (edge.Label.UsedByObject2) usageCount2++;                              }                              if ((!inverseArgs && usageCount1 % 2 == 0 && usageCount2 % 2 == 1) ||                                 (inverseArgs && usageCount1 % 2 == 1 && usageCount2 % 2 == 0))                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ---------------------------- crossing the border and the interior of the polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                      if ((isFirstGeometryPolyline && inverseArgs) ||                          (!isFirstGeometryPolyline && !inverseArgs))                      {                          // boundary polyline must be inside the polygon                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                  (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (inverseArgs && edge.Label.UsedByObject1) count++;                                      if (!inverseArgs && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 1 && polygon.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                              }                      }                      else                      {                          bool flag = false;                          // boundary of the polygon can intersect the interior of the polyline at                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (isFirstGeometryPolyline && edge.Label.UsedByObject1) count++;                                      if (!isFirstGeometryPolyline && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 0)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      flag = true;                                      break;                                  }                              }                            if (!flag) return;                            // perhaps also one-dimensional intersection' in which                           // case the graph must find at least one shared edge                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      break;                  // ---------------------------- crossing the border and the interior of the polygon                  case DimensionPair.TwoTwo:                      Polygon p1 = (Polygon)_sourceGeometry1;                      Polygon p2 = (Polygon)_sourceGeometry2;                      this[xPos' yPos] = ElementValue.Empty;                        // perhaps one-dimensional intersection' in which case the                      // graph must be some edge' used by one of the sites and are inside other                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                              if ((inverseArgs && edge.Label.UsedByObject1 && p2.ContainsPoint(edge.CenterPoint())) ||                                  (!inverseArgs && edge.Label.UsedByObject2 && p1.ContainsPoint(edge.CenterPoint())))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      break;              }
Missing Default,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalExternal,The following switch statement is missing a default case: switch (_sourceDimensions)              {                  // ---------------------------- the interior of the intersection point with the addition of a point                  case DimensionPair.ZeroZero:                      this[xPos' yPos] = ElementValue.Empty;                        //if (!((PointD)_sourceGeometry1).Equals((PointD)_sourceGeometry2))                      //    this[xPos' yPos] = ElementValue.Zero;                        foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                              if (node.Label.UsedByObject1 ^ inverseArgs)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                      break;                  // ----------------------------crossing the inner region and add points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                        if ((isFirstGeometryPolyline && !inverseArgs) ||                          (!isFirstGeometryPolyline && inverseArgs))                      {                          // intersection point with the additions interior of the polyline - dimensional (not in the degenerate case)                          if (_graph.Edges.Count > 0)                              this[xPos' yPos] = ElementValue.One;                      }                      else                      {                          // intersection of the complement to the interior of the polyline point' perhaps a zero-dimensional intersection                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                                  if ((isFirstGeometryPoint && node.Label.UsedByObject1) ||                                      (!isFirstGeometryPoint && node.Label.UsedByObject2))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                      }                      break;                  // ---------------------------- crossing the inner region and add a point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      if ((inverseArgs && isFirstGeometryPoint) ||                         (!inverseArgs && !isFirstGeometryPoint))                      {                          // addition point is always two-dimensional intersection with the inner region of the landfill                          if(_graph.Edges.Count > 0)                              this[xPos' yPos] = ElementValue.Two;                      }                      else                      {                          Polygon polygon = isFirstGeometryPoint ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                            // addition' the landfill has a zero-dimensional intersection with the interior of the point'                           // if the point does not lie within the polygon                          foreach (PlanarGraphNode node in _graph.Nodes)                          {                              if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                                  if (isFirstGeometryPoint ^ node.Label.UsedByObject2)                                  {                                      // node is not shared' if it lies outside the range - we have a zero-dimensional intersection                                      if (!polygon.ContainsPoint(node.Point))                                      {                                          this[xPos' yPos] = ElementValue.Zero;                                          return;                                      }                                      return;                                  }                          }                      }                      break;                  // ---------------------------- crossing the inner region and add polylines                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      //perhaps one-dimensional intersection' in which case there must be an edge is used by only one line                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                              if ((!inverseArgs && edge.Label.UsedByObject1) ||                                 (inverseArgs && edge.Label.UsedByObject2))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      break;                  // ---------------------------- crossing the inner region and add polylines and polygons                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                      Polygon p1 = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                      if ((inverseArgs && isFirstGeometryPolyline) ||                          (!inverseArgs && !isFirstGeometryPolyline))                      {                          // intersection of the complement to the interior of the polyline is two-dimensional polygon                          this[xPos' yPos] = ElementValue.Two;                          return;                      }                      else                      {                          //perhaps one-dimensional intersection polygon additions to the interior of the polyline'                          // in this case there must be an edge that belongs only polylines' and does not lie within the polygon                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                                  if ((!inverseArgs && edge.Label.UsedByObject1) ||                                      (inverseArgs && edge.Label.UsedByObject2))                                      if (!p1.ContainsPoint(edge.CenterPoint()))                                      {                                          this[xPos' yPos] = ElementValue.One;                                          return;                                      }                      }                      break;                  // ---------------------------- the intersection of the interior of the polygon and Supplies                  case DimensionPair.TwoTwo:                      this[xPos' yPos] = ElementValue.Empty;                      // possible two-dimensional intersection' if there is at least one edge is used                       // first ground does not lie within the other' or there is an edge is used only                      // in the second polygon lies inside the first' or there is an edge used                      // by both polygons so that they lie on opposite sides of it                      Polygon polygon1 = (Polygon)_sourceGeometry1;                      Polygon polygon2 = (Polygon)_sourceGeometry2;                      bool _orientationMarked = false;                        foreach (PlanarGraphEdge edge in _graph.Edges)                      {                          if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                          {                              if ((inverseArgs && edge.Label.UsedByObject2 && !polygon1.ContainsPoint(edge.CenterPoint())) ||                                 (!inverseArgs && edge.Label.UsedByObject1 && !polygon2.ContainsPoint(edge.CenterPoint())))                              {                                  this[xPos' yPos] = ElementValue.Two;                                  return;                              }                                if ((inverseArgs && edge.Label.UsedByObject1 && polygon2.ContainsPoint(edge.CenterPoint())) ||                                 (!inverseArgs && edge.Label.UsedByObject2 && polygon1.ContainsPoint(edge.CenterPoint())))                                {                                  this[xPos' yPos] = ElementValue.Two;                                  return;                              }                          }                          else                              if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              {                                  // possible orientations of the layout do not have to' if the intersection is calculated by other edges                                  if (_orientationMarked)                                  {                                      markPolygonsOrientation();                                      _orientationMarked = true;                                  }                                  if (edge.OrientationInObject1 != edge.OrientationInObject2)                                  {                                      this[xPos' yPos] = ElementValue.Two;                                      return;                                  }                              }                      }                      break;              }
Missing Default,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The following switch statement is missing a default case: switch (_sourceDimensions)              {                  // ---------------------------- border crossing point with the addition of a point                  case DimensionPair.ZeroZero:                      // always empty                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and add points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      if ((inverseArgs && !isFirstGeometryPoint) ||                          (!inverseArgs && isFirstGeometryPoint))                          // always empty                          this[xPos' yPos] = ElementValue.Empty;                      else                      {                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                                  if (node.IncidentEdges.Count % 2 == 1)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                      }                      break;                  // ---------------------------- crossing the border and add a point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      if ((inverseArgs && isFirstGeometryPoint) ||                          (!inverseArgs && !isFirstGeometryPoint))                      {                          // one-dimensional intersection in the nondegenerate case                          if (_graph.Edges.Count > 0)                              this[xPos' yPos] = ElementValue.One;                      }                      // otherwise empty                      break;                  // ---------------------------- crossing the border and add polylines                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node that is used only a polyline with an odd number of edges incident                      foreach (PlanarGraphNode node in _graph.Nodes)                          if ((!inverseArgs && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                              (inverseArgs && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                      break;                  // ---------------------------- crossing the border and add polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                                            if ((inverseArgs && isFirstGeometryPolyline) ||                          (!inverseArgs && !isFirstGeometryPolyline))                      {                          //perhaps one-dimensional intersection' if there is at least one edge ispolzeumoe only ground                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if ((isFirstGeometryPolyline && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1) ||                                 (!isFirstGeometryPolyline && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      else                      {                          //possibly zero-dimensional intersection' if there is at least one node'                           // use only the line that has an odd number of incident edges and lying within the polygon                          Polygon p1 = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                 (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                                  if(node.IncidentEdges.Count % 2 == 1 && !p1.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                      }                      break;                  // ---------------------------- crossing the border and add polygons                  case DimensionPair.TwoTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon1 = (Polygon)_sourceGeometry1;                       Polygon polygon2 = (Polygon)_sourceGeometry2;                        // perhaps one-dimensional intersection' if there is at least one edge                       // belongs to only one polygon and not contained within another                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if ((!inverseArgs && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2 && !polygon2.ContainsPoint(edge.CenterPoint())) ||                              (inverseArgs && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1 && !polygon1.ContainsPoint(edge.CenterPoint())))                          {                              this[xPos' yPos] = ElementValue.One;                              return;                          }                      break;              }
Missing Default,MapAround.Geometry,IntersectionMatrix,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,Matches,The following switch statement is missing a default case: switch (ch)                  {                       case '*':break;                      case 'F':                          if (_values[j' i] != ElementValue.Empty)                              return false;                          break;                      case 'T':                           if (_values[j' i] == ElementValue.Empty ||                              _values[j' i] == ElementValue.Undefined)                              return false;                          break;                      case '0':                          if (_values[j' i] != ElementValue.Zero)                              return false;                          break;                      case '1':                           if (_values[j' i] != ElementValue.One)                              return false;                          break;                      case '2':                          if (_values[j' i] != ElementValue.Two)                              return false;                          break;                  }
Missing Default,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,translateAngleQuadrant,The following switch statement is missing a default case: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return _twoPi - angle; }              }
Missing Default,MapAround.Geometry,PlanarGraph,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,processContour,The following switch statement is missing a default case: switch ((EdgeUsage)edge.Label.Tag)                          {                              case EdgeUsage.Both: break;                              case EdgeUsage.None:                                  possibleEdges.Add(edge);                                  break;                              case EdgeUsage.Forward:                                  if (edge.Node2 == currentNode)                                      possibleEdges.Add(edge);                                  break;                              case EdgeUsage.Backward:                                  if (edge.Node1 == currentNode)                                      possibleEdges.Add(edge);                                  break;                          }
Missing Default,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,AddFeature,The following switch statement is missing a default case: switch (feature.FeatureType)              {                   case FeatureType.Point:                      AddPoint(feature);                      break;                  case FeatureType.Polyline:                      AddPolyline(feature);                      break;                  case FeatureType.Polygon:                      AddPolygon(feature);                      break;                  case FeatureType.MultiPoint:                      AddMultiPoint(feature);                      break;              }
Missing Default,MapAround.Mapping,FeatureLayer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderFeaturesSample,The following switch statement is missing a default case: switch (sampleCount)                      {                           case 3:                              minX = image.Width / 3;                              maxX = 2 * image.Width / 3;                              break;                          case 2:                              if (drawPoint)                              {                                  minX = image.Width / 2;                                  maxX = image.Width;                              }                              else                                  maxX = image.Width / 2;                              break;                          case 1:                              maxX = image.Width;                              break;                      }
Missing Default,MapAround.Mapping,LayerFeaturesEnumerator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,getCurrentCollection,The following switch statement is missing a default case: switch (_currentFeatureType)                  {                      case FeatureType.Point: return _layer._points;                      case FeatureType.Polyline: return _layer._polylines;                      case FeatureType.Polygon: return _layer._polygons;                      case FeatureType.MultiPoint: return _layer._multiPoints;                  }
Missing Default,MapAround.Mapping,Feature,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,Clone,The following switch statement is missing a default case: switch(result.FeatureType)              {                  case FeatureType.Point:                      result.Point = (PointD)this.Point.Clone();                      break;                  case FeatureType.Polyline:                      result.Polyline = (Polyline)this.Polyline.Clone();                      break;                  case FeatureType.Polygon:                      result.Polygon = (Polygon)this.Polygon.Clone();                      break;                  case FeatureType.MultiPoint:                      result.MultiPoint = (MultiPoint)this.MultiPoint.Clone();                      break;              }
Missing Default,MapAround.Mapping,Feature,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,Feature,The following switch statement is missing a default case: switch (_featureType)              {                   case FeatureType.Point:                      _point = new PointD();                      break;                  case FeatureType.Polyline:                       _polyline = new Polyline();                      break;                  case FeatureType.Polygon:                      _polygon = new Polygon();                      break;                  case FeatureType.MultiPoint:                      _multiPoint = new MultiPoint();                      break;              }
Missing Default,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,addTitleBufferElement,The following switch statement is missing a default case: switch (feature.FeatureType)              {                  case FeatureType.Polyline:                      if (!titleStyle.LeadAlong)                      {                          foreach (LinePath path in feature.Polyline.Paths)                          {                              if (path.Vertices.Count > 2)                                  targetCoordinate = path.Vertices[path.Vertices.Count / 2 - 1];                              else                              {                                  s = new Segment(path.Vertices[0].X' path.Vertices[0].Y'                                                  path.Vertices[1].X' path.Vertices[1].Y);                                    targetCoordinate = s.Center();                              }                              addTitleBufferElement(titleStyle' targetCoordinate' size' scaleFactor' feature);                          }                      }                      else                      {                          int i = 0;                          foreach (LinePath path in feature.Polyline.Paths)                          {                              FollowingTitle followingTitle =                                   getFollowingTitle(g' path' feature.PolylinePartLengths[i]' feature.Title' titleStyle' viewBox' scaleFactor);                              if (followingTitle != null)                                  _titleBuffer.Add(new TitleBufferElement(followingTitle' titleStyle' _titleCount++));                              i++;                          }                      }                      return;                  case FeatureType.Polygon:                      //if (feature.Polygon.Contours.Count > 0)                      //    targetPoint = feature.Polygon.Contours[0].RibsCentroid();                      //else                      //    return;                      //break;                        if (feature.Polygon.Contours.Count > 0)                          try                          {                              targetCoordinate = feature.Polygon.PointOnSurface();                          }                          catch(InvalidOperationException)                          {                              //interior point of the polygon for some reason (usually singular) can not be found                              return;                          }                      else                          return;                      break;                                        case FeatureType.Point:                      targetCoordinate = feature.Point.Coordinate;                      //targetPoint.Y += size.Height / scaleFactor / 2;                      break;                  case FeatureType.MultiPoint:                      if (titleStyle.LeadAlong)                      {                          foreach (ICoordinate p in feature.MultiPoint.Points)                          {                              targetCoordinate = p;                              targetCoordinate.Y += size.Height / scaleFactor / 2;                              addTitleBufferElement(titleStyle' targetCoordinate' size' scaleFactor' feature);                          }                          return;                      }                      else                          targetCoordinate = PlanimetryAlgorithms.GetCentroid(feature.MultiPoint.Points);                      break;              }
Missing Default,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,translateAngleQuadrant,The following switch statement is missing a default case: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return 2 * Math.PI - angle; }              }
Missing Default,MapAround.Mapping,DefaultFeatureRenderer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRelativeDashSize,The following switch statement is missing a default case: switch (pen.DashStyle)              {                  case DashStyle.Dot:                      relativeDashSize = 2;                      break;                    case DashStyle.Dash:                      relativeDashSize = 4;                      break;                    case DashStyle.DashDot:                      relativeDashSize = 6;                      break;                    case DashStyle.DashDotDot:                      relativeDashSize = 8;                      break;                    case DashStyle.Custom:                      relativeDashSize = 0;                      foreach (float d in pen.DashPattern)                          relativeDashSize += d;                      break;              }
Missing Default,MapAround.Geometry.Tessellations,VoronoiBuilder,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,build,The following switch statement is missing a default case: switch (currentEvent.Kind)                  {                       case FortuneEvent.EventKind.Point :                          handlePointEvent((FortunePointEvent)currentEvent);                          break;                        case FortuneEvent.EventKind.Circle:                          handleCircleEvent((FortuneCircleEvent)currentEvent);                          break;                  }
Missing Default,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The following switch statement is missing a default case: switch (capLocation)              {                   case CapLocation.Start:                      angle += Math.PI / 2;                      startPoint.X = x1;                      startPoint.Y = y1;                      break;                  case CapLocation.End:                      angle -= Math.PI / 2;                      startPoint.X = x2;                      startPoint.Y = y2;                      break;              }
Missing Default,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The following switch statement is missing a default case: switch (cap)              {                   case LineCap.Flat:                      ICoordinate[] points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' 2);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Round:                      int pointsPerCircle = (int)(Math.Round(Width * Math.PI) / 2);                      points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' pointsPerCircle);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Square:                      double r = _width * _sqrt2 / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle + _squareCapAngle)'                                                startPoint.Y + r * Math.Sin(angle + _squareCapAngle)));                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle - _squareCapAngle + Math.PI)'                                                startPoint.Y + r * Math.Sin(angle - _squareCapAngle + Math.PI)));                      break;                  case LineCap.Triangle:                      double halfWidth = _width / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle)'                            startPoint.Y + halfWidth * Math.Sin(angle)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + _halfPI)'                            startPoint.Y + halfWidth * Math.Sin(angle + _halfPI)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + Math.PI)'                            startPoint.Y + halfWidth * Math.Sin(angle + Math.PI)));                      break;              }
Missing Default,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,translateAngleQuadrant,The following switch statement is missing a default case: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return _twoPi - angle; }              }
Missing Default,MapAround.Rendering,Polygonizer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addJoin,The following switch statement is missing a default case: switch (join)              {                   case LineJoin.Bevel:                      vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                      vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                      break;                  case LineJoin.Round:                      ICoordinate[] points =                          getCirclePoints(PlanimetryEnvironment.NewCoordinate(x2' y2)'                          angle1'                          angle1 - Math.PI + angleBetweenSegments'                           halfWidth'                          (int)(Math.Round(_width * Math.PI) / 2));                        foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineJoin.Miter:                  case LineJoin.MiterClipped:                        Segment s1 = new Segment(pointOnCircle(x1' y1' halfWidth' angle1)' pointOnCircle(x2' y2' halfWidth' angle1));                      Segment s2 = new Segment(pointOnCircle(x3' y3' halfWidth' angle2)' pointOnCircle(x2' y2' halfWidth' angle2));                        ICoordinate miterPoint = null;                        if (PlanimetryAlgorithms.DirectsIntersection(s1' s2' ref miterPoint) == Dimension.Zero)                      {                          double miterDistance2 = PlanimetryAlgorithms.Distance(miterPoint' PlanimetryEnvironment.NewCoordinate(x2' y2));                          if (miterDistance2 < _miterLimit * _width / 2)                              vertexList.Add(miterPoint);                          else                          {                              if (join == LineJoin.MiterClipped)                              {                                  vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                                  vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                              }                              else                              {                                  double l = _miterLimit * _width * 0.5;                                  double miterDistance1 = PlanimetryAlgorithms.Distance(s1.V2' miterPoint);                                  double clipDistance = ((miterDistance2 - l) * (miterDistance2 - l) + l) / miterDistance1;                                    double f = clipDistance / (miterDistance1 - clipDistance);                                  vertexList.Add(PlanimetryEnvironment.NewCoordinate((f * s1.V2.X + miterPoint.X) / (1 + f)'                                                            (f * s1.V2.Y + miterPoint.Y) / (1 + f)));                                  vertexList.Add(PlanimetryEnvironment.NewCoordinate((f * s2.V2.X + miterPoint.X) / (1 + f)'                                                            (f * s2.V2.Y + miterPoint.Y) / (1 + f)));                              }                          }                      }                      else                      {                          if (join == LineJoin.MiterClipped)                          {                              vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                              vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                          }                          else                          {                              double d = Math.Sqrt(_width * _width / 4 + _miterLimit * _miterLimit);                              double alpha = Math.Atan(1 / _miterLimit);                              vertexList.Add(pointOnCircle(x2' y2' d' angle1 - alpha));                              vertexList.Add(pointOnCircle(x2' y2' d' angle1 + alpha));                          }                      }                      break;              }
Missing Default,MapAround.Rendering,RenderingPipeline,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following switch statement is missing a default case: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Missing Default,MapAround.Rendering,RenderingPipeline,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Render,The following switch statement is missing a default case: switch(_parallelizationLevel)              {                  case ParallelizationLevel.Single:                      renderSingleThread(obj' fill);                      break;                  case ParallelizationLevel.Duo:                  case ParallelizationLevel.Quad:                      renderMultipleThreads(obj' fill);                      break;              }
Missing Default,MapAround.Rendering,SpanGenerator,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,addSpans,The following switch statement is missing a default case: switch(orientation)                          {                              case Orientation.Horizontal:                                  for (int k = spanStartIndex; k < i; k++)                                  {                                      double coverage = pixelCoverage[k];                                      if (coverage > _subPixelLevel)                                          coverage = _subPixelLevel;                                        double antiAliasingAlpha = _alphaTable[(int)(coverage / _subPixelLevel * 254f)];                                        Int32 color = fill.GetPixelColor((int)min + f + spanStartIndex' scanPosition);                                      byte fillAlpha = (byte)(color >> 24 & 0xFF);                                      if (fillAlpha == 0)                                          pixelValues[f] = (byte)(antiAliasingAlpha * 255f) << 24 | color;                                      else                                          pixelValues[f] = (byte)(antiAliasingAlpha * fillAlpha) << 24 | (color & 0x00FFFFFF);                                        f++;                                  }                                  spans.Add(new PixelSpan(Orientation.Horizontal' (int)min + spanStartIndex' scanPosition' pixelValues));                                  break;                                case Orientation.Vertical:                                  for (int k = spanStartIndex; k < i; k++)                                  {                                      double coverage = pixelCoverage[k];                                      if (coverage > _subPixelLevel)                                          coverage = _subPixelLevel;                                        double antiAliasingAlpha = _alphaTable[(int)(coverage / _subPixelLevel * 254f)];                                        Int32 color = fill.GetPixelColor(scanPosition' (int)min + f + spanStartIndex);                                      byte fillAlpha = (byte)(color >> 24 & 0xFF);                                      if (fillAlpha == 0)                                          pixelValues[f] = (byte)(antiAliasingAlpha * 255f) << 24 | color;                                      else                                          pixelValues[f] = (byte)(antiAliasingAlpha * fillAlpha) << 24 | (color & 0x00FFFFFF);                                        f++;                                  }                                  spans.Add(new PixelSpan(Orientation.Vertical' scanPosition' (int)min + spanStartIndex' pixelValues));                                  break;                          }
Missing Default,MapAround.Rendering,Region,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,InitScaning,The following switch statement is missing a default case: switch (orientation)              {                   case Orientation.Horizontal:                      fillEdgeTableForHorizontalScanning();                      break;                  case Orientation.Vertical:                      fillEdgeTableForVerticalScanning();                      break;              }
Missing Default,MapAround.Rendering,Region,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,ComputeHorizontalIntersections,The following switch statement is missing a default case: switch (_fillingMode)              {                  case InteriorFillMode.Alternate:                      computeHorizontalAlternateIntersections(scanY' out intersections);                      return;                  case InteriorFillMode.Winding:                      computeHorizontalWindingIntersections(scanY' out intersections);                      return;              }
Missing Default,MapAround.Rendering,Region,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,ComputeVerticalIntersections,The following switch statement is missing a default case: switch (_fillingMode)              {                  case InteriorFillMode.Alternate:                      computeVerticalAlternateIntersections(scanX' out intersections);                      return;                  case InteriorFillMode.Winding:                      computeVerticalWindingIntersections(scanX' out intersections);                      return;              }
Missing Default,MapAround.Serialization,BinaryGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,DeserializeGeometry,The following switch statement is missing a default case: switch (featureType)              {                  case 1: //Point                      return BinaryGeometrySerializer.DeserializePoint(stream);                  case 2: //Polyline                      return BinaryGeometrySerializer.DeserializePolyline(stream);                  case 3: //Polygon                      return BinaryGeometrySerializer.DeserializePolygon(stream);                  case 4: //MultiPoint                      return BinaryGeometrySerializer.DeserializeMultiPoint(stream);              }
Missing Default,MapAround.Serialization,WKTGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,GeometryFromWKT,The following switch statement is missing a default case: switch (tokenizer.GetStringValue().ToUpper())              {                  case "POINT": return readPoint(tokenizer);                  case "LINESTRING": return readLineString(tokenizer);                  case "MULTILINESTRING": return readMultiLineString(tokenizer);                  case "POLYGON": return readPolygon(tokenizer);                  case "MULTIPOLYGON": return readMultiPolygon(tokenizer);                  case "MULTIPOINT": return readMultiPoint(tokenizer);              }
Missing Default,MapAround.Serialization,WKBGeometrySerializer,D:\research\architectureSmells\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,DeserializeGeometry,The following switch statement is missing a default case: switch ((WKBGeometryType)type)              {                  case WKBGeometryType.Point:                      return readPoint(stream' (WKBByteOrder)byteOrder);                    case WKBGeometryType.LineString:                      return readLineString(stream' (WKBByteOrder)byteOrder);                    case WKBGeometryType.MultiLineString:                      return readMultiLineString(stream' (WKBByteOrder)byteOrder);                    case WKBGeometryType.Polygon:                      return readPolygon(stream' (WKBByteOrder)byteOrder);                    case WKBGeometryType.MultiPolygon:                      return readMultiPolygon(stream' (WKBByteOrder)byteOrder);                    case WKBGeometryType.MultiPoint:                      return readMultiPoint(stream' (WKBByteOrder)byteOrder);              }
