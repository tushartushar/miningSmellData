Implementation smell,Namespace,Class,File,Method,Description
Long Method,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolygonOverlay,The method has 112 lines of code.
Long Method,MapAround.Geometry,PlanimetryAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,DeterminantSign,The method has 170 lines of code.
Long Method,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculteInternalInternal,The method has 119 lines of code.
Long Method,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The method has 147 lines of code.
Long Method,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalExternal,The method has 168 lines of code.
Long Method,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The method has 113 lines of code.
Long Method,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,processLinePath,The method has 121 lines of code.
Long Method,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,BuildFaces,The method has 105 lines of code.
Long Method,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,processContour,The method has 104 lines of code.
Long Method,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,processContour,The method has 123 lines of code.
Long Method,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPrismPolygon,The method has 101 lines of code.
Long Method,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The method has 113 lines of code.
Long Method,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The method has 208 lines of code.
Long Method,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPolylineWithIntersectCalculation,The method has 125 lines of code.
Long Method,MapAround.MathUtils,SvdDecomposer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\MathUtils\MathUtils.cs,CalcDecomposition,The method has 286 lines of code.
Long Method,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The method has 119 lines of code.
Long Method,MapAround.Rendering,SpanGenerator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,addSpans,The method has 113 lines of code.
Long Method,MapAround.Web,MapServerBase,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,GetImage,The method has 119 lines of code.
Long Method,MapAround.Web,MapServerBase,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,GetVectorInfo,The method has 112 lines of code.
Long Method,MapAround.Web,JSONMpHelper,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,drawPolylineWithIntersectCalculation,The method has 113 lines of code.
Long Method,MapAround.Web.Wms,WMSServer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsServer.cs,GetFeatureInfo,The method has 183 lines of code.
Long Method,MapAround.Web.Wms,WMSServer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsServer.cs,GetMap,The method has 247 lines of code.
Long Method,MapAround.Web.Wms,WMSServer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsServer.cs,CheckRequestParams,The method has 100 lines of code.
Long Method,MapAround.Web.Wmts,WMTSServer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WMTSServer.cs,GetFeatureInfo,The method has 179 lines of code.
Long Method,MapAround.Web.Wmts,WMTSServer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WMTSServer.cs,GetTile,The method has 207 lines of code.
Complex Method,MapAround.CoordinateSystems,GeographicCoordinateSystem,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,EqualParams,Cyclomatic complexity of the method is 12
Complex Method,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,AlbersProjection,Cyclomatic complexity of the method is 10
Complex Method,MapAround.CoordinateSystems.Projections,LambertConformalConic2SP,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LambertConformalConic2SP,Cyclomatic complexity of the method is 9
Complex Method,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,calculateOptimalAffineTransformPoints,Cyclomatic complexity of the method is 9
Complex Method,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,Transform,Cyclomatic complexity of the method is 8
Complex Method,MapAround.DataProviders,ShapeFileSpatialDataProvider,C:\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\ShapeFileDataProvider.cs,internalQueryFeatures,Cyclomatic complexity of the method is 11
Complex Method,MapAround.Extensions.Surfaces,IsolineBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,getIsoline,Cyclomatic complexity of the method is 12
Complex Method,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPolylineStyle,Cyclomatic complexity of the method is 15
Complex Method,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,GetBuffer,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,MonotoneChain,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\DataStructures.cs,Split,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Geometry,DistanceCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\DataStructures.cs,calculateDistanceBrutForce,Cyclomatic complexity of the method is 15
Complex Method,MapAround.Geometry,Contour,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,ReduceSegments,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Geometry,Contour,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,GetSelfIntersectionPoint,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,SplitToConnectedDomains,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,getShellPointInHole,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,getHolePointInShell,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,getHolesIntersectionError,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,hasCycles,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,hasNonSinglePointTouch,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,GetBoundingRectangle,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,getInteriorPoint,Cyclomatic complexity of the method is 11
Complex Method,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,PointOnSurface,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,ContourLayoutElement,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,TryAddFromList,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,LinePath,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,ReduceSegments,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Geometry,Polyline,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,GetBoundingRectangle,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Geometry,Polyline,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,getWrongSelfIntersectionError,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,BoundingRectangle,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Intersects,Cyclomatic complexity of the method is 17
Complex Method,MapAround.Geometry,BoundingRectangle,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Intersects,Cyclomatic complexity of the method is 18
Complex Method,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,CalculateOverlay,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolygonPolygonOverlay,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolylinePolylineOverlay,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolylineOverlay,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolygonOverlay,Cyclomatic complexity of the method is 14
Complex Method,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolylinePolygonOverlay,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,calculateOverlay,Cyclomatic complexity of the method is 20
Complex Method,MapAround.Geometry,PlanimetryAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,RobustSegmentsIntersection,Cyclomatic complexity of the method is 13
Complex Method,MapAround.Geometry,PlanimetryAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,GetConvexHull,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Geometry,PlanimetryAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,filterPointsForConvexHull,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,PlanimetryAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,DeterminantSign,Cyclomatic complexity of the method is 24
Complex Method,MapAround.Geometry,GeometrySimplifier,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,getCrossPointsIndex,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,GeometrySimplifier,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,checkWeightedVertex,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,addVerticesAsNodes,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,addSourceSegments,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,addOrMergeNode,Cyclomatic complexity of the method is 13
Complex Method,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegmentByNodes,Cyclomatic complexity of the method is 13
Complex Method,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegmentBySegments,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegmentsByCrossPoints,Cyclomatic complexity of the method is 15
Complex Method,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,getNodeAt,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,processLinePath,Cyclomatic complexity of the method is 16
Complex Method,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,BuildFaces,Cyclomatic complexity of the method is 16
Complex Method,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitContour,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,processContour,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,processContour,Cyclomatic complexity of the method is 16
Complex Method,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,RecountColumnLength,Cyclomatic complexity of the method is 8
Complex Method,MapAround.IO,DbaseWriter,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseWriter.cs,Write,Cyclomatic complexity of the method is 9
Complex Method,MapAround.IO,StreamTokenizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\CommonWktClasses.cs,NextTokenAny,Cyclomatic complexity of the method is 11
Complex Method,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,CalculateBoundingRectangle,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Mapping,RasterLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,LoadRasterPreview,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,BuildPointsIndex,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,Cyclomatic complexity of the method is 14
Complex Method,MapAround.Mapping,Feature,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,Clone,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,setXml,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPolylineStyle,Cyclomatic complexity of the method is 15
Complex Method,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateOptimalAffineTransformPoints,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateRubberSheetTransform,Cyclomatic complexity of the method is 11
Complex Method,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,fillPixel,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,BindRaster,Cyclomatic complexity of the method is 9
Complex Method,MapAround.MathUtils,SvdDecomposer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\MathUtils\MathUtils.cs,CalcDecomposition,Cyclomatic complexity of the method is 56
Complex Method,MapAround.MathUtils,Matrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\MathUtils\MathUtils.cs,GetInverseMatrix,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geography,GeoContour,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,ReduceSegments,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Geography,EllipticOverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticOverlays.cs,CalculateOverlay,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geography,GeoBufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeoBuffer.cs,getPolylineBuffer,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geography,GeoBufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeoBuffer.cs,GetBuffer,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Geometry.Tessellations,FortuneShoreLine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,FindArc,Cyclomatic complexity of the method is 14
Complex Method,MapAround.Geometry.Tessellations,FortuneShoreLine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,removeArcRecursive,Cyclomatic complexity of the method is 14
Complex Method,MapAround.Geometry.Tessellations,FortuneShoreLine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,Finish,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Geometry.Tessellations,VoronoiBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,handlePointEvent,Cyclomatic complexity of the method is 11
Complex Method,MapAround.Geometry.Tessellations,VoronoiBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,handleCircleEvent,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Geometry.Tessellations,VoronoiBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,init,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Geometry.Tessellations,VoronoiBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,Build,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Indexing,KDTreeNode,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\KDTree.cs,Insert,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Indexing,KDTreeNode,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\KDTree.cs,BuildUnbalanced,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Indexing,QuadTreeNode,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\QuadTree.cs,insertIntoChild,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Indexing,QuadTreeNode,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\QuadTree.cs,canAddingToChildCell,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Indexing,QuadTreeNode,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\QuadTree.cs,Remove,Cyclomatic complexity of the method is 13
Complex Method,MapAround.Indexing,QuadTreeNode,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\QuadTree.cs,QueryObjectsInRectangle,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Indexing,QuadTreeNode,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\QuadTree.cs,QueryObjectsContainingPoint,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Rendering,LineTransformationSequence,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\LineTransformations.cs,GetLines,Cyclomatic complexity of the method is 9
Complex Method,MapAround.Rendering,StrokeGenerator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\LineTransformations.cs,GetLines,Cyclomatic complexity of the method is 12
Complex Method,MapAround.Rendering,SpanGenerator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,addSpans,Cyclomatic complexity of the method is 17
Complex Method,MapAround.Rendering,Region,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,fillEdgeTableForHorizontalScanning,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Rendering,Region,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,fillEdgeTableForVerticalScanning,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Rendering,Region,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeHorizontalWindingIntersections,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Rendering,Region,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeVerticalWindingIntersections,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Serialization,WKTGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,GetPolygonWKT,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Web,MapServerBase,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,ParseBbox,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Web,JSONMpHelper,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,DrawPolygon,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Web.Wms,WmsCapabilities,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsCapabilities.cs,GenerateServiceNode,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Web.Wms,WmsCapabilities,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsCapabilities.cs,GenerateContactInfoElement,Cyclomatic complexity of the method is 15
Complex Method,MapAround.Web.Wms,WMSServer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsServer.cs,GetFeatureInfo,Cyclomatic complexity of the method is 14
Complex Method,MapAround.Web.Wms,WMSServer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsServer.cs,GetMap,Cyclomatic complexity of the method is 15
Complex Method,MapAround.Web.Wms,WMSServer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsServer.cs,CheckRequestParams,Cyclomatic complexity of the method is 8
Complex Method,MapAround.Web.Wmts,WmtsCapabilities,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,GenerateServiceNode,Cyclomatic complexity of the method is 10
Complex Method,MapAround.Web.Wmts,WmtsCapabilities,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,GenerateContactInfoElement,Cyclomatic complexity of the method is 15
Complex Method,MapAround.Web.Wmts,WMTSServer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WMTSServer.cs,GetFeatureInfo,Cyclomatic complexity of the method is 13
Complex Method,MapAround.Web.Wmts,WMTSServer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WMTSServer.cs,GetTile,Cyclomatic complexity of the method is 15
Complex Method,MapAround.Web.Wmts,WMTSServer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WMTSServer.cs,CheckRequestParams,Cyclomatic complexity of the method is 10
Long Parameter List,MapAround.Caching,ITileCacheAccessor,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Caching\TileCaching.cs,SaveTileBytes,The method has 5 parameters. Parameters: layer' area' key' tile' contentType
Long Parameter List,MapAround.CoordinateSystems,Unit,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,Unit,The method has 7 parameters. Parameters: conversionFactor' name' authority' authorityCode' alias' abbreviation' remarks
Long Parameter List,MapAround.CoordinateSystems,LinearUnit,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,LinearUnit,The method has 7 parameters. Parameters: metersPerUnit' name' authority' authorityCode' alias' abbreviation' remarks
Long Parameter List,MapAround.CoordinateSystems,AngularUnit,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,AngularUnit,The method has 7 parameters. Parameters: radiansPerUnit' name' authority' authorityCode' alias' abbreviation' remarks
Long Parameter List,MapAround.CoordinateSystems,Ellipsoid,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,Ellipsoid,The method has 11 parameters. Parameters: semiMajorAxis' semiMinorAxis' inverseFlattening' isIvfDefinitive' axisUnit' name' authority' code' alias' abbreviation' remarks
Long Parameter List,MapAround.CoordinateSystems,PrimeMeridian,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,PrimeMeridian,The method has 8 parameters. Parameters: longitude' angularUnit' name' authority' authorityCode' alias' abbreviation' remarks
Long Parameter List,MapAround.CoordinateSystems,Datum,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,Datum,The method has 7 parameters. Parameters: type' name' authority' code' alias' remarks' abbreviation
Long Parameter List,MapAround.CoordinateSystems,HorizontalDatum,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,HorizontalDatum,The method has 9 parameters. Parameters: ellipsoid' toWgs84' type' name' authority' code' alias' remarks' abbreviation
Long Parameter List,MapAround.CoordinateSystems,SpatialReferenceInfo,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,SpatialReferenceInfo,The method has 6 parameters. Parameters: name' authority' code' alias' abbreviation' remarks
Long Parameter List,MapAround.CoordinateSystems,ICoordinateSystemFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateGeographicCoordinateSystem,The method has 6 parameters. Parameters: name' angularUnit' datum' primeMeridian' axis0' axis1
Long Parameter List,MapAround.CoordinateSystems,ICoordinateSystemFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateProjectedCoordinateSystem,The method has 6 parameters. Parameters: name' gcs' projection' linearUnit' axis0' axis1
Long Parameter List,MapAround.CoordinateSystems,CoordinateSystem,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CoordinateSystem,The method has 6 parameters. Parameters: name' authority' authorityCode' alias' abbreviation' remarks
Long Parameter List,MapAround.CoordinateSystems,CoordinateSystemFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateProjectedCoordinateSystem,The method has 6 parameters. Parameters: name' gcs' projection' linearUnit' axis0' axis1
Long Parameter List,MapAround.CoordinateSystems,CoordinateSystemFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateGeographicCoordinateSystem,The method has 6 parameters. Parameters: name' angularUnit' datum' primeMeridian' axis0' axis1
Long Parameter List,MapAround.CoordinateSystems,GeocentricCoordinateSystem,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,GeocentricCoordinateSystem,The method has 10 parameters. Parameters: datum' linearUnit' primeMeridian' axisinfo' name' authority' code' alias' remarks' abbreviation
Long Parameter List,MapAround.CoordinateSystems,GeographicCoordinateSystem,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,GeographicCoordinateSystem,The method has 10 parameters. Parameters: angularUnit' horizontalDatum' primeMeridian' axisInfo' name' authority' authorityCode' alias' abbreviation' remarks
Long Parameter List,MapAround.CoordinateSystems,HorizontalCoordinateSystem,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,HorizontalCoordinateSystem,The method has 8 parameters. Parameters: datum' axisInfo' name' authority' code' alias' remarks' abbreviation
Long Parameter List,MapAround.CoordinateSystems,ProjectedCoordinateSystem,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,ProjectedCoordinateSystem,The method has 11 parameters. Parameters: datum' geographicCoordinateSystem' linearUnit' projection' axisInfo' name' authority' code' alias' remarks' abbreviation
Long Parameter List,MapAround.CoordinateSystems,Wgs84ConversionInfo,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\WGS84ConversionInfo.cs,Wgs84ConversionInfo,The method has 7 parameters. Parameters: dx' dy' dz' ex' ey' ez' ppm
Long Parameter List,MapAround.CoordinateSystems,Wgs84ConversionInfo,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\WGS84ConversionInfo.cs,Wgs84ConversionInfo,The method has 8 parameters. Parameters: dx' dy' dz' ex' ey' ez' ppm' areaOfUse
Long Parameter List,MapAround.CoordinateSystems.Projections,Projection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,Projection,The method has 8 parameters. Parameters: className' parameters' name' authority' code' alias' remarks' abbreviation
Long Parameter List,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,mlfn,The method has 5 parameters. Parameters: e0' e1' e2' e3' phi
Long Parameter List,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,getAffineTransformMatrix,The method has 6 parameters. Parameters: p01' p02' p03' p11' p12' p13
Long Parameter List,MapAround.CoordinateSystems.Transformations,CoordinateTransformation,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,CoordinateTransformation,The method has 9 parameters. Parameters: sourceCS' targetCS' transformType' mathTransform' name' authority' authorityCode' areaOfUse' remarks
Long Parameter List,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Affine,The method has 6 parameters. Parameters: m11' m12' m21' m22' dx' dy
Long Parameter List,MapAround.DataProviders,IRasterProvider,C:\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\RasterProviders.cs,QueryRaster,The method has 8 parameters. Parameters: srcX' srcY' srcWidth' srcHeight' maxDestWidth' maxDestHeight' bounds' receiver
Long Parameter List,MapAround.DataProviders,InMemoryRasterProvider,C:\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\RasterProviders.cs,QueryRaster,The method has 8 parameters. Parameters: srcX' srcY' srcWidth' srcHeight' maxDestWidth' maxDestHeight' bounds' receiver
Long Parameter List,MapAround.DataProviders,ShapeFileSpatialDataProvider,C:\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\ShapeFileDataProvider.cs,processFeature,The method has 6 parameters. Parameters: feature' fr' points' multiPoints' polylines' polygons
Long Parameter List,MapAround.DataProviders,ShapeFileSpatialDataProvider,C:\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\ShapeFileDataProvider.cs,addFeaturesToCache,The method has 5 parameters. Parameters: fr' points' multiPoints' polylines' polygons
Long Parameter List,MapAround.Extensions.Surfaces,ShadedReliefBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\ShadedReliefBuilder.cs,GetLuminosity,The method has 5 parameters. Parameters: triangle' lightX' lightY' lightZ' zFactor
Long Parameter List,MapAround.Extensions.Surfaces,ShadedReliefBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\ShadedReliefBuilder.cs,BuildShadedRelief,The method has 6 parameters. Parameters: triangles' lightX' lightY' lightZ' zFactor' luminosityLevelNumber
Long Parameter List,MapAround.Extensions.Surfaces,ShadedReliefBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\ShadedReliefBuilder.cs,BuildShadedRelief,The method has 6 parameters. Parameters: surfacePoints' lightX' lightY' lightZ' zFactor' luminosityLevelNumber
Long Parameter List,MapAround.Extensions.Surfaces,IsolineBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,assignLevelsToPolygons,The method has 5 parameters. Parameters: surfacePoints' polygons' triangles' zLevels' bounds
Long Parameter List,MapAround.Extensions.Surfaces,IsolineBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,assignLevelsToPolygons,The method has 6 parameters. Parameters: surfaceMin' surfaceMax' polygons' triangles' zLevels' bounds
Long Parameter List,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getArcPoints,The method has 5 parameters. Parameters: point' startAngle' endAngle' distance' pointsPerCircle
Long Parameter List,MapAround.Geometry,DistanceCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\DataStructures.cs,calculateDistanceBrutForce,The method has 5 parameters. Parameters: geometry1' geometry2' points1' points2' threshold
Long Parameter List,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,addPoints,The method has 5 parameters. Parameters: graph' operation' p1' p2' collection
Long Parameter List,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,addPolyline,The method has 5 parameters. Parameters: graph' operation' p1' p2' collection
Long Parameter List,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,addPolygon,The method has 5 parameters. Parameters: graph' operation' p1' p2' collection
Long Parameter List,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolygonPolygonOverlay,The method has 5 parameters. Parameters: polygon1' polygon2' operation' result' performSnapping
Long Parameter List,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolylinePolylineOverlay,The method has 5 parameters. Parameters: polyline1' polyline2' operation' result' performSnapping
Long Parameter List,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolylineOverlay,The method has 6 parameters. Parameters: mp' polyline' operation' result' performSnapping' inverseArgs
Long Parameter List,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolygonOverlay,The method has 6 parameters. Parameters: mp' polygon' operation' result' performSnapping' inverseArgs
Long Parameter List,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolylinePolygonOverlay,The method has 6 parameters. Parameters: polyline' polygon' operation' result' performSnapping' inverseArgs
Long Parameter List,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,isNodeEnabled,The method has 5 parameters. Parameters: node' operation' polyline' polygon' inverseArgs
Long Parameter List,MapAround.Geometry,SDMinVertexWeightNeededEventArgs,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,SDMinVertexWeightNeededEventArgs,The method has 5 parameters. Parameters: previousPoint' point' nextPoint' pathIndex' pointIndex
Long Parameter List,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,AddColumn,The method has 5 parameters. Parameters: fieldName' fieldType' DataType' fieldLength' decimalCount
Long Parameter List,MapAround.Mapping,IRasterRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterRendering.cs,RenderRaster,The method has 6 parameters. Parameters: g' bitmap' style' viewBox' bitmapBounds' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultRasterRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterRendering.cs,RenderRaster,The method has 6 parameters. Parameters: g' bitmap' style' viewBox' bitmapBounds' scaleFactor
Long Parameter List,MapAround.Mapping,RasterBinding,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RasterBinding,The method has 5 parameters. Parameters: rasterX' rasterY' mapPoint' pixelWidth' pixelHeight
Long Parameter List,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,renderPolygons,The method has 5 parameters. Parameters: g' viewBox' mapCoordsViewBox' titlesVisible' scaleFactor
Long Parameter List,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,renderPolylines,The method has 5 parameters. Parameters: g' viewBox' mapCoordsViewBox' titlesVisible' scaleFactor
Long Parameter List,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,renderPointFeatureCollection,The method has 6 parameters. Parameters: points' g' viewBox' mapCoordsViewBox' titlesVisible' scaleFactor
Long Parameter List,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,renderPoints,The method has 5 parameters. Parameters: g' viewBox' mapCoordsViewBox' titlesVisible' scaleFactor
Long Parameter List,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The method has 5 parameters. Parameters: coordinate' width' height' contentAlignment' selectedFeature
Long Parameter List,MapAround.Mapping,LayerLegendSettings,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,LayerLegendSettings,The method has 6 parameters. Parameters: displayPointSample' displayPolylineSample' displayPolygonSample' pointSampleTitle' polylineSampleTitle' polygonSampleTitle
Long Parameter List,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,getAffineTransformMatrix,The method has 6 parameters. Parameters: p01' p02' p03' p11' p12' p13
Long Parameter List,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateRubberSheetTransform,The method has 7 parameters. Parameters: width' height' source' result' sourceNodes' destNodesShifts' progress
Long Parameter List,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,fillPixel,The method has 6 parameters. Parameters: x' y' bmp' fillCount' width' height
Long Parameter List,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateAffinneTransform,The method has 6 parameters. Parameters: width' height' affinneTransformResult' sourceNodes' destNodes' progress
Long Parameter List,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,notifyProgessListenerIfNeeded,The method has 6 parameters. Parameters: progress' startProgressPercent' endProgressPercent' completed' previousPercent' sourceWidth
Long Parameter List,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,BindRaster,The method has 5 parameters. Parameters: source' sourceControlPoints' destinationControlPoints' rectangle' progress
Long Parameter List,MapAround.Mapping,IFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The method has 7 parameters. Parameters: feature' g' style' titleStyle' viewBox' titleVisible' scaleFactor
Long Parameter List,MapAround.Mapping,IFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolyline,The method has 7 parameters. Parameters: feature' g' style' titleStyle' viewBox' titleVisible' scaleFactor
Long Parameter List,MapAround.Mapping,IFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolygon,The method has 7 parameters. Parameters: feature' g' style' titleStyle' viewBox' titleVisible' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The method has 7 parameters. Parameters: feature' g' style' titleStyle' viewBox' titleVisible' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolyline,The method has 7 parameters. Parameters: feature' g' style' titleStyle' viewBox' titleVisible' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolygon,The method has 7 parameters. Parameters: feature' g' style' titleStyle' viewBox' titleVisible' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The method has 7 parameters. Parameters: feature' g' style' titleStyle' viewBox' titleVisible' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolyline,The method has 7 parameters. Parameters: feature' g' style' titleStyle' viewBox' titleVisible' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolygon,The method has 7 parameters. Parameters: feature' g' style' titleStyle' viewBox' titleVisible' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,addTitleBufferElement,The method has 5 parameters. Parameters: g' feature' titleStyle' viewBox' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,addTitleBufferElement,The method has 5 parameters. Parameters: titleStyle' targetPoint' size' scaleFactor' feature
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The method has 7 parameters. Parameters: g' part' length' label' titleStyle' viewBox' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getLeftPoints,The method has 6 parameters. Parameters: points' firstPoint' targetDistance' vertexNumber' halfFontHeight' rotationDeltas
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRightPoints,The method has 6 parameters. Parameters: points' firstPoint' targetDistance' vertexNumber' halfFontHeight' rotationDeltas
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawVisiblePolylinePart,The method has 5 parameters. Parameters: g' path' pen' viewBox' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawVisiblePolylinePartWithStyleDetection,The method has 9 parameters. Parameters: g' path' style' defaultPen' annexPen' selected' viewBox' scaleFactor' lengthFromBegining
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPolylineWithIntersectCalculation,The method has 5 parameters. Parameters: g' feature' style' viewBox' scaleFactor
Long Parameter List,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPolylineSimple,The method has 5 parameters. Parameters: g' feature' style' viewBox' scaleFactor
Long Parameter List,MapAround.Mapping,FollowingTitleElement,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,FollowingTitleElement,The method has 8 parameters. Parameters: translationPoint' rotationAngle' titleOrigin' substring' v1' v2' v3' v4
Long Parameter List,MapAround.MathUtils,SvdDecomposer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\MathUtils\MathUtils.cs,svdLeastSquares,The method has 7 parameters. Parameters: U' w' V' m' n' b' x
Long Parameter List,MapAround.MathUtils,SvdDecomposer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\MathUtils\MathUtils.cs,CalcDecomposition,The method has 9 parameters. Parameters: A' m' n' w' matu' U' matv' V' ierr
Long Parameter List,MapAround.Geography,GeoBufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeoBuffer.cs,getArcPoints,The method has 5 parameters. Parameters: point' startAngle' endAngle' distance' pointsPerCircle
Long Parameter List,MapAround.Geography,GeoBufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeoBuffer.cs,getBoundsBuffer,The method has 5 parameters. Parameters: polygon' projection' distance' pointsPerCircle' allowParallels
Long Parameter List,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The method has 5 parameters. Parameters: ellipsoid' start' startBearing' distance' endBearing
Long Parameter List,MapAround.Rendering,HatchFill,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Fills.cs,HatchFill,The method has 5 parameters. Parameters: pattern' color1' color2' originX' originY
Long Parameter List,MapAround.Rendering,StrokeGenerator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\LineTransformations.cs,getStrokePoints,The method has 5 parameters. Parameters: points' startLength' strokeLength' segmentIndex' traversedLength
Long Parameter List,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getCirclePoints,The method has 5 parameters. Parameters: point' startAngle' endAngle' distance' pointsPerCircle
Long Parameter List,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The method has 7 parameters. Parameters: cap' vertexList' capLocation' x1' y1' x2' y2
Long Parameter List,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addInteriorJoin,The method has 7 parameters. Parameters: vertexList' x1' y1' x2' y2' x3' y3
Long Parameter List,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addJoin,The method has 8 parameters. Parameters: join' vertexList' x1' y1' x2' y2' x3' y3
Long Parameter List,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,SetPixel,The method has 6 parameters. Parameters: x' y' r' g' b' a
Long Parameter List,MapAround.Rendering,PixelSpan,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,GetSolid,The method has 5 parameters. Parameters: orientation' x' y' pixelData' length
Long Parameter List,MapAround.Rendering,IScannable,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,InitScaning,The method has 5 parameters. Parameters: minX' maxX' minY' maxY' orientation
Long Parameter List,MapAround.Rendering,SpanGenerator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,GetHorizontalSpans,The method has 6 parameters. Parameters: sourceGeometry' minX' minY' maxX' maxY' fill
Long Parameter List,MapAround.Rendering,SpanGenerator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,GetVerticalSpans,The method has 6 parameters. Parameters: sourceGeometry' minX' minY' maxX' maxY' fill
Long Parameter List,MapAround.Rendering,SpanGenerator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,addSpans,The method has 5 parameters. Parameters: orientation' spans' pixelScanIntersections' scanPosition' fill
Long Parameter List,MapAround.Rendering,SimpleCircle,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,InitScaning,The method has 5 parameters. Parameters: minX' maxX' minY' maxY' orientation
Long Parameter List,MapAround.Rendering,Region,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,InitScaning,The method has 5 parameters. Parameters: minX' maxX' minY' maxY' orientation
Long Parameter List,MapAround.Web,MapServerBase,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,GetImage,The method has 5 parameters. Parameters: width' height' backColor' useLayers' bboxWithGutters
Long Parameter List,MapAround.Web,MapServerBase,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,WriteLayer,The method has 6 parameters. Parameters: json' layer' bboxWithGutters' mapViewBox' scaleFactor' requestParams
Long Parameter List,MapAround.Web,MapServerBase,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,GetVector,The method has 6 parameters. Parameters: layerNumber' width' height' useLayers' bboxWithGutters' requestParams
Long Parameter List,MapAround.Web,MapServerBase,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,CheckRequestParams,The method has 6 parameters. Parameters: requestParams' responseOutputStream' responseContentType' originalBbox' width' height
Long Parameter List,MapAround.Web.Wms,WmsCapabilities,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsCapabilities.cs,createElement,The method has 5 parameters. Parameters: name' value' doc' IsXml' namespaceURI
Long Parameter List,MapAround.Web.Wms,WMSServer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsServer.cs,CheckRequestParams,The method has 6 parameters. Parameters: requestParams' responseOutputStream' responseContentType' originalBbox' width' height
Long Parameter List,MapAround.Web.Wmts,WmtsCapabilities,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,createElement,The method has 5 parameters. Parameters: name' value' doc' IsXml' namespaceURI
Long Parameter List,MapAround.Web.Wmts,WMTSServer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WMTSServer.cs,CheckRequestParams,The method has 6 parameters. Parameters: requestParams' responseOutputStream' responseContentType' originalBbox' width' height
Long Identifier,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,,The length of the parameter _affineTransformPointsIndicies is 30.
Long Identifier,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,,The length of the parameter _defaultPolylinesIndexSettings is 30.
Long Identifier,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,,The length of the parameter _invalidFeatureAdditionErrorMessage is 35.
Long Identifier,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,,The length of the parameter _invalidFeatureDeletionErrorMessage is 35.
Long Identifier,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,,The length of the parameter _invalidFeaturesDeletionErrorMessage is 36.
Long Statement,MapAround.CoordinateSystems,HorizontalDatum,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,EqualParams,The length of the statement  "                datum.Ellipsoid.EqualParams(this.Ellipsoid) || datum == null && this.Ellipsoid == null) && this.DatumType == datum.DatumType; " is 125.
Long Statement,MapAround.CoordinateSystems,CoordinateSystem,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,GetAxis,The length of the statement  "				throw new ArgumentException("AxisInfo not available for dimension " + dimension.ToString(CultureInfo.InvariantCulture)); " is 120.
Long Statement,MapAround.CoordinateSystems,CoordinateSystemFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateEllipsoid,The length of the statement  "            return new Ellipsoid(semiMajorAxis' semiMinorAxis' 1.0' false' linearUnit' name' String.Empty' -1' String.Empty' string.Empty' string.Empty); " is 141.
Long Statement,MapAround.CoordinateSystems,CoordinateSystemFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateFlattenedSphere,The length of the statement  "            return new Ellipsoid(semiMajorAxis' -1' inverseFlattening' true' linearUnit' name' String.Empty' -1' String.Empty' String.Empty' String.Empty); " is 143.
Long Statement,MapAround.CoordinateSystems,CoordinateSystemFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateProjectedCoordinateSystem,The length of the statement  "            return new ProjectedCoordinateSystem(null' gcs' linearUnit' projection' info' name' String.Empty' -1' String.Empty' String.Empty' String.Empty); " is 144.
Long Statement,MapAround.CoordinateSystems,CoordinateSystemFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateProjection,The length of the statement  "            return new Projection(wktProjectionClass' parameters' name' String.Empty' -1' String.Empty' String.Empty' String.Empty); " is 120.
Long Statement,MapAround.CoordinateSystems,CoordinateSystemFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateHorizontalDatum,The length of the statement  "            return new HorizontalDatum(ellipsoid' toWgs84' datumType' name' String.Empty' -1' String.Empty' String.Empty' String.Empty); " is 124.
Long Statement,MapAround.CoordinateSystems,CoordinateSystemFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateGeographicCoordinateSystem,The length of the statement  "            return new GeographicCoordinateSystem(angularUnit' datum' primeMeridian' info' name' String.Empty' -1' String.Empty' String.Empty' String.Empty); " is 145.
Long Statement,MapAround.CoordinateSystems,CoordinateSystemFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateGeocentricCoordinateSystem,The length of the statement  "            return new GeocentricCoordinateSystem(datum' linearUnit' primeMeridian' info' name' String.Empty' -1' String.Empty' String.Empty' String.Empty); " is 144.
Long Statement,MapAround.CoordinateSystems.Projections,Projection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,EqualParams,The length of the statement  "                ProjectionParameter param = _parameters.Find(delegate(ProjectionParameter par) { return par.Name.Equals(proj.GetParameter(i).Name' StringComparison.OrdinalIgnoreCase); }); " is 171.
Long Statement,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The length of the statement  "            double ro = Math.Sqrt(Math.Pow(p[0] * _metersPerUnit - _falseEasting' 2) + Math.Pow(ro0 - (p[1] * _metersPerUnit - _falseNorthing)' 2)); " is 136.
Long Statement,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The length of the statement  "                lat += (Math.Pow(1 - e2sin2' 2) / (2 * Math.Cos(lat))) * ((q / (1 - e_sq)) - sin / (1 - e2sin2) + 1 / (2 * e) * Math.Log((1 - e * sin) / (1 + e * sin))); " is 153.
Long Statement,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The length of the statement  "                double y = _falseNorthing + this._semiMajor * k0 * Math.Log(Math.Tan(PI * 0.25 + dLatitude * 0.5) * Math.Pow((1 - esinphi) / (1 + esinphi)' e * 0.5)); " is 150.
Long Statement,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,EqualParams,The length of the statement  "                ProjectionParameter param = _parameters.Find(delegate(ProjectionParameter par) { return par.Name.Equals(proj.GetParameter(i).Name' StringComparison.OrdinalIgnoreCase); }); " is 171.
Long Statement,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LongitudeToRadians,The length of the statement  "            throw new ArgumentOutOfRangeException("x"' x.ToString(CultureInfo.InvariantCulture) + " not a valid longitude in degrees."); " is 124.
Long Statement,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LatitudeToRadians,The length of the statement  "            throw new ArgumentOutOfRangeException("y"' y.ToString(CultureInfo.InvariantCulture) + " not a valid latitude in degrees."); " is 123.
Long Statement,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,calculateOptimalAffineTransformPoints,The length of the statement  "                                currentNorm += PlanimetryAlgorithms.Distance(_destinationControlPoints[i]' PlanimetryEnvironment.NewCoordinate(tempPoints[i].X' tempPoints[i].Y)); " is 146.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,Geog2Geoc,The length of the statement  "            return new CoordinateTransformation(source' target' TransformType.Conversion' geocMathTransform' String.Empty' String.Empty' -1' String.Empty' String.Empty); " is 157.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,Geoc2Geog,The length of the statement  "            return new CoordinateTransformation(source' target' TransformType.Conversion' geocMathTransform' String.Empty' String.Empty' -1' String.Empty' String.Empty); " is 157.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,Proj2Proj,The length of the statement  "            ct.CoordinateTransformationList.Add(ctFac.CreateFromCoordinateSystems(source.GeographicCoordinateSystem' target.GeographicCoordinateSystem)); " is 141.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,Geog2Proj,The length of the statement  "                IMathTransform mathTransform = CreateCoordinateOperation(target.Projection' target.GeographicCoordinateSystem.HorizontalDatum.Ellipsoid' target.LinearUnit); " is 156.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,Proj2Geog,The length of the statement  "                IMathTransform mathTransform = CreateCoordinateOperation(source.Projection' source.GeographicCoordinateSystem.HorizontalDatum.Ellipsoid' source.LinearUnit).Inverse(); " is 166.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,CreateGeog2Geog,The length of the statement  "                IGeocentricCoordinateSystem sourceCentric = cFac.CreateGeocentricCoordinateSystem(source.HorizontalDatum.Name + " Geocentric"' " is 126.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,CreateGeog2Geog,The length of the statement  "                IGeocentricCoordinateSystem targetCentric = cFac.CreateGeocentricCoordinateSystem(target.HorizontalDatum.Name + " Geocentric"' " is 126.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,CreateGeoc2Geoc,The length of the statement  "                    ((target.HorizontalDatum.Wgs84Parameters == null || target.HorizontalDatum.Wgs84Parameters.HasZeroValuesOnly) ? target : GeocentricCoordinateSystem.WGS84)' " is 155.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,CreateGeoc2Geoc,The length of the statement  "                    ((source.HorizontalDatum.Wgs84Parameters == null || source.HorizontalDatum.Wgs84Parameters.HasZeroValuesOnly) ? source : GeocentricCoordinateSystem.WGS84)' " is 155.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,CreateGeoc2Geoc,The length of the statement  "            if (ct.CoordinateTransformationList.Count == 1) //Since we only have one shift' lets just return the datumshift from/to wgs84 " is 125.
Long Statement,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,CreateGeoc2Geoc,The length of the statement  "                return new CoordinateTransformation(source' target' TransformType.ConversionAndTransformation' ct.CoordinateTransformationList[0].MathTransform' ""' ""' -1' ""' ""); " is 165.
Long Statement,MapAround.CoordinateSystems.Transformations,GeometryTransformer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformers.cs,TransformBoundingRectangle,The length of the statement  "            corners[2] = PlanimetryEnvironment.NewCoordinate(transform.Transform(PlanimetryEnvironment.NewCoordinate(box.MinX' box.MaxY).Values())); " is 136.
Long Statement,MapAround.CoordinateSystems.Transformations,GeometryTransformer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformers.cs,TransformBoundingRectangle,The length of the statement  "            corners[3] = PlanimetryEnvironment.NewCoordinate(transform.Transform(PlanimetryEnvironment.NewCoordinate(box.MaxX' box.MinY).Values()));  " is 136.
Long Statement,MapAround.Extensions.Surfaces,ShadedReliefBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\ShadedReliefBuilder.cs,GetLuminosity,The length of the statement  "            double D = -(p1.X * (p2.Y * p3.Z - p3.Y * p2.Z) + p2.X * (p3.Y * p1.Z - p1.Y * p3.Z) + p3.X * (p1.Y * p2.Z - p2.Y * p1.Z)); " is 123.
Long Statement,MapAround.Extensions.Surfaces,IsolineBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,BuildPolygonsForLevelRanges,The length of the statement  "                assignLevelsToPolygons(surfacePoints' polygons' triangles' zLevels' PlanimetryAlgorithms.GetPointsBoundingRectangle(coonvexHull)); " is 130.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addTitleStyleElement,The length of the statement  "            addAttribute( titleStyleElement' "render_priority"' ((int)TitleStyle.RenderPriority).ToString(CultureInfo.InvariantCulture)); " is 125.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addPolygonStyleElement,The length of the statement  "            addAttribute( polygonStyleElement' "border_dash_style"' ((int)PolygonStyle.BorderDashStyle).ToString(CultureInfo.InvariantCulture)); " is 132.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addPolygonStyleElement,The length of the statement  "            addAttribute( polygonStyleElement' "border_dash_cap"' ((int)PolygonStyle.BorderDashCap).ToString(CultureInfo.InvariantCulture)); " is 128.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addPolygonStyleElement,The length of the statement  "            addAttribute( polygonStyleElement' "hatch_style"' ((int)PolygonStyle.HatchStyle).ToString(CultureInfo.InvariantCulture)); " is 121.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addPolygonStyleElement,The length of the statement  "            addAttribute( polygonStyleElement' "fill_pattern"' ((int)PolygonStyle.FillPattern).ToString(CultureInfo.InvariantCulture)); " is 123.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addPolygonStyleElement,The length of the statement  "            addAttribute( polygonStyleElement' "fill_transparent"' PolygonStyle.FillBackColor.A.ToString(CultureInfo.InvariantCulture)); " is 124.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addPolylineStyleElement,The length of the statement  "            addAttribute( polylineStyleElement' "dash_style"' ((int)PolylineStyle.DashStyle).ToString(CultureInfo.InvariantCulture)); " is 121.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addPolylineStyleElement,The length of the statement  "            addAttribute( polylineStyleElement' "annex_dash_style"' ((int)PolylineStyle.AnnexDashStyle).ToString(CultureInfo.InvariantCulture)); " is 132.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addPolylineStyleElement,The length of the statement  "            addAttribute( polylineStyleElement' "annex_dash_cap"' ((int)PolylineStyle.AnnexDashCap).ToString(CultureInfo.InvariantCulture)); " is 128.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addPolylineStyleElement,The length of the statement  "            addAttribute( polylineStyleElement' "outline_width"' PolylineStyle.OutlineWidth.ToString(CultureInfo.InvariantCulture)); " is 120.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,addPolylineStyleElement,The length of the statement  "            addAttribute( polylineStyleElement' "outline_transparent"' PolylineStyle.OutlineColor.A.ToString(CultureInfo.InvariantCulture)); " is 128.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPolygonStyle,The length of the statement  "                PolygonStyle.BorderDashStyle = (DashStyle)int.Parse(polygonStyle.Attributes["border_dash_style"].Value' CultureInfo.InvariantCulture); " is 134.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPolygonStyle,The length of the statement  "                PolygonStyle.HatchStyle = (HatchStyle)int.Parse(polygonStyle.Attributes["hatch_style"].Value' CultureInfo.InvariantCulture); " is 124.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPolygonStyle,The length of the statement  "                    PolygonStyle.BorderDashCap = (DashCap)int.Parse(polygonStyle.Attributes["border_dash_cap"].Value' CultureInfo.InvariantCulture); " is 128.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPolygonStyle,The length of the statement  "                    PolygonStyle.FillBackColor = Color.FromArgb(int.Parse(polygonStyle.Attributes["fill_transparent"].Value' CultureInfo.InvariantCulture)' PolygonStyle.FillBackColor); " is 164.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPolygonStyle,The length of the statement  "                    PolygonStyle.FillPattern = (BuiltInFillPatterns)int.Parse(polygonStyle.Attributes["fill_pattern"].Value' CultureInfo.InvariantCulture); " is 135.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPolylineStyle,The length of the statement  "                PolylineStyle.DashStyle = (DashStyle)int.Parse(polylineStyle.Attributes["dash_style"].Value' CultureInfo.InvariantCulture); " is 123.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPolylineStyle,The length of the statement  "                    PolylineStyle.AnnexDashStyle = (DashStyle)int.Parse(polylineStyle.Attributes["annex_dash_style"].Value' CultureInfo.InvariantCulture); " is 134.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPolylineStyle,The length of the statement  "                        PolylineStyle.AnnexDashCap = (DashCap)int.Parse(polylineStyle.Attributes["annex_dash_cap"].Value' CultureInfo.InvariantCulture); " is 128.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPolylineStyle,The length of the statement  "                    PolylineStyle.OutlineColor = Color.FromArgb(int.Parse(polylineStyle.Attributes["outline_transparent"].Value' CultureInfo.InvariantCulture)' PolylineStyle.OutlineColor); " is 168.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPointStyle,The length of the statement  "                    PointStyle.DisplayKind = (PointDisplayKind)(int.Parse(pointStyle.Attributes["display_kind"].Value' CultureInfo.InvariantCulture)); " is 130.
Long Statement,MapAround.ThematicLayer,FeatureLayerExtension,C:\repos\gkrsu_maparound.core\src\MapAround.Core\FeatureLayerExtension\FeatureLayerExtension.cs,processPointStyle,The length of the statement  "                if ( (pointStyle.Attributes["contentAlignment"]!=null) && (Enum.TryParse(pointStyle.Attributes["contentAlignment"].Value'true'out contentAlignment))) " is 149.
Long Statement,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getArcPoints,The length of the statement  "                result[i] = PlanimetryEnvironment.NewCoordinate(point.X + distance * Math.Cos(angle)' point.Y + distance * Math.Sin(angle)); " is 124.
Long Statement,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getArcPoints,The length of the statement  "            result[n] = PlanimetryEnvironment.NewCoordinate(point.X + distance * Math.Cos(endAngle)' point.Y + distance * Math.Sin(endAngle)); " is 130.
Long Statement,MapAround.Geometry,MonotoneChain,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\DataStructures.cs,ReplaceLabel,The length of the statement  "                throw new ArgumentOutOfRangeException("The index should not be negative and smaller than the size of the collection"' "index"); " is 127.
Long Statement,MapAround.Geometry,PointD,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,GetBoundingRectangle,The length of the statement  "            return new BoundingRectangle(PlanimetryEnvironment.NewCoordinate(_coordinate.X' _coordinate.Y)' PlanimetryEnvironment.NewCoordinate(_coordinate.X' _coordinate.Y)); " is 163.
Long Statement,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,calcContourNestingList,The length of the statement  "                            testPoint = (new Segment(singleContourPolygons[i].Contours[0].Vertices[0]' singleContourPolygons[i].Contours[0].Vertices[1])).Center(); " is 135.
Long Statement,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,hasNonSinglePointTouch,The length of the statement  "            Segment segmentStub = new Segment(PlanimetryEnvironment.NewCoordinate(0' 0)' PlanimetryEnvironment.NewCoordinate(0' 0)); " is 120.
Long Statement,MapAround.Geometry,Polyline,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,getWrongSelfIntersectionError,The length of the statement  "                        if (PlanimetryAlgorithms.SegmentsIntersection(s1' s2' out pointStub' out segmentStub) == MapAround.Geometry.Dimension.One) " is 122.
Long Statement,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,CalculateOverlay,The length of the statement  "                            throw new NotSupportedException(string.Format("Overlay calculation for \"{0}\" is not supported"' geometry1.GetType().FullName)); " is 129.
Long Statement,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,CalculateOverlay,The length of the statement  "                            throw new NotSupportedException(string.Format("Overlay calculation for \"{0}\" is not supported"' geometry2.GetType().FullName)); " is 129.
Long Statement,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolygonPolygonOverlay,The length of the statement  "                        throw new InvalidOperationException("Unable to complete operation correctly with this value of tolerance (PlanimertyAlgorithms.Tolerance)"); " is 140.
Long Statement,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolylinePolylineOverlay,The length of the statement  "                        throw new InvalidOperationException("Unable to complete operation correctly with this value of tolerance (PlanimertyAlgorithms.Tolerance)"); " is 140.
Long Statement,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolylineOverlay,The length of the statement  "                        throw new InvalidOperationException("Unable to complete operation correctly with this value of tolerance (PlanimertyAlgorithms.Tolerance)"); " is 140.
Long Statement,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolygonOverlay,The length of the statement  "                        throw new InvalidOperationException("Unable to complete operation correctly with this value of tolerance (PlanimertyAlgorithms.Tolerance)"); " is 140.
Long Statement,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolylinePolygonOverlay,The length of the statement  "                        throw new InvalidOperationException("Unable to complete operation correctly with this value of tolerance (PlanimertyAlgorithms.Tolerance)"); " is 140.
Long Statement,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,simplifyLinePaths,The length of the statement  "                        throw new InvalidOperationException("Unable to complete operation correctly with this value of tolerance (PlanimertyAlgorithms.Tolerance)"); " is 140.
Long Statement,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,simplifyContours,The length of the statement  "                        throw new InvalidOperationException("Unable to complete operation correctly with this value of tolerance (PlanimertyAlgorithms.Tolerance)"); " is 140.
Long Statement,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The length of the statement  "                        if ((!inverseArgs && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2 && !polygon2.ContainsPoint(edge.CenterPoint())) || " is 125.
Long Statement,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,addVerticesAsNodes,The length of the statement  "            throw new NotSupportedException(string.Format("Planar graph building for \"{0}\" is not supported."' g.GetType().FullName)); " is 124.
Long Statement,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,addSourceSegments,The length of the statement  "            throw new NotSupportedException(string.Format("Planar graph building for \"{0}\" is not supported."' g.GetType().FullName)); " is 124.
Long Statement,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitContour,The length of the statement  "                segments.Add(new Segment(contour.Vertices[i]' i == contour.Vertices.Count - 1 ? contour.Vertices[0] : contour.Vertices[i + 1])); " is 128.
Long Statement,MapAround.IO,StreamTokenizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\CommonWktClasses.cs,GetNumericValue,The length of the statement  "            throw new InvalidDataException(String.Format(CultureInfo.InvariantCulture.NumberFormat' "Lexem '{0}' is not a number. Line {1} position {2}."' " is 142.
Long Statement,MapAround.IO,WktStreamTokenizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\CommonWktClasses.cs,ReadToken,The length of the statement  "                throw new ArgumentException(String.Format(CultureInfo.InvariantCulture.NumberFormat' "Expected ('{3}')' but goes '{0}'. Line {1}' position {2}."' this.GetStringValue()' this.LineNumber' this.Column' expectedToken)); " is 215.
Long Statement,MapAround.IO,DbaseReader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseReader.cs,readDbfValue,The length of the statement  "                    throw (new NotSupportedException("Unable to process field '" + dbf.Name + "' (data type '" + dbf.DataType.ToString() + "')")); " is 126.
Long Statement,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadHeader,The length of the statement  "                string msg = String.Format(System.Globalization.CultureInfo.InvariantCulture' "Invalid FileCode encountered. Expecting {0}."' ShapeFile._expectedFileCode); " is 155.
Long Statement,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadRecord,The length of the statement  "                //            string msg = String.Format(System.Globalization.CultureInfo.InvariantCulture' "ShapeType {0} is not supported."' (int)record.ShapeType); " is 150.
Long Statement,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteShapes,The length of the statement  "                throw new ArgumentException("Geometries in the shape file should be the instances of the same type."' "geometryCollection"); " is 124.
Long Statement,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteShapes,The length of the statement  "                    Handlers.ShapeHandler handler = ShapeFile.GetShapeHandler(ShapeFile.GetShapeType(geometryCollection[0]));//.Geometries[0])); " is 124.
Long Statement,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,GetShapeHandler,The length of the statement  "                    string msg = String.Format(System.Globalization.CultureInfo.InvariantCulture' "ShapeType {0} is not supported."' (int)type); " is 124.
Long Statement,MapAround.IO.Handlers,MultiLineHandler,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiLineHandler.cs,GetLength,The length of the statement  "            return (22 + (2 * numParts) + geometry.CoordinateCount/*.NumPoints*/ * 8); // 22 => shapetype(2) + bbox(4*4) + numparts(2) + numpoints(2) " is 137.
Long Statement,MapAround.IO.Handlers,MultiPointHandler,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiPointHandler.cs,Write,The length of the statement  "                throw new ArgumentException("Geometry Type error: MultiPoint expected' but the type retrieved is " + geometry.GetType().Name); " is 126.
Long Statement,MapAround.IO.Handlers,MultiPointHandler,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiPointHandler.cs,Write,The length of the statement  "            BoundingRectangle bounds = geometry.GetBoundingRectangle();//GetEnvelopeExternal(/*geometryFactory.PrecisionModel'*/ box); " is 122.
Long Statement,MapAround.IO.Handlers,PolygonHandler,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\PolygonHandler.cs,Write,The length of the statement  "            BoundingRectangle bounds = geometry.GetBoundingRectangle(); // GetEnvelopeExternal(/*geometryFactory.PrecisionModel'*/  box); " is 125.
Long Statement,MapAround.IO.Handlers,PolygonHandler,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\PolygonHandler.cs,GetLength,The length of the statement  "            return (22 + (2 * numParts) + (geometry.CoordinateCount + numParts) * 8); // 22 => shapetype(2) + bbox(4*4) + numparts(2) + numpoints(2) " is 136.
Long Statement,MapAround.Mapping,PolygonStyle,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,brushPatternParamsChanged,The length of the statement  "            _brushPattern = new Bitmap(_originalBrushPattern.Width' _originalBrushPattern.Height' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 138.
Long Statement,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderPolylineSampleInternal,The length of the statement  "            feature.Polyline = new Polyline(new ICoordinate[] { PlanimetryEnvironment.NewCoordinate(viewBox.MinX + margin' viewBox.MinY + margin)'  " is 134.
Long Statement,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderPolygonSampleInternal,The length of the statement  "            feature.Polygon = new Polygon(new ICoordinate[] { PlanimetryEnvironment.NewCoordinate(viewBox.MinX + margin' viewBox.MinY + margin)'  " is 132.
Long Statement,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderFeaturesSample,The length of the statement  "                    Map.RenderPolygonSampleInternal(g' new BoundingRectangle((sampleCount - 1) * image.Width / sampleCount' 0' image.Width' image.Height)' PolygonStyle' margin); " is 157.
Long Statement,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The length of the statement  "                BoundingRectangle box = new BoundingRectangle(coordinate.X - Map.SelectionPointRadius' coordinate.Y - Map.SelectionPointRadius' " is 127.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addTitleStyleElement,The length of the statement  "            addAttribute(doc' titleStyleElement' "render_priority"' ((int)TitleStyle.RenderPriority).ToString(CultureInfo.InvariantCulture)); " is 129.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolygonStyleElement,The length of the statement  "            addAttribute(doc' polygonStyleElement' "border_width"' PolygonStyle.BorderWidth.ToString(CultureInfo.InvariantCulture)); " is 120.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolygonStyleElement,The length of the statement  "            addAttribute(doc' polygonStyleElement' "border_dash_style"' ((int)PolygonStyle.BorderDashStyle).ToString(CultureInfo.InvariantCulture)); " is 136.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolygonStyleElement,The length of the statement  "            addAttribute(doc' polygonStyleElement' "border_dash_cap"' ((int)PolygonStyle.BorderDashCap).ToString(CultureInfo.InvariantCulture)); " is 132.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolygonStyleElement,The length of the statement  "            addAttribute(doc' polygonStyleElement' "hatch_style"' ((int)PolygonStyle.HatchStyle).ToString(CultureInfo.InvariantCulture)); " is 125.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolygonStyleElement,The length of the statement  "            addAttribute(doc' polygonStyleElement' "fill_pattern"' ((int)PolygonStyle.FillPattern).ToString(CultureInfo.InvariantCulture)); " is 127.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolygonStyleElement,The length of the statement  "            addAttribute(doc' polygonStyleElement' "fill_transparent"' PolygonStyle.FillBackColor.A.ToString(CultureInfo.InvariantCulture)); " is 128.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolylineStyleElement,The length of the statement  "            addAttribute(doc' polylineStyleElement' "dash_style"' ((int)PolylineStyle.DashStyle).ToString(CultureInfo.InvariantCulture)); " is 125.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolylineStyleElement,The length of the statement  "            addAttribute(doc' polylineStyleElement' "dash_cap"' ((int)PolylineStyle.DashCap).ToString(CultureInfo.InvariantCulture)); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolylineStyleElement,The length of the statement  "            addAttribute(doc' polylineStyleElement' "annex_dash_style"' ((int)PolylineStyle.AnnexDashStyle).ToString(CultureInfo.InvariantCulture)); " is 136.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolylineStyleElement,The length of the statement  "            addAttribute(doc' polylineStyleElement' "annex_dash_cap"' ((int)PolylineStyle.AnnexDashCap).ToString(CultureInfo.InvariantCulture)); " is 132.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolylineStyleElement,The length of the statement  "            addAttribute(doc' polylineStyleElement' "outline_width"' PolylineStyle.OutlineWidth.ToString(CultureInfo.InvariantCulture)); " is 124.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPolylineStyleElement,The length of the statement  "            addAttribute(doc' polylineStyleElement' "outline_transparent"' PolylineStyle.OutlineColor.A.ToString(CultureInfo.InvariantCulture)); " is 132.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addPointStyleElement,The length of the statement  "            addAttribute(doc' pointStyleElement' "display_kind"' ((int)PointStyle.DisplayKind).ToString(CultureInfo.InvariantCulture)); " is 123.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterbindingElement,The length of the statement  "            addAttribute(doc' bindingElement' "pixel_width"' ((double)layer.Binding.PixelWidth).ToString(CultureInfo.InvariantCulture)); " is 124.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterbindingElement,The length of the statement  "            addAttribute(doc' bindingElement' "pixel_height"' ((double)layer.Binding.PixelHeight).ToString(CultureInfo.InvariantCulture)); " is 126.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "interpolation_mode"' ((int)layer.Style.InterpolationMode).ToString(CultureInfo.InvariantCulture)); " is 137.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm00"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix00).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm01"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix01).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm02"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix02).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm03"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix03).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm04"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix04).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm10"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix10).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm11"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix11).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm12"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix12).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm13"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix13).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm14"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix14).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm20"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix20).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm21"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix21).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm22"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix22).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm23"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix23).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm24"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix24).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm30"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix30).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm31"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix31).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm32"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix32).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm33"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix33).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm34"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix34).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm40"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix40).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm41"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix41).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm42"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix42).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm43"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix43).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addRasterStyleElement,The length of the statement  "            addAttribute(doc' rasterStyleElement' "cm44"' ((double)layer.Style.ColorAdjustmentMatrix.Matrix44).ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addIndiciesElements,The length of the statement  "            addAttribute(doc' pointsIndexElement' "box_square_threshold"' layer.DefaultPointsIndexSettings.BoxSquareThreshold.ToString(CultureInfo.InvariantCulture)); " is 154.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addIndiciesElements,The length of the statement  "            addAttribute(doc' pointsIndexElement' "max_depth"' layer.DefaultPointsIndexSettings.MaxDepth.ToString(CultureInfo.InvariantCulture)); " is 133.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addIndiciesElements,The length of the statement  "            addAttribute(doc' pointsIndexElement' "min_shape_count"' layer.DefaultPointsIndexSettings.MinFeatureCount.ToString(CultureInfo.InvariantCulture)); " is 146.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addIndiciesElements,The length of the statement  "            addAttribute(doc' polylinesIndexElement' "box_square_threshold"' layer.DefaultPolylinesIndexSettings.BoxSquareThreshold.ToString(CultureInfo.InvariantCulture)); " is 160.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addIndiciesElements,The length of the statement  "            addAttribute(doc' polylinesIndexElement' "max_depth"' layer.DefaultPolylinesIndexSettings.MaxDepth.ToString(CultureInfo.InvariantCulture)); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addIndiciesElements,The length of the statement  "            addAttribute(doc' polylinesIndexElement' "min_shape_count"' layer.DefaultPolylinesIndexSettings.MinFeatureCount.ToString(CultureInfo.InvariantCulture)); " is 152.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addIndiciesElements,The length of the statement  "            addAttribute(doc' polygonsIndexElement' "box_square_threshold"' layer.DefaultPolygonsIndexSettings.BoxSquareThreshold.ToString(CultureInfo.InvariantCulture)); " is 158.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addIndiciesElements,The length of the statement  "            addAttribute(doc' polygonsIndexElement' "max_depth"' layer.DefaultPolygonsIndexSettings.MaxDepth.ToString(CultureInfo.InvariantCulture)); " is 137.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addIndiciesElements,The length of the statement  "            addAttribute(doc' polygonsIndexElement' "min_shape_count"' layer.DefaultPolygonsIndexSettings.MinFeatureCount.ToString(CultureInfo.InvariantCulture)); " is 150.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,addAutoTitleSettingsElement,The length of the statement  "                addAttribute(doc' autoTitlesSettings' "attribute_index"' layer.AutoTitleSettings.AttributeIndex.ToString(CultureInfo.InvariantCulture)); " is 136.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPolygonStyle,The length of the statement  "                PolygonStyle.BorderDashStyle = (DashStyle)int.Parse(polygonStyle.Attributes["border_dash_style"].Value' CultureInfo.InvariantCulture); " is 134.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPolygonStyle,The length of the statement  "                PolygonStyle.HatchStyle = (HatchStyle)int.Parse(polygonStyle.Attributes["hatch_style"].Value' CultureInfo.InvariantCulture); " is 124.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPolygonStyle,The length of the statement  "                    PolygonStyle.BorderDashCap = (DashCap)int.Parse(polygonStyle.Attributes["border_dash_cap"].Value' CultureInfo.InvariantCulture); " is 128.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPolygonStyle,The length of the statement  "                    PolygonStyle.FillBackColor = Color.FromArgb(int.Parse(polygonStyle.Attributes["fill_transparent"].Value' CultureInfo.InvariantCulture)' PolygonStyle.FillBackColor); " is 164.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPolygonStyle,The length of the statement  "                    PolygonStyle.FillPattern = (BuiltInFillPatterns)int.Parse(polygonStyle.Attributes["fill_pattern"].Value' CultureInfo.InvariantCulture); " is 135.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPolylineStyle,The length of the statement  "                PolylineStyle.DashStyle = (DashStyle)int.Parse(polylineStyle.Attributes["dash_style"].Value' CultureInfo.InvariantCulture); " is 123.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPolylineStyle,The length of the statement  "                    PolylineStyle.AnnexDashStyle = (DashStyle)int.Parse(polylineStyle.Attributes["annex_dash_style"].Value' CultureInfo.InvariantCulture); " is 134.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPolylineStyle,The length of the statement  "                        PolylineStyle.AnnexDashCap = (DashCap)int.Parse(polylineStyle.Attributes["annex_dash_cap"].Value' CultureInfo.InvariantCulture); " is 128.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPolylineStyle,The length of the statement  "                    PolylineStyle.OutlineColor = Color.FromArgb(int.Parse(polylineStyle.Attributes["outline_transparent"].Value' CultureInfo.InvariantCulture)' PolylineStyle.OutlineColor); " is 168.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.InterpolationMode = (InterpolationMode)int.Parse(rasterStyle.Attributes["interpolation_mode"].Value' CultureInfo.InvariantCulture); " is 139.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix00 = float.Parse(rasterStyle.Attributes["cm00"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix01 = float.Parse(rasterStyle.Attributes["cm01"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix02 = float.Parse(rasterStyle.Attributes["cm02"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix03 = float.Parse(rasterStyle.Attributes["cm03"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix04 = float.Parse(rasterStyle.Attributes["cm04"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix10 = float.Parse(rasterStyle.Attributes["cm10"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix11 = float.Parse(rasterStyle.Attributes["cm11"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix12 = float.Parse(rasterStyle.Attributes["cm12"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix13 = float.Parse(rasterStyle.Attributes["cm13"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix14 = float.Parse(rasterStyle.Attributes["cm14"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix20 = float.Parse(rasterStyle.Attributes["cm20"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix21 = float.Parse(rasterStyle.Attributes["cm21"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix22 = float.Parse(rasterStyle.Attributes["cm22"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix23 = float.Parse(rasterStyle.Attributes["cm23"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix24 = float.Parse(rasterStyle.Attributes["cm24"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix30 = float.Parse(rasterStyle.Attributes["cm30"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix31 = float.Parse(rasterStyle.Attributes["cm31"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix32 = float.Parse(rasterStyle.Attributes["cm32"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix33 = float.Parse(rasterStyle.Attributes["cm33"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix34 = float.Parse(rasterStyle.Attributes["cm34"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix40 = float.Parse(rasterStyle.Attributes["cm40"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix41 = float.Parse(rasterStyle.Attributes["cm41"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix42 = float.Parse(rasterStyle.Attributes["cm42"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix43 = float.Parse(rasterStyle.Attributes["cm43"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processRasterStyle,The length of the statement  "                l.Style.ColorAdjustmentMatrix.Matrix44 = float.Parse(rasterStyle.Attributes["cm44"].Value' CultureInfo.InvariantCulture); " is 121.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPointStyle,The length of the statement  "                    PointStyle.DisplayKind = (PointDisplayKind)(int.Parse(pointStyle.Attributes["display_kind"].Value' CultureInfo.InvariantCulture)); " is 130.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processPointStyle,The length of the statement  "                if ((pointStyle.Attributes["contentAlignment"] != null) && (Enum.TryParse(pointStyle.Attributes["contentAlignment"].Value' true' out contentAlignment))) " is 152.
Long Statement,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processLayer,The length of the statement  "                    fl.DataSourceType = (LayerDataSourceType)int.Parse(node.Attributes["datasource_type"].Value' CultureInfo.InvariantCulture); " is 123.
Long Statement,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateOptimalAffineTransformPoints,The length of the statement  "                                currentNorm += PlanimetryAlgorithms.Distance(destNodes[i]' PlanimetryEnvironment.NewCoordinate(tempPoints[i].X' tempPoints[i].Y)); " is 130.
Long Statement,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateRubberSheetTransform,The length of the statement  "                notifyProgessListenerIfNeeded(progress' startProgressPercent' endProgressPercent' ref completed' ref previousPercent' width); " is 125.
Long Statement,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,The length of the statement  "                notifyProgessListenerIfNeeded(progress' startProgressPercent' endProgressPercent' ref completed' ref previousPercent' source.Width); " is 132.
Long Statement,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,The length of the statement  "                notifyProgessListenerIfNeeded(progress' startProgressPercent' endProgressPercent' ref completed' ref previousPercent' source.Width); " is 132.
Long Statement,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,The length of the statement  "                notifyProgessListenerIfNeeded(progress' startProgressPercent' endProgressPercent' ref completed' ref previousPercent' source.Width); " is 132.
Long Statement,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,BindRaster,The length of the statement  "            calculateAffinneTransform(source.Width' source.Height' affinneTransformResult' sourceControlPoints' destinationControlPoints' progress); " is 136.
Long Statement,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,BindRaster,The length of the statement  "                shifts[i] = PlanimetryEnvironment.NewCoordinate(destinationControlPoints[i].X - p.X' destinationControlPoints[i].Y - p.Y); " is 122.
Long Statement,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,BindRaster,The length of the statement  "            calculateRubberSheetTransform(source.Width' source.Height' affinneTransformResult' warpTransformResult' destinationControlPoints' shifts' progress); " is 148.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,createSelectionTexture,The length of the statement  "                _selectionTexture = new Bitmap(originalPattern.Width' originalPattern.Height' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 130.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawTitle,The length of the statement  "                                        path.AddString(element.Substring' f.FontFamily' (int)f.Style' f.Size' element.TitleOrigin' StringFormat.GenericTypographic); " is 124.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawTitle,The length of the statement  "                                    path.AddString(element.Substring' f.FontFamily' (int)f.Style' f.Size' element.TitleOrigin' StringFormat.GenericTypographic); " is 124.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The length of the statement  "                            float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)' " is 123.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getLeftPoints,The length of the statement  "                        double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle < 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin); " is 122.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getLeftPoints,The length of the statement  "                    double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle < 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin); " is 122.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRightPoints,The length of the statement  "                        double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle > 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin); " is 122.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRightPoints,The length of the statement  "                    double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle > 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin); " is 122.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawVisiblePolylinePartWithStyleDetection,The length of the statement  "            // Necessary to calculate the displacement pattern of the pen before drawing a polyline' or generated images will not be used for cross-linking. " is 144.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawVisiblePolylinePartWithStyleDetection,The length of the statement  "            // Knowing the length of the zero-vertex to the portion of the polyline' you can calculate the shift pattern at the beginning of the portion. " is 141.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPolylineWithIntersectCalculation,The length of the statement  "                                drawVisiblePolylinePartWithStyleDetection(g' currentPath' style' pen' annexPen' feature.Selected' viewBox' scaleFactor' currentLength); " is 135.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPolylineWithIntersectCalculation,The length of the statement  "                                        drawVisiblePolylinePartWithStyleDetection(g' currentPath' style' pen' annexPen' feature.Selected' viewBox' scaleFactor' currentLength); " is 135.
Long Statement,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPolylineWithIntersectCalculation,The length of the statement  "                        drawVisiblePolylinePartWithStyleDetection(g' currentPath' style' pen' annexPen' feature.Selected' viewBox' scaleFactor' currentLength); " is 135.
Long Statement,MapAround.Mapping,TitleBufferElement,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,intersectsWithComplexTitle,The length of the statement  "                        if (PlanimetryAlgorithms.SegmentsIntersection(segment1' segments[i]' out pointStub' out segmentStub) != Dimension.None || " is 121.
Long Statement,MapAround.Geography,GeoPath,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,ReduceSegments,The length of the statement  "            v1 = UnitSphere.LatLonToGeocentric(path.Vertices[path.Vertices.Count - 1].Phi' path.Vertices[path.Vertices.Count - 1].L); " is 121.
Long Statement,MapAround.Geography,GeoPath,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,ReduceSegments,The length of the statement  "            v2 = UnitSphere.LatLonToGeocentric(this.Vertices[this.Vertices.Count - 1].Phi' this.Vertices[this.Vertices.Count - 1].L); " is 121.
Long Statement,MapAround.Geography,GeoContour,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,ReduceSegments,The length of the statement  "                    v2 = UnitSphere.LatLonToGeocentric(contour.Vertices[contour.Vertices.Count - 1].Phi' contour.Vertices[contour.Vertices.Count - 1].L); " is 133.
Long Statement,MapAround.Geography,EllipticOverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticOverlays.cs,CalculateOverlay,The length of the statement  "                            throw new NotSupportedException(string.Format("Overlay calculations for \"{0}\" is not supported."' geography1.GetType().FullName)); " is 132.
Long Statement,MapAround.Geography,EllipticOverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticOverlays.cs,CalculateOverlay,The length of the statement  "                            throw new NotSupportedException(string.Format("Overlay calculations for \"{0}\" is not supported."' geography2.GetType().FullName)); " is 132.
Long Statement,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The length of the statement  "            double L = lambda - (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cosSigmaM2 + C * cosSigma * (-1 + 2 * cos2SigmaM2))); " is 123.
Long Statement,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The length of the statement  "                deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2))); " is 156.
Long Statement,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The length of the statement  "                lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2))); " is 120.
Long Statement,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticMeasurement,The length of the statement  "            Ellipsoid ellipsoid = new Ellipsoid(a' f == 0 ? a : 0' f == 0 ? 0 : 1 / f' f != 0' LinearUnit.Metre' string.Empty' string.Empty' 0' string.Empty' string.Empty' string.Empty); " is 174.
Long Statement,MapAround.Indexing,KDTree,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\KDTree.cs,Insert,The length of the statement  "                throw new ArgumentException("Bounding rectangle of the object is outside of the indexed space. Need to rebuild index."' "obj"); " is 127.
Long Statement,MapAround.Indexing,QuadTree,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\QuadTree.cs,Insert,The length of the statement  "                throw new ArgumentException("Bounding rectangle of the object outside the indexed space. Need to rebuild index."' "obj"); " is 121.
Long Statement,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getCirclePoints,The length of the statement  "                result[i] = PlanimetryEnvironment.NewCoordinate(point.X + distance * Math.Cos(angle)' point.Y + distance * Math.Sin(angle)); " is 124.
Long Statement,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getCirclePoints,The length of the statement  "            result[n] = PlanimetryEnvironment.NewCoordinate(point.X + distance * Math.Cos(endAngle)' point.Y + distance * Math.Sin(endAngle)); " is 130.
Long Statement,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addJoin,The length of the statement  "            double angleBetweenSegments = getAngle(PlanimetryEnvironment.NewCoordinate(x1' y1)' PlanimetryEnvironment.NewCoordinate(x2' y2)' PlanimetryEnvironment.NewCoordinate(x3' y3)' true); " is 180.
Long Statement,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,GetBitmap,The length of the statement  "                    bmp.LockBits(new Rectangle(0' 0' _width' _height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 151.
Long Statement,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,FromBitmap,The length of the statement  "                    bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 166.
Long Statement,MapAround.Rendering,RenderingPipeline,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The length of the statement  "                    _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height }); " is 135.
Long Statement,MapAround.Rendering,RenderingPipeline,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The length of the statement  "                    _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 }); " is 122.
Long Statement,MapAround.Rendering,RenderingPipeline,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The length of the statement  "                    _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2}); " is 137.
Long Statement,MapAround.Rendering,RenderingPipeline,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The length of the statement  "                    _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height}); " is 138.
Long Statement,MapAround.Rendering,RenderingPipeline,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The length of the statement  "                    _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height }); " is 155.
Long Statement,MapAround.Serialization,WKBGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,readMultiPoint,The length of the statement  "                multiPoint.Points.Add(PlanimetryEnvironment.NewCoordinate(readDouble(stream' byteOrder)' readDouble(stream' byteOrder))); " is 121.
Long Statement,MapAround.Serialization,WKBGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,readMultiLineString,The length of the statement  "                    result.Paths[i].Vertices.Add(PlanimetryEnvironment.NewCoordinate(readDouble(stream' byteOrder)' readDouble(stream' byteOrder))); " is 128.
Long Statement,MapAround.Serialization,CoordinateSystemWktDeserializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\SpatialReferenceSerializers.cs,ReadAuthority,The length of the statement  "			try { authorityCode = long.Parse(tokenizer.ReadDoubleQuotedWord()' System.Globalization.NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture.NumberFormat); } " is 172.
Long Statement,MapAround.Serialization,CoordinateSystemWktDeserializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\SpatialReferenceSerializers.cs,ReadEllipsoid,The length of the statement  "            IEllipsoid ellipsoid = new Ellipsoid(majorAxis' 0.0' e' true' LinearUnit.Metre' name' authority' authorityCode' String.Empty' string.Empty' string.Empty); " is 154.
Long Statement,MapAround.Serialization,CoordinateSystemWktDeserializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\SpatialReferenceSerializers.cs,ReadProjection,The length of the statement  "            IProjection projection = new Projection(projectionName' paramList' projectionName' authority' authorityCode' String.Empty' String.Empty' string.Empty); " is 151.
Long Statement,MapAround.Serialization,CoordinateSystemWktDeserializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\SpatialReferenceSerializers.cs,ReadProjectedCoordinateSystem,The length of the statement  "            IProjectedCoordinateSystem projectedCS = new ProjectedCoordinateSystem(geographicCS.HorizontalDatum' geographicCS' unit as LinearUnit' projection' axes' name' authority' authorityCode' String.Empty' String.Empty' String.Empty); " is 227.
Long Statement,MapAround.Serialization,CoordinateSystemWktDeserializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\SpatialReferenceSerializers.cs,ReadHorizontalDatum,The length of the statement  "            IHorizontalDatum horizontalDatum = new HorizontalDatum(ellipsoid' wgsInfo' DatumType.HD_Geocentric' name' authority' authorityCode' String.Empty' String.Empty' String.Empty); " is 174.
Long Statement,MapAround.Serialization,CoordinateSystemWktDeserializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\SpatialReferenceSerializers.cs,ReadPrimeMeridian,The length of the statement  "            IPrimeMeridian primeMeridian = new PrimeMeridian(longitude' AngularUnit.Degrees' name' authority' authorityCode' String.Empty' String.Empty' String.Empty); " is 155.
Long Statement,MapAround.UI,ImageLegend,C:\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,DrawLegend,The length of the statement  "                g.DrawString(Caption' _captionFont' new SolidBrush(_captionColor)' new PointF(_width / 2 - captionSize.Width / 2' _margin)); " is 124.
Long Statement,MapAround.Web,MapServerBase,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,GetVectorInfo,The length of the statement  "            CheckRequestParams(requestParams' responseOutputStream' ref responseContentType' out originalBbox' out width' out height); " is 122.
Long Statement,MapAround.Web,MapServerBase,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,GetImageFromChach,The length of the statement  "                byte[] tileBytes = _tileCacheAccessor.ExtractTileBytes(layer.Alias'bboxWithGutters' getTileString(bboxWithGutters)'"png"); " is 122.
Long Statement,MapAround.Web,MapServerBase,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,WmsException,The length of the statement  "            sb.Append("<ServiceExceptionReport version=\"1.1.1\" xmlns=\"http://www.opengis.net/ogc\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n"); " is 151.
Long Statement,MapAround.Web,MapServerBase,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,WmtsException,The length of the statement  "            sb.Append("<ServiceExceptionReport version=\"1.1.1\" xmlns=\"http://www.opengis.net/ogc\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n"); " is 151.
Long Statement,MapAround.Web.Wms,WmsCapabilities,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsCapabilities.cs,GenerateServiceNode,The length of the statement  "                serviceNode.AppendChild(createElement("LayerLimit"' serviceDescription.LayerLimit.ToString(CultureInfo.InvariantCulture)' " is 121.
Long Statement,MapAround.Web.Wms,WmsCapabilities,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsCapabilities.cs,GenerateServiceNode,The length of the statement  "                serviceNode.AppendChild(createElement("MaxWidth"' serviceDescription.MaxWidth.ToString(CultureInfo.InvariantCulture)' capabilities' " is 131.
Long Statement,MapAround.Web.Wms,WmsCapabilities,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wms\WmsCapabilities.cs,GenerateServiceNode,The length of the statement  "                serviceNode.AppendChild(createElement("MaxHeight"' serviceDescription.MaxHeight.ToString(CultureInfo.InvariantCulture)' capabilities' " is 133.
Long Statement,MapAround.Web.Wmts,WmtsCapabilities,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,GenerateServiceNode,The length of the statement  "                serviceNode.AppendChild(createElement("LayerLimit"' serviceDescription.LayerLimit.ToString(CultureInfo.InvariantCulture)' " is 121.
Long Statement,MapAround.Web.Wmts,WmtsCapabilities,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,GenerateServiceNode,The length of the statement  "                serviceNode.AppendChild(createElement("MaxWidth"' serviceDescription.MaxWidth.ToString(CultureInfo.InvariantCulture)' capabilities' " is 131.
Long Statement,MapAround.Web.Wmts,WmtsCapabilities,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,GenerateServiceNode,The length of the statement  "                serviceNode.AppendChild(createElement("MaxHeight"' serviceDescription.MaxHeight.ToString(CultureInfo.InvariantCulture)' capabilities' " is 133.
Long Statement,MapAround.Web.Wmts,WmtsCapabilities,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,GenerateTileMatrixInfo,The length of the statement  "            matrixInfo.AppendChild(createElement("ows:Identifier"' serviceDescription.ZoomLevel.Keys.ToList()[i].ToString()' capabilities' false' wmtsNamespaceURI)); " is 153.
Long Statement,MapAround.Web.Wmts,WmtsCapabilities,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,GenerateTileMatrixInfo,The length of the statement  "            matrixInfo.AppendChild(createElement("ScaleDenominator"' serviceDescription.GetScaleDenominator(i).ToString()' capabilities' false' wmtsNamespaceURI)); " is 151.
Long Statement,MapAround.Web.Wmts,WmtsCapabilities,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,GenerateTileMatrixInfo,The length of the statement  "            matrixInfo.AppendChild(createElement("MatrixHeight"' Math.Pow(2' i).ToString()' capabilities' false' wmtsNamespaceURI)); " is 120.
Long Statement,MapAround.Web.Wmts,WMTSServer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WMTSServer.cs,CheckRequestParams,The length of the statement  "            tile.PixelSize = (_description as WmtsServiceDescription).GetPixelSize((_description as WmtsServiceDescription).ZoomLevel[tileMatrixName]); // Attention!! " is 154.
Complex Conditional,MapAround.DataProviders,ShapeFileSpatialDataProvider,C:\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\ShapeFileDataProvider.cs,internalQueryFeatures,The conditional expression  "!checkBounds ||                      (record.MaxX >= bounds.MinX && record.MaxY >= bounds.MinY &&                       record.MinX <= bounds.MaxX && record.MinY <= bounds.MaxY)"  is complex.
Complex Conditional,MapAround.Extensions.Surfaces,IsolineBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,getIsoline,The conditional expression  "(z == tz[0] && z == tz[1]) ||                      (z == tz[1] && z == tz[2])"  is complex.
Complex Conditional,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,GetBuffer,The conditional expression  "!(geometry is PointD) && !(geometry is Polyline) && !(geometry is Polygon) && !(geometry is MultiPoint)"  is complex.
Complex Conditional,MapAround.Geometry,DistanceCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\DataStructures.cs,checkGeometry,The conditional expression  "!(geometry is PointD) &&                   !(geometry is Polyline) &&                   !(geometry is Polygon) &&                   !(geometry is MultiPoint)"  is complex.
Complex Conditional,MapAround.Geometry,DistanceCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\DataStructures.cs,calculateDistanceBrutForce,The conditional expression  "(geometry1 is Polygon || geometry1 is Polyline) &&                  (geometry2 is Polygon || geometry2 is Polyline)"  is complex.
Complex Conditional,MapAround.Geometry,PointD,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Intersects,The conditional expression  "matrix.Matches("T********") ||                 matrix.Matches("*T*******") ||                 matrix.Matches("***T*****") ||                 matrix.Matches("****T****")"  is complex.
Complex Conditional,MapAround.Geometry,MultiPoint,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Intersects,The conditional expression  "matrix.Matches("T********") ||                 matrix.Matches("*T*******") ||                 matrix.Matches("***T*****") ||                 matrix.Matches("****T****")"  is complex.
Complex Conditional,MapAround.Geometry,Contour,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,PointLiesInside,The conditional expression  "(p1y > y) && (p2y <= y) || (p1y <= y) && (p2y > y)"  is complex.
Complex Conditional,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,hasCycles,The conditional expression  "(touchedContourPairs[k].Key == touchedContourIndices[i] &&                               touchedContourPairs[k].Value == touchedContourIndices[j]) ||                              (touchedContourPairs[k].Key == touchedContourIndices[j] &&                               touchedContourPairs[k].Value == touchedContourIndices[i])"  is complex.
Complex Conditional,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Intersects,The conditional expression  "matrix.Matches("T********") ||                 matrix.Matches("*T*******") ||                 matrix.Matches("***T*****") ||                 matrix.Matches("****T****")"  is complex.
Complex Conditional,MapAround.Geometry,Polyline,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Intersects,The conditional expression  "matrix.Matches("T********") ||                 matrix.Matches("*T*******") ||                 matrix.Matches("***T*****") ||                 matrix.Matches("****T****")"  is complex.
Complex Conditional,MapAround.Geometry,BoundingRectangle,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Intersects,The conditional expression  "polygon.ContainsPoint(Min) || polygon.ContainsPoint(Max) ||                  polygon.ContainsPoint(PlanimetryEnvironment.NewCoordinate(MinX' MaxY)) ||                  polygon.ContainsPoint(PlanimetryEnvironment.NewCoordinate(MaxX' MinY))"  is complex.
Complex Conditional,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolygonOverlay,The conditional expression  "operation == OverlayType.Union || operation == OverlayType.SymmetricDifference ||                         (operation == OverlayType.Difference && inverseArgs)"  is complex.
Complex Conditional,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolylinePolygonOverlay,The conditional expression  "operation == OverlayType.SymmetricDifference || operation == OverlayType.Union ||                          (operation == OverlayType.Difference && inverseArgs)"  is complex.
Complex Conditional,MapAround.Geometry,PlanimetryAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,RobustSegmentsIntersection,The conditional expression  "p11 == 0 && p12 == 0 && p21 == 0 && p22 == 0"  is complex.
Complex Conditional,MapAround.Geometry,PlanimetryAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,filterPointsForConvexHull,The conditional expression  "current.X > bounds.MinX && current.X < bounds.MaxX &&                     current.Y > bounds.MinY && current.Y < bounds.MaxY"  is complex.
Complex Conditional,MapAround.Geometry,GeometrySimplifier,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,simplifyPolylineSDMin,The conditional expression  "currentVertex.Deleted ||                       currentVertex.IsCrossSegmentVertex ||                      currentVertex.Previous == null ||                       currentVertex.Next == null"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculteInternalInternal,The conditional expression  "((flag && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1) ||                                (!flag && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2)) && polygon.ContainsPoint(edge.CenterPoint())"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The conditional expression  "(isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The conditional expression  "(isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The conditional expression  "(!inverseArgs && usageCount1 % 2 == 0 && usageCount2 % 2 == 1) ||                                 (inverseArgs && usageCount1 % 2 == 1 && usageCount2 % 2 == 0)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The conditional expression  "(isFirstGeometryPolyline && inverseArgs) ||                          (!isFirstGeometryPolyline && !inverseArgs)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The conditional expression  "(isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                  (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The conditional expression  "(inverseArgs && edge.Label.UsedByObject1 && p2.ContainsPoint(edge.CenterPoint())) ||                                  (!inverseArgs && edge.Label.UsedByObject2 && p1.ContainsPoint(edge.CenterPoint()))"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalExternal,The conditional expression  "(isFirstGeometryPolyline && !inverseArgs) ||                          (!isFirstGeometryPolyline && inverseArgs)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalExternal,The conditional expression  "(isFirstGeometryPoint && node.Label.UsedByObject1) ||                                      (!isFirstGeometryPoint && node.Label.UsedByObject2)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalExternal,The conditional expression  "(inverseArgs && isFirstGeometryPoint) ||                         (!inverseArgs && !isFirstGeometryPoint)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalExternal,The conditional expression  "(!inverseArgs && edge.Label.UsedByObject1) ||                                 (inverseArgs && edge.Label.UsedByObject2)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalExternal,The conditional expression  "(inverseArgs && isFirstGeometryPolyline) ||                          (!inverseArgs && !isFirstGeometryPolyline)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalExternal,The conditional expression  "(!inverseArgs && edge.Label.UsedByObject1) ||                                      (inverseArgs && edge.Label.UsedByObject2)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalExternal,The conditional expression  "(inverseArgs && edge.Label.UsedByObject2 && !polygon1.ContainsPoint(edge.CenterPoint())) ||                                 (!inverseArgs && edge.Label.UsedByObject1 && !polygon2.ContainsPoint(edge.CenterPoint()))"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalExternal,The conditional expression  "(inverseArgs && edge.Label.UsedByObject1 && polygon2.ContainsPoint(edge.CenterPoint())) ||                                 (!inverseArgs && edge.Label.UsedByObject2 && polygon1.ContainsPoint(edge.CenterPoint()))"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The conditional expression  "(inverseArgs && !isFirstGeometryPoint) ||                          (!inverseArgs && isFirstGeometryPoint)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The conditional expression  "(inverseArgs && isFirstGeometryPoint) ||                          (!inverseArgs && !isFirstGeometryPoint)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The conditional expression  "(!inverseArgs && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                              (inverseArgs && node.Label.UsedByObject2 && !node.Label.UsedByObject1)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The conditional expression  "(inverseArgs && isFirstGeometryPolyline) ||                          (!inverseArgs && !isFirstGeometryPolyline)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The conditional expression  "(isFirstGeometryPolyline && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1) ||                                 (!isFirstGeometryPolyline && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The conditional expression  "(isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                 (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1)"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The conditional expression  "(!inverseArgs && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2 && !polygon2.ContainsPoint(edge.CenterPoint())) ||                              (inverseArgs && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1 && !polygon1.ContainsPoint(edge.CenterPoint()))"  is complex.
Complex Conditional,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,checkGeometry,The conditional expression  "!(geometry is PointD) && !(geometry is Polyline) && !(geometry is Polygon) && !(geometry is MultiPoint)"  is complex.
Complex Conditional,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,addOrMergeNode,The conditional expression  "(_performSnapping && p.ExactEquals(coordinate)) ||                          (!_performSnapping && p.Equals(coordinate))"  is complex.
Complex Conditional,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,updateSplittedSegment,The conditional expression  "(_performSnapping && ss.Segment.ExactEquals(segment.Segment)) ||                      (!_performSnapping && ss.Segment == segment.Segment)"  is complex.
Complex Conditional,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,AddColumn,The conditional expression  "dataType == typeof(short) || dataType == typeof(ushort) ||                           dataType == typeof(int) || dataType == typeof(uint) ||                           dataType == typeof(long) || dataType == typeof(ulong)"  is complex.
Complex Conditional,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,RecountColumnLength,The conditional expression  "field.DataType == typeof(Double) ||field.DataType == typeof(Single) || field.DataType == typeof(Decimal) ||                           field.DataType == typeof(Int16) || field.DataType == typeof(Int32) || field.DataType == typeof(Int64)                           || field.DataType == typeof(UInt16) || field.DataType == typeof(UInt32) || field.DataType == typeof(UInt64)"  is complex.
Complex Conditional,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectTopObject,The conditional expression  "l.Visible && l.FeaturesSelectable &&                          (l.MaxVisibleScale >= scale && l.MinVisibleScale <= scale)"  is complex.
Complex Conditional,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObjects,The conditional expression  "l.Visible && l.FeaturesSelectable &&                          (_layers[i].MaxVisibleScale >= scale && _layers[i].MinVisibleScale <= scale)"  is complex.
Complex Conditional,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The conditional expression  "coordinate.X > bounds.MinX && coordinate.Y > bounds.MinY &&                      coordinate.X < bounds.MaxX && coordinate.Y < bounds.MaxY"  is complex.
Complex Conditional,MapAround.Mapping,MapWorkspace,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapWorkspace.cs,processViewBox,The conditional expression  "viewBox.Attributes["min_x"].Value.Length != 0 &&                      viewBox.Attributes["min_y"].Value.Length != 0 &&                      viewBox.Attributes["max_x"].Value.Length != 0 &&                      viewBox.Attributes["max_y"].Value.Length != 0"  is complex.
Complex Conditional,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,The conditional expression  "!double.IsNaN(warpTransformResult[i' j].X) && !double.IsNaN(warpTransformResult[i' j].Y) &&                          x >= 0 && y >= 0"  is complex.
Complex Conditional,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,checkControlPoints,The conditional expression  "p.X < 0 || p.Y < 0 || p.X >= sourceWidth || p.Y >= sourceHeight"  is complex.
Complex Conditional,MapAround.Mapping,TitleBufferElement,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,contoursIntersect,The conditional expression  "PlanimetryAlgorithms.SegmentsIntersection(segment1' segment3' out pointStub' out segmentStub) != Dimension.None ||                      PlanimetryAlgorithms.SegmentsIntersection(segment1' segment4' out pointStub' out segmentStub) != Dimension.None ||                      PlanimetryAlgorithms.SegmentsIntersection(segment2' segment3' out pointStub' out segmentStub) != Dimension.None ||                      PlanimetryAlgorithms.SegmentsIntersection(segment2' segment4' out pointStub' out segmentStub) != Dimension.None"  is complex.
Complex Conditional,MapAround.Geometry.Tessellations,FortuneShoreLine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,FindArc,The conditional expression  "(currentArc.Left == null || pointsPrev[0].X <= eventX) &&                      (currentArc.Right == null || pointsNext[0].X >= eventX)"  is complex.
Complex Conditional,MapAround.Indexing,QuadTreeNode,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\QuadTree.cs,Remove,The conditional expression  "this._geometriesRectangle.MinX == obj.BoundingRectangle.MinX ||                          this._geometriesRectangle.MinY == obj.BoundingRectangle.MinY ||                          this._geometriesRectangle.MaxX == obj.BoundingRectangle.MaxX ||                          this._geometriesRectangle.MaxY == obj.BoundingRectangle.MaxY"  is complex.
Complex Conditional,MapAround.Rendering,Region,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,containsPoint,The conditional expression  "(p1y > y) && (p2y <= y) || (p1y <= y) && (p2y > y)"  is complex.
Complex Conditional,MapAround.UI,LegendBase,C:\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,AddElementsForLayer,The conditional expression  "(l.LegendSettings.DisplayPointSample ||                     l.LegendSettings.DisplayPolylineSample ||                     l.LegendSettings.DisplayPolygonSample) &&                     l.FeatureRenderer == null"  is complex.
Empty Catch Block,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,MapViewBoxFromPresentationViewBox,The method has an empty catch block.
Empty Catch Block,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,tryJoinWithTransformedPoint,The method has an empty catch block.
Magic Number,MapAround.CoordinateSystems,Ellipsoid,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,SurfaceArea,The following statement contains a magic number: if (SemiMajorAxis > SemiMinorAxis)              {                  double a = SemiMajorAxis;                  double b = SemiMinorAxis;                  double ab = Math.Sqrt(a * a - b * b);                    return 2.0 * Math.PI * a * (a + b * b / ab * Math.Log((a + ab) / b));              }              else                  if (SemiMajorAxis == SemiMinorAxis)                  {                      return 4.0 * Math.PI * SemiMajorAxis * SemiMajorAxis;                  }                  else                  {                      double a = SemiMajorAxis;                      double b = SemiMinorAxis;                      double ba = Math.Sqrt(b * b - a * a);                        return 2.0 * Math.PI * a * (a + b * b / ba * Math.Asin(ba / b));                  }
Magic Number,MapAround.CoordinateSystems,Ellipsoid,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,SurfaceArea,The following statement contains a magic number: if (SemiMajorAxis > SemiMinorAxis)              {                  double a = SemiMajorAxis;                  double b = SemiMinorAxis;                  double ab = Math.Sqrt(a * a - b * b);                    return 2.0 * Math.PI * a * (a + b * b / ab * Math.Log((a + ab) / b));              }              else                  if (SemiMajorAxis == SemiMinorAxis)                  {                      return 4.0 * Math.PI * SemiMajorAxis * SemiMajorAxis;                  }                  else                  {                      double a = SemiMajorAxis;                      double b = SemiMinorAxis;                      double ba = Math.Sqrt(b * b - a * a);                        return 2.0 * Math.PI * a * (a + b * b / ba * Math.Asin(ba / b));                  }
Magic Number,MapAround.CoordinateSystems,Ellipsoid,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,SurfaceArea,The following statement contains a magic number: if (SemiMajorAxis > SemiMinorAxis)              {                  double a = SemiMajorAxis;                  double b = SemiMinorAxis;                  double ab = Math.Sqrt(a * a - b * b);                    return 2.0 * Math.PI * a * (a + b * b / ab * Math.Log((a + ab) / b));              }              else                  if (SemiMajorAxis == SemiMinorAxis)                  {                      return 4.0 * Math.PI * SemiMajorAxis * SemiMajorAxis;                  }                  else                  {                      double a = SemiMajorAxis;                      double b = SemiMinorAxis;                      double ba = Math.Sqrt(b * b - a * a);                        return 2.0 * Math.PI * a * (a + b * b / ba * Math.Asin(ba / b));                  }
Magic Number,MapAround.CoordinateSystems,CoordinateSystemFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateProjectedCoordinateSystem,The following statement contains a magic number: List<AxisInfo> info = new List<AxisInfo>(2);
Magic Number,MapAround.CoordinateSystems,CoordinateSystemFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateGeographicCoordinateSystem,The following statement contains a magic number: List<AxisInfo> info = new List<AxisInfo>(2);
Magic Number,MapAround.CoordinateSystems,CoordinateSystemFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,CreateGeocentricCoordinateSystem,The following statement contains a magic number: List<AxisInfo> info = new List<AxisInfo>(3);
Magic Number,MapAround.CoordinateSystems,GeocentricCoordinateSystem,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,GeocentricCoordinateSystem,The following statement contains a magic number: if (axisinfo.Count != 3)                  throw new ArgumentException("Axis info should contain three axes for geocentric coordinate systems");
Magic Number,MapAround.CoordinateSystems,HorizontalCoordinateSystem,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\CoordinateSystems.cs,HorizontalCoordinateSystem,The following statement contains a magic number: if (axisInfo.Count != 2)                  throw new ArgumentException("Axis info should contain two axes for horizontal coordinate systems");
Magic Number,MapAround.CoordinateSystems,Wgs84ConversionInfo,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\WGS84ConversionInfo.cs,GetAffineTransform,The following statement contains a magic number: double RS = 1 + Ppm * 0.000001;
Magic Number,MapAround.CoordinateSystems,Wgs84ConversionInfo,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\WGS84ConversionInfo.cs,GetAffineTransform,The following statement contains a magic number: return new double[7] { RS' Ex * SEC_TO_RAD * RS' Ey * SEC_TO_RAD * RS' Ez * SEC_TO_RAD * RS' Dx' Dy' Dz };
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,AlbersProjection,The following statement contains a magic number: e_sq = 1.0 - Math.Pow(this._semiMinor / this._semiMajor' 2);
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,AlbersProjection,The following statement contains a magic number: double m1 = Math.Cos(lat1) / Math.Sqrt(1 - e_sq * Math.Pow(Math.Sin(lat1)' 2));
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,AlbersProjection,The following statement contains a magic number: double m2 = Math.Cos(lat2) / Math.Sqrt(1 - e_sq * Math.Pow(Math.Sin(lat2)' 2));
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,AlbersProjection,The following statement contains a magic number: n = (Math.Pow(m1' 2) - Math.Pow(m2' 2)) / (alpha2 - alpha1);
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,AlbersProjection,The following statement contains a magic number: n = (Math.Pow(m1' 2) - Math.Pow(m2' 2)) / (alpha2 - alpha1);
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,AlbersProjection,The following statement contains a magic number: C = Math.Pow(m1' 2) + (n * alpha1);
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: if (lonlat.Length == 2)                  return new double[] { dLongitude / _metersPerUnit' dLatitude / _metersPerUnit };              else                  return new double[] { dLongitude / _metersPerUnit' dLatitude / _metersPerUnit' lonlat[2] };
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: if (lonlat.Length == 2)                  return new double[] { dLongitude / _metersPerUnit' dLatitude / _metersPerUnit };              else                  return new double[] { dLongitude / _metersPerUnit' dLatitude / _metersPerUnit' lonlat[2] };
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double ro = Math.Sqrt(Math.Pow(p[0] * _metersPerUnit - _falseEasting' 2) + Math.Pow(ro0 - (p[1] * _metersPerUnit - _falseNorthing)' 2));
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double ro = Math.Sqrt(Math.Pow(p[0] * _metersPerUnit - _falseEasting' 2) + Math.Pow(ro0 - (p[1] * _metersPerUnit - _falseNorthing)' 2));
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double q = (C - Math.Pow(ro' 2) * Math.Pow(n' 2) / Math.Pow(this._semiMajor' 2)) / n;
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double q = (C - Math.Pow(ro' 2) * Math.Pow(n' 2) / Math.Pow(this._semiMajor' 2)) / n;
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double q = (C - Math.Pow(ro' 2) * Math.Pow(n' 2) / Math.Pow(this._semiMajor' 2)) / n;
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double b = Math.Sin(q / (1 - ((1 - e_sq) / (2 * e)) * Math.Log((1 - e) / (1 + e))));
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double lat = Math.Asin(q * 0.5);
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: while (Math.Abs(lat - preLat) > 0.000001)              {                  preLat = lat;                  double sin = Math.Sin(lat);                  double e2sin2 = e_sq * Math.Pow(sin' 2);                  lat += (Math.Pow(1 - e2sin2' 2) / (2 * Math.Cos(lat))) * ((q / (1 - e_sq)) - sin / (1 - e2sin2) + 1 / (2 * e) * Math.Log((1 - e * sin) / (1 + e * sin)));                  iterationCounter++;                  if (iterationCounter > 25)                      throw new ApplicationException("Inverse Albers transform failed to converge.");              }
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: while (Math.Abs(lat - preLat) > 0.000001)              {                  preLat = lat;                  double sin = Math.Sin(lat);                  double e2sin2 = e_sq * Math.Pow(sin' 2);                  lat += (Math.Pow(1 - e2sin2' 2) / (2 * Math.Cos(lat))) * ((q / (1 - e_sq)) - sin / (1 - e2sin2) + 1 / (2 * e) * Math.Log((1 - e * sin) / (1 + e * sin)));                  iterationCounter++;                  if (iterationCounter > 25)                      throw new ApplicationException("Inverse Albers transform failed to converge.");              }
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: while (Math.Abs(lat - preLat) > 0.000001)              {                  preLat = lat;                  double sin = Math.Sin(lat);                  double e2sin2 = e_sq * Math.Pow(sin' 2);                  lat += (Math.Pow(1 - e2sin2' 2) / (2 * Math.Cos(lat))) * ((q / (1 - e_sq)) - sin / (1 - e2sin2) + 1 / (2 * e) * Math.Log((1 - e * sin) / (1 + e * sin)));                  iterationCounter++;                  if (iterationCounter > 25)                      throw new ApplicationException("Inverse Albers transform failed to converge.");              }
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: while (Math.Abs(lat - preLat) > 0.000001)              {                  preLat = lat;                  double sin = Math.Sin(lat);                  double e2sin2 = e_sq * Math.Pow(sin' 2);                  lat += (Math.Pow(1 - e2sin2' 2) / (2 * Math.Cos(lat))) * ((q / (1 - e_sq)) - sin / (1 - e2sin2) + 1 / (2 * e) * Math.Log((1 - e * sin) / (1 + e * sin)));                  iterationCounter++;                  if (iterationCounter > 25)                      throw new ApplicationException("Inverse Albers transform failed to converge.");              }
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: while (Math.Abs(lat - preLat) > 0.000001)              {                  preLat = lat;                  double sin = Math.Sin(lat);                  double e2sin2 = e_sq * Math.Pow(sin' 2);                  lat += (Math.Pow(1 - e2sin2' 2) / (2 * Math.Cos(lat))) * ((q / (1 - e_sq)) - sin / (1 - e2sin2) + 1 / (2 * e) * Math.Log((1 - e * sin) / (1 + e * sin)));                  iterationCounter++;                  if (iterationCounter > 25)                      throw new ApplicationException("Inverse Albers transform failed to converge.");              }
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: while (Math.Abs(lat - preLat) > 0.000001)              {                  preLat = lat;                  double sin = Math.Sin(lat);                  double e2sin2 = e_sq * Math.Pow(sin' 2);                  lat += (Math.Pow(1 - e2sin2' 2) / (2 * Math.Cos(lat))) * ((q / (1 - e_sq)) - sin / (1 - e2sin2) + 1 / (2 * e) * Math.Log((1 - e * sin) / (1 + e * sin)));                  iterationCounter++;                  if (iterationCounter > 25)                      throw new ApplicationException("Inverse Albers transform failed to converge.");              }
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (p.Length < 3)                  return new double[]                   {                      MathUtils.Radians.ToDegrees(lon)'                       MathUtils.Radians.ToDegrees(lat)                   };              else                  return new double[]                   {                       MathUtils.Radians.ToDegrees(lon)'                       MathUtils.Radians.ToDegrees(lat)' p[2]                   };
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (p.Length < 3)                  return new double[]                   {                      MathUtils.Radians.ToDegrees(lon)'                       MathUtils.Radians.ToDegrees(lat)                   };              else                  return new double[]                   {                       MathUtils.Radians.ToDegrees(lon)'                       MathUtils.Radians.ToDegrees(lat)' p[2]                   };
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,alpha,The following statement contains a magic number: double sinsq = Math.Pow(sin' 2);
Magic Number,MapAround.CoordinateSystems.Projections,AlbersProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,alpha,The following statement contains a magic number: return (1 - e_sq) * (((sin / (1 - e_sq * sinsq)) - 1 / (2 * e) * Math.Log((1 - e * sin) / (1 + e * sin))));
Magic Number,MapAround.CoordinateSystems.Projections,LambertConformalConic2SP,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LambertConformalConic2SP,The following statement contains a magic number: this.AuthorityCode = 9802;
Magic Number,MapAround.CoordinateSystems.Projections,LambertConformalConic2SP,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LambertConformalConic2SP,The following statement contains a magic number: es = 1.0 - Math.Pow(this._semiMinor / this._semiMajor' 2);
Magic Number,MapAround.CoordinateSystems.Projections,LambertConformalConic2SP,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: if (lonlat.Length == 2)                  return new double[] { dLongitude / _metersPerUnit' dLatitude / _metersPerUnit };              else                  return new double[] { dLongitude / _metersPerUnit' dLatitude / _metersPerUnit' lonlat[2] };
Magic Number,MapAround.CoordinateSystems.Projections,LambertConformalConic2SP,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: if (lonlat.Length == 2)                  return new double[] { dLongitude / _metersPerUnit' dLatitude / _metersPerUnit };              else                  return new double[] { dLongitude / _metersPerUnit' dLatitude / _metersPerUnit' lonlat[2] };
Magic Number,MapAround.CoordinateSystems.Projections,LambertConformalConic2SP,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (p.Length == 2)                  return new double[]                   {                       MathUtils.Radians.ToDegrees(dLongitude)'                       MathUtils.Radians.ToDegrees(dLatitude)                   };              else                  return new double[]                   {                       MathUtils.Radians.ToDegrees(dLongitude)'                       MathUtils.Radians.ToDegrees(dLatitude)' p[2] };
Magic Number,MapAround.CoordinateSystems.Projections,LambertConformalConic2SP,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (p.Length == 2)                  return new double[]                   {                       MathUtils.Radians.ToDegrees(dLongitude)'                       MathUtils.Radians.ToDegrees(dLatitude)                   };              else                  return new double[]                   {                       MathUtils.Radians.ToDegrees(dLongitude)'                       MathUtils.Radians.ToDegrees(dLatitude)' p[2] };
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,Mercator,The following statement contains a magic number: if (scale_factor == null)               {                  k0 = Math.Cos(lat_origin) / Math.Sqrt(1.0 - e2 * Math.Sin(lat_origin) * Math.Sin(lat_origin));                  this.AuthorityCode = 9805;                  this.Name = "Mercator_2SP";              }              else               {                  k0 = scale_factor.Value;                  this.Name = "Mercator_1SP";              }
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: if (Math.Abs(Math.Abs(dLatitude) - HALF_PI) <= Tolerance)              //if (Math.Abs(Math.Abs(dLatitude) - HALF_PI) <= Math.PI / 15)                  throw new ApplicationException("Transformation cannot be computed at the poles.");              else              {                  double esinphi = e * Math.Sin(dLatitude);                  double x = _falseEasting + this._semiMajor * k0 * (dLongitude - lon_center);                  double y = _falseNorthing + this._semiMajor * k0 * Math.Log(Math.Tan(PI * 0.25 + dLatitude * 0.5) * Math.Pow((1 - esinphi) / (1 + esinphi)' e * 0.5));                    if (lonlat.Length < 3)                      return new double[] { x / _metersPerUnit' y / _metersPerUnit };                  else                      return new double[] { x / _metersPerUnit' y / _metersPerUnit' lonlat[2] };              }
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: if (Math.Abs(Math.Abs(dLatitude) - HALF_PI) <= Tolerance)              //if (Math.Abs(Math.Abs(dLatitude) - HALF_PI) <= Math.PI / 15)                  throw new ApplicationException("Transformation cannot be computed at the poles.");              else              {                  double esinphi = e * Math.Sin(dLatitude);                  double x = _falseEasting + this._semiMajor * k0 * (dLongitude - lon_center);                  double y = _falseNorthing + this._semiMajor * k0 * Math.Log(Math.Tan(PI * 0.25 + dLatitude * 0.5) * Math.Pow((1 - esinphi) / (1 + esinphi)' e * 0.5));                    if (lonlat.Length < 3)                      return new double[] { x / _metersPerUnit' y / _metersPerUnit };                  else                      return new double[] { x / _metersPerUnit' y / _metersPerUnit' lonlat[2] };              }
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: if (Math.Abs(Math.Abs(dLatitude) - HALF_PI) <= Tolerance)              //if (Math.Abs(Math.Abs(dLatitude) - HALF_PI) <= Math.PI / 15)                  throw new ApplicationException("Transformation cannot be computed at the poles.");              else              {                  double esinphi = e * Math.Sin(dLatitude);                  double x = _falseEasting + this._semiMajor * k0 * (dLongitude - lon_center);                  double y = _falseNorthing + this._semiMajor * k0 * Math.Log(Math.Tan(PI * 0.25 + dLatitude * 0.5) * Math.Pow((1 - esinphi) / (1 + esinphi)' e * 0.5));                    if (lonlat.Length < 3)                      return new double[] { x / _metersPerUnit' y / _metersPerUnit };                  else                      return new double[] { x / _metersPerUnit' y / _metersPerUnit' lonlat[2] };              }
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: if (Math.Abs(Math.Abs(dLatitude) - HALF_PI) <= Tolerance)              //if (Math.Abs(Math.Abs(dLatitude) - HALF_PI) <= Math.PI / 15)                  throw new ApplicationException("Transformation cannot be computed at the poles.");              else              {                  double esinphi = e * Math.Sin(dLatitude);                  double x = _falseEasting + this._semiMajor * k0 * (dLongitude - lon_center);                  double y = _falseNorthing + this._semiMajor * k0 * Math.Log(Math.Tan(PI * 0.25 + dLatitude * 0.5) * Math.Pow((1 - esinphi) / (1 + esinphi)' e * 0.5));                    if (lonlat.Length < 3)                      return new double[] { x / _metersPerUnit' y / _metersPerUnit };                  else                      return new double[] { x / _metersPerUnit' y / _metersPerUnit' lonlat[2] };              }
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: if (Math.Abs(Math.Abs(dLatitude) - HALF_PI) <= Tolerance)              //if (Math.Abs(Math.Abs(dLatitude) - HALF_PI) <= Math.PI / 15)                  throw new ApplicationException("Transformation cannot be computed at the poles.");              else              {                  double esinphi = e * Math.Sin(dLatitude);                  double x = _falseEasting + this._semiMajor * k0 * (dLongitude - lon_center);                  double y = _falseNorthing + this._semiMajor * k0 * Math.Log(Math.Tan(PI * 0.25 + dLatitude * 0.5) * Math.Pow((1 - esinphi) / (1 + esinphi)' e * 0.5));                    if (lonlat.Length < 3)                      return new double[] { x / _metersPerUnit' y / _metersPerUnit };                  else                      return new double[] { x / _metersPerUnit' y / _metersPerUnit' lonlat[2] };              }
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double chi = HALF_PI - 2 * Math.Atan(ts);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double e4 = Math.Pow(e' 4);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double e6 = Math.Pow(e' 6);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: double e8 = Math.Pow(e' 8);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: dLatitude = chi + (e2 * 0.5 + 5 * e4 / 24 + e6 / 12 + 13 * e8 / 360) * Math.Sin(2 * chi)                  + (7 * e4 / 48 + 29 * e6 / 240 + 811 * e8 / 11520) * Math.Sin(4 * chi) +                  +(7 * e6 / 120 + 81 * e8 / 1120) * Math.Sin(6 * chi) +                  +(4279 * e8 / 161280) * Math.Sin(8 * chi);
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (p.Length < 3)                  return new double[]                   {                       MathUtils.Radians.ToDegrees(dLongitude)'                       MathUtils.Radians.ToDegrees(dLatitude)                   };              else                  return new double[]                   {                       MathUtils.Radians.ToDegrees(dLongitude)'                       MathUtils.Radians.ToDegrees(dLatitude)' p[2]                   };
Magic Number,MapAround.CoordinateSystems.Projections,Mercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (p.Length < 3)                  return new double[]                   {                       MathUtils.Radians.ToDegrees(dLongitude)'                       MathUtils.Radians.ToDegrees(dLatitude)                   };              else                  return new double[]                   {                       MathUtils.Radians.ToDegrees(dLongitude)'                       MathUtils.Radians.ToDegrees(dLatitude)' p[2]                   };
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,TransverseMercator,The following statement contains a magic number: this.AuthorityCode = 9807;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,TransverseMercator,The following statement contains a magic number: es = 1.0 - Math.Pow(this._semiMinor / this._semiMajor' 2);
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: als = Math.Pow(al' 2);
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: c = esp * Math.Pow(cosPhi' 2);
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: t = Math.Pow(tq' 2);
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: con = 1.0 - es * Math.Pow(sinPhi' 2);
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double x =                  _scaleFactor * n * al * (1.0 + als / 6.0 * (1.0 - t + c + als / 20.0 *                  (5.0 - 18.0 * t + Math.Pow(t' 2) + 72.0 * c - 58.0 * esp))) + _falseEasting;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double x =                  _scaleFactor * n * al * (1.0 + als / 6.0 * (1.0 - t + c + als / 20.0 *                  (5.0 - 18.0 * t + Math.Pow(t' 2) + 72.0 * c - 58.0 * esp))) + _falseEasting;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double x =                  _scaleFactor * n * al * (1.0 + als / 6.0 * (1.0 - t + c + als / 20.0 *                  (5.0 - 18.0 * t + Math.Pow(t' 2) + 72.0 * c - 58.0 * esp))) + _falseEasting;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double x =                  _scaleFactor * n * al * (1.0 + als / 6.0 * (1.0 - t + c + als / 20.0 *                  (5.0 - 18.0 * t + Math.Pow(t' 2) + 72.0 * c - 58.0 * esp))) + _falseEasting;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double x =                  _scaleFactor * n * al * (1.0 + als / 6.0 * (1.0 - t + c + als / 20.0 *                  (5.0 - 18.0 * t + Math.Pow(t' 2) + 72.0 * c - 58.0 * esp))) + _falseEasting;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double x =                  _scaleFactor * n * al * (1.0 + als / 6.0 * (1.0 - t + c + als / 20.0 *                  (5.0 - 18.0 * t + Math.Pow(t' 2) + 72.0 * c - 58.0 * esp))) + _falseEasting;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double x =                  _scaleFactor * n * al * (1.0 + als / 6.0 * (1.0 - t + c + als / 20.0 *                  (5.0 - 18.0 * t + Math.Pow(t' 2) + 72.0 * c - 58.0 * esp))) + _falseEasting;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: double y = _scaleFactor * (ml - _ml0 + n * tq * (als * (0.5 + als / 24.0 *                  (5.0 - t + 9.0 * c + 4.0 * Math.Pow(c' 2) + als / 30.0 * (61.0 - 58.0 * t                  + Math.Pow(t' 2) + 600.0 * c - 330.0 * esp))))) + _falseNorthing;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: if (lonlat.Length < 3)                  return new double[] { x / _metersPerUnit' y / _metersPerUnit };              else                  return new double[] { x / _metersPerUnit' y / _metersPerUnit' lonlat[2] };
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,DegreesToMeters,The following statement contains a magic number: if (lonlat.Length < 3)                  return new double[] { x / _metersPerUnit' y / _metersPerUnit };              else                  return new double[] { x / _metersPerUnit' y / _metersPerUnit' lonlat[2] };
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: long maxIterCount = 6;
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: for (i = 0; ; i++)              {                  deltaPhi = ((con + e1 * Math.Sin(2.0 * phi) - e2 * Math.Sin(4.0 * phi) + e3 * Math.Sin(6.0 * phi))                      / e0) - phi;                  phi += deltaPhi;                  if (Math.Abs(deltaPhi) <= Tolerance) break;                  if (i >= maxIterCount)                      throw new ApplicationException("Latitude failed to converge");              }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: for (i = 0; ; i++)              {                  deltaPhi = ((con + e1 * Math.Sin(2.0 * phi) - e2 * Math.Sin(4.0 * phi) + e3 * Math.Sin(6.0 * phi))                      / e0) - phi;                  phi += deltaPhi;                  if (Math.Abs(deltaPhi) <= Tolerance) break;                  if (i >= maxIterCount)                      throw new ApplicationException("Latitude failed to converge");              }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: for (i = 0; ; i++)              {                  deltaPhi = ((con + e1 * Math.Sin(2.0 * phi) - e2 * Math.Sin(4.0 * phi) + e3 * Math.Sin(6.0 * phi))                      / e0) - phi;                  phi += deltaPhi;                  if (Math.Abs(deltaPhi) <= Tolerance) break;                  if (i >= maxIterCount)                      throw new ApplicationException("Latitude failed to converge");              }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,TransverseMercator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,MetersToDegrees,The following statement contains a magic number: if (Math.Abs(phi) < HALF_PI)              {                  sincos(phi' out sinPhi' out cosPhi);                  tanPhi = Math.Tan(phi);                  c = esp * Math.Pow(cosPhi' 2);                  cs = Math.Pow(c' 2);                  t = Math.Pow(tanPhi' 2);                  ts = Math.Pow(t' 2);                  con = 1.0 - es * Math.Pow(sinPhi' 2);                  n = this._semiMajor / Math.Sqrt(con);                  r = n * (1.0 - es) / con;                  d = x / (n * _scaleFactor);                  ds = Math.Pow(d' 2);                    double lat = phi - (n * tanPhi * ds / r) * (0.5 - ds / 24.0 * (5.0 + 3.0 * t +                      10.0 * c - 4.0 * cs - 9.0 * esp - ds / 30.0 * (61.0 + 90.0 * t +                      298.0 * c + 45.0 * ts - 252.0 * esp - 3.0 * cs)));                  double lon = adjustLon(_centralMeridian + (d * (1.0 - ds / 6.0 * (1.0 + 2.0 * t +                      c - ds / 20.0 * (5.0 - 2.0 * c + 28.0 * t - 3.0 * cs + 8.0 * esp +                      24.0 * ts))) / cosPhi));                    if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(lon)'                           MathUtils.Radians.ToDegrees(lat)' p[2]                       };              }              else              {                  if (p.Length < 3)                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)                       };                  else                      return new double[]                       {                           MathUtils.Radians.ToDegrees(HALF_PI * sign(y))'                           MathUtils.Radians.ToDegrees(_centralMeridian)' p[2]                       };                }
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,CUBE,The following statement contains a magic number: return Math.Pow(x' 3);
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,QUAD,The following statement contains a magic number: return Math.Pow(x' 4);
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,adjustLon,The following statement contains a magic number: for (; ; )              {                  if (Math.Abs(x) <= PI)                      break;                  else                      if (((long)Math.Abs(x / Math.PI)) < 2)                          x = x - (sign(x) * TWO_PI);                      else                          if (((long)Math.Abs(x / TWO_PI)) < prjMAXLONG)                          {                              x = x - (((long)(x / TWO_PI)) * TWO_PI);                          }                          else                              if (((long)Math.Abs(x / (prjMAXLONG * TWO_PI))) < prjMAXLONG)                              {                                  x = x - (((long)(x / (prjMAXLONG * TWO_PI))) * (TWO_PI * prjMAXLONG));                              }                              else                                  if (((long)Math.Abs(x / (DBLLONG * TWO_PI))) < prjMAXLONG)                                  {                                      x = x - (((long)(x / (DBLLONG * TWO_PI))) * (TWO_PI * DBLLONG));                                  }                                  else                                      x = x - (sign(x) * TWO_PI);                  count++;                  if (count > MAX_VAL)                      break;              }
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,qsfnz,The following statement contains a magic number: if (eccent > 1.0e-7)              {                  con = eccent * sinPhi;                  return ((1 - eccent * eccent) * (sinPhi / (1 - con * con) - (0.5 / eccent) *                      Math.Log((1 - con) / (1 + con))));              }              else                  return 2 * sinPhi;
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,qsfnz,The following statement contains a magic number: if (eccent > 1.0e-7)              {                  con = eccent * sinPhi;                  return ((1 - eccent * eccent) * (sinPhi / (1 - con * con) - (0.5 / eccent) *                      Math.Log((1 - con) / (1 + con))));              }              else                  return 2 * sinPhi;
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,qsfnz,The following statement contains a magic number: if (eccent > 1.0e-7)              {                  con = eccent * sinPhi;                  return ((1 - eccent * eccent) * (sinPhi / (1 - con * con) - (0.5 / eccent) *                      Math.Log((1 - con) / (1 + con))));              }              else                  return 2 * sinPhi;
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,tsfnz,The following statement contains a magic number: com = 0.5 * eccent;
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,tsfnz,The following statement contains a magic number: return (Math.Tan(.5 * (HALF_PI - phi)) / con);
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,phi1z,The following statement contains a magic number: phi = asinz(0.5 * qs);
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,phi1z,The following statement contains a magic number: for (i = 1; i <= 25; i++)              {                  sincos(phi' out sinpi' out cospi);                  con = eccent * sinpi;                  com = 1 - con * con;                  dphi = 0.5 * com * com / cospi * (qs / (1 - eccnts) - sinpi / com +                      0.5 / eccent * Math.Log((1 - con) / (1 + con)));                  phi = phi + dphi;                  if (Math.Abs(dphi) <= 1e-7)                      return (phi);              }
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,phi1z,The following statement contains a magic number: for (i = 1; i <= 25; i++)              {                  sincos(phi' out sinpi' out cospi);                  con = eccent * sinpi;                  com = 1 - con * con;                  dphi = 0.5 * com * com / cospi * (qs / (1 - eccnts) - sinpi / com +                      0.5 / eccent * Math.Log((1 - con) / (1 + con)));                  phi = phi + dphi;                  if (Math.Abs(dphi) <= 1e-7)                      return (phi);              }
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,phi1z,The following statement contains a magic number: for (i = 1; i <= 25; i++)              {                  sincos(phi' out sinpi' out cospi);                  con = eccent * sinpi;                  com = 1 - con * con;                  dphi = 0.5 * com * com / cospi * (qs / (1 - eccnts) - sinpi / com +                      0.5 / eccent * Math.Log((1 - con) / (1 + con)));                  phi = phi + dphi;                  if (Math.Abs(dphi) <= 1e-7)                      return (phi);              }
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,phi1z,The following statement contains a magic number: for (i = 1; i <= 25; i++)              {                  sincos(phi' out sinpi' out cospi);                  con = eccent * sinpi;                  com = 1 - con * con;                  dphi = 0.5 * com * com / cospi * (qs / (1 - eccnts) - sinpi / com +                      0.5 / eccent * Math.Log((1 - con) / (1 + con)));                  phi = phi + dphi;                  if (Math.Abs(dphi) <= 1e-7)                      return (phi);              }
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,phi2z,The following statement contains a magic number: double eccnth = .5 * eccent;
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,phi2z,The following statement contains a magic number: double chi = HALF_PI - 2 * Math.Atan(ts);
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,phi2z,The following statement contains a magic number: for (i = 0; i <= 15; i++)              {                  sinpi = Math.Sin(chi);                  con = eccent * sinpi;                  dphi = HALF_PI - 2 * Math.Atan(ts * (Math.Pow(((1.0 - con) / (1.0 + con))' eccnth))) - chi;                  chi += dphi;                  if (Math.Abs(dphi) <= 0.0000000001)                      return (chi);              }
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,phi2z,The following statement contains a magic number: for (i = 0; i <= 15; i++)              {                  sinpi = Math.Sin(chi);                  con = eccent * sinpi;                  dphi = HALF_PI - 2 * Math.Atan(ts * (Math.Pow(((1.0 - con) / (1.0 + con))' eccnth))) - chi;                  chi += dphi;                  if (Math.Abs(dphi) <= 0.0000000001)                      return (chi);              }
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,phi2z,The following statement contains a magic number: for (i = 0; i <= 15; i++)              {                  sinpi = Math.Sin(chi);                  con = eccent * sinpi;                  dphi = HALF_PI - 2 * Math.Atan(ts * (Math.Pow(((1.0 - con) / (1.0 + con))' eccnth))) - chi;                  chi += dphi;                  if (Math.Abs(dphi) <= 0.0000000001)                      return (chi);              }
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e0fn,The following statement contains a magic number: return (1.0 - 0.25 * x * (1.0 + x / 16.0 * (3.0 + 1.25 * x)));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e0fn,The following statement contains a magic number: return (1.0 - 0.25 * x * (1.0 + x / 16.0 * (3.0 + 1.25 * x)));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e0fn,The following statement contains a magic number: return (1.0 - 0.25 * x * (1.0 + x / 16.0 * (3.0 + 1.25 * x)));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e0fn,The following statement contains a magic number: return (1.0 - 0.25 * x * (1.0 + x / 16.0 * (3.0 + 1.25 * x)));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e1fn,The following statement contains a magic number: return (0.375 * x * (1.0 + 0.25 * x * (1.0 + 0.46875 * x)));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e1fn,The following statement contains a magic number: return (0.375 * x * (1.0 + 0.25 * x * (1.0 + 0.46875 * x)));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e1fn,The following statement contains a magic number: return (0.375 * x * (1.0 + 0.25 * x * (1.0 + 0.46875 * x)));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e2fn,The following statement contains a magic number: return (0.05859375 * x * x * (1.0 + 0.75 * x));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e2fn,The following statement contains a magic number: return (0.05859375 * x * x * (1.0 + 0.75 * x));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e3fn,The following statement contains a magic number: return (x * x * x * (35.0 / 3072.0));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,e3fn,The following statement contains a magic number: return (x * x * x * (35.0 / 3072.0));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,mlfn,The following statement contains a magic number: return (e0 * phi - e1 * Math.Sin(2.0 * phi) + e2 * Math.Sin(4.0 * phi) - e3 * Math.Sin(6.0 * phi));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,mlfn,The following statement contains a magic number: return (e0 * phi - e1 * Math.Sin(2.0 * phi) + e2 * Math.Sin(4.0 * phi) - e3 * Math.Sin(6.0 * phi));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,mlfn,The following statement contains a magic number: return (e0 * phi - e1 * Math.Sin(2.0 * phi) + e2 * Math.Sin(4.0 * phi) - e3 * Math.Sin(6.0 * phi));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,calcUtmZone,The following statement contains a magic number: return ((long)(((lon + 180.0) / 6.0) + 1.0));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,calcUtmZone,The following statement contains a magic number: return ((long)(((lon + 180.0) / 6.0) + 1.0));
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LongitudeToRadians,The following statement contains a magic number: if (edge ? (x >= -180 && x <= 180) : (x > -180 && x < 180))                  return MathUtils.Degrees.ToRadians(x);
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LongitudeToRadians,The following statement contains a magic number: if (edge ? (x >= -180 && x <= 180) : (x > -180 && x < 180))                  return MathUtils.Degrees.ToRadians(x);
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LongitudeToRadians,The following statement contains a magic number: if (edge ? (x >= -180 && x <= 180) : (x > -180 && x < 180))                  return MathUtils.Degrees.ToRadians(x);
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LongitudeToRadians,The following statement contains a magic number: if (edge ? (x >= -180 && x <= 180) : (x > -180 && x < 180))                  return MathUtils.Degrees.ToRadians(x);
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LatitudeToRadians,The following statement contains a magic number: if (edge ? (y >= -90 && y <= 90) : (y > -90 && y < 90))                  return MathUtils.Degrees.ToRadians(y);
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LatitudeToRadians,The following statement contains a magic number: if (edge ? (y >= -90 && y <= 90) : (y > -90 && y < 90))                  return MathUtils.Degrees.ToRadians(y);
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LatitudeToRadians,The following statement contains a magic number: if (edge ? (y >= -90 && y <= 90) : (y > -90 && y < 90))                  return MathUtils.Degrees.ToRadians(y);
Magic Number,MapAround.CoordinateSystems.Projections,MapProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Projections\Projections.cs,LatitudeToRadians,The following statement contains a magic number: if (edge ? (y >= -90 && y <= 90) : (y > -90 && y < 90))                  return MathUtils.Degrees.ToRadians(y);
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,getAffineTransformMatrix,The following statement contains a magic number: a[0' 2] = 0;
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,getAffineTransformMatrix,The following statement contains a magic number: a[1' 2] = 0;
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,getAffineTransformMatrix,The following statement contains a magic number: a[2' 2] = 1;
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,getAffineTransformMatrix,The following statement contains a magic number: a[2' 2] = 1;
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,calculateOptimalAffineTransformPoints,The following statement contains a magic number: int[] result = new int[3];
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,calculateOptimalAffineTransformPoints,The following statement contains a magic number: for (int i1 = 0; i1 < _sourceControlPoints.Length - 2; i1++)                  for (int i2 = i1 + 1; i2 < _sourceControlPoints.Length - 1; i2++)                      for (int i3 = i2 + 1; i3 < _sourceControlPoints.Length; i3++)                      {                          ICoordinate p01 = _sourceControlPoints[i1];                          ICoordinate p02 = _sourceControlPoints[i2];                          ICoordinate p03 = _sourceControlPoints[i3];                            ICoordinate p11 = _destinationControlPoints[i1];                          ICoordinate p12 = _destinationControlPoints[i2];                          ICoordinate p13 = _destinationControlPoints[i3];                            Matrix m = getAffineTransformMatrix(p01' p02' p03' p11' p12' p13);                            if (m != null)                          {                              ICoordinate[] tempPoints = new ICoordinate[_sourceControlPoints.Length];                              for (int i = 0; i < _sourceControlPoints.Length; i++)                                  tempPoints[i] = (ICoordinate)_sourceControlPoints[i].Clone();                                Affine affineTransform = new Affine(m);                                for (int i = 0; i < tempPoints.Length; i++)                                  tempPoints[i] =                                       PlanimetryEnvironment.NewCoordinate(                                          affineTransform.Transform(tempPoints[i].Values()));                                double currentNorm = 0;                              for (int i = 0; i < tempPoints.Length; i++)                                  currentNorm += PlanimetryAlgorithms.Distance(_destinationControlPoints[i]' PlanimetryEnvironment.NewCoordinate(tempPoints[i].X' tempPoints[i].Y));                                if (currentNorm < minNorm)                              {                                  minNorm = currentNorm;                                  result[0] = i1;                                  result[1] = i2;                                  result[2] = i3;                              }                          }                      }
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,calculateOptimalAffineTransformPoints,The following statement contains a magic number: for (int i1 = 0; i1 < _sourceControlPoints.Length - 2; i1++)                  for (int i2 = i1 + 1; i2 < _sourceControlPoints.Length - 1; i2++)                      for (int i3 = i2 + 1; i3 < _sourceControlPoints.Length; i3++)                      {                          ICoordinate p01 = _sourceControlPoints[i1];                          ICoordinate p02 = _sourceControlPoints[i2];                          ICoordinate p03 = _sourceControlPoints[i3];                            ICoordinate p11 = _destinationControlPoints[i1];                          ICoordinate p12 = _destinationControlPoints[i2];                          ICoordinate p13 = _destinationControlPoints[i3];                            Matrix m = getAffineTransformMatrix(p01' p02' p03' p11' p12' p13);                            if (m != null)                          {                              ICoordinate[] tempPoints = new ICoordinate[_sourceControlPoints.Length];                              for (int i = 0; i < _sourceControlPoints.Length; i++)                                  tempPoints[i] = (ICoordinate)_sourceControlPoints[i].Clone();                                Affine affineTransform = new Affine(m);                                for (int i = 0; i < tempPoints.Length; i++)                                  tempPoints[i] =                                       PlanimetryEnvironment.NewCoordinate(                                          affineTransform.Transform(tempPoints[i].Values()));                                double currentNorm = 0;                              for (int i = 0; i < tempPoints.Length; i++)                                  currentNorm += PlanimetryAlgorithms.Distance(_destinationControlPoints[i]' PlanimetryEnvironment.NewCoordinate(tempPoints[i].X' tempPoints[i].Y));                                if (currentNorm < minNorm)                              {                                  minNorm = currentNorm;                                  result[0] = i1;                                  result[1] = i2;                                  result[2] = i3;                              }                          }                      }
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,Transform,The following statement contains a magic number: for (int k = 0; k < _sourceControlPoints.Length; k++)              {                  double temp = (maxDistance - distances[k]) / (maxDistance * distances[k]);                  sum += Math.Pow(temp' 2);              }
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,Transform,The following statement contains a magic number: for (int k = 0; k < _sourceControlPoints.Length; k++)              {                  double temp = (maxDistance - distances[k]) / (maxDistance * distances[k]);                  w[k] = Math.Pow(temp' 2) / sum;              }
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,RubberSheetingTransform,The following statement contains a magic number: if (sourceControlPoints.Length < 3)                  throw new ArgumentException("Number of source control points should be equal or greater than three."' "sourceControlPoints");
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,RubberSheetingTransform,The following statement contains a magic number: if (destinationControlPoints.Length < 3)                  throw new ArgumentException("Number of destination control points should be equal or greater than three."' "destinationControlPoints");
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,RubberSheetingTransform,The following statement contains a magic number: _optimalAffineTransform = new Affine(                  getAffineTransformMatrix(                  _sourceControlPoints[_affineTransformPointsIndicies[0]]'                  _sourceControlPoints[_affineTransformPointsIndicies[1]]'                  _sourceControlPoints[_affineTransformPointsIndicies[2]]'                  _destinationControlPoints[_affineTransformPointsIndicies[0]]'                  _destinationControlPoints[_affineTransformPointsIndicies[1]]'                  _destinationControlPoints[_affineTransformPointsIndicies[2]]                  ));
Magic Number,MapAround.CoordinateSystems.Transformations,RubberSheetingTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\RubberSheeting.cs,RubberSheetingTransform,The following statement contains a magic number: _optimalAffineTransform = new Affine(                  getAffineTransformMatrix(                  _sourceControlPoints[_affineTransformPointsIndicies[0]]'                  _sourceControlPoints[_affineTransformPointsIndicies[1]]'                  _sourceControlPoints[_affineTransformPointsIndicies[2]]'                  _destinationControlPoints[_affineTransformPointsIndicies[0]]'                  _destinationControlPoints[_affineTransformPointsIndicies[1]]'                  _destinationControlPoints[_affineTransformPointsIndicies[2]]                  ));
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,GeocentricTransform,The following statement contains a magic number: ses = (Math.Pow(semiMajor' 2) - Math.Pow(semiMinor' 2)) / Math.Pow(semiMinor' 2);
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,GeocentricTransform,The following statement contains a magic number: ses = (Math.Pow(semiMajor' 2) - Math.Pow(semiMinor' 2)) / Math.Pow(semiMinor' 2);
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,GeocentricTransform,The following statement contains a magic number: ses = (Math.Pow(semiMajor' 2) - Math.Pow(semiMinor' 2)) / Math.Pow(semiMinor' 2);
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,DegreesToMeters,The following statement contains a magic number: double h = lonlat.Length < 3 ? 0 : lonlat[2].Equals(Double.NaN) ? 0 : lonlat[2];
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,DegreesToMeters,The following statement contains a magic number: double h = lonlat.Length < 3 ? 0 : lonlat[2].Equals(Double.NaN) ? 0 : lonlat[2];
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,DegreesToMeters,The following statement contains a magic number: double h = lonlat.Length < 3 ? 0 : lonlat[2].Equals(Double.NaN) ? 0 : lonlat[2];
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,DegreesToMeters,The following statement contains a magic number: double v = semiMajor / Math.Sqrt(1 - es * Math.Pow(Math.Sin(lat)' 2));
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,MetersToDegrees,The following statement contains a magic number: double Z = pnt.Length < 3 ? 0 : pnt[2].Equals(Double.NaN) ? 0 : pnt[2];
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,MetersToDegrees,The following statement contains a magic number: double Z = pnt.Length < 3 ? 0 : pnt[2].Equals(Double.NaN) ? 0 : pnt[2];
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,MetersToDegrees,The following statement contains a magic number: double Z = pnt.Length < 3 ? 0 : pnt[2].Equals(Double.NaN) ? 0 : pnt[2];
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,MetersToDegrees,The following statement contains a magic number: if (pnt[0] != 0.0)                  lon = Math.Atan2(pnt[1]' pnt[0]);              else              {                  if (pnt[1] > 0)                      lon = Math.PI / 2;                  else if (pnt[1] < 0)                      lon = -Math.PI * 0.5;                  else                  {                      At_Pole = true;                      lon = 0.0;                      if (Z > 0.0)                      {   /* north pole */                          lat = Math.PI * 0.5;                      }                      else if (Z < 0.0)                      {   /* south pole */                          lat = -Math.PI * 0.5;                      }                      else                      {   /* center of earth */                          return new double[]                           {                               MathUtils.Radians.ToDegrees(lon)'                               MathUtils.Radians.ToDegrees(Math.PI * 0.5)' -semiMinor'                           };                      }                  }              }
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,MetersToDegrees,The following statement contains a magic number: if (pnt[0] != 0.0)                  lon = Math.Atan2(pnt[1]' pnt[0]);              else              {                  if (pnt[1] > 0)                      lon = Math.PI / 2;                  else if (pnt[1] < 0)                      lon = -Math.PI * 0.5;                  else                  {                      At_Pole = true;                      lon = 0.0;                      if (Z > 0.0)                      {   /* north pole */                          lat = Math.PI * 0.5;                      }                      else if (Z < 0.0)                      {   /* south pole */                          lat = -Math.PI * 0.5;                      }                      else                      {   /* center of earth */                          return new double[]                           {                               MathUtils.Radians.ToDegrees(lon)'                               MathUtils.Radians.ToDegrees(Math.PI * 0.5)' -semiMinor'                           };                      }                  }              }
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,MetersToDegrees,The following statement contains a magic number: if (pnt[0] != 0.0)                  lon = Math.Atan2(pnt[1]' pnt[0]);              else              {                  if (pnt[1] > 0)                      lon = Math.PI / 2;                  else if (pnt[1] < 0)                      lon = -Math.PI * 0.5;                  else                  {                      At_Pole = true;                      lon = 0.0;                      if (Z > 0.0)                      {   /* north pole */                          lat = Math.PI * 0.5;                      }                      else if (Z < 0.0)                      {   /* south pole */                          lat = -Math.PI * 0.5;                      }                      else                      {   /* center of earth */                          return new double[]                           {                               MathUtils.Radians.ToDegrees(lon)'                               MathUtils.Radians.ToDegrees(Math.PI * 0.5)' -semiMinor'                           };                      }                  }              }
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,MetersToDegrees,The following statement contains a magic number: if (pnt[0] != 0.0)                  lon = Math.Atan2(pnt[1]' pnt[0]);              else              {                  if (pnt[1] > 0)                      lon = Math.PI / 2;                  else if (pnt[1] < 0)                      lon = -Math.PI * 0.5;                  else                  {                      At_Pole = true;                      lon = 0.0;                      if (Z > 0.0)                      {   /* north pole */                          lat = Math.PI * 0.5;                      }                      else if (Z < 0.0)                      {   /* south pole */                          lat = -Math.PI * 0.5;                      }                      else                      {   /* center of earth */                          return new double[]                           {                               MathUtils.Radians.ToDegrees(lon)'                               MathUtils.Radians.ToDegrees(Math.PI * 0.5)' -semiMinor'                           };                      }                  }              }
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,MetersToDegrees,The following statement contains a magic number: if (pnt[0] != 0.0)                  lon = Math.Atan2(pnt[1]' pnt[0]);              else              {                  if (pnt[1] > 0)                      lon = Math.PI / 2;                  else if (pnt[1] < 0)                      lon = -Math.PI * 0.5;                  else                  {                      At_Pole = true;                      lon = 0.0;                      if (Z > 0.0)                      {   /* north pole */                          lat = Math.PI * 0.5;                      }                      else if (Z < 0.0)                      {   /* south pole */                          lat = -Math.PI * 0.5;                      }                      else                      {   /* center of earth */                          return new double[]                           {                               MathUtils.Radians.ToDegrees(lon)'                               MathUtils.Radians.ToDegrees(Math.PI * 0.5)' -semiMinor'                           };                      }                  }              }
Magic Number,MapAround.CoordinateSystems.Transformations,GeocentricTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,MetersToDegrees,The following statement contains a magic number: double Sin3_B0 = Math.Pow(Sin_B0' 3);
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,apply,The following statement contains a magic number: return new double[] {  				v[0] * p[0] - v[3] * p[1] + v[2] * p[2] + v[4]'  				v[3] * p[0] + v[0] * p[1] - v[1] * p[2] + v[5]'  			   -v[2] * p[0] + v[1] * p[1] + v[0] * p[2] + v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,apply,The following statement contains a magic number: return new double[] {  				v[0] * p[0] - v[3] * p[1] + v[2] * p[2] + v[4]'  				v[3] * p[0] + v[0] * p[1] - v[1] * p[2] + v[5]'  			   -v[2] * p[0] + v[1] * p[1] + v[0] * p[2] + v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,apply,The following statement contains a magic number: return new double[] {  				v[0] * p[0] - v[3] * p[1] + v[2] * p[2] + v[4]'  				v[3] * p[0] + v[0] * p[1] - v[1] * p[2] + v[5]'  			   -v[2] * p[0] + v[1] * p[1] + v[0] * p[2] + v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,apply,The following statement contains a magic number: return new double[] {  				v[0] * p[0] - v[3] * p[1] + v[2] * p[2] + v[4]'  				v[3] * p[0] + v[0] * p[1] - v[1] * p[2] + v[5]'  			   -v[2] * p[0] + v[1] * p[1] + v[0] * p[2] + v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,apply,The following statement contains a magic number: return new double[] {  				v[0] * p[0] - v[3] * p[1] + v[2] * p[2] + v[4]'  				v[3] * p[0] + v[0] * p[1] - v[1] * p[2] + v[5]'  			   -v[2] * p[0] + v[1] * p[1] + v[0] * p[2] + v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,apply,The following statement contains a magic number: return new double[] {  				v[0] * p[0] - v[3] * p[1] + v[2] * p[2] + v[4]'  				v[3] * p[0] + v[0] * p[1] - v[1] * p[2] + v[5]'  			   -v[2] * p[0] + v[1] * p[1] + v[0] * p[2] + v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,apply,The following statement contains a magic number: return new double[] {  				v[0] * p[0] - v[3] * p[1] + v[2] * p[2] + v[4]'  				v[3] * p[0] + v[0] * p[1] - v[1] * p[2] + v[5]'  			   -v[2] * p[0] + v[1] * p[1] + v[0] * p[2] + v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,apply,The following statement contains a magic number: return new double[] {  				v[0] * p[0] - v[3] * p[1] + v[2] * p[2] + v[4]'  				v[3] * p[0] + v[0] * p[1] - v[1] * p[2] + v[5]'  			   -v[2] * p[0] + v[1] * p[1] + v[0] * p[2] + v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,apply,The following statement contains a magic number: return new double[] {  				v[0] * p[0] - v[3] * p[1] + v[2] * p[2] + v[4]'  				v[3] * p[0] + v[0] * p[1] - v[1] * p[2] + v[5]'  			   -v[2] * p[0] + v[1] * p[1] + v[0] * p[2] + v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,apply,The following statement contains a magic number: return new double[] {  				v[0] * p[0] - v[3] * p[1] + v[2] * p[2] + v[4]'  				v[3] * p[0] + v[0] * p[1] - v[1] * p[2] + v[5]'  			   -v[2] * p[0] + v[1] * p[1] + v[0] * p[2] + v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,applyInverted,The following statement contains a magic number: return new double[] {  				v[0] * p[0] + v[3] * p[1] - v[2] * p[2] - v[4]'  			   -v[3] * p[0] + v[0] * p[1] + v[1] * p[2] - v[5]'  			    v[2] * p[0] - v[1] * p[1] + v[0] * p[2] - v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,applyInverted,The following statement contains a magic number: return new double[] {  				v[0] * p[0] + v[3] * p[1] - v[2] * p[2] - v[4]'  			   -v[3] * p[0] + v[0] * p[1] + v[1] * p[2] - v[5]'  			    v[2] * p[0] - v[1] * p[1] + v[0] * p[2] - v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,applyInverted,The following statement contains a magic number: return new double[] {  				v[0] * p[0] + v[3] * p[1] - v[2] * p[2] - v[4]'  			   -v[3] * p[0] + v[0] * p[1] + v[1] * p[2] - v[5]'  			    v[2] * p[0] - v[1] * p[1] + v[0] * p[2] - v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,applyInverted,The following statement contains a magic number: return new double[] {  				v[0] * p[0] + v[3] * p[1] - v[2] * p[2] - v[4]'  			   -v[3] * p[0] + v[0] * p[1] + v[1] * p[2] - v[5]'  			    v[2] * p[0] - v[1] * p[1] + v[0] * p[2] - v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,applyInverted,The following statement contains a magic number: return new double[] {  				v[0] * p[0] + v[3] * p[1] - v[2] * p[2] - v[4]'  			   -v[3] * p[0] + v[0] * p[1] + v[1] * p[2] - v[5]'  			    v[2] * p[0] - v[1] * p[1] + v[0] * p[2] - v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,applyInverted,The following statement contains a magic number: return new double[] {  				v[0] * p[0] + v[3] * p[1] - v[2] * p[2] - v[4]'  			   -v[3] * p[0] + v[0] * p[1] + v[1] * p[2] - v[5]'  			    v[2] * p[0] - v[1] * p[1] + v[0] * p[2] - v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,applyInverted,The following statement contains a magic number: return new double[] {  				v[0] * p[0] + v[3] * p[1] - v[2] * p[2] - v[4]'  			   -v[3] * p[0] + v[0] * p[1] + v[1] * p[2] - v[5]'  			    v[2] * p[0] - v[1] * p[1] + v[0] * p[2] - v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,applyInverted,The following statement contains a magic number: return new double[] {  				v[0] * p[0] + v[3] * p[1] - v[2] * p[2] - v[4]'  			   -v[3] * p[0] + v[0] * p[1] + v[1] * p[2] - v[5]'  			    v[2] * p[0] - v[1] * p[1] + v[0] * p[2] - v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,applyInverted,The following statement contains a magic number: return new double[] {  				v[0] * p[0] + v[3] * p[1] - v[2] * p[2] - v[4]'  			   -v[3] * p[0] + v[0] * p[1] + v[1] * p[2] - v[5]'  			    v[2] * p[0] - v[1] * p[1] + v[0] * p[2] - v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,DatumTransform,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,applyInverted,The following statement contains a magic number: return new double[] {  				v[0] * p[0] + v[3] * p[1] - v[2] * p[2] - v[4]'  			   -v[3] * p[0] + v[0] * p[1] + v[1] * p[2] - v[5]'  			    v[2] * p[0] - v[1] * p[1] + v[0] * p[2] - v[6]' };
Magic Number,MapAround.CoordinateSystems.Transformations,CoordinateTransformationFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformations.cs,CreateCoordinateOperation,The following statement contains a magic number: List<ProjectionParameter> parameterList = new List<ProjectionParameter>(2);
Magic Number,MapAround.CoordinateSystems.Transformations,GeometryTransformer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformers.cs,TransformBoundingRectangle,The following statement contains a magic number: ICoordinate[] corners = new ICoordinate[4];
Magic Number,MapAround.CoordinateSystems.Transformations,GeometryTransformer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformers.cs,TransformBoundingRectangle,The following statement contains a magic number: corners[2] = PlanimetryEnvironment.NewCoordinate(transform.Transform(PlanimetryEnvironment.NewCoordinate(box.MinX' box.MaxY).Values()));
Magic Number,MapAround.CoordinateSystems.Transformations,GeometryTransformer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformers.cs,TransformBoundingRectangle,The following statement contains a magic number: corners[3] = PlanimetryEnvironment.NewCoordinate(transform.Transform(PlanimetryEnvironment.NewCoordinate(box.MaxX' box.MinY).Values()));
Magic Number,MapAround.CoordinateSystems.Transformations,GeometryTransformer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformers.cs,TransformBoundingRectangle,The following statement contains a magic number: for (int i = 0; i < 4; i++)                  result.Join(corners[i]);
Magic Number,MapAround.CoordinateSystems.Transformations,GeometryTransformer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformers.cs,TransformMultiPoint,The following statement contains a magic number: for (int i = 0; i < multiPoint.Points.Count; i++)                  points.Add(new double[2] { multiPoint.Points[i].X' multiPoint.Points[i].Y });
Magic Number,MapAround.CoordinateSystems.Transformations,GeometryTransformer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformers.cs,TransformContour,The following statement contains a magic number: for (int i = 0; i < contour.Vertices.Count; i++)                  points.Add(new double[2] { contour.Vertices[i].X' contour.Vertices[i].Y });
Magic Number,MapAround.CoordinateSystems.Transformations,GeometryTransformer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformers.cs,TransformLinePath,The following statement contains a magic number: for (int i = 0; i < linePath.Vertices.Count; i++)                  points.Add(new double[2] { linePath.Vertices[i].X' linePath.Vertices[i].Y });
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: int delta = 2;
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: if (p.Length % 3 == 0)                  delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: if (p.Length % 3 == 0)                  delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double p1 = MathUtils.Degrees.ToRadians(p[i]);                  double p2 = MathUtils.Degrees.ToRadians(p[i + 1]);                    result[i + 1] = _cy * p2;                  result[i] = _cx * p1 * (_ca + asqrt(1 - _cb * p2 * p2));              }
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double p1 = MathUtils.Degrees.ToRadians(p[i]);                  double p2 = MathUtils.Degrees.ToRadians(p[i + 1]);                    result[i + 1] = _cy * p2;                  result[i] = _cx * p1 * (_ca + asqrt(1 - _cb * p2 * p2));              }
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double p1 = MathUtils.Degrees.ToRadians(p[i]);                  double p2 = MathUtils.Degrees.ToRadians(p[i + 1]);                    result[i + 1] = _cy * p2;                  result[i] = _cx * p1 * (_ca + asqrt(1 - _cb * p2 * p2));              }
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double p1 = MathUtils.Degrees.ToRadians(p[i]);                  double p2 = MathUtils.Degrees.ToRadians(p[i + 1]);                    result[i + 1] = _cy * p2;                  result[i] = _cx * p1 * (_ca + asqrt(1 - _cb * p2 * p2));              }
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: int delta = 2;
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: if (p.Length % 3 == 0)                  delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: if (p.Length % 3 == 0)                  delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double r2 = p[i + 1] / _cy;                  double r1 = p[i] / (_cx * (_ca + asqrt(1 - _cb * r2 * r2)));                    result[i] = MathUtils.Radians.ToDegrees(r1);                  result[i + 1] = MathUtils.Radians.ToDegrees(r2);              }
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double r2 = p[i + 1] / _cy;                  double r1 = p[i] / (_cx * (_ca + asqrt(1 - _cb * r2 * r2)));                    result[i] = MathUtils.Radians.ToDegrees(r1);                  result[i + 1] = MathUtils.Radians.ToDegrees(r2);              }
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double r2 = p[i + 1] / _cy;                  double r1 = p[i] / (_cx * (_ca + asqrt(1 - _cb * r2 * r2)));                    result[i] = MathUtils.Radians.ToDegrees(r1);                  result[i + 1] = MathUtils.Radians.ToDegrees(r2);              }
Magic Number,MapAround.CoordinateSystems.Transformations,Wagner6,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double r2 = p[i + 1] / _cy;                  double r1 = p[i] / (_cx * (_ca + asqrt(1 - _cb * r2 * r2)));                    result[i] = MathUtils.Radians.ToDegrees(r1);                  result[i + 1] = MathUtils.Radians.ToDegrees(r2);              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: int delta = 2;
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: if (p.Length % 3 == 0)                  delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: if (p.Length % 3 == 0)                  delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double p1 = MathUtils.Degrees.ToRadians(p[i]);                  double p2 = MathUtils.Degrees.ToRadians(p[i + 1]);                    double dphi;                    int nodeIndex = (int)Math.Floor((dphi = Math.Abs(p2)) * _c1);                    if (nodeIndex >= _nodes)                      nodeIndex = _nodes - 1;                    dphi = MathUtils.Radians.ToDegrees(dphi - _rc1 * nodeIndex);                  result[i] = V(_x' nodeIndex * 4' dphi) * _fxc * p1;                  result[i + 1] = V(_y' nodeIndex * 4' dphi) * _fyc;                    if (p2 < 0)                      result[i + 1] = -result[i + 1];              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double p1 = MathUtils.Degrees.ToRadians(p[i]);                  double p2 = MathUtils.Degrees.ToRadians(p[i + 1]);                    double dphi;                    int nodeIndex = (int)Math.Floor((dphi = Math.Abs(p2)) * _c1);                    if (nodeIndex >= _nodes)                      nodeIndex = _nodes - 1;                    dphi = MathUtils.Radians.ToDegrees(dphi - _rc1 * nodeIndex);                  result[i] = V(_x' nodeIndex * 4' dphi) * _fxc * p1;                  result[i + 1] = V(_y' nodeIndex * 4' dphi) * _fyc;                    if (p2 < 0)                      result[i + 1] = -result[i + 1];              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double p1 = MathUtils.Degrees.ToRadians(p[i]);                  double p2 = MathUtils.Degrees.ToRadians(p[i + 1]);                    double dphi;                    int nodeIndex = (int)Math.Floor((dphi = Math.Abs(p2)) * _c1);                    if (nodeIndex >= _nodes)                      nodeIndex = _nodes - 1;                    dphi = MathUtils.Radians.ToDegrees(dphi - _rc1 * nodeIndex);                  result[i] = V(_x' nodeIndex * 4' dphi) * _fxc * p1;                  result[i + 1] = V(_y' nodeIndex * 4' dphi) * _fyc;                    if (p2 < 0)                      result[i + 1] = -result[i + 1];              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double p1 = MathUtils.Degrees.ToRadians(p[i]);                  double p2 = MathUtils.Degrees.ToRadians(p[i + 1]);                    double dphi;                    int nodeIndex = (int)Math.Floor((dphi = Math.Abs(p2)) * _c1);                    if (nodeIndex >= _nodes)                      nodeIndex = _nodes - 1;                    dphi = MathUtils.Radians.ToDegrees(dphi - _rc1 * nodeIndex);                  result[i] = V(_x' nodeIndex * 4' dphi) * _fxc * p1;                  result[i + 1] = V(_y' nodeIndex * 4' dphi) * _fyc;                    if (p2 < 0)                      result[i + 1] = -result[i + 1];              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double p1 = MathUtils.Degrees.ToRadians(p[i]);                  double p2 = MathUtils.Degrees.ToRadians(p[i + 1]);                    double dphi;                    int nodeIndex = (int)Math.Floor((dphi = Math.Abs(p2)) * _c1);                    if (nodeIndex >= _nodes)                      nodeIndex = _nodes - 1;                    dphi = MathUtils.Radians.ToDegrees(dphi - _rc1 * nodeIndex);                  result[i] = V(_x' nodeIndex * 4' dphi) * _fxc * p1;                  result[i + 1] = V(_y' nodeIndex * 4' dphi) * _fyc;                    if (p2 < 0)                      result[i + 1] = -result[i + 1];              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double p1 = MathUtils.Degrees.ToRadians(p[i]);                  double p2 = MathUtils.Degrees.ToRadians(p[i + 1]);                    double dphi;                    int nodeIndex = (int)Math.Floor((dphi = Math.Abs(p2)) * _c1);                    if (nodeIndex >= _nodes)                      nodeIndex = _nodes - 1;                    dphi = MathUtils.Radians.ToDegrees(dphi - _rc1 * nodeIndex);                  result[i] = V(_x' nodeIndex * 4' dphi) * _fxc * p1;                  result[i + 1] = V(_y' nodeIndex * 4' dphi) * _fyc;                    if (p2 < 0)                      result[i + 1] = -result[i + 1];              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: int delta = 2;
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: if (p.Length % 3 == 0)                  delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: if (p.Length % 3 == 0)                  delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double[] T = new double[4];                    result[i] = p[i] / _fxc;                  result[i + 1] = Math.Abs(p[i + 1] / _fyc);                  if (result[i + 1] >= 1)                  {                      if (result[i + 1] > _oneTolerance)                          throw new ApplicationException();                        result[i + 1] =                          p[i + 1] < 0 ? -Math.PI * 0.5 : Math.PI * 0.5;                      result[i] /= _x[_nodes * 4];                  }                  else                  {                      int k;                      for (k = (int)Math.Floor(result[i + 1] * _nodes); k < 100000; )                      {                          if (_y[k * 4] > result[i + 1])                              --k;                          else                              if (_y[(k + 1) * 4] <= result[i + 1])                                  ++k;                              else                                  break;                      }                      Array.Copy(_y' k * 4' T' 0' 4);                      double t = 5 * (result[i + 1] - T[0]) / (_y[(k + 1) * 4] - T[0]);                      T[0] -= result[i + 1];                      while (true)                      {                          double t1 = V(T' 0' t) / DV(T' 0' t);                          t -= t1;                          if (Math.Abs(t1) < _rolerance)                              break;                      }                        result[i + 1] = 5 * k + t;                      if (p[i + 1] < 0)                          result[i + 1] = -result[i + 1];                      result[i] /= V(_x' (k * 4)' t);                  }                    result[i] = MathUtils.Radians.ToDegrees(result[i]);              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double[] T = new double[4];                    result[i] = p[i] / _fxc;                  result[i + 1] = Math.Abs(p[i + 1] / _fyc);                  if (result[i + 1] >= 1)                  {                      if (result[i + 1] > _oneTolerance)                          throw new ApplicationException();                        result[i + 1] =                          p[i + 1] < 0 ? -Math.PI * 0.5 : Math.PI * 0.5;                      result[i] /= _x[_nodes * 4];                  }                  else                  {                      int k;                      for (k = (int)Math.Floor(result[i + 1] * _nodes); k < 100000; )                      {                          if (_y[k * 4] > result[i + 1])                              --k;                          else                              if (_y[(k + 1) * 4] <= result[i + 1])                                  ++k;                              else                                  break;                      }                      Array.Copy(_y' k * 4' T' 0' 4);                      double t = 5 * (result[i + 1] - T[0]) / (_y[(k + 1) * 4] - T[0]);                      T[0] -= result[i + 1];                      while (true)                      {                          double t1 = V(T' 0' t) / DV(T' 0' t);                          t -= t1;                          if (Math.Abs(t1) < _rolerance)                              break;                      }                        result[i + 1] = 5 * k + t;                      if (p[i + 1] < 0)                          result[i + 1] = -result[i + 1];                      result[i] /= V(_x' (k * 4)' t);                  }                    result[i] = MathUtils.Radians.ToDegrees(result[i]);              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double[] T = new double[4];                    result[i] = p[i] / _fxc;                  result[i + 1] = Math.Abs(p[i + 1] / _fyc);                  if (result[i + 1] >= 1)                  {                      if (result[i + 1] > _oneTolerance)                          throw new ApplicationException();                        result[i + 1] =                          p[i + 1] < 0 ? -Math.PI * 0.5 : Math.PI * 0.5;                      result[i] /= _x[_nodes * 4];                  }                  else                  {                      int k;                      for (k = (int)Math.Floor(result[i + 1] * _nodes); k < 100000; )                      {                          if (_y[k * 4] > result[i + 1])                              --k;                          else                              if (_y[(k + 1) * 4] <= result[i + 1])                                  ++k;                              else                                  break;                      }                      Array.Copy(_y' k * 4' T' 0' 4);                      double t = 5 * (result[i + 1] - T[0]) / (_y[(k + 1) * 4] - T[0]);                      T[0] -= result[i + 1];                      while (true)                      {                          double t1 = V(T' 0' t) / DV(T' 0' t);                          t -= t1;                          if (Math.Abs(t1) < _rolerance)                              break;                      }                        result[i + 1] = 5 * k + t;                      if (p[i + 1] < 0)                          result[i + 1] = -result[i + 1];                      result[i] /= V(_x' (k * 4)' t);                  }                    result[i] = MathUtils.Radians.ToDegrees(result[i]);              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double[] T = new double[4];                    result[i] = p[i] / _fxc;                  result[i + 1] = Math.Abs(p[i + 1] / _fyc);                  if (result[i + 1] >= 1)                  {                      if (result[i + 1] > _oneTolerance)                          throw new ApplicationException();                        result[i + 1] =                          p[i + 1] < 0 ? -Math.PI * 0.5 : Math.PI * 0.5;                      result[i] /= _x[_nodes * 4];                  }                  else                  {                      int k;                      for (k = (int)Math.Floor(result[i + 1] * _nodes); k < 100000; )                      {                          if (_y[k * 4] > result[i + 1])                              --k;                          else                              if (_y[(k + 1) * 4] <= result[i + 1])                                  ++k;                              else                                  break;                      }                      Array.Copy(_y' k * 4' T' 0' 4);                      double t = 5 * (result[i + 1] - T[0]) / (_y[(k + 1) * 4] - T[0]);                      T[0] -= result[i + 1];                      while (true)                      {                          double t1 = V(T' 0' t) / DV(T' 0' t);                          t -= t1;                          if (Math.Abs(t1) < _rolerance)                              break;                      }                        result[i + 1] = 5 * k + t;                      if (p[i + 1] < 0)                          result[i + 1] = -result[i + 1];                      result[i] /= V(_x' (k * 4)' t);                  }                    result[i] = MathUtils.Radians.ToDegrees(result[i]);              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double[] T = new double[4];                    result[i] = p[i] / _fxc;                  result[i + 1] = Math.Abs(p[i + 1] / _fyc);                  if (result[i + 1] >= 1)                  {                      if (result[i + 1] > _oneTolerance)                          throw new ApplicationException();                        result[i + 1] =                          p[i + 1] < 0 ? -Math.PI * 0.5 : Math.PI * 0.5;                      result[i] /= _x[_nodes * 4];                  }                  else                  {                      int k;                      for (k = (int)Math.Floor(result[i + 1] * _nodes); k < 100000; )                      {                          if (_y[k * 4] > result[i + 1])                              --k;                          else                              if (_y[(k + 1) * 4] <= result[i + 1])                                  ++k;                              else                                  break;                      }                      Array.Copy(_y' k * 4' T' 0' 4);                      double t = 5 * (result[i + 1] - T[0]) / (_y[(k + 1) * 4] - T[0]);                      T[0] -= result[i + 1];                      while (true)                      {                          double t1 = V(T' 0' t) / DV(T' 0' t);                          t -= t1;                          if (Math.Abs(t1) < _rolerance)                              break;                      }                        result[i + 1] = 5 * k + t;                      if (p[i + 1] < 0)                          result[i + 1] = -result[i + 1];                      result[i] /= V(_x' (k * 4)' t);                  }                    result[i] = MathUtils.Radians.ToDegrees(result[i]);              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double[] T = new double[4];                    result[i] = p[i] / _fxc;                  result[i + 1] = Math.Abs(p[i + 1] / _fyc);                  if (result[i + 1] >= 1)                  {                      if (result[i + 1] > _oneTolerance)                          throw new ApplicationException();                        result[i + 1] =                          p[i + 1] < 0 ? -Math.PI * 0.5 : Math.PI * 0.5;                      result[i] /= _x[_nodes * 4];                  }                  else                  {                      int k;                      for (k = (int)Math.Floor(result[i + 1] * _nodes); k < 100000; )                      {                          if (_y[k * 4] > result[i + 1])                              --k;                          else                              if (_y[(k + 1) * 4] <= result[i + 1])                                  ++k;                              else                                  break;                      }                      Array.Copy(_y' k * 4' T' 0' 4);                      double t = 5 * (result[i + 1] - T[0]) / (_y[(k + 1) * 4] - T[0]);                      T[0] -= result[i + 1];                      while (true)                      {                          double t1 = V(T' 0' t) / DV(T' 0' t);                          t -= t1;                          if (Math.Abs(t1) < _rolerance)                              break;                      }                        result[i + 1] = 5 * k + t;                      if (p[i + 1] < 0)                          result[i + 1] = -result[i + 1];                      result[i] /= V(_x' (k * 4)' t);                  }                    result[i] = MathUtils.Radians.ToDegrees(result[i]);              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double[] T = new double[4];                    result[i] = p[i] / _fxc;                  result[i + 1] = Math.Abs(p[i + 1] / _fyc);                  if (result[i + 1] >= 1)                  {                      if (result[i + 1] > _oneTolerance)                          throw new ApplicationException();                        result[i + 1] =                          p[i + 1] < 0 ? -Math.PI * 0.5 : Math.PI * 0.5;                      result[i] /= _x[_nodes * 4];                  }                  else                  {                      int k;                      for (k = (int)Math.Floor(result[i + 1] * _nodes); k < 100000; )                      {                          if (_y[k * 4] > result[i + 1])                              --k;                          else                              if (_y[(k + 1) * 4] <= result[i + 1])                                  ++k;                              else                                  break;                      }                      Array.Copy(_y' k * 4' T' 0' 4);                      double t = 5 * (result[i + 1] - T[0]) / (_y[(k + 1) * 4] - T[0]);                      T[0] -= result[i + 1];                      while (true)                      {                          double t1 = V(T' 0' t) / DV(T' 0' t);                          t -= t1;                          if (Math.Abs(t1) < _rolerance)                              break;                      }                        result[i + 1] = 5 * k + t;                      if (p[i + 1] < 0)                          result[i + 1] = -result[i + 1];                      result[i] /= V(_x' (k * 4)' t);                  }                    result[i] = MathUtils.Radians.ToDegrees(result[i]);              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double[] T = new double[4];                    result[i] = p[i] / _fxc;                  result[i + 1] = Math.Abs(p[i + 1] / _fyc);                  if (result[i + 1] >= 1)                  {                      if (result[i + 1] > _oneTolerance)                          throw new ApplicationException();                        result[i + 1] =                          p[i + 1] < 0 ? -Math.PI * 0.5 : Math.PI * 0.5;                      result[i] /= _x[_nodes * 4];                  }                  else                  {                      int k;                      for (k = (int)Math.Floor(result[i + 1] * _nodes); k < 100000; )                      {                          if (_y[k * 4] > result[i + 1])                              --k;                          else                              if (_y[(k + 1) * 4] <= result[i + 1])                                  ++k;                              else                                  break;                      }                      Array.Copy(_y' k * 4' T' 0' 4);                      double t = 5 * (result[i + 1] - T[0]) / (_y[(k + 1) * 4] - T[0]);                      T[0] -= result[i + 1];                      while (true)                      {                          double t1 = V(T' 0' t) / DV(T' 0' t);                          t -= t1;                          if (Math.Abs(t1) < _rolerance)                              break;                      }                        result[i + 1] = 5 * k + t;                      if (p[i + 1] < 0)                          result[i + 1] = -result[i + 1];                      result[i] /= V(_x' (k * 4)' t);                  }                    result[i] = MathUtils.Radians.ToDegrees(result[i]);              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double[] T = new double[4];                    result[i] = p[i] / _fxc;                  result[i + 1] = Math.Abs(p[i + 1] / _fyc);                  if (result[i + 1] >= 1)                  {                      if (result[i + 1] > _oneTolerance)                          throw new ApplicationException();                        result[i + 1] =                          p[i + 1] < 0 ? -Math.PI * 0.5 : Math.PI * 0.5;                      result[i] /= _x[_nodes * 4];                  }                  else                  {                      int k;                      for (k = (int)Math.Floor(result[i + 1] * _nodes); k < 100000; )                      {                          if (_y[k * 4] > result[i + 1])                              --k;                          else                              if (_y[(k + 1) * 4] <= result[i + 1])                                  ++k;                              else                                  break;                      }                      Array.Copy(_y' k * 4' T' 0' 4);                      double t = 5 * (result[i + 1] - T[0]) / (_y[(k + 1) * 4] - T[0]);                      T[0] -= result[i + 1];                      while (true)                      {                          double t1 = V(T' 0' t) / DV(T' 0' t);                          t -= t1;                          if (Math.Abs(t1) < _rolerance)                              break;                      }                        result[i + 1] = 5 * k + t;                      if (p[i + 1] < 0)                          result[i + 1] = -result[i + 1];                      result[i] /= V(_x' (k * 4)' t);                  }                    result[i] = MathUtils.Radians.ToDegrees(result[i]);              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double[] T = new double[4];                    result[i] = p[i] / _fxc;                  result[i + 1] = Math.Abs(p[i + 1] / _fyc);                  if (result[i + 1] >= 1)                  {                      if (result[i + 1] > _oneTolerance)                          throw new ApplicationException();                        result[i + 1] =                          p[i + 1] < 0 ? -Math.PI * 0.5 : Math.PI * 0.5;                      result[i] /= _x[_nodes * 4];                  }                  else                  {                      int k;                      for (k = (int)Math.Floor(result[i + 1] * _nodes); k < 100000; )                      {                          if (_y[k * 4] > result[i + 1])                              --k;                          else                              if (_y[(k + 1) * 4] <= result[i + 1])                                  ++k;                              else                                  break;                      }                      Array.Copy(_y' k * 4' T' 0' 4);                      double t = 5 * (result[i + 1] - T[0]) / (_y[(k + 1) * 4] - T[0]);                      T[0] -= result[i + 1];                      while (true)                      {                          double t1 = V(T' 0' t) / DV(T' 0' t);                          t -= t1;                          if (Math.Abs(t1) < _rolerance)                              break;                      }                        result[i + 1] = 5 * k + t;                      if (p[i + 1] < 0)                          result[i + 1] = -result[i + 1];                      result[i] /= V(_x' (k * 4)' t);                  }                    result[i] = MathUtils.Radians.ToDegrees(result[i]);              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double[] T = new double[4];                    result[i] = p[i] / _fxc;                  result[i + 1] = Math.Abs(p[i + 1] / _fyc);                  if (result[i + 1] >= 1)                  {                      if (result[i + 1] > _oneTolerance)                          throw new ApplicationException();                        result[i + 1] =                          p[i + 1] < 0 ? -Math.PI * 0.5 : Math.PI * 0.5;                      result[i] /= _x[_nodes * 4];                  }                  else                  {                      int k;                      for (k = (int)Math.Floor(result[i + 1] * _nodes); k < 100000; )                      {                          if (_y[k * 4] > result[i + 1])                              --k;                          else                              if (_y[(k + 1) * 4] <= result[i + 1])                                  ++k;                              else                                  break;                      }                      Array.Copy(_y' k * 4' T' 0' 4);                      double t = 5 * (result[i + 1] - T[0]) / (_y[(k + 1) * 4] - T[0]);                      T[0] -= result[i + 1];                      while (true)                      {                          double t1 = V(T' 0' t) / DV(T' 0' t);                          t -= t1;                          if (Math.Abs(t1) < _rolerance)                              break;                      }                        result[i + 1] = 5 * k + t;                      if (p[i + 1] < 0)                          result[i + 1] = -result[i + 1];                      result[i] /= V(_x' (k * 4)' t);                  }                    result[i] = MathUtils.Radians.ToDegrees(result[i]);              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double[] T = new double[4];                    result[i] = p[i] / _fxc;                  result[i + 1] = Math.Abs(p[i + 1] / _fyc);                  if (result[i + 1] >= 1)                  {                      if (result[i + 1] > _oneTolerance)                          throw new ApplicationException();                        result[i + 1] =                          p[i + 1] < 0 ? -Math.PI * 0.5 : Math.PI * 0.5;                      result[i] /= _x[_nodes * 4];                  }                  else                  {                      int k;                      for (k = (int)Math.Floor(result[i + 1] * _nodes); k < 100000; )                      {                          if (_y[k * 4] > result[i + 1])                              --k;                          else                              if (_y[(k + 1) * 4] <= result[i + 1])                                  ++k;                              else                                  break;                      }                      Array.Copy(_y' k * 4' T' 0' 4);                      double t = 5 * (result[i + 1] - T[0]) / (_y[(k + 1) * 4] - T[0]);                      T[0] -= result[i + 1];                      while (true)                      {                          double t1 = V(T' 0' t) / DV(T' 0' t);                          t -= t1;                          if (Math.Abs(t1) < _rolerance)                              break;                      }                        result[i + 1] = 5 * k + t;                      if (p[i + 1] < 0)                          result[i + 1] = -result[i + 1];                      result[i] /= V(_x' (k * 4)' t);                  }                    result[i] = MathUtils.Radians.ToDegrees(result[i]);              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double[] T = new double[4];                    result[i] = p[i] / _fxc;                  result[i + 1] = Math.Abs(p[i + 1] / _fyc);                  if (result[i + 1] >= 1)                  {                      if (result[i + 1] > _oneTolerance)                          throw new ApplicationException();                        result[i + 1] =                          p[i + 1] < 0 ? -Math.PI * 0.5 : Math.PI * 0.5;                      result[i] /= _x[_nodes * 4];                  }                  else                  {                      int k;                      for (k = (int)Math.Floor(result[i + 1] * _nodes); k < 100000; )                      {                          if (_y[k * 4] > result[i + 1])                              --k;                          else                              if (_y[(k + 1) * 4] <= result[i + 1])                                  ++k;                              else                                  break;                      }                      Array.Copy(_y' k * 4' T' 0' 4);                      double t = 5 * (result[i + 1] - T[0]) / (_y[(k + 1) * 4] - T[0]);                      T[0] -= result[i + 1];                      while (true)                      {                          double t1 = V(T' 0' t) / DV(T' 0' t);                          t -= t1;                          if (Math.Abs(t1) < _rolerance)                              break;                      }                        result[i + 1] = 5 * k + t;                      if (p[i + 1] < 0)                          result[i + 1] = -result[i + 1];                      result[i] /= V(_x' (k * 4)' t);                  }                    result[i] = MathUtils.Radians.ToDegrees(result[i]);              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double[] T = new double[4];                    result[i] = p[i] / _fxc;                  result[i + 1] = Math.Abs(p[i + 1] / _fyc);                  if (result[i + 1] >= 1)                  {                      if (result[i + 1] > _oneTolerance)                          throw new ApplicationException();                        result[i + 1] =                          p[i + 1] < 0 ? -Math.PI * 0.5 : Math.PI * 0.5;                      result[i] /= _x[_nodes * 4];                  }                  else                  {                      int k;                      for (k = (int)Math.Floor(result[i + 1] * _nodes); k < 100000; )                      {                          if (_y[k * 4] > result[i + 1])                              --k;                          else                              if (_y[(k + 1) * 4] <= result[i + 1])                                  ++k;                              else                                  break;                      }                      Array.Copy(_y' k * 4' T' 0' 4);                      double t = 5 * (result[i + 1] - T[0]) / (_y[(k + 1) * 4] - T[0]);                      T[0] -= result[i + 1];                      while (true)                      {                          double t1 = V(T' 0' t) / DV(T' 0' t);                          t -= t1;                          if (Math.Abs(t1) < _rolerance)                              break;                      }                        result[i + 1] = 5 * k + t;                      if (p[i + 1] < 0)                          result[i + 1] = -result[i + 1];                      result[i] /= V(_x' (k * 4)' t);                  }                    result[i] = MathUtils.Radians.ToDegrees(result[i]);              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double[] T = new double[4];                    result[i] = p[i] / _fxc;                  result[i + 1] = Math.Abs(p[i + 1] / _fyc);                  if (result[i + 1] >= 1)                  {                      if (result[i + 1] > _oneTolerance)                          throw new ApplicationException();                        result[i + 1] =                          p[i + 1] < 0 ? -Math.PI * 0.5 : Math.PI * 0.5;                      result[i] /= _x[_nodes * 4];                  }                  else                  {                      int k;                      for (k = (int)Math.Floor(result[i + 1] * _nodes); k < 100000; )                      {                          if (_y[k * 4] > result[i + 1])                              --k;                          else                              if (_y[(k + 1) * 4] <= result[i + 1])                                  ++k;                              else                                  break;                      }                      Array.Copy(_y' k * 4' T' 0' 4);                      double t = 5 * (result[i + 1] - T[0]) / (_y[(k + 1) * 4] - T[0]);                      T[0] -= result[i + 1];                      while (true)                      {                          double t1 = V(T' 0' t) / DV(T' 0' t);                          t -= t1;                          if (Math.Abs(t1) < _rolerance)                              break;                      }                        result[i + 1] = 5 * k + t;                      if (p[i + 1] < 0)                          result[i + 1] = -result[i + 1];                      result[i] /= V(_x' (k * 4)' t);                  }                    result[i] = MathUtils.Radians.ToDegrees(result[i]);              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double[] T = new double[4];                    result[i] = p[i] / _fxc;                  result[i + 1] = Math.Abs(p[i + 1] / _fyc);                  if (result[i + 1] >= 1)                  {                      if (result[i + 1] > _oneTolerance)                          throw new ApplicationException();                        result[i + 1] =                          p[i + 1] < 0 ? -Math.PI * 0.5 : Math.PI * 0.5;                      result[i] /= _x[_nodes * 4];                  }                  else                  {                      int k;                      for (k = (int)Math.Floor(result[i + 1] * _nodes); k < 100000; )                      {                          if (_y[k * 4] > result[i + 1])                              --k;                          else                              if (_y[(k + 1) * 4] <= result[i + 1])                                  ++k;                              else                                  break;                      }                      Array.Copy(_y' k * 4' T' 0' 4);                      double t = 5 * (result[i + 1] - T[0]) / (_y[(k + 1) * 4] - T[0]);                      T[0] -= result[i + 1];                      while (true)                      {                          double t1 = V(T' 0' t) / DV(T' 0' t);                          t -= t1;                          if (Math.Abs(t1) < _rolerance)                              break;                      }                        result[i + 1] = 5 * k + t;                      if (p[i + 1] < 0)                          result[i + 1] = -result[i + 1];                      result[i] /= V(_x' (k * 4)' t);                  }                    result[i] = MathUtils.Radians.ToDegrees(result[i]);              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    double[] T = new double[4];                    result[i] = p[i] / _fxc;                  result[i + 1] = Math.Abs(p[i + 1] / _fyc);                  if (result[i + 1] >= 1)                  {                      if (result[i + 1] > _oneTolerance)                          throw new ApplicationException();                        result[i + 1] =                          p[i + 1] < 0 ? -Math.PI * 0.5 : Math.PI * 0.5;                      result[i] /= _x[_nodes * 4];                  }                  else                  {                      int k;                      for (k = (int)Math.Floor(result[i + 1] * _nodes); k < 100000; )                      {                          if (_y[k * 4] > result[i + 1])                              --k;                          else                              if (_y[(k + 1) * 4] <= result[i + 1])                                  ++k;                              else                                  break;                      }                      Array.Copy(_y' k * 4' T' 0' 4);                      double t = 5 * (result[i + 1] - T[0]) / (_y[(k + 1) * 4] - T[0]);                      T[0] -= result[i + 1];                      while (true)                      {                          double t1 = V(T' 0' t) / DV(T' 0' t);                          t -= t1;                          if (Math.Abs(t1) < _rolerance)                              break;                      }                        result[i + 1] = 5 * k + t;                      if (p[i + 1] < 0)                          result[i + 1] = -result[i + 1];                      result[i] /= V(_x' (k * 4)' t);                  }                    result[i] = MathUtils.Radians.ToDegrees(result[i]);              }
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,V,The following statement contains a magic number: return C[iStart] + z * (C[iStart + 1] + z * (C[iStart + 2] + z * C[iStart + 3]));
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,V,The following statement contains a magic number: return C[iStart] + z * (C[iStart + 1] + z * (C[iStart + 2] + z * C[iStart + 3]));
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,DV,The following statement contains a magic number: return C[iStart + 1] + z * (C[iStart + 2] + C[iStart + 2] + z * 3 * C[iStart + 3]);
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,DV,The following statement contains a magic number: return C[iStart + 1] + z * (C[iStart + 2] + C[iStart + 2] + z * 3 * C[iStart + 3]);
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,DV,The following statement contains a magic number: return C[iStart + 1] + z * (C[iStart + 2] + C[iStart + 2] + z * 3 * C[iStart + 3]);
Magic Number,MapAround.CoordinateSystems.Transformations,Robinson,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,DV,The following statement contains a magic number: return C[iStart + 1] + z * (C[iStart + 2] + C[iStart + 2] + z * 3 * C[iStart + 3]);
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,getMinEntryIndex,The following statement contains a magic number: if (Math.Abs(values[2]) < Math.Abs(values[i]))                  i = 2;
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,getMinEntryIndex,The following statement contains a magic number: if (Math.Abs(values[2]) < Math.Abs(values[i]))                  i = 2;
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Gnomonic,The following statement contains a magic number: double[] vector = new double[3];
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Gnomonic,The following statement contains a magic number: int j = (k + 2) % 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Gnomonic,The following statement contains a magic number: int j = (k + 2) % 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Gnomonic,The following statement contains a magic number: int i = (j + 2) % 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Gnomonic,The following statement contains a magic number: int i = (j + 2) % 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Gnomonic,The following statement contains a magic number: _xAxis = (new Vector3(vector[0]' vector[1]' vector[2])).Unitize();
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: int delta = 2;
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: if (p.Length % 3 == 0)                  delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: if (p.Length % 3 == 0)                  delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    Vector3 vector =                       UnitSphere.LatLonToGeocentric(                          Degrees.ToRadians(p[i + 1])'                           Degrees.ToRadians(p[i]));                    double r = vector * _center;                    if (r < 1e-8)                      throw new ApplicationException();                    vector = vector / r;                    result[i] = vector * _xAxis;                  result[i + 1] = vector * _yAxis;                }
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    Vector3 vector =                       UnitSphere.LatLonToGeocentric(                          Degrees.ToRadians(p[i + 1])'                           Degrees.ToRadians(p[i]));                    double r = vector * _center;                    if (r < 1e-8)                      throw new ApplicationException();                    vector = vector / r;                    result[i] = vector * _xAxis;                  result[i + 1] = vector * _yAxis;                }
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    Vector3 vector =                       UnitSphere.LatLonToGeocentric(                          Degrees.ToRadians(p[i + 1])'                           Degrees.ToRadians(p[i]));                    double r = vector * _center;                    if (r < 1e-8)                      throw new ApplicationException();                    vector = vector / r;                    result[i] = vector * _xAxis;                  result[i + 1] = vector * _yAxis;                }
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    Vector3 vector =                       UnitSphere.LatLonToGeocentric(                          Degrees.ToRadians(p[i + 1])'                           Degrees.ToRadians(p[i]));                    double r = vector * _center;                    if (r < 1e-8)                      throw new ApplicationException();                    vector = vector / r;                    result[i] = vector * _xAxis;                  result[i + 1] = vector * _yAxis;                }
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    Vector3 vector =                       UnitSphere.LatLonToGeocentric(                          Degrees.ToRadians(p[i + 1])'                           Degrees.ToRadians(p[i]));                    double r = vector * _center;                    if (r < 1e-8)                      throw new ApplicationException();                    vector = vector / r;                    result[i] = vector * _xAxis;                  result[i + 1] = vector * _yAxis;                }
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: int delta = 2;
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: if (p.Length % 3 == 0)                  delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: if (p.Length % 3 == 0)                  delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    Vector3 vector = _center + _xAxis * p[i] + _yAxis * p[i + 1];                  result[i + 1] = Radians.ToDegrees(UnitSphere.Latitude(vector));                  result[i] = Radians.ToDegrees(UnitSphere.Longitude(vector));              }
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    Vector3 vector = _center + _xAxis * p[i] + _yAxis * p[i + 1];                  result[i + 1] = Radians.ToDegrees(UnitSphere.Latitude(vector));                  result[i] = Radians.ToDegrees(UnitSphere.Longitude(vector));              }
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    Vector3 vector = _center + _xAxis * p[i] + _yAxis * p[i + 1];                  result[i + 1] = Radians.ToDegrees(UnitSphere.Latitude(vector));                  result[i] = Radians.ToDegrees(UnitSphere.Longitude(vector));              }
Magic Number,MapAround.CoordinateSystems.Transformations,Gnomonic,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  if (delta == 3)                      result[i + 2] = p[i + 2];                    Vector3 vector = _center + _xAxis * p[i] + _yAxis * p[i + 1];                  result[i + 1] = Radians.ToDegrees(UnitSphere.Latitude(vector));                  result[i] = Radians.ToDegrees(UnitSphere.Longitude(vector));              }
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Affine,The following statement contains a magic number: if (matrix.Size != 3)                  throw new ArgumentException("Affine transform matrix size should be equal three."' "matrix");
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Affine,The following statement contains a magic number: if (matrix[0' 2] != 0 || matrix[1' 2] != 0 || matrix[2' 2] != 1)                  throw new ArgumentException("Matrix does not define an affine transformation."' "matrix");
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Affine,The following statement contains a magic number: if (matrix[0' 2] != 0 || matrix[1' 2] != 0 || matrix[2' 2] != 1)                  throw new ArgumentException("Matrix does not define an affine transformation."' "matrix");
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Affine,The following statement contains a magic number: if (matrix[0' 2] != 0 || matrix[1' 2] != 0 || matrix[2' 2] != 1)                  throw new ArgumentException("Matrix does not define an affine transformation."' "matrix");
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Affine,The following statement contains a magic number: if (matrix[0' 2] != 0 || matrix[1' 2] != 0 || matrix[2' 2] != 1)                  throw new ArgumentException("Matrix does not define an affine transformation."' "matrix");
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Inverse,The following statement contains a magic number: if (_inverseMatrix == null)              {                  _inverseMatrix = _matrix.GetInverseMatrix();                    //values ​​may differ slightly from the exact'                   //in which case check the affinity will not be passed'                   //so set the value of the third column manually                  _inverseMatrix[0' 2] = 0;                  _inverseMatrix[1' 2] = 0;                  _inverseMatrix[2' 2] = 1;              }
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Inverse,The following statement contains a magic number: if (_inverseMatrix == null)              {                  _inverseMatrix = _matrix.GetInverseMatrix();                    //values ​​may differ slightly from the exact'                   //in which case check the affinity will not be passed'                   //so set the value of the third column manually                  _inverseMatrix[0' 2] = 0;                  _inverseMatrix[1' 2] = 0;                  _inverseMatrix[2' 2] = 1;              }
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Inverse,The following statement contains a magic number: if (_inverseMatrix == null)              {                  _inverseMatrix = _matrix.GetInverseMatrix();                    //values ​​may differ slightly from the exact'                   //in which case check the affinity will not be passed'                   //so set the value of the third column manually                  _inverseMatrix[0' 2] = 0;                  _inverseMatrix[1' 2] = 0;                  _inverseMatrix[2' 2] = 1;              }
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,Inverse,The following statement contains a magic number: if (_inverseMatrix == null)              {                  _inverseMatrix = _matrix.GetInverseMatrix();                    //values ​​may differ slightly from the exact'                   //in which case check the affinity will not be passed'                   //so set the value of the third column manually                  _inverseMatrix[0' 2] = 0;                  _inverseMatrix[1' 2] = 0;                  _inverseMatrix[2' 2] = 1;              }
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: int delta = 2;
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: if (p.Length % 3 == 0)                  delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: if (p.Length % 3 == 0)                  delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  result[i] = p[i] * _matrix[0' 0] + p[i + 1] * _matrix[1' 0] + _matrix[2' 0];                  result[i + 1] = p[i] * _matrix[0' 1] + p[i + 1] * _matrix[1' 1] + _matrix[2' 1];                    if (delta == 3)                      result[i + 2] = p[i + 2];              }
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  result[i] = p[i] * _matrix[0' 0] + p[i + 1] * _matrix[1' 0] + _matrix[2' 0];                  result[i + 1] = p[i] * _matrix[0' 1] + p[i + 1] * _matrix[1' 1] + _matrix[2' 1];                    if (delta == 3)                      result[i + 2] = p[i + 2];              }
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  result[i] = p[i] * _matrix[0' 0] + p[i + 1] * _matrix[1' 0] + _matrix[2' 0];                  result[i + 1] = p[i] * _matrix[0' 1] + p[i + 1] * _matrix[1' 1] + _matrix[2' 1];                    if (delta == 3)                      result[i + 2] = p[i + 2];              }
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  result[i] = p[i] * _matrix[0' 0] + p[i + 1] * _matrix[1' 0] + _matrix[2' 0];                  result[i + 1] = p[i] * _matrix[0' 1] + p[i + 1] * _matrix[1' 1] + _matrix[2' 1];                    if (delta == 3)                      result[i + 2] = p[i + 2];              }
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  result[i] = p[i] * _matrix[0' 0] + p[i + 1] * _matrix[1' 0] + _matrix[2' 0];                  result[i + 1] = p[i] * _matrix[0' 1] + p[i + 1] * _matrix[1' 1] + _matrix[2' 1];                    if (delta == 3)                      result[i + 2] = p[i + 2];              }
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,apply,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  result[i] = p[i] * _matrix[0' 0] + p[i + 1] * _matrix[1' 0] + _matrix[2' 0];                  result[i + 1] = p[i] * _matrix[0' 1] + p[i + 1] * _matrix[1' 1] + _matrix[2' 1];                    if (delta == 3)                      result[i + 2] = p[i + 2];              }
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: int delta = 2;
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: if (p.Length % 3 == 0)                  delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: if (p.Length % 3 == 0)                  delta = 3;
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  result[i] = p[i] * _inverseMatrix[0' 0] + p[i + 1] * _inverseMatrix[1' 0] + _inverseMatrix[2' 0];                  result[i + 1] = p[i] * _inverseMatrix[0' 1] + p[i + 1] * _inverseMatrix[1' 1] + _inverseMatrix[2' 1];                    if (delta == 3)                      result[i + 2] = p[i + 2];              }
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  result[i] = p[i] * _inverseMatrix[0' 0] + p[i + 1] * _inverseMatrix[1' 0] + _inverseMatrix[2' 0];                  result[i + 1] = p[i] * _inverseMatrix[0' 1] + p[i + 1] * _inverseMatrix[1' 1] + _inverseMatrix[2' 1];                    if (delta == 3)                      result[i + 2] = p[i + 2];              }
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  result[i] = p[i] * _inverseMatrix[0' 0] + p[i + 1] * _inverseMatrix[1' 0] + _inverseMatrix[2' 0];                  result[i + 1] = p[i] * _inverseMatrix[0' 1] + p[i + 1] * _inverseMatrix[1' 1] + _inverseMatrix[2' 1];                    if (delta == 3)                      result[i + 2] = p[i + 2];              }
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  result[i] = p[i] * _inverseMatrix[0' 0] + p[i + 1] * _inverseMatrix[1' 0] + _inverseMatrix[2' 0];                  result[i + 1] = p[i] * _inverseMatrix[0' 1] + p[i + 1] * _inverseMatrix[1' 1] + _inverseMatrix[2' 1];                    if (delta == 3)                      result[i + 2] = p[i + 2];              }
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  result[i] = p[i] * _inverseMatrix[0' 0] + p[i + 1] * _inverseMatrix[1' 0] + _inverseMatrix[2' 0];                  result[i + 1] = p[i] * _inverseMatrix[0' 1] + p[i + 1] * _inverseMatrix[1' 1] + _inverseMatrix[2' 1];                    if (delta == 3)                      result[i + 2] = p[i + 2];              }
Magic Number,MapAround.CoordinateSystems.Transformations,Affine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Useful.cs,applyInverted,The following statement contains a magic number: for (int i = 0; i < p.Length / 2; i += delta)              {                  result[i] = p[i] * _inverseMatrix[0' 0] + p[i + 1] * _inverseMatrix[1' 0] + _inverseMatrix[2' 0];                  result[i + 1] = p[i] * _inverseMatrix[0' 1] + p[i + 1] * _inverseMatrix[1' 1] + _inverseMatrix[2' 1];                    if (delta == 3)                      result[i + 2] = p[i + 2];              }
Magic Number,MapAround.DataProviders,ShapeFileSpatialDataProvider,C:\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\ShapeFileDataProvider.cs,geometryFromShapeRecord,The following statement contains a magic number: switch (record.ShapeType)              {                  // point                  case 1:                      return new PointD(record.Points[0].X' record.Points[0].Y);                  // polyline                  case 3:                      Polyline polyline = new Polyline();                      for (int i = 0; i < record.Parts.Count; i++)                      {                          LinePath path = new LinePath();                          int j;                          for (j = record.Parts[i]; j < (i == record.Parts.Count - 1 ? record.Points.Count : record.Parts[i + 1]); j++)                              path.Vertices.Add(PlanimetryEnvironment.NewCoordinate(record.Points[j].X' record.Points[j].Y));                            polyline.Paths.Add(path);                      }                      return polyline;                  // ground                  case 5:                      Polygon p = new Polygon();                      for (int i = 0; i < record.Parts.Count; i++)                      {                          Contour contour = new Contour();                          int j;                          for (j = record.Parts[i]; j < (i == record.Parts.Count - 1 ? record.Points.Count : record.Parts[i + 1]); j++)                              contour.Vertices.Add(PlanimetryEnvironment.NewCoordinate(record.Points[j].X' record.Points[j].Y));                            contour.Vertices.RemoveAt(contour.Vertices.Count - 1);                          p.Contours.Add(contour);                      }                      if (p.CoordinateCount > 0)                          return p;                      else                          return null;                  // set of points                  case 8:                      MultiPoint mp = new MultiPoint();                      for (int i = 0; i < record.Points.Count; i++)                          mp.Points.Add(PlanimetryEnvironment.NewCoordinate(record.Points[i].X' record.Points[i].Y));                      return mp;              }
Magic Number,MapAround.DataProviders,ShapeFileSpatialDataProvider,C:\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\ShapeFileDataProvider.cs,geometryFromShapeRecord,The following statement contains a magic number: switch (record.ShapeType)              {                  // point                  case 1:                      return new PointD(record.Points[0].X' record.Points[0].Y);                  // polyline                  case 3:                      Polyline polyline = new Polyline();                      for (int i = 0; i < record.Parts.Count; i++)                      {                          LinePath path = new LinePath();                          int j;                          for (j = record.Parts[i]; j < (i == record.Parts.Count - 1 ? record.Points.Count : record.Parts[i + 1]); j++)                              path.Vertices.Add(PlanimetryEnvironment.NewCoordinate(record.Points[j].X' record.Points[j].Y));                            polyline.Paths.Add(path);                      }                      return polyline;                  // ground                  case 5:                      Polygon p = new Polygon();                      for (int i = 0; i < record.Parts.Count; i++)                      {                          Contour contour = new Contour();                          int j;                          for (j = record.Parts[i]; j < (i == record.Parts.Count - 1 ? record.Points.Count : record.Parts[i + 1]); j++)                              contour.Vertices.Add(PlanimetryEnvironment.NewCoordinate(record.Points[j].X' record.Points[j].Y));                            contour.Vertices.RemoveAt(contour.Vertices.Count - 1);                          p.Contours.Add(contour);                      }                      if (p.CoordinateCount > 0)                          return p;                      else                          return null;                  // set of points                  case 8:                      MultiPoint mp = new MultiPoint();                      for (int i = 0; i < record.Points.Count; i++)                          mp.Points.Add(PlanimetryEnvironment.NewCoordinate(record.Points[i].X' record.Points[i].Y));                      return mp;              }
Magic Number,MapAround.DataProviders,ShapeFileSpatialDataProvider,C:\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\ShapeFileDataProvider.cs,geometryFromShapeRecord,The following statement contains a magic number: switch (record.ShapeType)              {                  // point                  case 1:                      return new PointD(record.Points[0].X' record.Points[0].Y);                  // polyline                  case 3:                      Polyline polyline = new Polyline();                      for (int i = 0; i < record.Parts.Count; i++)                      {                          LinePath path = new LinePath();                          int j;                          for (j = record.Parts[i]; j < (i == record.Parts.Count - 1 ? record.Points.Count : record.Parts[i + 1]); j++)                              path.Vertices.Add(PlanimetryEnvironment.NewCoordinate(record.Points[j].X' record.Points[j].Y));                            polyline.Paths.Add(path);                      }                      return polyline;                  // ground                  case 5:                      Polygon p = new Polygon();                      for (int i = 0; i < record.Parts.Count; i++)                      {                          Contour contour = new Contour();                          int j;                          for (j = record.Parts[i]; j < (i == record.Parts.Count - 1 ? record.Points.Count : record.Parts[i + 1]); j++)                              contour.Vertices.Add(PlanimetryEnvironment.NewCoordinate(record.Points[j].X' record.Points[j].Y));                            contour.Vertices.RemoveAt(contour.Vertices.Count - 1);                          p.Contours.Add(contour);                      }                      if (p.CoordinateCount > 0)                          return p;                      else                          return null;                  // set of points                  case 8:                      MultiPoint mp = new MultiPoint();                      for (int i = 0; i < record.Points.Count; i++)                          mp.Points.Add(PlanimetryEnvironment.NewCoordinate(record.Points[i].X' record.Points[i].Y));                      return mp;              }
Magic Number,MapAround.DataProviders,SpatialDataProviderBase,C:\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\SpatialDataProviders.cs,readInt,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int b = stream.ReadByte();                  if (b == -1)                      throw new EndOfStreamException();                  intBytes[i] = (byte)b;              }
Magic Number,MapAround.DataProviders,SpatialDataProviderBase,C:\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\SpatialDataProviders.cs,writeInt,The following statement contains a magic number: for (int i = 0; i < 4; i++)                  stream.WriteByte(intBytes[i]);
Magic Number,MapAround.Extensions.Surfaces,ShadedReliefBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\ShadedReliefBuilder.cs,mergeTriangles,The following statement contains a magic number: while (activePolygons.Count != 1)              {                  for (int i = 0; i < activePolygons.Count; i += 2)                  {                      Polygon union;                      if (i == activePolygons.Count - 1)                          union = activePolygons[i];                      else                          union = (Polygon)activePolygons[i].Union(activePolygons[i + 1])[0];                        mergedPolygons.Add(union);                  }                  activePolygons = mergedPolygons;                  mergedPolygons = new List<Polygon>();              }
Magic Number,MapAround.Extensions.Surfaces,ShadedReliefBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\ShadedReliefBuilder.cs,BuildShadedRelief,The following statement contains a magic number: foreach (List<Polygon> collector in collectors)              {                  result[i] = new LightenedPolygon(mergeTriangles(collector)' minL + luminosityRange * i + luminosityRange * 0.5);                  i++;              }
Magic Number,MapAround.Extensions.Surfaces,IsolineBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,getIsoline,The following statement contains a magic number: for (int i = 0; i < triangles.Count; i++)              {                  Triangle t = triangles[i];                    Coordinate3D v1 = ((Coordinate3D)t.Cell1.DataPoint);                  Coordinate3D v2 = ((Coordinate3D)t.Cell2.DataPoint);                  Coordinate3D v3 = ((Coordinate3D)t.Cell3.DataPoint);                    List<double> tz = new List<double>();                  tz.Add(v1.Z);                  tz.Add(v2.Z);                  tz.Add(v3.Z);                    tz.Sort();                    // triangle is below the plane                  if (z > tz[2]) continue;                    // triangle lies in the plane                  if (z == tz[0] && z == tz[1] && z == tz[2])                      continue;                    // Triangle is above the plane.                   // This means that all the remaining triangles are also above the plane.                  // Stop processing.                  if (z <= tz[0]) break;                    List<ICoordinate> coords = new List<ICoordinate>();                  // one edge of triangle lies in the plane                  if ((z == tz[0] && z == tz[1]) ||                      (z == tz[1] && z == tz[2]))                  {                      if (z == v1.Z) coords.Add(v1);                      if (z == v2.Z) coords.Add(v2);                      if (z == v3.Z) coords.Add(v3);                        result.Paths.Add(new LinePath(coords));                      continue;                  }                    // triangle intersects the plane                  if (liesBetween(z' v1.Z' v2.Z))                      coords.Add(getPlaneSegmentIntersection(v1' v2' z));                    if (liesBetween(z' v2.Z' v3.Z))                      coords.Add(getPlaneSegmentIntersection(v2' v3' z));                    if (liesBetween(z' v3.Z' v1.Z))                      coords.Add(getPlaneSegmentIntersection(v3' v1' z));                    result.Paths.Add(new LinePath(coords));              }
Magic Number,MapAround.Extensions.Surfaces,IsolineBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,getIsoline,The following statement contains a magic number: for (int i = 0; i < triangles.Count; i++)              {                  Triangle t = triangles[i];                    Coordinate3D v1 = ((Coordinate3D)t.Cell1.DataPoint);                  Coordinate3D v2 = ((Coordinate3D)t.Cell2.DataPoint);                  Coordinate3D v3 = ((Coordinate3D)t.Cell3.DataPoint);                    List<double> tz = new List<double>();                  tz.Add(v1.Z);                  tz.Add(v2.Z);                  tz.Add(v3.Z);                    tz.Sort();                    // triangle is below the plane                  if (z > tz[2]) continue;                    // triangle lies in the plane                  if (z == tz[0] && z == tz[1] && z == tz[2])                      continue;                    // Triangle is above the plane.                   // This means that all the remaining triangles are also above the plane.                  // Stop processing.                  if (z <= tz[0]) break;                    List<ICoordinate> coords = new List<ICoordinate>();                  // one edge of triangle lies in the plane                  if ((z == tz[0] && z == tz[1]) ||                      (z == tz[1] && z == tz[2]))                  {                      if (z == v1.Z) coords.Add(v1);                      if (z == v2.Z) coords.Add(v2);                      if (z == v3.Z) coords.Add(v3);                        result.Paths.Add(new LinePath(coords));                      continue;                  }                    // triangle intersects the plane                  if (liesBetween(z' v1.Z' v2.Z))                      coords.Add(getPlaneSegmentIntersection(v1' v2' z));                    if (liesBetween(z' v2.Z' v3.Z))                      coords.Add(getPlaneSegmentIntersection(v2' v3' z));                    if (liesBetween(z' v3.Z' v1.Z))                      coords.Add(getPlaneSegmentIntersection(v3' v1' z));                    result.Paths.Add(new LinePath(coords));              }
Magic Number,MapAround.Extensions.Surfaces,IsolineBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,getIsoline,The following statement contains a magic number: for (int i = 0; i < triangles.Count; i++)              {                  Triangle t = triangles[i];                    Coordinate3D v1 = ((Coordinate3D)t.Cell1.DataPoint);                  Coordinate3D v2 = ((Coordinate3D)t.Cell2.DataPoint);                  Coordinate3D v3 = ((Coordinate3D)t.Cell3.DataPoint);                    List<double> tz = new List<double>();                  tz.Add(v1.Z);                  tz.Add(v2.Z);                  tz.Add(v3.Z);                    tz.Sort();                    // triangle is below the plane                  if (z > tz[2]) continue;                    // triangle lies in the plane                  if (z == tz[0] && z == tz[1] && z == tz[2])                      continue;                    // Triangle is above the plane.                   // This means that all the remaining triangles are also above the plane.                  // Stop processing.                  if (z <= tz[0]) break;                    List<ICoordinate> coords = new List<ICoordinate>();                  // one edge of triangle lies in the plane                  if ((z == tz[0] && z == tz[1]) ||                      (z == tz[1] && z == tz[2]))                  {                      if (z == v1.Z) coords.Add(v1);                      if (z == v2.Z) coords.Add(v2);                      if (z == v3.Z) coords.Add(v3);                        result.Paths.Add(new LinePath(coords));                      continue;                  }                    // triangle intersects the plane                  if (liesBetween(z' v1.Z' v2.Z))                      coords.Add(getPlaneSegmentIntersection(v1' v2' z));                    if (liesBetween(z' v2.Z' v3.Z))                      coords.Add(getPlaneSegmentIntersection(v2' v3' z));                    if (liesBetween(z' v3.Z' v1.Z))                      coords.Add(getPlaneSegmentIntersection(v3' v1' z));                    result.Paths.Add(new LinePath(coords));              }
Magic Number,MapAround.Extensions.Surfaces,IsolineBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,assignLevelsToPolygons,The following statement contains a magic number: index.MinObjectCount = 10;
Magic Number,MapAround.Extensions.Surfaces,IsolineBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,assignLevelsToPolygons,The following statement contains a magic number: index.MaxDepth = 20;
Magic Number,MapAround.Extensions.Surfaces,IsolineBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,assignLevelsToPolygons,The following statement contains a magic number: index.BoxSquareThreshold = index.IndexedSpace.Width * index.IndexedSpace.Height / 10000;
Magic Number,MapAround.Extensions.Surfaces,IsolineBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Extensions\Surfaces\IsolineBuilder.cs,assignLevelsToPolygons,The following statement contains a magic number: foreach (Polygon p in polygons)              {                  ICoordinate c = p.PointOnSurface();                  List<Feature> t = new List<Feature>();                  index.QueryObjectsContainingPoint(c' t);                  foreach (Feature f in t)                  {                      Polygon triangle = f.Polygon;                      if (triangle.ContainsPoint(c))                      {                          double z =                              getZ(c'                                   new Coordinate3D(triangle.Contours[0].Vertices[0].Values())'                                   new Coordinate3D(triangle.Contours[0].Vertices[1].Values())'                                   new Coordinate3D(triangle.Contours[0].Vertices[2].Values()));                            LevelRange range = getRange(z' ranges);                          result.Add(new LevelRangePolygon(range' p));                          break;                      }                  }              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: if (segment.V1.X == segment.V2.X)              {                  bool downToUp = segment.V1.Y < segment.V2.Y;                    points1 = getArcPoints(downToUp ? segment.V1 : segment.V2'                                          Math.PI'                                          2 * Math.PI'                                          distance'                                          downToUp && !bothSides ? 2 : pointsPerCircle);                  points2 = getArcPoints(downToUp ? segment.V2 : segment.V1'                                          0'                                          Math.PI'                                          distance'                                         !downToUp && !bothSides ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: if (segment.V1.X == segment.V2.X)              {                  bool downToUp = segment.V1.Y < segment.V2.Y;                    points1 = getArcPoints(downToUp ? segment.V1 : segment.V2'                                          Math.PI'                                          2 * Math.PI'                                          distance'                                          downToUp && !bothSides ? 2 : pointsPerCircle);                  points2 = getArcPoints(downToUp ? segment.V2 : segment.V1'                                          0'                                          Math.PI'                                          distance'                                         !downToUp && !bothSides ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: if (segment.V1.X == segment.V2.X)              {                  bool downToUp = segment.V1.Y < segment.V2.Y;                    points1 = getArcPoints(downToUp ? segment.V1 : segment.V2'                                          Math.PI'                                          2 * Math.PI'                                          distance'                                          downToUp && !bothSides ? 2 : pointsPerCircle);                  points2 = getArcPoints(downToUp ? segment.V2 : segment.V1'                                          0'                                          Math.PI'                                          distance'                                         !downToUp && !bothSides ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: if (segment.V1.Y == segment.V2.Y)              {                  bool leftToRight = segment.V1.X < segment.V2.X;                    points1 = getArcPoints(leftToRight ? segment.V1 : segment.V2'                                          0.5 * Math.PI'                                          1.5 * Math.PI'                                          distance'                                          leftToRight && !bothSides ? 2 : pointsPerCircle);                  points2 = getArcPoints(leftToRight ? segment.V2 : segment.V1'                                          1.5 * Math.PI'                                          2.5 * Math.PI'                                          distance'                                         !leftToRight && !bothSides ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: if (segment.V1.Y == segment.V2.Y)              {                  bool leftToRight = segment.V1.X < segment.V2.X;                    points1 = getArcPoints(leftToRight ? segment.V1 : segment.V2'                                          0.5 * Math.PI'                                          1.5 * Math.PI'                                          distance'                                          leftToRight && !bothSides ? 2 : pointsPerCircle);                  points2 = getArcPoints(leftToRight ? segment.V2 : segment.V1'                                          1.5 * Math.PI'                                          2.5 * Math.PI'                                          distance'                                         !leftToRight && !bothSides ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: if (segment.V1.Y == segment.V2.Y)              {                  bool leftToRight = segment.V1.X < segment.V2.X;                    points1 = getArcPoints(leftToRight ? segment.V1 : segment.V2'                                          0.5 * Math.PI'                                          1.5 * Math.PI'                                          distance'                                          leftToRight && !bothSides ? 2 : pointsPerCircle);                  points2 = getArcPoints(leftToRight ? segment.V2 : segment.V1'                                          1.5 * Math.PI'                                          2.5 * Math.PI'                                          distance'                                         !leftToRight && !bothSides ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: if (segment.V1.Y == segment.V2.Y)              {                  bool leftToRight = segment.V1.X < segment.V2.X;                    points1 = getArcPoints(leftToRight ? segment.V1 : segment.V2'                                          0.5 * Math.PI'                                          1.5 * Math.PI'                                          distance'                                          leftToRight && !bothSides ? 2 : pointsPerCircle);                  points2 = getArcPoints(leftToRight ? segment.V2 : segment.V1'                                          1.5 * Math.PI'                                          2.5 * Math.PI'                                          distance'                                         !leftToRight && !bothSides ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: if (segment.V1.Y == segment.V2.Y)              {                  bool leftToRight = segment.V1.X < segment.V2.X;                    points1 = getArcPoints(leftToRight ? segment.V1 : segment.V2'                                          0.5 * Math.PI'                                          1.5 * Math.PI'                                          distance'                                          leftToRight && !bothSides ? 2 : pointsPerCircle);                  points2 = getArcPoints(leftToRight ? segment.V2 : segment.V1'                                          1.5 * Math.PI'                                          2.5 * Math.PI'                                          distance'                                         !leftToRight && !bothSides ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: if (segment.V1.Y == segment.V2.Y)              {                  bool leftToRight = segment.V1.X < segment.V2.X;                    points1 = getArcPoints(leftToRight ? segment.V1 : segment.V2'                                          0.5 * Math.PI'                                          1.5 * Math.PI'                                          distance'                                          leftToRight && !bothSides ? 2 : pointsPerCircle);                  points2 = getArcPoints(leftToRight ? segment.V2 : segment.V1'                                          1.5 * Math.PI'                                          2.5 * Math.PI'                                          distance'                                         !leftToRight && !bothSides ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: if (segment.V1.Y < segment.V2.Y)              {                  points1 = getArcPoints(segment.V1'                                          angle + 0.5 * Math.PI'                                          angle + 1.5 * Math.PI'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          angle - 0.5 * Math.PI'                                          angle + 0.5 * Math.PI'                                          distance'                                          !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }              else              {                  points1 = getArcPoints(segment.V1'                                          0.5 * Math.PI - angle'                                          1.5 * Math.PI - angle'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          1.5 * Math.PI - angle'                                          2.5 * Math.PI - angle'                                          distance'                                         !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: if (segment.V1.Y < segment.V2.Y)              {                  points1 = getArcPoints(segment.V1'                                          angle + 0.5 * Math.PI'                                          angle + 1.5 * Math.PI'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          angle - 0.5 * Math.PI'                                          angle + 0.5 * Math.PI'                                          distance'                                          !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }              else              {                  points1 = getArcPoints(segment.V1'                                          0.5 * Math.PI - angle'                                          1.5 * Math.PI - angle'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          1.5 * Math.PI - angle'                                          2.5 * Math.PI - angle'                                          distance'                                         !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: if (segment.V1.Y < segment.V2.Y)              {                  points1 = getArcPoints(segment.V1'                                          angle + 0.5 * Math.PI'                                          angle + 1.5 * Math.PI'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          angle - 0.5 * Math.PI'                                          angle + 0.5 * Math.PI'                                          distance'                                          !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }              else              {                  points1 = getArcPoints(segment.V1'                                          0.5 * Math.PI - angle'                                          1.5 * Math.PI - angle'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          1.5 * Math.PI - angle'                                          2.5 * Math.PI - angle'                                          distance'                                         !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: if (segment.V1.Y < segment.V2.Y)              {                  points1 = getArcPoints(segment.V1'                                          angle + 0.5 * Math.PI'                                          angle + 1.5 * Math.PI'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          angle - 0.5 * Math.PI'                                          angle + 0.5 * Math.PI'                                          distance'                                          !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }              else              {                  points1 = getArcPoints(segment.V1'                                          0.5 * Math.PI - angle'                                          1.5 * Math.PI - angle'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          1.5 * Math.PI - angle'                                          2.5 * Math.PI - angle'                                          distance'                                         !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: if (segment.V1.Y < segment.V2.Y)              {                  points1 = getArcPoints(segment.V1'                                          angle + 0.5 * Math.PI'                                          angle + 1.5 * Math.PI'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          angle - 0.5 * Math.PI'                                          angle + 0.5 * Math.PI'                                          distance'                                          !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }              else              {                  points1 = getArcPoints(segment.V1'                                          0.5 * Math.PI - angle'                                          1.5 * Math.PI - angle'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          1.5 * Math.PI - angle'                                          2.5 * Math.PI - angle'                                          distance'                                         !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: if (segment.V1.Y < segment.V2.Y)              {                  points1 = getArcPoints(segment.V1'                                          angle + 0.5 * Math.PI'                                          angle + 1.5 * Math.PI'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          angle - 0.5 * Math.PI'                                          angle + 0.5 * Math.PI'                                          distance'                                          !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }              else              {                  points1 = getArcPoints(segment.V1'                                          0.5 * Math.PI - angle'                                          1.5 * Math.PI - angle'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          1.5 * Math.PI - angle'                                          2.5 * Math.PI - angle'                                          distance'                                         !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: if (segment.V1.Y < segment.V2.Y)              {                  points1 = getArcPoints(segment.V1'                                          angle + 0.5 * Math.PI'                                          angle + 1.5 * Math.PI'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          angle - 0.5 * Math.PI'                                          angle + 0.5 * Math.PI'                                          distance'                                          !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }              else              {                  points1 = getArcPoints(segment.V1'                                          0.5 * Math.PI - angle'                                          1.5 * Math.PI - angle'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          1.5 * Math.PI - angle'                                          2.5 * Math.PI - angle'                                          distance'                                         !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: if (segment.V1.Y < segment.V2.Y)              {                  points1 = getArcPoints(segment.V1'                                          angle + 0.5 * Math.PI'                                          angle + 1.5 * Math.PI'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          angle - 0.5 * Math.PI'                                          angle + 0.5 * Math.PI'                                          distance'                                          !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }              else              {                  points1 = getArcPoints(segment.V1'                                          0.5 * Math.PI - angle'                                          1.5 * Math.PI - angle'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          1.5 * Math.PI - angle'                                          2.5 * Math.PI - angle'                                          distance'                                         !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: if (segment.V1.Y < segment.V2.Y)              {                  points1 = getArcPoints(segment.V1'                                          angle + 0.5 * Math.PI'                                          angle + 1.5 * Math.PI'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          angle - 0.5 * Math.PI'                                          angle + 0.5 * Math.PI'                                          distance'                                          !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }              else              {                  points1 = getArcPoints(segment.V1'                                          0.5 * Math.PI - angle'                                          1.5 * Math.PI - angle'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          1.5 * Math.PI - angle'                                          2.5 * Math.PI - angle'                                          distance'                                         !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: if (segment.V1.Y < segment.V2.Y)              {                  points1 = getArcPoints(segment.V1'                                          angle + 0.5 * Math.PI'                                          angle + 1.5 * Math.PI'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          angle - 0.5 * Math.PI'                                          angle + 0.5 * Math.PI'                                          distance'                                          !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }              else              {                  points1 = getArcPoints(segment.V1'                                          0.5 * Math.PI - angle'                                          1.5 * Math.PI - angle'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          1.5 * Math.PI - angle'                                          2.5 * Math.PI - angle'                                          distance'                                         !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: if (segment.V1.Y < segment.V2.Y)              {                  points1 = getArcPoints(segment.V1'                                          angle + 0.5 * Math.PI'                                          angle + 1.5 * Math.PI'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          angle - 0.5 * Math.PI'                                          angle + 0.5 * Math.PI'                                          distance'                                          !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }              else              {                  points1 = getArcPoints(segment.V1'                                          0.5 * Math.PI - angle'                                          1.5 * Math.PI - angle'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          1.5 * Math.PI - angle'                                          2.5 * Math.PI - angle'                                          distance'                                         !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getSegmentPreBuffer,The following statement contains a magic number: if (segment.V1.Y < segment.V2.Y)              {                  points1 = getArcPoints(segment.V1'                                          angle + 0.5 * Math.PI'                                          angle + 1.5 * Math.PI'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          angle - 0.5 * Math.PI'                                          angle + 0.5 * Math.PI'                                          distance'                                          !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }              else              {                  points1 = getArcPoints(segment.V1'                                          0.5 * Math.PI - angle'                                          1.5 * Math.PI - angle'                                          distance'                                         !bothSides && !wasSwapped ? 2 : pointsPerCircle);                  points2 = getArcPoints(segment.V2'                                          1.5 * Math.PI - angle'                                          2.5 * Math.PI - angle'                                          distance'                                         !bothSides && wasSwapped ? 2 : pointsPerCircle);                    Polygon result = new Polygon(points1);                  foreach (ICoordinate p in points2)                      result.Contours[0].Vertices.Add(p);                    return result;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,mergePartialBuffers,The following statement contains a magic number: while (buffers.Count > 1)              {                  List<Polygon> tempBuffers = new List<Polygon>();                  for (int i = 0; i < buffers.Count; i += 2)                  {                      if (i + 1 == buffers.Count)                          tempBuffers.Add(buffers[i]);                      else                      {                          gc = buffers[i].Union(buffers[i + 1]);                          if (gc.Count > 0)                              temp = (Polygon)((GeometryCollection)gc)[0];                          tempBuffers.Add(temp);                      }                  }                  buffers = tempBuffers;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,mergePartialBuffers,The following statement contains a magic number: if (!allowParallels || buffers.Count < 20)                  return mergePartialBuffers(buffers);              else              {                  Thread t = new Thread(mergePartialBuffers);                  List<Polygon> buffersForAnotherThread = new List<Polygon>();                  List<Polygon> buffersForThisThread = new List<Polygon>();                  for (int i = 0; i < buffers.Count; i++)                  {                      if(i > buffers.Count / 2)                          buffersForAnotherThread.Add(buffers[i]);                      else                          buffersForThisThread.Add(buffers[i]);                  }                    ThreadStartData tsd = new ThreadStartData();                  tsd.Buffers = buffersForAnotherThread;                  t.Start(tsd);                  Polygon p = mergePartialBuffers(buffersForThisThread);                  t.Join();                  ICollection<IGeometry> gc = p.Union(tsd.Result);                    if (gc.Count > 0)                      return (Polygon)((GeometryCollection)gc)[0];                  else                      return null;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,mergePartialBuffers,The following statement contains a magic number: if (!allowParallels || buffers.Count < 20)                  return mergePartialBuffers(buffers);              else              {                  Thread t = new Thread(mergePartialBuffers);                  List<Polygon> buffersForAnotherThread = new List<Polygon>();                  List<Polygon> buffersForThisThread = new List<Polygon>();                  for (int i = 0; i < buffers.Count; i++)                  {                      if(i > buffers.Count / 2)                          buffersForAnotherThread.Add(buffers[i]);                      else                          buffersForThisThread.Add(buffers[i]);                  }                    ThreadStartData tsd = new ThreadStartData();                  tsd.Buffers = buffersForAnotherThread;                  t.Start(tsd);                  Polygon p = mergePartialBuffers(buffersForThisThread);                  t.Join();                  ICollection<IGeometry> gc = p.Union(tsd.Result);                    if (gc.Count > 0)                      return (Polygon)((GeometryCollection)gc)[0];                  else                      return null;              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getBoundsBuffer,The following statement contains a magic number: foreach (Contour contour in polygon.Contours)              {                  for (int i = 0; i < contour.Vertices.Count; i++)                  {                      int j = i == contour.Vertices.Count - 1 ? 0 : i + 1;                      Segment s = new Segment(contour.Vertices[i]' contour.Vertices[j]);                      gc = temp.Union(getSegmentPreBuffer(s' Math.Abs(distance)' pointsPerCircle' false));                      if (gc.Count > 0)                          temp = (Polygon)((GeometryCollection)gc)[0];                        c++;                      if (c == 3)                      {                          partialBuffers.Add(temp);                          temp = new Polygon();                          c = 0;                      }                  }              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getPolylineBuffer,The following statement contains a magic number: foreach (LinePath path in polyline.Paths)              {                  for (int i = 0; i < path.Vertices.Count - 1; i++)                  {                      Segment s = new Segment(path.Vertices[i]' path.Vertices[i + 1]);                      gc = temp.Union(getSegmentPreBuffer(s' Math.Abs(distance)' pointsPerCircle' i == 0));                      if (gc.Count > 0)                          temp = (Polygon)((GeometryCollection)gc)[0];                        c++;                      if (c == 3)                      {                          partialBuffers.Add(temp);                          temp = new Polygon();                          c = 0;                      }                  }              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,getMultiPointBuffer,The following statement contains a magic number: foreach (ICoordinate p in multiPoint.Points)              {                  gc = temp.Union(getCoordinateBuffer(p' distance' pointsPerCircle));                  if (gc.Count > 0)                      temp = (Polygon)((GeometryCollection)gc)[0];                    c++;                  if (c == 3)                  {                      partialBuffers.Add(temp);                      temp = new Polygon();                      c = 0;                  }              }
Magic Number,MapAround.Geometry,BufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Buffer.cs,GetBuffer,The following statement contains a magic number: if (pointsPerCircle <= 2)                  throw new ArgumentOutOfRangeException("pointsPerCircle");
Magic Number,MapAround.Geometry,MonotoneChain,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\DataStructures.cs,isPointInSegmentsBounds,The following statement contains a magic number: while (minIndex != maxIndex)              {                  int middleIndex = minIndex + (maxIndex - minIndex) / 2;                  BoundingRectangle br1 = getSubChainBounds(minIndex' middleIndex);                  BoundingRectangle br2 = getSubChainBounds(middleIndex + 1' maxIndex);                  if (br1.ContainsPoint(point))                      maxIndex = middleIndex;                  else if (br2.ContainsPoint(point))                      minIndex = middleIndex + 1;                  else                      return false;              }
Magic Number,MapAround.Geometry,Coordinate,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,Values,The following statement contains a magic number: return new double[2] { _x' _y };
Magic Number,MapAround.Geometry,Coordinate,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,Coordinate,The following statement contains a magic number: if (coords.Length != 2)                  throw new NotSupportedException("Allowed objects with only two coordinates");
Magic Number,MapAround.Geometry,Coordinate3D,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,Values,The following statement contains a magic number: return new double[3] { _x' _y' _z };
Magic Number,MapAround.Geometry,Coordinate3D,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,Coordinate3D,The following statement contains a magic number: if (coords.Length == 2)              {                  _x = coords[0];                  _y = coords[1];                  _z = 0;                  return;              }
Magic Number,MapAround.Geometry,Coordinate3D,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,Coordinate3D,The following statement contains a magic number: if (coords.Length == 3)              {                  _x = coords[0];                  _y = coords[1];                  _z = coords[2];                  return;              }
Magic Number,MapAround.Geometry,Coordinate3D,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,Coordinate3D,The following statement contains a magic number: if (coords.Length == 3)              {                  _x = coords[0];                  _y = coords[1];                  _z = coords[2];                  return;              }
Magic Number,MapAround.Geometry,ReadOnlyCoordinate,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,Values,The following statement contains a magic number: return new double[2] { _x' _y };
Magic Number,MapAround.Geometry,ReadOnlyCoordinate,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,ReadOnlyCoordinate,The following statement contains a magic number: if (coords.Length != 2)                  throw new NotSupportedException("Allowed objects with only two coordinates");
Magic Number,MapAround.Geometry,ReadOnlyCoordinate3D,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,Values,The following statement contains a magic number: return new double[3] { _x' _y' _z };
Magic Number,MapAround.Geometry,ReadOnlyCoordinate3D,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,ReadOnlyCoordinate3D,The following statement contains a magic number: if (coords.Length == 2)              {                  _x = coords[0];                  _y = coords[1];                  _z = 0;                  return;              }
Magic Number,MapAround.Geometry,ReadOnlyCoordinate3D,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,ReadOnlyCoordinate3D,The following statement contains a magic number: if (coords.Length == 3)              {                  _x = coords[0];                  _y = coords[1];                  _z = coords[2];                  return;              }
Magic Number,MapAround.Geometry,ReadOnlyCoordinate3D,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,ReadOnlyCoordinate3D,The following statement contains a magic number: if (coords.Length == 3)              {                  _x = coords[0];                  _y = coords[1];                  _z = coords[2];                  return;              }
Magic Number,MapAround.Geometry,Coordinate3DFactory,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Environment.cs,Create,The following statement contains a magic number: if(values.Length == 2)                  return new Coordinate3D(values[0]' values[1]' _defaultZValue);              else                  return new Coordinate3D(values);
Magic Number,MapAround.Geometry,Segment,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Center,The following statement contains a magic number: return PlanimetryEnvironment.NewCoordinate((V1.X + V2.X) / 2' (V1.Y + V2.Y) / 2);
Magic Number,MapAround.Geometry,Segment,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Center,The following statement contains a magic number: return PlanimetryEnvironment.NewCoordinate((V1.X + V2.X) / 2' (V1.Y + V2.Y) / 2);
Magic Number,MapAround.Geometry,Contour,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,weedSection,The following statement contains a magic number: if (endIndex - startIndex < 2)                  return;
Magic Number,MapAround.Geometry,Contour,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,SignedArea,The following statement contains a magic number: if (Vertices.Count < 3)                  return 0;
Magic Number,MapAround.Geometry,Contour,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,SignedArea,The following statement contains a magic number: for (int i = 0; i < cnt; i++)              {                  if (i == cnt - 1) j = 0; else j = i + 1;                    result += (Vertices[i].X + Vertices[j].X - delta.X * 2) * (Vertices[i].Y - Vertices[j].Y) / 2;              }
Magic Number,MapAround.Geometry,Contour,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,SignedArea,The following statement contains a magic number: for (int i = 0; i < cnt; i++)              {                  if (i == cnt - 1) j = 0; else j = i + 1;                    result += (Vertices[i].X + Vertices[j].X - delta.X * 2) * (Vertices[i].Y - Vertices[j].Y) / 2;              }
Magic Number,MapAround.Geometry,Contour,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,PointLiesInside,The following statement contains a magic number: return crossCount % 2 == 1;
Magic Number,MapAround.Geometry,Contour,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Reverse,The following statement contains a magic number: for (int i = 0' j = Vertices.Count - 1; i < Vertices.Count / 2; i++' j--)              {                  ICoordinate temp = Vertices[i];                  Vertices[i] = Vertices[j];                  Vertices[j] = temp;              }
Magic Number,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,processCycle,The following statement contains a magic number: for (int i = 0; i < connectivity.GetLength(0); i++)              {                  int lastChainElement = chain[chain.Count - 1];                  if (lastChainElement == i) continue;                    bool currentConnection =                       horizontal ?                      connectivity[lastChainElement' i] :                      connectivity[i' lastChainElement];                    if (currentConnection)                  {                      if (chain.Contains(i))                      {                          if (chain.Count > 2)                          {                              if(i != chain[chain.Count - 2])                                  return true;                          }                      }                      else                      {                          chain.Add(i);                          if (processCycle(connectivity' chain' !horizontal))                              return true;                            chain.RemoveAt(chain.Count - 1);                      }                  }              }
Magic Number,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,processCycle,The following statement contains a magic number: for (int i = 0; i < connectivity.GetLength(0); i++)              {                  int lastChainElement = chain[chain.Count - 1];                  if (lastChainElement == i) continue;                    bool currentConnection =                       horizontal ?                      connectivity[lastChainElement' i] :                      connectivity[i' lastChainElement];                    if (currentConnection)                  {                      if (chain.Contains(i))                      {                          if (chain.Count > 2)                          {                              if(i != chain[chain.Count - 2])                                  return true;                          }                      }                      else                      {                          chain.Add(i);                          if (processCycle(connectivity' chain' !horizontal))                              return true;                            chain.RemoveAt(chain.Count - 1);                      }                  }              }
Magic Number,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,ContainsPoint,The following statement contains a magic number: return crossCount % 2 == 1;
Magic Number,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,getInteriorPoint,The following statement contains a magic number: foreach (Contour c in Contours)              {                  for (int i = 0; i < c.Vertices.Count; i++)                  {                      ICoordinate p = null;                      Segment s = new Segment();                        Segment currentSegment = new Segment(c.Vertices[i]' c.Vertices[i == c.Vertices.Count - 1 ? 0 : i + 1]);                      double currentSegmentMinY = Math.Min(currentSegment.V1.Y' currentSegment.V2.Y);                      Dimension cross = PlanimetryAlgorithms.SegmentsIntersection(besector' currentSegment' out p' out s);                      if (cross == MapAround.Geometry.Dimension.Zero && p.Y != currentSegmentMinY)                          besections.Add(p);                      if (cross == MapAround.Geometry.Dimension.One)                      {                          if (isLooped)                              return currentSegment.V1;                            double newY = (besector.V1.Y + minY) / 2;                          return getInteriorPoint(new Segment(besector.V1.X' newY' besector.V2.X' newY)' minY);                      }                  }              }
Magic Number,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,getInteriorPoint,The following statement contains a magic number: for (int i = 1; i < besections.Count; i += 2)              {                  double currentDistance = PlanimetryAlgorithms.Distance(besections[i]' besections[i - 1]);                  if (currentDistance > maxDistance)                  {                      maxDistance = currentDistance;                      maxIndex = i;                  }              }
Magic Number,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,getInteriorPoint,The following statement contains a magic number: if (maxDistance <= PlanimetryAlgorithms.Tolerance)              {                  if (isLooped)                      throw new InvalidOperationException("Unable to calculate interior point of polygon");                    double newY = (besector.V1.Y + minY) / 2;                  return getInteriorPoint(new Segment(besector.V1.X' newY' besector.V2.X' newY)' minY);              }
Magic Number,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,PointOnSurface,The following statement contains a magic number: foreach(Contour c in Contours)                  if (c.Vertices.Count > 2)                  {                      isSingular = false;                      break;                  }
Magic Number,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,PointOnSurface,The following statement contains a magic number: foreach (Contour c in Contours)              {                  if (c.Vertices.Count > 2)                  {                      double currentArea = Math.Abs(c.SignedArea());                      if (maxArea < currentArea)                      {                          maxArea = currentArea;                          targetContour = c;                      }                  }              }
Magic Number,MapAround.Geometry,LinePath,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,weedSection,The following statement contains a magic number: if (endIndex - startIndex < 2)                  return;
Magic Number,MapAround.Geometry,LinePath,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Reverse,The following statement contains a magic number: for (int i = 0' j = Vertices.Count - 1; i < Vertices.Count / 2; i++' j--)              {                  ICoordinate temp = Vertices[i];                  Vertices[i] = Vertices[j];                  Vertices[j] = temp;              }
Magic Number,MapAround.Geometry,BoundingRectangle,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Grow,The following statement contains a magic number: if(delta < 0)                   if(-delta > Width / 2 && -delta > Height / 2)                  {                      _bounds = new Segment(Center()' Center());                      return;                  }
Magic Number,MapAround.Geometry,BoundingRectangle,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,Grow,The following statement contains a magic number: if(delta < 0)                   if(-delta > Width / 2 && -delta > Height / 2)                  {                      _bounds = new Segment(Center()' Center());                      return;                  }
Magic Number,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,calculateOverlay,The following statement contains a magic number: if (minDim == 2 && maxDim == 2)                  getPolygonPolygonOverlay((Polygon)geometry1' (Polygon)geometry2' operation' result' false);
Magic Number,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,calculateOverlay,The following statement contains a magic number: if (minDim == 2 && maxDim == 2)                  getPolygonPolygonOverlay((Polygon)geometry1' (Polygon)geometry2' operation' result' false);
Magic Number,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,calculateOverlay,The following statement contains a magic number: if (minDim == 0 && maxDim == 2)              {                  if (geometry1 is MultiPoint)                      getPointPolygonOverlay((MultiPoint)geometry1' (Polygon)geometry2' operation' result' false' false);                  else                      getPointPolygonOverlay((MultiPoint)geometry2' (Polygon)geometry1' operation' result' false' true);              }
Magic Number,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,calculateOverlay,The following statement contains a magic number: if (minDim == 1 && maxDim == 2)              {                  if (geometry1 is Polyline)                      getPolylinePolygonOverlay((Polyline)geometry1' (Polygon)geometry2' operation' result' false' false);                  else                      getPolylinePolygonOverlay((Polyline)geometry2' (Polygon)geometry1' operation' result' false' true);              }
Magic Number,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,init,The following statement contains a magic number: if (!br.IsEmpty())              {                  _translationCenter = br.Center();                    _geometry1 = translateGeometry(_geometry1' -_translationCenter.X' -_translationCenter.Y);                  if (_geometry2 != null)                      _geometry2 = translateGeometry(_geometry2' -_translationCenter.X' -_translationCenter.Y);                    if (performSnapping)                  {                      _geometry1 = snapGeometryPoints(_geometry1);                      reduceGeometrySegments(_geometry1' PlanimetryAlgorithms.Tolerance * 1.42);                        if (_geometry2 != null)                      {                          _geometry2 = snapGeometryPoints(_geometry2);                          reduceGeometrySegments(_geometry2' PlanimetryAlgorithms.Tolerance * 1.42);                      }                  }                  else                  {                      reduceGeometrySegments(_geometry1' PlanimetryAlgorithms.Tolerance);                      if (_geometry2 != null)                          reduceGeometrySegments(_geometry2' PlanimetryAlgorithms.Tolerance);                  }              }              else                  _translationCenter = PlanimetryEnvironment.NewCoordinate(0' 0);
Magic Number,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,init,The following statement contains a magic number: if (!br.IsEmpty())              {                  _translationCenter = br.Center();                    _geometry1 = translateGeometry(_geometry1' -_translationCenter.X' -_translationCenter.Y);                  if (_geometry2 != null)                      _geometry2 = translateGeometry(_geometry2' -_translationCenter.X' -_translationCenter.Y);                    if (performSnapping)                  {                      _geometry1 = snapGeometryPoints(_geometry1);                      reduceGeometrySegments(_geometry1' PlanimetryAlgorithms.Tolerance * 1.42);                        if (_geometry2 != null)                      {                          _geometry2 = snapGeometryPoints(_geometry2);                          reduceGeometrySegments(_geometry2' PlanimetryAlgorithms.Tolerance * 1.42);                      }                  }                  else                  {                      reduceGeometrySegments(_geometry1' PlanimetryAlgorithms.Tolerance);                      if (_geometry2 != null)                          reduceGeometrySegments(_geometry2' PlanimetryAlgorithms.Tolerance);                  }              }              else                  _translationCenter = PlanimetryEnvironment.NewCoordinate(0' 0);
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,SignedDistanceToLine,The following statement contains a magic number: double mx = (v1x + v2x + x) / 3;
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,SignedDistanceToLine,The following statement contains a magic number: double my = (v1y + v2y + y) / 3;
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,RobustSegmentsIntersection,The following statement contains a magic number: if (p11 == 0 && p12 == 0 && p21 == 0 && p22 == 0)              {                  List<ICoordinate> list = new List<ICoordinate>();                  list.Add(s1.V1);                  list.Add(s1.V2);                  list.Add(s2.V1);                  list.Add(s2.V2);                    //if the segments are vertical' vertical sorting                  if (s1.V1.X == s1.V2.X)                      list.Sort((ICoordinate p1' ICoordinate p2) => p1.Y > p2.Y ? -1 : 1);                  //otherwise horizontally                  else                      list.Sort((ICoordinate p1' ICoordinate p2) => p1.X > p2.X ? -1 : 1);                  intersectionSegment = new Segment(list[2]' list[1]);                    if (intersectionSegment.Length() <= PlanimetryAlgorithms.Tolerance)                  {                      intersectionPoint = list[2];                      return Dimension.Zero;                  }                    return Dimension.One;              }
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,RobustSegmentsIntersection,The following statement contains a magic number: if (p11 == 0 && p12 == 0 && p21 == 0 && p22 == 0)              {                  List<ICoordinate> list = new List<ICoordinate>();                  list.Add(s1.V1);                  list.Add(s1.V2);                  list.Add(s2.V1);                  list.Add(s2.V2);                    //if the segments are vertical' vertical sorting                  if (s1.V1.X == s1.V2.X)                      list.Sort((ICoordinate p1' ICoordinate p2) => p1.Y > p2.Y ? -1 : 1);                  //otherwise horizontally                  else                      list.Sort((ICoordinate p1' ICoordinate p2) => p1.X > p2.X ? -1 : 1);                  intersectionSegment = new Segment(list[2]' list[1]);                    if (intersectionSegment.Length() <= PlanimetryAlgorithms.Tolerance)                  {                      intersectionPoint = list[2];                      return Dimension.Zero;                  }                    return Dimension.One;              }
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,SegmentsIntersection,The following statement contains a magic number: if (denominator == 0) //parallel or coincident lines                  if (u1Numerator == 0 && u2Numerator == 0)                  {                      // OPPORTUNITY segments degenerate' then their intersection - a point                      if (s1.IsSingular() || s2.IsSingular())                      {                          intersectionPoint = (ICoordinate)s1.V1.Clone();                          return Dimension.Zero;                      }                        // if the lines coincide' and segments intersect.                      // We have already examined the intersection of their projections on the coordinate axes                        List<ICoordinate> list = new List<ICoordinate>();                      list.Add((ICoordinate)s1.V1.Clone());                      list.Add((ICoordinate)s1.V2.Clone());                      list.Add((ICoordinate)s2.V1.Clone());                      list.Add((ICoordinate)s2.V2.Clone());                        //if the segments are vertical' vertical sorting                      if (s1.V1.X == s1.V2.X)                          list.Sort((ICoordinate p1' ICoordinate p2) => p1.Y > p2.Y ? -1 : 1);                      //otherwise horizontally                      else                          list.Sort((ICoordinate p1' ICoordinate p2) => p1.X > p2.X ? -1 : 1);                      intersectionSegment = new Segment(list[2]' list[1]);                        if (intersectionSegment.IsSingular())                      {                          intersectionPoint = list[2];                          return Dimension.Zero;                      }                        return Dimension.One;                  }
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,SegmentsIntersection,The following statement contains a magic number: if (denominator == 0) //parallel or coincident lines                  if (u1Numerator == 0 && u2Numerator == 0)                  {                      // OPPORTUNITY segments degenerate' then their intersection - a point                      if (s1.IsSingular() || s2.IsSingular())                      {                          intersectionPoint = (ICoordinate)s1.V1.Clone();                          return Dimension.Zero;                      }                        // if the lines coincide' and segments intersect.                      // We have already examined the intersection of their projections on the coordinate axes                        List<ICoordinate> list = new List<ICoordinate>();                      list.Add((ICoordinate)s1.V1.Clone());                      list.Add((ICoordinate)s1.V2.Clone());                      list.Add((ICoordinate)s2.V1.Clone());                      list.Add((ICoordinate)s2.V2.Clone());                        //if the segments are vertical' vertical sorting                      if (s1.V1.X == s1.V2.X)                          list.Sort((ICoordinate p1' ICoordinate p2) => p1.Y > p2.Y ? -1 : 1);                      //otherwise horizontally                      else                          list.Sort((ICoordinate p1' ICoordinate p2) => p1.X > p2.X ? -1 : 1);                      intersectionSegment = new Segment(list[2]' list[1]);                        if (intersectionSegment.IsSingular())                      {                          intersectionPoint = list[2];                          return Dimension.Zero;                      }                        return Dimension.One;                  }
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,OrderPointsOverAxis,The following statement contains a magic number: if (coordinates.Count < 2)                  return;
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,GetConvexHull,The following statement contains a magic number: if (result.Count <= 2)                  return result;
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,GetConvexHull,The following statement contains a magic number: if (result.Count > 200)                  filterPointsForConvexHull(result);
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,GetConvexHull,The following statement contains a magic number: pointStack.Push(result[2]);
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,GetConvexHull,The following statement contains a magic number: for (int i = 3; i < result.Count; i++)              {                  ICoordinate c = pointStack.Pop();                    while (PlanimetryAlgorithms.OrientationIndex(new Segment(pointStack.Peek()' c)' result[i]) > 0)                      c = pointStack.Pop();                    pointStack.Push(c);                  pointStack.Push(result[i]);              }
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,SnapToGrid,The following statement contains a magic number: double unitGridExtent = 1e15;
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,SnapToGrid,The following statement contains a magic number: coordinate.X = Math.Floor((coordinate.X - origin.X) / cellSize + 0.5) * cellSize + origin.X;
Magic Number,MapAround.Geometry,PlanimetryAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\PlanimetryAlgorithms.cs,SnapToGrid,The following statement contains a magic number: coordinate.Y = Math.Floor((coordinate.Y - origin.Y) / cellSize + 0.5) * cellSize + origin.Y;
Magic Number,MapAround.Geometry,GeometrySimplifier,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,getCrossPointsIndex,The following statement contains a magic number: result.MaxDepth = 10;
Magic Number,MapAround.Geometry,GeometrySimplifier,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,getCrossPointsIndex,The following statement contains a magic number: result.MinObjectCount = 10;
Magic Number,MapAround.Geometry,GeometrySimplifier,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,getCrossPointsIndex,The following statement contains a magic number: result.BoxSquareThreshold = br.Width * br.Height / 10000;
Magic Number,MapAround.Geometry,GeometrySimplifier,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,buildVertexIndex,The following statement contains a magic number: result.MaxDepth = 14;
Magic Number,MapAround.Geometry,GeometrySimplifier,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,buildVertexIndex,The following statement contains a magic number: result.MinObjectCount = 10;
Magic Number,MapAround.Geometry,GeometrySimplifier,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,buildVertexIndex,The following statement contains a magic number: result.BoxSquareThreshold = br.Width * br.Height / 10000;
Magic Number,MapAround.Geometry,GeometrySimplifier,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,checkWeightedVertex,The following statement contains a magic number: foreach (SDMinVertex vertex in vertices)              {                  ICoordinate p = pointOfWeightedVertex(polyline' vertex);                    //point should not be the top of the triangle                  if (p.ExactEquals(triangle.Contours[0].Vertices[0]) ||                     p.ExactEquals(triangle.Contours[0].Vertices[1]) ||                     p.ExactEquals(triangle.Contours[0].Vertices[2]))                      continue;                    if (triangle.ContainsPoint(p))                      return false;              }
Magic Number,MapAround.Geometry,GeometrySimplifier,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,getPolygonFromBounds,The following statement contains a magic number: foreach (LinePath path in polyline.Paths)              {                  if (path.Vertices.Count <= 2)                      continue;                  Contour c = new Contour();                  result.Contours.Add(c);                  for (int i = 0; i < path.Vertices.Count - 1; i++ )                      c.Vertices.Add(path.Vertices[i]);              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,getDimensionPair,The following statement contains a magic number: if (maxDim == 0)              {                  _sourceDimensions = DimensionPair.ZeroZero;              }              else if (maxDim == 1)              {                  if (minDim == 0)                      _sourceDimensions = DimensionPair.ZeroOne;                  else                      _sourceDimensions = DimensionPair.OneOne;              }              else if (maxDim == 2)              {                  switch (minDim)                  {                      case 0: _sourceDimensions = DimensionPair.ZeroTwo;                          break;                      case 1: _sourceDimensions = DimensionPair.OneTwo;                          break;                      case 2: _sourceDimensions = DimensionPair.TwoTwo;                          break;                  }              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,getDimensionPair,The following statement contains a magic number: if (maxDim == 0)              {                  _sourceDimensions = DimensionPair.ZeroZero;              }              else if (maxDim == 1)              {                  if (minDim == 0)                      _sourceDimensions = DimensionPair.ZeroOne;                  else                      _sourceDimensions = DimensionPair.OneOne;              }              else if (maxDim == 2)              {                  switch (minDim)                  {                      case 0: _sourceDimensions = DimensionPair.ZeroTwo;                          break;                      case 1: _sourceDimensions = DimensionPair.OneTwo;                          break;                      case 2: _sourceDimensions = DimensionPair.TwoTwo;                          break;                  }              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,elementToChar,The following statement contains a magic number: if (x < 0 || x > 2)                  throw new ArgumentOutOfRangeException("x");
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,elementToChar,The following statement contains a magic number: if (y < 0 || y > 2)                  throw new ArgumentOutOfRangeException("x");
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateValue,The following statement contains a magic number: if (x == 2 && y == 2)              {                  _values[2' 2] = ElementValue.Two;                  return;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateValue,The following statement contains a magic number: if (x == 2 && y == 2)              {                  _values[2' 2] = ElementValue.Two;                  return;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateValue,The following statement contains a magic number: if (x == 2 && y == 2)              {                  _values[2' 2] = ElementValue.Two;                  return;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateValue,The following statement contains a magic number: if (x == 2 && y == 2)              {                  _values[2' 2] = ElementValue.Two;                  return;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateValue,The following statement contains a magic number: if (x == 0 && y == 0)              {                  calculteInternalInternal();                  return;              } // the intersection of the interior of the first object with the second boundary              else if (x == 0 && y == 1)              {                  calculateInternalBounds(false);                  return;              } //the intersection of the interior of the first object with the addition of the second              else if (x == 0 && y == 2)              {                  calculateInternalExternal(false);                  return;              } // crossing the border of the first object to the interior of the second              else if (x == 1 && y == 0)              {                  calculateInternalBounds(true);                  return;              } // border crossing facilities              else if (x == 1 && y == 1)              {                  calculateBoundsBounds();                  return;              } // crossing the border of the first object with the addition of the second              else if (x == 1 && y == 2)              {                  calculateBoundsExternal(false);                  return;              } // intersection of the complement of the first object to the interior of the second              else if (x == 2 && y == 0)              {                  calculateInternalExternal(true);                  return;              } // intersection of the complement of the first object with the boundary of the second              else if (x == 2 && y == 1)              {                  calculateBoundsExternal(true);              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateValue,The following statement contains a magic number: if (x == 0 && y == 0)              {                  calculteInternalInternal();                  return;              } // the intersection of the interior of the first object with the second boundary              else if (x == 0 && y == 1)              {                  calculateInternalBounds(false);                  return;              } //the intersection of the interior of the first object with the addition of the second              else if (x == 0 && y == 2)              {                  calculateInternalExternal(false);                  return;              } // crossing the border of the first object to the interior of the second              else if (x == 1 && y == 0)              {                  calculateInternalBounds(true);                  return;              } // border crossing facilities              else if (x == 1 && y == 1)              {                  calculateBoundsBounds();                  return;              } // crossing the border of the first object with the addition of the second              else if (x == 1 && y == 2)              {                  calculateBoundsExternal(false);                  return;              } // intersection of the complement of the first object to the interior of the second              else if (x == 2 && y == 0)              {                  calculateInternalExternal(true);                  return;              } // intersection of the complement of the first object with the boundary of the second              else if (x == 2 && y == 1)              {                  calculateBoundsExternal(true);              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateValue,The following statement contains a magic number: if (x == 0 && y == 0)              {                  calculteInternalInternal();                  return;              } // the intersection of the interior of the first object with the second boundary              else if (x == 0 && y == 1)              {                  calculateInternalBounds(false);                  return;              } //the intersection of the interior of the first object with the addition of the second              else if (x == 0 && y == 2)              {                  calculateInternalExternal(false);                  return;              } // crossing the border of the first object to the interior of the second              else if (x == 1 && y == 0)              {                  calculateInternalBounds(true);                  return;              } // border crossing facilities              else if (x == 1 && y == 1)              {                  calculateBoundsBounds();                  return;              } // crossing the border of the first object with the addition of the second              else if (x == 1 && y == 2)              {                  calculateBoundsExternal(false);                  return;              } // intersection of the complement of the first object to the interior of the second              else if (x == 2 && y == 0)              {                  calculateInternalExternal(true);                  return;              } // intersection of the complement of the first object with the boundary of the second              else if (x == 2 && y == 1)              {                  calculateBoundsExternal(true);              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateValue,The following statement contains a magic number: if (x == 0 && y == 0)              {                  calculteInternalInternal();                  return;              } // the intersection of the interior of the first object with the second boundary              else if (x == 0 && y == 1)              {                  calculateInternalBounds(false);                  return;              } //the intersection of the interior of the first object with the addition of the second              else if (x == 0 && y == 2)              {                  calculateInternalExternal(false);                  return;              } // crossing the border of the first object to the interior of the second              else if (x == 1 && y == 0)              {                  calculateInternalBounds(true);                  return;              } // border crossing facilities              else if (x == 1 && y == 1)              {                  calculateBoundsBounds();                  return;              } // crossing the border of the first object with the addition of the second              else if (x == 1 && y == 2)              {                  calculateBoundsExternal(false);                  return;              } // intersection of the complement of the first object to the interior of the second              else if (x == 2 && y == 0)              {                  calculateInternalExternal(true);                  return;              } // intersection of the complement of the first object with the boundary of the second              else if (x == 2 && y == 1)              {                  calculateBoundsExternal(true);              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculteInternalInternal,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ---------------------------- the intersection of the interior of the two points                  case DimensionPair.ZeroZero:                        this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                              break;                          }                      break;                  // ---------------------------- the intersection of the interior of a point and a polyline                  case DimensionPair.ZeroOne:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2 && node.IncidentEdges.Count % 2 != 1)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                              break;                          }                      break;                  // ---------------------------- crossing point' and the interior of the polygon                  case DimensionPair.ZeroTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        Polygon polygon = _sourceGeometry1 is Polygon ? (Polygon)_sourceGeometry1 : (Polygon)_sourceGeometry2;                        foreach (PlanarGraphNode node in _graph.Nodes)                      {                          if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                              //node is used by one of the objects                              if (isFirstGeometryPoint ^ node.Label.UsedByObject2)                                  //not a polygon. need to check whether it is inside the polygon.                                  if (polygon.ContainsPoint(node.Point))                                  {                                      this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                                      break;                                  }                      }                      break;                  // ---------------------------- the intersection of the interior of polylines                  case DimensionPair.OneOne:                      this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      // lines may intersect at a point' then the graph has a node used by both                       // lines and does not coincide with their boundaries                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              // node was found' make sure that it does not limit:                              // at the boundary points of an odd number of edges used line                              int use1Count = 0;                              int use2Count = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) use1Count++;                                  if (edge.Label.UsedByObject2) use2Count++;                              }                              if (use1Count % 2 != 1 && use2Count % 2 != 1)                              {                                  // polylines intersect at least at                                  this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                                  break;                              }                          }                        // possible intersection of the one-dimensional'                      // then they should be shared at least one edge of the graph                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.One;                              return;                          }                      break;                  // ---------------------------- the intersection of the interior of the polyline and polygon                  case DimensionPair.OneTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      polygon = _sourceGeometry1 is Polygon ? (Polygon)_sourceGeometry1 : (Polygon)_sourceGeometry2;                      bool flag = _sourceGeometry1 is Polygon;                        // perhaps one-dimensional intersection' then the edge must lie                       // within the polygon' and used only the line                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (((flag && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1) ||                                (!flag && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2)) && polygon.ContainsPoint(edge.CenterPoint()))                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.One;                              return;                          }                      break;                  // ---------------------------- the intersection of the interior of polygons                  case DimensionPair.TwoTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        // possible two-dimensional intersection' in which case at least one edge only                      // have one ground should lie within the other' or at least one edge of the polygon                       // is used both on the same side of the two polygons to mark up orientation                       // of the edges of polygons along the bypass                      markPolygonsOrientation();                        foreach (PlanarGraphEdge edge in _graph.Edges)                      {                          flag = false;                          if (edge.Label.UsedByObject1 && !edge.Label.UsedByObject2)                              if (((Polygon)_sourceGeometry2).ContainsPoint(edge.CenterPoint()))                                  flag = true;                            if (edge.Label.UsedByObject2 && !edge.Label.UsedByObject1)                              if (((Polygon)_sourceGeometry1).ContainsPoint(edge.CenterPoint()))                                  flag = true;                            if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              if (edge.OrientationInObject1 == edge.OrientationInObject2)                                  flag = true;                            if(flag)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Two;                              return;                          }                      }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculteInternalInternal,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ---------------------------- the intersection of the interior of the two points                  case DimensionPair.ZeroZero:                        this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                              break;                          }                      break;                  // ---------------------------- the intersection of the interior of a point and a polyline                  case DimensionPair.ZeroOne:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2 && node.IncidentEdges.Count % 2 != 1)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                              break;                          }                      break;                  // ---------------------------- crossing point' and the interior of the polygon                  case DimensionPair.ZeroTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        Polygon polygon = _sourceGeometry1 is Polygon ? (Polygon)_sourceGeometry1 : (Polygon)_sourceGeometry2;                        foreach (PlanarGraphNode node in _graph.Nodes)                      {                          if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                              //node is used by one of the objects                              if (isFirstGeometryPoint ^ node.Label.UsedByObject2)                                  //not a polygon. need to check whether it is inside the polygon.                                  if (polygon.ContainsPoint(node.Point))                                  {                                      this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                                      break;                                  }                      }                      break;                  // ---------------------------- the intersection of the interior of polylines                  case DimensionPair.OneOne:                      this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      // lines may intersect at a point' then the graph has a node used by both                       // lines and does not coincide with their boundaries                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              // node was found' make sure that it does not limit:                              // at the boundary points of an odd number of edges used line                              int use1Count = 0;                              int use2Count = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) use1Count++;                                  if (edge.Label.UsedByObject2) use2Count++;                              }                              if (use1Count % 2 != 1 && use2Count % 2 != 1)                              {                                  // polylines intersect at least at                                  this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                                  break;                              }                          }                        // possible intersection of the one-dimensional'                      // then they should be shared at least one edge of the graph                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.One;                              return;                          }                      break;                  // ---------------------------- the intersection of the interior of the polyline and polygon                  case DimensionPair.OneTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      polygon = _sourceGeometry1 is Polygon ? (Polygon)_sourceGeometry1 : (Polygon)_sourceGeometry2;                      bool flag = _sourceGeometry1 is Polygon;                        // perhaps one-dimensional intersection' then the edge must lie                       // within the polygon' and used only the line                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (((flag && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1) ||                                (!flag && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2)) && polygon.ContainsPoint(edge.CenterPoint()))                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.One;                              return;                          }                      break;                  // ---------------------------- the intersection of the interior of polygons                  case DimensionPair.TwoTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        // possible two-dimensional intersection' in which case at least one edge only                      // have one ground should lie within the other' or at least one edge of the polygon                       // is used both on the same side of the two polygons to mark up orientation                       // of the edges of polygons along the bypass                      markPolygonsOrientation();                        foreach (PlanarGraphEdge edge in _graph.Edges)                      {                          flag = false;                          if (edge.Label.UsedByObject1 && !edge.Label.UsedByObject2)                              if (((Polygon)_sourceGeometry2).ContainsPoint(edge.CenterPoint()))                                  flag = true;                            if (edge.Label.UsedByObject2 && !edge.Label.UsedByObject1)                              if (((Polygon)_sourceGeometry1).ContainsPoint(edge.CenterPoint()))                                  flag = true;                            if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              if (edge.OrientationInObject1 == edge.OrientationInObject2)                                  flag = true;                            if(flag)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Two;                              return;                          }                      }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculteInternalInternal,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ---------------------------- the intersection of the interior of the two points                  case DimensionPair.ZeroZero:                        this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                              break;                          }                      break;                  // ---------------------------- the intersection of the interior of a point and a polyline                  case DimensionPair.ZeroOne:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2 && node.IncidentEdges.Count % 2 != 1)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                              break;                          }                      break;                  // ---------------------------- crossing point' and the interior of the polygon                  case DimensionPair.ZeroTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        Polygon polygon = _sourceGeometry1 is Polygon ? (Polygon)_sourceGeometry1 : (Polygon)_sourceGeometry2;                        foreach (PlanarGraphNode node in _graph.Nodes)                      {                          if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                              //node is used by one of the objects                              if (isFirstGeometryPoint ^ node.Label.UsedByObject2)                                  //not a polygon. need to check whether it is inside the polygon.                                  if (polygon.ContainsPoint(node.Point))                                  {                                      this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                                      break;                                  }                      }                      break;                  // ---------------------------- the intersection of the interior of polylines                  case DimensionPair.OneOne:                      this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      // lines may intersect at a point' then the graph has a node used by both                       // lines and does not coincide with their boundaries                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              // node was found' make sure that it does not limit:                              // at the boundary points of an odd number of edges used line                              int use1Count = 0;                              int use2Count = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) use1Count++;                                  if (edge.Label.UsedByObject2) use2Count++;                              }                              if (use1Count % 2 != 1 && use2Count % 2 != 1)                              {                                  // polylines intersect at least at                                  this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                                  break;                              }                          }                        // possible intersection of the one-dimensional'                      // then they should be shared at least one edge of the graph                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.One;                              return;                          }                      break;                  // ---------------------------- the intersection of the interior of the polyline and polygon                  case DimensionPair.OneTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      polygon = _sourceGeometry1 is Polygon ? (Polygon)_sourceGeometry1 : (Polygon)_sourceGeometry2;                      bool flag = _sourceGeometry1 is Polygon;                        // perhaps one-dimensional intersection' then the edge must lie                       // within the polygon' and used only the line                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (((flag && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1) ||                                (!flag && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2)) && polygon.ContainsPoint(edge.CenterPoint()))                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.One;                              return;                          }                      break;                  // ---------------------------- the intersection of the interior of polygons                  case DimensionPair.TwoTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        // possible two-dimensional intersection' in which case at least one edge only                      // have one ground should lie within the other' or at least one edge of the polygon                       // is used both on the same side of the two polygons to mark up orientation                       // of the edges of polygons along the bypass                      markPolygonsOrientation();                        foreach (PlanarGraphEdge edge in _graph.Edges)                      {                          flag = false;                          if (edge.Label.UsedByObject1 && !edge.Label.UsedByObject2)                              if (((Polygon)_sourceGeometry2).ContainsPoint(edge.CenterPoint()))                                  flag = true;                            if (edge.Label.UsedByObject2 && !edge.Label.UsedByObject1)                              if (((Polygon)_sourceGeometry1).ContainsPoint(edge.CenterPoint()))                                  flag = true;                            if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              if (edge.OrientationInObject1 == edge.OrientationInObject2)                                  flag = true;                            if(flag)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Two;                              return;                          }                      }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsBounds,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ---------------------------- two border crossing points                  case DimensionPair.ZeroZero:                      // border points - the empty set' and their intersection is also                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ---------------------------- border crossing points and polylines                  case DimensionPair.ZeroOne:                      // border points - the empty set' the intersection of the boundary polyline too                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ----------------------------border crossing point and polygon                  case DimensionPair.ZeroTwo:                      //border points - the empty set' the intersection of the boundary of the landfill' too                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ---------------------------- border crossing polylines                  case DimensionPair.OneOne:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possible boundary lines coincide' in this case in the graph'                       // there must exist a node incident to the edges of which are used an odd number of times both lines                      foreach (PlanarGraphNode node in _graph.Nodes)                      {                          int use1count = 0;                          int use2count = 0;                          foreach (PlanarGraphEdge edge in node.IncidentEdges)                          {                              if (edge.Label.UsedByObject1) use1count++;                              if (edge.Label.UsedByObject2) use2count++;                          }                          if (use1count % 2 == 1 && use2count % 2 == 1)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                              return;                          }                      }                      break;                  // ---------------------------- border crossing polyline and polygon                  case DimensionPair.OneTwo:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node used polygon and polyline' and the number of edges                       // incident to a node used polyline' must be odd                                         bool flag = _sourceGeometry1 is Polygon;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usedEdgesCount = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (flag && edge.Label.UsedByObject2) usedEdgesCount++;                                  if (!flag && edge.Label.UsedByObject1) usedEdgesCount++;                              }                              if (usedEdgesCount % 2 == 1)                              {                                  this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ----------------------------intersection polygon boundaries                  case DimensionPair.TwoTwo:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possibly zero-dimensional intersection' in this case in the graph' there must exist a node used by both polygons                      flag = false;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                              flag = true;                              break;                          }                        if (!flag) return;                        // perhaps there is a one-dimensional intersection' in which case the graph must find at least one shared edge                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.One;                              return;                          }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsBounds,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ---------------------------- two border crossing points                  case DimensionPair.ZeroZero:                      // border points - the empty set' and their intersection is also                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ---------------------------- border crossing points and polylines                  case DimensionPair.ZeroOne:                      // border points - the empty set' the intersection of the boundary polyline too                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ----------------------------border crossing point and polygon                  case DimensionPair.ZeroTwo:                      //border points - the empty set' the intersection of the boundary of the landfill' too                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ---------------------------- border crossing polylines                  case DimensionPair.OneOne:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possible boundary lines coincide' in this case in the graph'                       // there must exist a node incident to the edges of which are used an odd number of times both lines                      foreach (PlanarGraphNode node in _graph.Nodes)                      {                          int use1count = 0;                          int use2count = 0;                          foreach (PlanarGraphEdge edge in node.IncidentEdges)                          {                              if (edge.Label.UsedByObject1) use1count++;                              if (edge.Label.UsedByObject2) use2count++;                          }                          if (use1count % 2 == 1 && use2count % 2 == 1)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                              return;                          }                      }                      break;                  // ---------------------------- border crossing polyline and polygon                  case DimensionPair.OneTwo:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node used polygon and polyline' and the number of edges                       // incident to a node used polyline' must be odd                                         bool flag = _sourceGeometry1 is Polygon;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usedEdgesCount = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (flag && edge.Label.UsedByObject2) usedEdgesCount++;                                  if (!flag && edge.Label.UsedByObject1) usedEdgesCount++;                              }                              if (usedEdgesCount % 2 == 1)                              {                                  this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ----------------------------intersection polygon boundaries                  case DimensionPair.TwoTwo:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possibly zero-dimensional intersection' in this case in the graph' there must exist a node used by both polygons                      flag = false;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                              flag = true;                              break;                          }                        if (!flag) return;                        // perhaps there is a one-dimensional intersection' in which case the graph must find at least one shared edge                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.One;                              return;                          }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsBounds,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ---------------------------- two border crossing points                  case DimensionPair.ZeroZero:                      // border points - the empty set' and their intersection is also                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ---------------------------- border crossing points and polylines                  case DimensionPair.ZeroOne:                      // border points - the empty set' the intersection of the boundary polyline too                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ----------------------------border crossing point and polygon                  case DimensionPair.ZeroTwo:                      //border points - the empty set' the intersection of the boundary of the landfill' too                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ---------------------------- border crossing polylines                  case DimensionPair.OneOne:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possible boundary lines coincide' in this case in the graph'                       // there must exist a node incident to the edges of which are used an odd number of times both lines                      foreach (PlanarGraphNode node in _graph.Nodes)                      {                          int use1count = 0;                          int use2count = 0;                          foreach (PlanarGraphEdge edge in node.IncidentEdges)                          {                              if (edge.Label.UsedByObject1) use1count++;                              if (edge.Label.UsedByObject2) use2count++;                          }                          if (use1count % 2 == 1 && use2count % 2 == 1)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                              return;                          }                      }                      break;                  // ---------------------------- border crossing polyline and polygon                  case DimensionPair.OneTwo:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node used polygon and polyline' and the number of edges                       // incident to a node used polyline' must be odd                                         bool flag = _sourceGeometry1 is Polygon;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usedEdgesCount = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (flag && edge.Label.UsedByObject2) usedEdgesCount++;                                  if (!flag && edge.Label.UsedByObject1) usedEdgesCount++;                              }                              if (usedEdgesCount % 2 == 1)                              {                                  this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ----------------------------intersection polygon boundaries                  case DimensionPair.TwoTwo:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possibly zero-dimensional intersection' in this case in the graph' there must exist a node used by both polygons                      flag = false;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                              flag = true;                              break;                          }                        if (!flag) return;                        // perhaps there is a one-dimensional intersection' in which case the graph must find at least one shared edge                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.One;                              return;                          }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ----------------------------the interior of the intersection points with the boundary point - always empty                  case DimensionPair.ZeroZero:                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and the interior of the points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                           return;                        // possibly zero-dimensional intersection' in this case' there must exist a node count of incident edges is odd                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                        break;                  // ---------------------------- crossing the border and the interior of the point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                          return;                        // possibly zero-dimensional intersection' in this case' there must exist a shared graph node                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[xPos' yPos] = ElementValue.Zero;                              return;                          }                      break;                  // ---------------------------- crossing the border and the interior of the polyline                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node for which the number of incident edges'                      // used a polyline - odd' the other used a polyline - even                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usageCount1 = 0;                              int usageCount2 = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) usageCount1++;                                  if (edge.Label.UsedByObject2) usageCount2++;                              }                              if ((!inverseArgs && usageCount1 % 2 == 0 && usageCount2 % 2 == 1) ||                                 (inverseArgs && usageCount1 % 2 == 1 && usageCount2 % 2 == 0))                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ---------------------------- crossing the border and the interior of the polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                      if ((isFirstGeometryPolyline && inverseArgs) ||                          (!isFirstGeometryPolyline && !inverseArgs))                      {                          // boundary polyline must be inside the polygon                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                  (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (inverseArgs && edge.Label.UsedByObject1) count++;                                      if (!inverseArgs && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 1 && polygon.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                              }                      }                      else                      {                          bool flag = false;                          // boundary of the polygon can intersect the interior of the polyline at                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (isFirstGeometryPolyline && edge.Label.UsedByObject1) count++;                                      if (!isFirstGeometryPolyline && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 0)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      flag = true;                                      break;                                  }                              }                            if (!flag) return;                            // perhaps also one-dimensional intersection' in which                           // case the graph must find at least one shared edge                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      break;                  // ---------------------------- crossing the border and the interior of the polygon                  case DimensionPair.TwoTwo:                      Polygon p1 = (Polygon)_sourceGeometry1;                      Polygon p2 = (Polygon)_sourceGeometry2;                      this[xPos' yPos] = ElementValue.Empty;                        // perhaps one-dimensional intersection' in which case the                      // graph must be some edge' used by one of the sites and are inside other                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                              if ((inverseArgs && edge.Label.UsedByObject1 && p2.ContainsPoint(edge.CenterPoint())) ||                                  (!inverseArgs && edge.Label.UsedByObject2 && p1.ContainsPoint(edge.CenterPoint())))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ----------------------------the interior of the intersection points with the boundary point - always empty                  case DimensionPair.ZeroZero:                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and the interior of the points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                           return;                        // possibly zero-dimensional intersection' in this case' there must exist a node count of incident edges is odd                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                        break;                  // ---------------------------- crossing the border and the interior of the point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                          return;                        // possibly zero-dimensional intersection' in this case' there must exist a shared graph node                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[xPos' yPos] = ElementValue.Zero;                              return;                          }                      break;                  // ---------------------------- crossing the border and the interior of the polyline                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node for which the number of incident edges'                      // used a polyline - odd' the other used a polyline - even                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usageCount1 = 0;                              int usageCount2 = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) usageCount1++;                                  if (edge.Label.UsedByObject2) usageCount2++;                              }                              if ((!inverseArgs && usageCount1 % 2 == 0 && usageCount2 % 2 == 1) ||                                 (inverseArgs && usageCount1 % 2 == 1 && usageCount2 % 2 == 0))                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ---------------------------- crossing the border and the interior of the polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                      if ((isFirstGeometryPolyline && inverseArgs) ||                          (!isFirstGeometryPolyline && !inverseArgs))                      {                          // boundary polyline must be inside the polygon                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                  (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (inverseArgs && edge.Label.UsedByObject1) count++;                                      if (!inverseArgs && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 1 && polygon.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                              }                      }                      else                      {                          bool flag = false;                          // boundary of the polygon can intersect the interior of the polyline at                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (isFirstGeometryPolyline && edge.Label.UsedByObject1) count++;                                      if (!isFirstGeometryPolyline && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 0)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      flag = true;                                      break;                                  }                              }                            if (!flag) return;                            // perhaps also one-dimensional intersection' in which                           // case the graph must find at least one shared edge                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      break;                  // ---------------------------- crossing the border and the interior of the polygon                  case DimensionPair.TwoTwo:                      Polygon p1 = (Polygon)_sourceGeometry1;                      Polygon p2 = (Polygon)_sourceGeometry2;                      this[xPos' yPos] = ElementValue.Empty;                        // perhaps one-dimensional intersection' in which case the                      // graph must be some edge' used by one of the sites and are inside other                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                              if ((inverseArgs && edge.Label.UsedByObject1 && p2.ContainsPoint(edge.CenterPoint())) ||                                  (!inverseArgs && edge.Label.UsedByObject2 && p1.ContainsPoint(edge.CenterPoint())))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ----------------------------the interior of the intersection points with the boundary point - always empty                  case DimensionPair.ZeroZero:                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and the interior of the points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                           return;                        // possibly zero-dimensional intersection' in this case' there must exist a node count of incident edges is odd                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                        break;                  // ---------------------------- crossing the border and the interior of the point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                          return;                        // possibly zero-dimensional intersection' in this case' there must exist a shared graph node                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[xPos' yPos] = ElementValue.Zero;                              return;                          }                      break;                  // ---------------------------- crossing the border and the interior of the polyline                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node for which the number of incident edges'                      // used a polyline - odd' the other used a polyline - even                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usageCount1 = 0;                              int usageCount2 = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) usageCount1++;                                  if (edge.Label.UsedByObject2) usageCount2++;                              }                              if ((!inverseArgs && usageCount1 % 2 == 0 && usageCount2 % 2 == 1) ||                                 (inverseArgs && usageCount1 % 2 == 1 && usageCount2 % 2 == 0))                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ---------------------------- crossing the border and the interior of the polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                      if ((isFirstGeometryPolyline && inverseArgs) ||                          (!isFirstGeometryPolyline && !inverseArgs))                      {                          // boundary polyline must be inside the polygon                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                  (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (inverseArgs && edge.Label.UsedByObject1) count++;                                      if (!inverseArgs && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 1 && polygon.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                              }                      }                      else                      {                          bool flag = false;                          // boundary of the polygon can intersect the interior of the polyline at                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (isFirstGeometryPolyline && edge.Label.UsedByObject1) count++;                                      if (!isFirstGeometryPolyline && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 0)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      flag = true;                                      break;                                  }                              }                            if (!flag) return;                            // perhaps also one-dimensional intersection' in which                           // case the graph must find at least one shared edge                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      break;                  // ---------------------------- crossing the border and the interior of the polygon                  case DimensionPair.TwoTwo:                      Polygon p1 = (Polygon)_sourceGeometry1;                      Polygon p2 = (Polygon)_sourceGeometry2;                      this[xPos' yPos] = ElementValue.Empty;                        // perhaps one-dimensional intersection' in which case the                      // graph must be some edge' used by one of the sites and are inside other                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                              if ((inverseArgs && edge.Label.UsedByObject1 && p2.ContainsPoint(edge.CenterPoint())) ||                                  (!inverseArgs && edge.Label.UsedByObject2 && p1.ContainsPoint(edge.CenterPoint())))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ----------------------------the interior of the intersection points with the boundary point - always empty                  case DimensionPair.ZeroZero:                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and the interior of the points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                           return;                        // possibly zero-dimensional intersection' in this case' there must exist a node count of incident edges is odd                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                        break;                  // ---------------------------- crossing the border and the interior of the point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                          return;                        // possibly zero-dimensional intersection' in this case' there must exist a shared graph node                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[xPos' yPos] = ElementValue.Zero;                              return;                          }                      break;                  // ---------------------------- crossing the border and the interior of the polyline                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node for which the number of incident edges'                      // used a polyline - odd' the other used a polyline - even                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usageCount1 = 0;                              int usageCount2 = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) usageCount1++;                                  if (edge.Label.UsedByObject2) usageCount2++;                              }                              if ((!inverseArgs && usageCount1 % 2 == 0 && usageCount2 % 2 == 1) ||                                 (inverseArgs && usageCount1 % 2 == 1 && usageCount2 % 2 == 0))                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ---------------------------- crossing the border and the interior of the polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                      if ((isFirstGeometryPolyline && inverseArgs) ||                          (!isFirstGeometryPolyline && !inverseArgs))                      {                          // boundary polyline must be inside the polygon                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                  (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (inverseArgs && edge.Label.UsedByObject1) count++;                                      if (!inverseArgs && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 1 && polygon.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                              }                      }                      else                      {                          bool flag = false;                          // boundary of the polygon can intersect the interior of the polyline at                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (isFirstGeometryPolyline && edge.Label.UsedByObject1) count++;                                      if (!isFirstGeometryPolyline && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 0)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      flag = true;                                      break;                                  }                              }                            if (!flag) return;                            // perhaps also one-dimensional intersection' in which                           // case the graph must find at least one shared edge                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      break;                  // ---------------------------- crossing the border and the interior of the polygon                  case DimensionPair.TwoTwo:                      Polygon p1 = (Polygon)_sourceGeometry1;                      Polygon p2 = (Polygon)_sourceGeometry2;                      this[xPos' yPos] = ElementValue.Empty;                        // perhaps one-dimensional intersection' in which case the                      // graph must be some edge' used by one of the sites and are inside other                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                              if ((inverseArgs && edge.Label.UsedByObject1 && p2.ContainsPoint(edge.CenterPoint())) ||                                  (!inverseArgs && edge.Label.UsedByObject2 && p1.ContainsPoint(edge.CenterPoint())))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ----------------------------the interior of the intersection points with the boundary point - always empty                  case DimensionPair.ZeroZero:                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and the interior of the points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                           return;                        // possibly zero-dimensional intersection' in this case' there must exist a node count of incident edges is odd                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                        break;                  // ---------------------------- crossing the border and the interior of the point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                          return;                        // possibly zero-dimensional intersection' in this case' there must exist a shared graph node                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[xPos' yPos] = ElementValue.Zero;                              return;                          }                      break;                  // ---------------------------- crossing the border and the interior of the polyline                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node for which the number of incident edges'                      // used a polyline - odd' the other used a polyline - even                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usageCount1 = 0;                              int usageCount2 = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) usageCount1++;                                  if (edge.Label.UsedByObject2) usageCount2++;                              }                              if ((!inverseArgs && usageCount1 % 2 == 0 && usageCount2 % 2 == 1) ||                                 (inverseArgs && usageCount1 % 2 == 1 && usageCount2 % 2 == 0))                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ---------------------------- crossing the border and the interior of the polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                      if ((isFirstGeometryPolyline && inverseArgs) ||                          (!isFirstGeometryPolyline && !inverseArgs))                      {                          // boundary polyline must be inside the polygon                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                  (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (inverseArgs && edge.Label.UsedByObject1) count++;                                      if (!inverseArgs && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 1 && polygon.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                              }                      }                      else                      {                          bool flag = false;                          // boundary of the polygon can intersect the interior of the polyline at                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (isFirstGeometryPolyline && edge.Label.UsedByObject1) count++;                                      if (!isFirstGeometryPolyline && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 0)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      flag = true;                                      break;                                  }                              }                            if (!flag) return;                            // perhaps also one-dimensional intersection' in which                           // case the graph must find at least one shared edge                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      break;                  // ---------------------------- crossing the border and the interior of the polygon                  case DimensionPair.TwoTwo:                      Polygon p1 = (Polygon)_sourceGeometry1;                      Polygon p2 = (Polygon)_sourceGeometry2;                      this[xPos' yPos] = ElementValue.Empty;                        // perhaps one-dimensional intersection' in which case the                      // graph must be some edge' used by one of the sites and are inside other                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                              if ((inverseArgs && edge.Label.UsedByObject1 && p2.ContainsPoint(edge.CenterPoint())) ||                                  (!inverseArgs && edge.Label.UsedByObject2 && p1.ContainsPoint(edge.CenterPoint())))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ----------------------------the interior of the intersection points with the boundary point - always empty                  case DimensionPair.ZeroZero:                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and the interior of the points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                           return;                        // possibly zero-dimensional intersection' in this case' there must exist a node count of incident edges is odd                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                        break;                  // ---------------------------- crossing the border and the interior of the point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                          return;                        // possibly zero-dimensional intersection' in this case' there must exist a shared graph node                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[xPos' yPos] = ElementValue.Zero;                              return;                          }                      break;                  // ---------------------------- crossing the border and the interior of the polyline                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node for which the number of incident edges'                      // used a polyline - odd' the other used a polyline - even                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usageCount1 = 0;                              int usageCount2 = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) usageCount1++;                                  if (edge.Label.UsedByObject2) usageCount2++;                              }                              if ((!inverseArgs && usageCount1 % 2 == 0 && usageCount2 % 2 == 1) ||                                 (inverseArgs && usageCount1 % 2 == 1 && usageCount2 % 2 == 0))                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ---------------------------- crossing the border and the interior of the polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                      if ((isFirstGeometryPolyline && inverseArgs) ||                          (!isFirstGeometryPolyline && !inverseArgs))                      {                          // boundary polyline must be inside the polygon                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                  (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (inverseArgs && edge.Label.UsedByObject1) count++;                                      if (!inverseArgs && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 1 && polygon.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                              }                      }                      else                      {                          bool flag = false;                          // boundary of the polygon can intersect the interior of the polyline at                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (isFirstGeometryPolyline && edge.Label.UsedByObject1) count++;                                      if (!isFirstGeometryPolyline && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 0)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      flag = true;                                      break;                                  }                              }                            if (!flag) return;                            // perhaps also one-dimensional intersection' in which                           // case the graph must find at least one shared edge                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      break;                  // ---------------------------- crossing the border and the interior of the polygon                  case DimensionPair.TwoTwo:                      Polygon p1 = (Polygon)_sourceGeometry1;                      Polygon p2 = (Polygon)_sourceGeometry2;                      this[xPos' yPos] = ElementValue.Empty;                        // perhaps one-dimensional intersection' in which case the                      // graph must be some edge' used by one of the sites and are inside other                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                              if ((inverseArgs && edge.Label.UsedByObject1 && p2.ContainsPoint(edge.CenterPoint())) ||                                  (!inverseArgs && edge.Label.UsedByObject2 && p1.ContainsPoint(edge.CenterPoint())))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ----------------------------the interior of the intersection points with the boundary point - always empty                  case DimensionPair.ZeroZero:                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and the interior of the points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                           return;                        // possibly zero-dimensional intersection' in this case' there must exist a node count of incident edges is odd                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                        break;                  // ---------------------------- crossing the border and the interior of the point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                          return;                        // possibly zero-dimensional intersection' in this case' there must exist a shared graph node                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[xPos' yPos] = ElementValue.Zero;                              return;                          }                      break;                  // ---------------------------- crossing the border and the interior of the polyline                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node for which the number of incident edges'                      // used a polyline - odd' the other used a polyline - even                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usageCount1 = 0;                              int usageCount2 = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) usageCount1++;                                  if (edge.Label.UsedByObject2) usageCount2++;                              }                              if ((!inverseArgs && usageCount1 % 2 == 0 && usageCount2 % 2 == 1) ||                                 (inverseArgs && usageCount1 % 2 == 1 && usageCount2 % 2 == 0))                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ---------------------------- crossing the border and the interior of the polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                      if ((isFirstGeometryPolyline && inverseArgs) ||                          (!isFirstGeometryPolyline && !inverseArgs))                      {                          // boundary polyline must be inside the polygon                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                  (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (inverseArgs && edge.Label.UsedByObject1) count++;                                      if (!inverseArgs && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 1 && polygon.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                              }                      }                      else                      {                          bool flag = false;                          // boundary of the polygon can intersect the interior of the polyline at                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (isFirstGeometryPolyline && edge.Label.UsedByObject1) count++;                                      if (!isFirstGeometryPolyline && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 0)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      flag = true;                                      break;                                  }                              }                            if (!flag) return;                            // perhaps also one-dimensional intersection' in which                           // case the graph must find at least one shared edge                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      break;                  // ---------------------------- crossing the border and the interior of the polygon                  case DimensionPair.TwoTwo:                      Polygon p1 = (Polygon)_sourceGeometry1;                      Polygon p2 = (Polygon)_sourceGeometry2;                      this[xPos' yPos] = ElementValue.Empty;                        // perhaps one-dimensional intersection' in which case the                      // graph must be some edge' used by one of the sites and are inside other                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                              if ((inverseArgs && edge.Label.UsedByObject1 && p2.ContainsPoint(edge.CenterPoint())) ||                                  (!inverseArgs && edge.Label.UsedByObject2 && p1.ContainsPoint(edge.CenterPoint())))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ---------------------------- border crossing point with the addition of a point                  case DimensionPair.ZeroZero:                      // always empty                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and add points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      if ((inverseArgs && !isFirstGeometryPoint) ||                          (!inverseArgs && isFirstGeometryPoint))                          // always empty                          this[xPos' yPos] = ElementValue.Empty;                      else                      {                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                                  if (node.IncidentEdges.Count % 2 == 1)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                      }                      break;                  // ---------------------------- crossing the border and add a point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      if ((inverseArgs && isFirstGeometryPoint) ||                          (!inverseArgs && !isFirstGeometryPoint))                      {                          // one-dimensional intersection in the nondegenerate case                          if (_graph.Edges.Count > 0)                              this[xPos' yPos] = ElementValue.One;                      }                      // otherwise empty                      break;                  // ---------------------------- crossing the border and add polylines                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node that is used only a polyline with an odd number of edges incident                      foreach (PlanarGraphNode node in _graph.Nodes)                          if ((!inverseArgs && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                              (inverseArgs && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                      break;                  // ---------------------------- crossing the border and add polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                                            if ((inverseArgs && isFirstGeometryPolyline) ||                          (!inverseArgs && !isFirstGeometryPolyline))                      {                          //perhaps one-dimensional intersection' if there is at least one edge ispolzeumoe only ground                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if ((isFirstGeometryPolyline && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1) ||                                 (!isFirstGeometryPolyline && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      else                      {                          //possibly zero-dimensional intersection' if there is at least one node'                           // use only the line that has an odd number of incident edges and lying within the polygon                          Polygon p1 = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                 (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                                  if(node.IncidentEdges.Count % 2 == 1 && !p1.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                      }                      break;                  // ---------------------------- crossing the border and add polygons                  case DimensionPair.TwoTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon1 = (Polygon)_sourceGeometry1;                       Polygon polygon2 = (Polygon)_sourceGeometry2;                        // perhaps one-dimensional intersection' if there is at least one edge                       // belongs to only one polygon and not contained within another                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if ((!inverseArgs && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2 && !polygon2.ContainsPoint(edge.CenterPoint())) ||                              (inverseArgs && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1 && !polygon1.ContainsPoint(edge.CenterPoint())))                          {                              this[xPos' yPos] = ElementValue.One;                              return;                          }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ---------------------------- border crossing point with the addition of a point                  case DimensionPair.ZeroZero:                      // always empty                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and add points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      if ((inverseArgs && !isFirstGeometryPoint) ||                          (!inverseArgs && isFirstGeometryPoint))                          // always empty                          this[xPos' yPos] = ElementValue.Empty;                      else                      {                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                                  if (node.IncidentEdges.Count % 2 == 1)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                      }                      break;                  // ---------------------------- crossing the border and add a point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      if ((inverseArgs && isFirstGeometryPoint) ||                          (!inverseArgs && !isFirstGeometryPoint))                      {                          // one-dimensional intersection in the nondegenerate case                          if (_graph.Edges.Count > 0)                              this[xPos' yPos] = ElementValue.One;                      }                      // otherwise empty                      break;                  // ---------------------------- crossing the border and add polylines                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node that is used only a polyline with an odd number of edges incident                      foreach (PlanarGraphNode node in _graph.Nodes)                          if ((!inverseArgs && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                              (inverseArgs && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                      break;                  // ---------------------------- crossing the border and add polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                                            if ((inverseArgs && isFirstGeometryPolyline) ||                          (!inverseArgs && !isFirstGeometryPolyline))                      {                          //perhaps one-dimensional intersection' if there is at least one edge ispolzeumoe only ground                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if ((isFirstGeometryPolyline && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1) ||                                 (!isFirstGeometryPolyline && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      else                      {                          //possibly zero-dimensional intersection' if there is at least one node'                           // use only the line that has an odd number of incident edges and lying within the polygon                          Polygon p1 = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                 (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                                  if(node.IncidentEdges.Count % 2 == 1 && !p1.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                      }                      break;                  // ---------------------------- crossing the border and add polygons                  case DimensionPair.TwoTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon1 = (Polygon)_sourceGeometry1;                       Polygon polygon2 = (Polygon)_sourceGeometry2;                        // perhaps one-dimensional intersection' if there is at least one edge                       // belongs to only one polygon and not contained within another                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if ((!inverseArgs && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2 && !polygon2.ContainsPoint(edge.CenterPoint())) ||                              (inverseArgs && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1 && !polygon1.ContainsPoint(edge.CenterPoint())))                          {                              this[xPos' yPos] = ElementValue.One;                              return;                          }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The following statement contains a magic number: switch (_sourceDimensions)              {                  // ---------------------------- border crossing point with the addition of a point                  case DimensionPair.ZeroZero:                      // always empty                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and add points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      if ((inverseArgs && !isFirstGeometryPoint) ||                          (!inverseArgs && isFirstGeometryPoint))                          // always empty                          this[xPos' yPos] = ElementValue.Empty;                      else                      {                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                                  if (node.IncidentEdges.Count % 2 == 1)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                      }                      break;                  // ---------------------------- crossing the border and add a point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      if ((inverseArgs && isFirstGeometryPoint) ||                          (!inverseArgs && !isFirstGeometryPoint))                      {                          // one-dimensional intersection in the nondegenerate case                          if (_graph.Edges.Count > 0)                              this[xPos' yPos] = ElementValue.One;                      }                      // otherwise empty                      break;                  // ---------------------------- crossing the border and add polylines                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node that is used only a polyline with an odd number of edges incident                      foreach (PlanarGraphNode node in _graph.Nodes)                          if ((!inverseArgs && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                              (inverseArgs && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                      break;                  // ---------------------------- crossing the border and add polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                                            if ((inverseArgs && isFirstGeometryPolyline) ||                          (!inverseArgs && !isFirstGeometryPolyline))                      {                          //perhaps one-dimensional intersection' if there is at least one edge ispolzeumoe only ground                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if ((isFirstGeometryPolyline && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1) ||                                 (!isFirstGeometryPolyline && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      else                      {                          //possibly zero-dimensional intersection' if there is at least one node'                           // use only the line that has an odd number of incident edges and lying within the polygon                          Polygon p1 = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                 (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                                  if(node.IncidentEdges.Count % 2 == 1 && !p1.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                      }                      break;                  // ---------------------------- crossing the border and add polygons                  case DimensionPair.TwoTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon1 = (Polygon)_sourceGeometry1;                       Polygon polygon2 = (Polygon)_sourceGeometry2;                        // perhaps one-dimensional intersection' if there is at least one edge                       // belongs to only one polygon and not contained within another                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if ((!inverseArgs && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2 && !polygon2.ContainsPoint(edge.CenterPoint())) ||                              (inverseArgs && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1 && !polygon1.ContainsPoint(edge.CenterPoint())))                          {                              this[xPos' yPos] = ElementValue.One;                              return;                          }                      break;              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateValues,The following statement contains a magic number: for (int i = 0; i < 3; i++)                      for (int j = 0; j < 3; j++)                          calculateValue(i' j);
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateValues,The following statement contains a magic number: for (int i = 0; i < 3; i++)                      for (int j = 0; j < 3; j++)                          calculateValue(i' j);
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateValuesPartial,The following statement contains a magic number: for (int i = 0; i < 3; i++)                  for (int j = 0; j < 3; j++)                  {                      if(template[pos] != '*')                          calculateValue(i' j);                      pos++;                  }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateValuesPartial,The following statement contains a magic number: for (int i = 0; i < 3; i++)                  for (int j = 0; j < 3; j++)                  {                      if(template[pos] != '*')                          calculateValue(i' j);                      pos++;                  }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,initSourceGeometries,The following statement contains a magic number: reduceGeometrySegments(_sourceGeometry1' PlanimetryAlgorithms.Tolerance * 1.42);
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,initSourceGeometries,The following statement contains a magic number: reduceGeometrySegments(_sourceGeometry2' PlanimetryAlgorithms.Tolerance * 1.42);
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,Matches,The following statement contains a magic number: if (template.Length != 9)                  throw new ArgumentException("Intersection matrix template should be 9-character string"' "template");
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,Matches,The following statement contains a magic number: foreach (char ch in templateChars)              {                  switch (ch)                  {                       case '*':break;                      case 'F':                          if (_values[j' i] != ElementValue.Empty)                              return false;                          break;                      case 'T':                           if (_values[j' i] == ElementValue.Empty ||                              _values[j' i] == ElementValue.Undefined)                              return false;                          break;                      case '0':                          if (_values[j' i] != ElementValue.Zero)                              return false;                          break;                      case '1':                           if (_values[j' i] != ElementValue.One)                              return false;                          break;                      case '2':                          if (_values[j' i] != ElementValue.Two)                              return false;                          break;                  }                    i++;                  if (i == 3)                  {                      j++;                      i = 0;                  }              }
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,ToString,The following statement contains a magic number: for (int i = 0; i < 3; i++)                  for (int j = 0; j < 3; j++)                      result += elementToChar(i' j);
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,ToString,The following statement contains a magic number: for (int i = 0; i < 3; i++)                  for (int j = 0; j < 3; j++)                      result += elementToChar(i' j);
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,CalculatePartial,The following statement contains a magic number: if(template.Length != 9)                  throw new ArgumentException("Intersection matrix template should be 9-character string"' "template");
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,IntersectionMatrix,The following statement contains a magic number: for (int i = 0; i < 3; i++)                  for (int j = 0; j < 3; j++)                      _values[i' j] = ElementValue.Undefined;
Magic Number,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,IntersectionMatrix,The following statement contains a magic number: for (int i = 0; i < 3; i++)                  for (int j = 0; j < 3; j++)                      _values[i' j] = ElementValue.Undefined;
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,addOrMergeNode,The following statement contains a magic number: while (endIndex - startIndex > 1)              {                  int index = startIndex + (endIndex - startIndex) / 2;                  if (_nodes[index].Point.X < x)                      startIndex = index;                  else                      endIndex = index;              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,init,The following statement contains a magic number: if (pointCount > 800)              {                  _sourceBounds.Grow(PlanimetryAlgorithms.Tolerance * 10);                    _splittedSegmentIndex = new KDTree(_sourceBounds);                  _splittedSegmentIndex.MaxDepth = 20;                  _splittedSegmentIndex.BoxSquareThreshold = _sourceBounds.Width * _sourceBounds.Height / 10000;              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,init,The following statement contains a magic number: if (pointCount > 800)              {                  _sourceBounds.Grow(PlanimetryAlgorithms.Tolerance * 10);                    _splittedSegmentIndex = new KDTree(_sourceBounds);                  _splittedSegmentIndex.MaxDepth = 20;                  _splittedSegmentIndex.BoxSquareThreshold = _sourceBounds.Width * _sourceBounds.Height / 10000;              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,init,The following statement contains a magic number: if (pointCount > 800)              {                  _sourceBounds.Grow(PlanimetryAlgorithms.Tolerance * 10);                    _splittedSegmentIndex = new KDTree(_sourceBounds);                  _splittedSegmentIndex.MaxDepth = 20;                  _splittedSegmentIndex.BoxSquareThreshold = _sourceBounds.Width * _sourceBounds.Height / 10000;              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,init,The following statement contains a magic number: if (pointCount > 800)              {                  _sourceBounds.Grow(PlanimetryAlgorithms.Tolerance * 10);                    _splittedSegmentIndex = new KDTree(_sourceBounds);                  _splittedSegmentIndex.MaxDepth = 20;                  _splittedSegmentIndex.BoxSquareThreshold = _sourceBounds.Width * _sourceBounds.Height / 10000;              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,build,The following statement contains a magic number: if (_sourceGeometry2 != null)              {                  addVerticesAsNodes(_sourceGeometry2);                  addSourceSegments(_sourceGeometry2' 2);              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,updateSplittedSegment,The following statement contains a magic number: foreach (SplittedSegment ss in relatedSegments)                  if ((_performSnapping && ss.Segment.ExactEquals(segment.Segment)) ||                      (!_performSnapping && ss.Segment == segment.Segment))                  {                      // current segment coincided with the previously calculated                        if (_sourceGeometry1 is Polygon)                          // For polygons segment - the border. "Use" is defined by the parity of entry.                          ss.UsedByObject1 = ss.UsedByObject1 ^ segment.ObjectNumber == 1;                      else                      {                          // For polyline segment - interior. "Use" is defined by the fact of the entry.                          ss.UsedByObject1 = ss.UsedByObject1 || segment.ObjectNumber == 1;                      }                        if (_sourceGeometry2 is Polygon)                          ss.UsedByObject2 = ss.UsedByObject2 ^ segment.ObjectNumber == 2;                      else                          ss.UsedByObject2 = ss.UsedByObject2 || segment.ObjectNumber == 2;                        if (segment.ObjectNumber == 1)                          ss.Object1OccurrencesCount++;                      else                          ss.Object2OccurrencesCount++;                        return true;                  }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,updateSplittedSegment,The following statement contains a magic number: foreach (SplittedSegment ss in relatedSegments)                  if ((_performSnapping && ss.Segment.ExactEquals(segment.Segment)) ||                      (!_performSnapping && ss.Segment == segment.Segment))                  {                      // current segment coincided with the previously calculated                        if (_sourceGeometry1 is Polygon)                          // For polygons segment - the border. "Use" is defined by the parity of entry.                          ss.UsedByObject1 = ss.UsedByObject1 ^ segment.ObjectNumber == 1;                      else                      {                          // For polyline segment - interior. "Use" is defined by the fact of the entry.                          ss.UsedByObject1 = ss.UsedByObject1 || segment.ObjectNumber == 1;                      }                        if (_sourceGeometry2 is Polygon)                          ss.UsedByObject2 = ss.UsedByObject2 ^ segment.ObjectNumber == 2;                      else                          ss.UsedByObject2 = ss.UsedByObject2 || segment.ObjectNumber == 2;                        if (segment.ObjectNumber == 1)                          ss.Object1OccurrencesCount++;                      else                          ss.Object2OccurrencesCount++;                        return true;                  }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegmentByNodes,The following statement contains a magic number: while (endNodesIndex - startNodesIndex > 1)              {                  int index = startNodesIndex + (endNodesIndex - startNodesIndex) / 2;                  if (_nodes[index].Point.X < minX)                      startNodesIndex = index;                  else                      endNodesIndex = index;              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegmentByNodes,The following statement contains a magic number: for (int i = startNodesIndex; i <= endNodesIndex; i++)              {                  PlanarGraphNode node = _nodes[i];                    // exclude the end-points                  bool isNotCurrentSegmentVertex =                      (!_performSnapping &&                       (PlanimetryAlgorithms.Distance(node.Point' segment.Segment.V1) > tolerance &&                        PlanimetryAlgorithms.Distance(node.Point' segment.Segment.V2) > tolerance)) ||                      (_performSnapping &&                       (!node.Point.ExactEquals(segment.Segment.V1) &&                        !node.Point.ExactEquals(segment.Segment.V2)));                    if (isNotCurrentSegmentVertex)                  {                      if (PlanimetryAlgorithms.DistanceToSegment(node.Point' segment.Segment) < tolerance / 1.45)                      {                          if (nodesCrossPoints == null)                              nodesCrossPoints = new List<ICoordinate>();                            nodesCrossPoints.Add(node.Point);                      }                  }              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegmentBySegments,The following statement contains a magic number: foreach (SplittedSegment ss in relatedSegments)              {                  Dimension crossKind =                      PlanimetryAlgorithms.RobustSegmentsIntersection(ss.Segment'                                                                      currentSegment.Segment'                                                                      out _pointStub'                                                                      out _segmentStub);                    if (crossKind == Dimension.One)                  {                      if (_performSnapping)                      {                          PlanimetryAlgorithms.SnapToGrid(ref _segmentStub.V1' _gridOrigin' PlanimetryAlgorithms.Tolerance);                          PlanimetryAlgorithms.SnapToGrid(ref _segmentStub.V2' _gridOrigin' PlanimetryAlgorithms.Tolerance);                            if (_segmentStub.Length() / PlanimetryAlgorithms.Tolerance > 1.42)                              throw new InvalidOperationException();                          else                          {                              crossKind = Dimension.Zero;                              _pointStub = _segmentStub.V1;                          }                      }                      else                          throw new InvalidOperationException();                  }                    if (crossKind == Dimension.Zero)                      if (PerformSnapping)                      {                          PlanimetryAlgorithms.SnapToGrid(ref _pointStub' _gridOrigin' PlanimetryAlgorithms.Tolerance);                            if (!_pointStub.ExactEquals(currentSegment.Segment.V1) &&                              !_pointStub.ExactEquals(currentSegment.Segment.V2))                          {                                if (segmentsCrossPoints == null)                              {                                  segmentsCrossPoints = new List<ICoordinate>();                                  segmentsToSplit = new List<SplittedSegment>();                              }                                segmentsCrossPoints.Add(_pointStub);                              segmentsToSplit.Add(ss);                          }                      }                      else                      {                          if (!_pointStub.Equals(currentSegment.Segment.V1) &&                              !_pointStub.Equals(currentSegment.Segment.V2))                          {                                if (segmentsCrossPoints == null)                              {                                  segmentsCrossPoints = new List<ICoordinate>();                                  segmentsToSplit = new List<SplittedSegment>();                              }                                segmentsCrossPoints.Add(_pointStub);                              segmentsToSplit.Add(ss);                          }                      }                }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegmentsByCrossPoints,The following statement contains a magic number: foreach (SplittedSegment ss in segmentsToSplit)              {                  removeSplittedSegment(ss);                  if (ss.UsedByObject1)                  {                      SourceSegment s = new SourceSegment();                      s.Segment = new Segment(ss.Segment.V1' segmentsCrossPoints[i]);                      if (!s.Segment.V1.ExactEquals(s.Segment.V2))                      {                          s.ObjectNumber = 1;                          _sourceSegments.Add(s);                      }                        s = new SourceSegment();                      s.Segment = new Segment(segmentsCrossPoints[i]' ss.Segment.V2);                      if (!s.Segment.V1.ExactEquals(s.Segment.V2))                      {                          s.ObjectNumber = 1;                          _sourceSegments.Add(s);                      }                  }                  if (ss.UsedByObject2)                  {                      SourceSegment s = new SourceSegment();                      s.Segment = new Segment(ss.Segment.V1' segmentsCrossPoints[i]);                      if (!s.Segment.V1.ExactEquals(s.Segment.V2))                      {                          s.ObjectNumber = 2;                          _sourceSegments.Add(s);                      }                        s = new SourceSegment();                      s.Segment = new Segment(segmentsCrossPoints[i]' ss.Segment.V2);                      if (!s.Segment.V1.ExactEquals(s.Segment.V2))                      {                          s.ObjectNumber = 2;                          _sourceSegments.Add(s);                      }                  }                  i++;              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegmentsByCrossPoints,The following statement contains a magic number: foreach (SplittedSegment ss in segmentsToSplit)              {                  removeSplittedSegment(ss);                  if (ss.UsedByObject1)                  {                      SourceSegment s = new SourceSegment();                      s.Segment = new Segment(ss.Segment.V1' segmentsCrossPoints[i]);                      if (!s.Segment.V1.ExactEquals(s.Segment.V2))                      {                          s.ObjectNumber = 1;                          _sourceSegments.Add(s);                      }                        s = new SourceSegment();                      s.Segment = new Segment(segmentsCrossPoints[i]' ss.Segment.V2);                      if (!s.Segment.V1.ExactEquals(s.Segment.V2))                      {                          s.ObjectNumber = 1;                          _sourceSegments.Add(s);                      }                  }                  if (ss.UsedByObject2)                  {                      SourceSegment s = new SourceSegment();                      s.Segment = new Segment(ss.Segment.V1' segmentsCrossPoints[i]);                      if (!s.Segment.V1.ExactEquals(s.Segment.V2))                      {                          s.ObjectNumber = 2;                          _sourceSegments.Add(s);                      }                        s = new SourceSegment();                      s.Segment = new Segment(segmentsCrossPoints[i]' ss.Segment.V2);                      if (!s.Segment.V1.ExactEquals(s.Segment.V2))                      {                          s.ObjectNumber = 2;                          _sourceSegments.Add(s);                      }                  }                  i++;              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegmentsByCrossPoints,The following statement contains a magic number: foreach (ICoordinate point in segmentsCrossPoints)              {                  // unit used "owners" segments which crossed the current                  if (segmentsToSplit[i].UsedByObject1)                      addOrMergeNode(point' _sourceGeometry1);                    if (segmentsToSplit[i].UsedByObject2)                      addOrMergeNode(point' _sourceGeometry2);                    //as well as the "owner" of the current segment                  if (currentSegment.ObjectNumber == 1)                      addOrMergeNode(point' _sourceGeometry1);                    if (currentSegment.ObjectNumber == 2)                      addOrMergeNode(point' _sourceGeometry2);                  i++;              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,getRelatedSegments,The following statement contains a magic number: if (_splittedSegmentIndex != null)                  _splittedSegmentIndex.QueryObjectsInRectangle(segment.GetBoundingRectangle()' result);              else              {                  int startIndex = 0;                  int endIndex = _splittedSegments.Count - 1;                  double v2x = segment.V2.X;                  double v1x = segment.V1.X;                  double tolerance = PlanimetryAlgorithms.Tolerance;                    while (endIndex - startIndex > 1)                  {                      int index = startIndex + (endIndex - startIndex) / 2;                      if (_splittedSegments[index].Segment.V1.X > v2x)                          endIndex = index;                      else                          startIndex = index;                  }                    while (endIndex < _splittedSegments.Count - 1 &&                         _splittedSegments[endIndex].Segment.V1.X < v2x + tolerance)                      endIndex++;                    for (int i = endIndex; i >= 0; i--)                  {                      if (_splittedSegments[i].Segment.V2.X + tolerance < v1x ||                          _splittedSegments[i].Segment.V1.X - tolerance > v2x)                          continue;                        result.Add(_splittedSegments[i]);                  }              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,addSplittedSegment,The following statement contains a magic number: if (_splittedSegmentIndex != null)                  _splittedSegmentIndex.Insert(ss);              else              {                  double tolerance = PlanimetryAlgorithms.Tolerance;                  double v1x = ss.Segment.V1.X;                    int startIndex = 0' endIndex = _splittedSegments.Count - 1;                    while (endIndex - startIndex > 1)                  {                      int index = startIndex + (endIndex - startIndex) / 2;                      if (_splittedSegments[index].Segment.V1.X < v1x)                          startIndex = index;                      else                          endIndex = index;                  }                    while (startIndex > 0 &&                         _splittedSegments[startIndex].Segment.V1.X + tolerance > v1x)                      startIndex--;                    while (endIndex < _splittedSegments.Count - 1 &&                         _splittedSegments[endIndex].Segment.V1.X - tolerance < v1x)                      endIndex++;                    for (int i = startIndex; i <= endIndex; i++)                  {                      if (_splittedSegments[i].Segment.V1.X > v1x)                      {                          _splittedSegments.Insert(i' ss);                          return;                      }                  }                    _splittedSegments.Add(ss);              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegments,The following statement contains a magic number: while (_sourceSegments.Count > 0)              {                  SourceSegment currentSegment = _sourceSegments[_sourceSegments.Count - 1];                  _sourceSegments.RemoveAt(_sourceSegments.Count - 1);                    normalizeSourceSegment(currentSegment);                    // calculate the lengths that can match the current or intersects with the                  List<SplittedSegment> relatedSegments = getRelatedSegments(currentSegment.Segment);                    // update previously treated segment in the case of complete coincidence' if it was a coincidence' continue                  if (updateSplittedSegment(relatedSegments' currentSegment))                      continue;                    // Splits the current segment of the nodes if the segment was split' continue                  if (splitSegmentByNodes(currentSegment))                      continue;                    // Splits the current segment of the other segment if the segment was split' continue                  if (splitSegmentBySegments(relatedSegments' currentSegment))                      continue;                    // if we got here' then the segment does not require additional processing' add it to the list of processed segments                  SplittedSegment ss = new SplittedSegment();                  ss.UsedByObject1 = currentSegment.ObjectNumber == 1;                  ss.UsedByObject2 = currentSegment.ObjectNumber == 2;                  ss.Object1OccurrencesCount = currentSegment.ObjectNumber == 1 ? 1 : 0;                  ss.Object2OccurrencesCount = currentSegment.ObjectNumber == 2 ? 1 : 0;                  ss.Segment = currentSegment.Segment;                  addSplittedSegment(ss);              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,splitSegments,The following statement contains a magic number: while (_sourceSegments.Count > 0)              {                  SourceSegment currentSegment = _sourceSegments[_sourceSegments.Count - 1];                  _sourceSegments.RemoveAt(_sourceSegments.Count - 1);                    normalizeSourceSegment(currentSegment);                    // calculate the lengths that can match the current or intersects with the                  List<SplittedSegment> relatedSegments = getRelatedSegments(currentSegment.Segment);                    // update previously treated segment in the case of complete coincidence' if it was a coincidence' continue                  if (updateSplittedSegment(relatedSegments' currentSegment))                      continue;                    // Splits the current segment of the nodes if the segment was split' continue                  if (splitSegmentByNodes(currentSegment))                      continue;                    // Splits the current segment of the other segment if the segment was split' continue                  if (splitSegmentBySegments(relatedSegments' currentSegment))                      continue;                    // if we got here' then the segment does not require additional processing' add it to the list of processed segments                  SplittedSegment ss = new SplittedSegment();                  ss.UsedByObject1 = currentSegment.ObjectNumber == 1;                  ss.UsedByObject2 = currentSegment.ObjectNumber == 2;                  ss.Object1OccurrencesCount = currentSegment.ObjectNumber == 1 ? 1 : 0;                  ss.Object2OccurrencesCount = currentSegment.ObjectNumber == 2 ? 1 : 0;                  ss.Segment = currentSegment.Segment;                  addSplittedSegment(ss);              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,getNodeAt,The following statement contains a magic number: while (endNodesIndex - startNodesIndex > 1)              {                  int index = startNodesIndex + (endNodesIndex - startNodesIndex) / 2;                  if (_nodes[index].Point.X < minX)                      startNodesIndex = index;                  else                      endNodesIndex = index;              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,translateAngleQuadrant,The following statement contains a magic number: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return _twoPi - angle; }              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,translateAngleQuadrant,The following statement contains a magic number: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return _twoPi - angle; }              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,translateAngleQuadrant,The following statement contains a magic number: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return _twoPi - angle; }              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,pointQuadrantNumber,The following statement contains a magic number: if (p.X > 0)              {                  if (p.Y > 0) return 1; else return 4;              }              else              {                  if (p.Y > 0) return 2; else return 3;              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,pointQuadrantNumber,The following statement contains a magic number: if (p.X > 0)              {                  if (p.Y > 0) return 1; else return 4;              }              else              {                  if (p.Y > 0) return 2; else return 3;              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,pointQuadrantNumber,The following statement contains a magic number: if (p.X > 0)              {                  if (p.Y > 0) return 1; else return 4;              }              else              {                  if (p.Y > 0) return 2; else return 3;              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,processLinePath,The following statement contains a magic number: for (int j = 0; j < startNode.IncidentEdges.Count; j++)              {                  if (!startNode.IncidentEdges[j].IsVisited &&                       startNode.IncidentEdges[j].Enabled) //incident to Fail                  {                      j = -1;                      sideNumber++;                      if (sideNumber > 2)                          break;                        if (result == null && sideNumber == 1)                      {                          result = new LinePath();                          result.Vertices.Add((ICoordinate)startNode.Point.Clone()); // the first peak of the new polyline                      }                        PlanarGraphNode currentNode = startNode;                        Segment previousEdge = new Segment();                      bool edgeDetected = false;                        List<PlanarGraphEdge> possibleEdges = new List<PlanarGraphEdge>();                        while (true)                      {                          // definition of edges to turn to the right                          possibleEdges.Clear();                            foreach (PlanarGraphEdge edge in currentNode.IncidentEdges)                              if (!edge.IsVisited && edge.Enabled)                                  possibleEdges.Add(edge);                            if (possibleEdges.Count > 0)                          {                              if (!edgeDetected)                              {                                  previousEdge.V1 =(ICoordinate)currentNode.Point.Clone();                                  previousEdge.V2 = (ICoordinate)currentNode.Point.Clone();                                    double l = PlanimetryAlgorithms.Tolerance * 1e10;                                    previousEdge.V2.Y += l;                                  edgeDetected = true;                              }                                double maxAngle = 0; // maximum rotation angle found                              double minAngle = _twoPi; // минимальный найденный угол поворота                              PlanarGraphEdge targetEdge = null; // Target edge                                if (possibleEdges.Count == 1)                                  targetEdge = possibleEdges[0];                              else                              {                                  for (int k = 0; k < possibleEdges.Count; k++) // find the edge with the minimum angle                                  {                                      PlanarGraphEdge edge = possibleEdges[k];                                      Segment kEdge = new Segment(edge.Node1.Point' edge.Node2.Point);                                      double angle;                                      try                                      {                                          angle = getAngleBetweenEdges(ref previousEdge' ref kEdge' false);                                      }                                      catch (ArgumentException)                                      {                                          throw new TopologyException();                                      }                                        if (angle >= _twoPi)                                          angle -= _twoPi;                                        if (result.Vertices.Count > 1)                                      {                                          if (angle > maxAngle)                                          {                                              maxAngle = angle;                                              targetEdge = edge;                                          }                                      }                                      else // first rib - a special case' we search for the minimum angle                                      {                                          if (angle < minAngle)                                          {                                              minAngle = angle;                                              targetEdge = edge;                                          }                                      }                                  }                              }                                if (targetEdge != null)                              {                                  if (targetEdge.Node1.Point.ExactEquals(currentNode.Point))                                  {                                      if (markObject1EdgesOrientation)                                          targetEdge.OrientationInObject1 = PlanarGraphEdge.EdgeOrientation.Forward;                                        if (markObject2EdgesOrientation)                                          targetEdge.OrientationInObject2 = PlanarGraphEdge.EdgeOrientation.Forward;                                        ICoordinate coord = (ICoordinate)targetEdge.Node2.Point.Clone();                                      if (sideNumber == 1)                                          result.Vertices.Add(coord);                                      else                                          result.Vertices.Insert(0' coord);                                      currentNode = targetEdge.Node2;                                  }                                  else                                  {                                      if (markObject1EdgesOrientation)                                          targetEdge.OrientationInObject1 = PlanarGraphEdge.EdgeOrientation.Backward;                                        if (markObject2EdgesOrientation)                                          targetEdge.OrientationInObject2 = PlanarGraphEdge.EdgeOrientation.Backward;                                        ICoordinate coord = (ICoordinate)targetEdge.Node1.Point.Clone();                                      if (sideNumber == 1)                                          result.Vertices.Add(coord);                                      else                                          result.Vertices.Insert(0' coord);                                      currentNode = targetEdge.Node1;                                  }                                    previousEdge = new Segment(targetEdge.Node1.Point' targetEdge.Node2.Point);                                  targetEdge.IsVisited = true;                              }                              else                                  break;                          }                          else                              break;                      }                  }              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,processLinePath,The following statement contains a magic number: for (int j = 0; j < startNode.IncidentEdges.Count; j++)              {                  if (!startNode.IncidentEdges[j].IsVisited &&                       startNode.IncidentEdges[j].Enabled) //incident to Fail                  {                      j = -1;                      sideNumber++;                      if (sideNumber > 2)                          break;                        if (result == null && sideNumber == 1)                      {                          result = new LinePath();                          result.Vertices.Add((ICoordinate)startNode.Point.Clone()); // the first peak of the new polyline                      }                        PlanarGraphNode currentNode = startNode;                        Segment previousEdge = new Segment();                      bool edgeDetected = false;                        List<PlanarGraphEdge> possibleEdges = new List<PlanarGraphEdge>();                        while (true)                      {                          // definition of edges to turn to the right                          possibleEdges.Clear();                            foreach (PlanarGraphEdge edge in currentNode.IncidentEdges)                              if (!edge.IsVisited && edge.Enabled)                                  possibleEdges.Add(edge);                            if (possibleEdges.Count > 0)                          {                              if (!edgeDetected)                              {                                  previousEdge.V1 =(ICoordinate)currentNode.Point.Clone();                                  previousEdge.V2 = (ICoordinate)currentNode.Point.Clone();                                    double l = PlanimetryAlgorithms.Tolerance * 1e10;                                    previousEdge.V2.Y += l;                                  edgeDetected = true;                              }                                double maxAngle = 0; // maximum rotation angle found                              double minAngle = _twoPi; // минимальный найденный угол поворота                              PlanarGraphEdge targetEdge = null; // Target edge                                if (possibleEdges.Count == 1)                                  targetEdge = possibleEdges[0];                              else                              {                                  for (int k = 0; k < possibleEdges.Count; k++) // find the edge with the minimum angle                                  {                                      PlanarGraphEdge edge = possibleEdges[k];                                      Segment kEdge = new Segment(edge.Node1.Point' edge.Node2.Point);                                      double angle;                                      try                                      {                                          angle = getAngleBetweenEdges(ref previousEdge' ref kEdge' false);                                      }                                      catch (ArgumentException)                                      {                                          throw new TopologyException();                                      }                                        if (angle >= _twoPi)                                          angle -= _twoPi;                                        if (result.Vertices.Count > 1)                                      {                                          if (angle > maxAngle)                                          {                                              maxAngle = angle;                                              targetEdge = edge;                                          }                                      }                                      else // first rib - a special case' we search for the minimum angle                                      {                                          if (angle < minAngle)                                          {                                              minAngle = angle;                                              targetEdge = edge;                                          }                                      }                                  }                              }                                if (targetEdge != null)                              {                                  if (targetEdge.Node1.Point.ExactEquals(currentNode.Point))                                  {                                      if (markObject1EdgesOrientation)                                          targetEdge.OrientationInObject1 = PlanarGraphEdge.EdgeOrientation.Forward;                                        if (markObject2EdgesOrientation)                                          targetEdge.OrientationInObject2 = PlanarGraphEdge.EdgeOrientation.Forward;                                        ICoordinate coord = (ICoordinate)targetEdge.Node2.Point.Clone();                                      if (sideNumber == 1)                                          result.Vertices.Add(coord);                                      else                                          result.Vertices.Insert(0' coord);                                      currentNode = targetEdge.Node2;                                  }                                  else                                  {                                      if (markObject1EdgesOrientation)                                          targetEdge.OrientationInObject1 = PlanarGraphEdge.EdgeOrientation.Backward;                                        if (markObject2EdgesOrientation)                                          targetEdge.OrientationInObject2 = PlanarGraphEdge.EdgeOrientation.Backward;                                        ICoordinate coord = (ICoordinate)targetEdge.Node1.Point.Clone();                                      if (sideNumber == 1)                                          result.Vertices.Add(coord);                                      else                                          result.Vertices.Insert(0' coord);                                      currentNode = targetEdge.Node1;                                  }                                    previousEdge = new Segment(targetEdge.Node1.Point' targetEdge.Node2.Point);                                  targetEdge.IsVisited = true;                              }                              else                                  break;                          }                          else                              break;                      }                  }              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,BuildPolygon,The following statement contains a magic number: for (int i = 0; i < _nodes.Count; i++)              {                  // the first node is involved in at least one outer loop                  if (i == 0)                      _nodes[i].Layout = PlanarGraphNode.NodeLayout.External;                    // If the location of the site is not yet known                  if (_nodes[i].Layout == PlanarGraphNode.NodeLayout.Unknown)                  {                      ICoordinate point = _nodes[i].Point;                      bool isInternalNode = Polygon.ContainsPoint(point' result);                        if (isInternalNode)                          _nodes[i].Layout = PlanarGraphNode.NodeLayout.Internal;                      else                          _nodes[i].Layout = PlanarGraphNode.NodeLayout.External;                  }                    Contour c;                  do                  {                      c = processContour(i'                                                 _nodes[i].Layout'                                                 markObject1EdgesOrientation'                                                 markObject2EdgesOrientation);                        if (c != null)                          if (c.Vertices.Count > 2) //discard degenerate contours                          {                              if (_nodes[i].Layout == PlanarGraphNode.NodeLayout.Internal)                                  c.Layout = Contour.ContourLayout.Internal;                              else                                  c.Layout = Contour.ContourLayout.External;                                c.Reverse();                              result.Add(c);                          }                  } while (c != null);              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,processContour,The following statement contains a magic number: for (int j = 0; j < startNode.IncidentEdges.Count; j++)              {                  if (!startNode.IncidentEdges[j].IsVisited &&                      startNode.IncidentEdges[j].Enabled) // инцидентное ребро не пройдено                  {                      if (result == null)                          result = new Contour();                        result.Vertices.Add((ICoordinate)startNode.Point.Clone()); // первая вершина нового контура                        PlanarGraphNode currentNode = startNode;                        Segment previousEdge = new Segment();                      bool edgeDetected = false;                        List<PlanarGraphEdge> possibleEdges = new List<PlanarGraphEdge>();                        while (true)                      {                          // определение ребра для поворота направо (налево для дырки)                          possibleEdges.Clear();                            foreach (PlanarGraphEdge edge in currentNode.IncidentEdges)                              if (!edge.IsVisited && edge.Enabled)                                  possibleEdges.Add(edge);                            if (possibleEdges.Count > 0)                          {                              if (!edgeDetected)                              {                                  previousEdge.V1 = (ICoordinate)currentNode.Point.Clone();                                  previousEdge.V2 = (ICoordinate)currentNode.Point.Clone();                                    double l = PlanimetryAlgorithms.Tolerance * 1e10;                                    if (layout == PlanarGraphNode.NodeLayout.Internal) // для 1-го ребра должен определяться угол с вертикалью                                      previousEdge.V2.Y -= l;                                  else                                      previousEdge.V2.Y += l;                                    edgeDetected = true;                              }                                double maxAngle = 0; // максимальный найденный угол поворота                              double minAngle = _twoPi; // минимальный найденный угол поворота                              PlanarGraphEdge targetEdge = null; // целевое ребро                                if (possibleEdges.Count == 1)                                  targetEdge = possibleEdges[0];                              else                              {                                  for (int k = 0; k < possibleEdges.Count; k++) // находим ребро с минимальным углом                                  {                                      PlanarGraphEdge edge = possibleEdges[k];                                      Segment kEdge = new Segment(edge.Node1.Point' edge.Node2.Point);                                      double angle;                                      try                                      {                                          if (result.Vertices.Count < 2)                                              angle = Math.Min(getAngleBetweenEdges(ref previousEdge' ref kEdge' true)'                                                               getAngleBetweenEdges(ref previousEdge' ref kEdge' false));                                          else                                              angle = getAngleBetweenEdges(ref previousEdge' ref kEdge' layout == PlanarGraphNode.NodeLayout.Internal);                                      }                                      catch (ArgumentException)                                      {                                          throw new TopologyException();                                      }                                        if (angle >= _twoPi)                                          angle -= _twoPi;                                        if (result.Vertices.Count > 1)                                      {                                          if (angle > maxAngle)                                          {                                              maxAngle = angle;                                              targetEdge = edge;                                          }                                      }                                      else // первое ребро - особый случай' ищем минимальный угол                                      {                                          if (angle < minAngle)                                          {                                              minAngle = angle;                                              targetEdge = edge;                                          }                                      }                                  }                              }                                if (targetEdge != null)                              {                                  if (targetEdge.Node1.Point.ExactEquals(currentNode.Point))                                  {                                      if (markObject1EdgesOrientation)                                              targetEdge.OrientationInObject1 = PlanarGraphEdge.EdgeOrientation.Forward;                                        if (markObject2EdgesOrientation)                                              targetEdge.OrientationInObject2 = PlanarGraphEdge.EdgeOrientation.Forward;                                        result.Vertices.Add((ICoordinate)targetEdge.Node2.Point.Clone());                                      targetEdge.Node2.Layout = layout;                                      currentNode = targetEdge.Node2;                                  }                                  else                                  {                                      if (markObject1EdgesOrientation)                                              targetEdge.OrientationInObject1 = PlanarGraphEdge.EdgeOrientation.Backward;                                        if (markObject2EdgesOrientation)                                              targetEdge.OrientationInObject2 = PlanarGraphEdge.EdgeOrientation.Backward;                                        result.Vertices.Add((ICoordinate)targetEdge.Node1.Point.Clone());                                      targetEdge.Node1.Layout = layout;                                      currentNode = targetEdge.Node1;                                  }                                    previousEdge = new Segment(targetEdge.Node1.Point' targetEdge.Node2.Point);                                  targetEdge.IsVisited = true;                                    if (currentNode == startNode) // пришли' контур сформирован                                  {                                      result.Vertices.RemoveAt(result.Vertices.Count - 1);                                      break;                                  }                              }                              else                                  break;                          }                          else                          {                              // по какой-то причине контур не может быть завершен                              throw new TopologyException();                          }                      }                      break;                  }              }
Magic Number,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,processContour,The following statement contains a magic number: for (int j = 0; j < startNode.IncidentEdges.Count; j++)              {                  if (!startNode.IncidentEdges[j].IsVisited &&                      startNode.IncidentEdges[j].Enabled) // инцидентное ребро не пройдено                  {                      if (result == null)                          result = new Contour();                        result.Vertices.Add((ICoordinate)startNode.Point.Clone()); // первая вершина нового контура                        PlanarGraphNode currentNode = startNode;                        Segment previousEdge = new Segment();                      bool edgeDetected = false;                        List<PlanarGraphEdge> possibleEdges = new List<PlanarGraphEdge>();                        while (true)                      {                          // определение ребра для поворота направо (налево для дырки)                          possibleEdges.Clear();                            foreach (PlanarGraphEdge edge in currentNode.IncidentEdges)                              if (!edge.IsVisited && edge.Enabled)                                  possibleEdges.Add(edge);                            if (possibleEdges.Count > 0)                          {                              if (!edgeDetected)                              {                                  previousEdge.V1 = (ICoordinate)currentNode.Point.Clone();                                  previousEdge.V2 = (ICoordinate)currentNode.Point.Clone();                                    double l = PlanimetryAlgorithms.Tolerance * 1e10;                                    if (layout == PlanarGraphNode.NodeLayout.Internal) // для 1-го ребра должен определяться угол с вертикалью                                      previousEdge.V2.Y -= l;                                  else                                      previousEdge.V2.Y += l;                                    edgeDetected = true;                              }                                double maxAngle = 0; // максимальный найденный угол поворота                              double minAngle = _twoPi; // минимальный найденный угол поворота                              PlanarGraphEdge targetEdge = null; // целевое ребро                                if (possibleEdges.Count == 1)                                  targetEdge = possibleEdges[0];                              else                              {                                  for (int k = 0; k < possibleEdges.Count; k++) // находим ребро с минимальным углом                                  {                                      PlanarGraphEdge edge = possibleEdges[k];                                      Segment kEdge = new Segment(edge.Node1.Point' edge.Node2.Point);                                      double angle;                                      try                                      {                                          if (result.Vertices.Count < 2)                                              angle = Math.Min(getAngleBetweenEdges(ref previousEdge' ref kEdge' true)'                                                               getAngleBetweenEdges(ref previousEdge' ref kEdge' false));                                          else                                              angle = getAngleBetweenEdges(ref previousEdge' ref kEdge' layout == PlanarGraphNode.NodeLayout.Internal);                                      }                                      catch (ArgumentException)                                      {                                          throw new TopologyException();                                      }                                        if (angle >= _twoPi)                                          angle -= _twoPi;                                        if (result.Vertices.Count > 1)                                      {                                          if (angle > maxAngle)                                          {                                              maxAngle = angle;                                              targetEdge = edge;                                          }                                      }                                      else // первое ребро - особый случай' ищем минимальный угол                                      {                                          if (angle < minAngle)                                          {                                              minAngle = angle;                                              targetEdge = edge;                                          }                                      }                                  }                              }                                if (targetEdge != null)                              {                                  if (targetEdge.Node1.Point.ExactEquals(currentNode.Point))                                  {                                      if (markObject1EdgesOrientation)                                              targetEdge.OrientationInObject1 = PlanarGraphEdge.EdgeOrientation.Forward;                                        if (markObject2EdgesOrientation)                                              targetEdge.OrientationInObject2 = PlanarGraphEdge.EdgeOrientation.Forward;                                        result.Vertices.Add((ICoordinate)targetEdge.Node2.Point.Clone());                                      targetEdge.Node2.Layout = layout;                                      currentNode = targetEdge.Node2;                                  }                                  else                                  {                                      if (markObject1EdgesOrientation)                                              targetEdge.OrientationInObject1 = PlanarGraphEdge.EdgeOrientation.Backward;                                        if (markObject2EdgesOrientation)                                              targetEdge.OrientationInObject2 = PlanarGraphEdge.EdgeOrientation.Backward;                                        result.Vertices.Add((ICoordinate)targetEdge.Node1.Point.Clone());                                      targetEdge.Node1.Layout = layout;                                      currentNode = targetEdge.Node1;                                  }                                    previousEdge = new Segment(targetEdge.Node1.Point' targetEdge.Node2.Point);                                  targetEdge.IsVisited = true;                                    if (currentNode == startNode) // пришли' контур сформирован                                  {                                      result.Vertices.RemoveAt(result.Vertices.Count - 1);                                      break;                                  }                              }                              else                                  break;                          }                          else                          {                              // по какой-то причине контур не может быть завершен                              throw new TopologyException();                          }                      }                      break;                  }              }
Magic Number,MapAround.IO,BigEndianBinaryWriter,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\BigEndianBinaryWriter.cs,WriteIntBE,The following statement contains a magic number: Debug.Assert(bytes.Length == 4);
Magic Number,MapAround.IO,BigEndianBinaryWriter,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\BigEndianBinaryWriter.cs,WriteIntBE,The following statement contains a magic number: Array.Reverse(bytes' 0' 4);
Magic Number,MapAround.IO,BigEndianBinaryWriter,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\BigEndianBinaryWriter.cs,WriteDoubleBE,The following statement contains a magic number: Debug.Assert(bytes.Length == 8);
Magic Number,MapAround.IO,BigEndianBinaryWriter,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\BigEndianBinaryWriter.cs,WriteDoubleBE,The following statement contains a magic number: Array.Reverse(bytes' 0' 8);
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,AddColumn,The following statement contains a magic number: if (tempFieldName.Length > 11)              {                  tempFieldName = tempFieldName.Substring(0' 11);                  //!!!Trace.Write("FieldName " + fieldName + " is longer than 11 characters' truncating to " + tempFieldName);              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,AddColumn,The following statement contains a magic number: if (tempFieldName.Length > 11)              {                  tempFieldName = tempFieldName.Substring(0' 11);                  //!!!Trace.Write("FieldName " + fieldName + " is longer than 11 characters' truncating to " + tempFieldName);              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,AddColumn,The following statement contains a magic number: if ((fieldType == 'C') || (fieldType == 'c'))              {                  tempFieldDescriptors[_dbaseColumns.Length].DbaseType = 'C';              }              else if ((fieldType == 'S') || (fieldType == 's'))              {                  tempFieldDescriptors[_dbaseColumns.Length].DbaseType = 'C';                  tempFieldDescriptors[_dbaseColumns.Length].Length = 8;              }              else if ((fieldType == 'D') || (fieldType == 'd'))              {                  tempFieldDescriptors[_dbaseColumns.Length].DbaseType = 'D';                  tempFieldDescriptors[_dbaseColumns.Length].Length = 8;              }              else if ((fieldType == 'F') || (fieldType == 'f'))              {                  tempFieldDescriptors[_dbaseColumns.Length].DbaseType = 'F';              }              else if ((fieldType == 'N') || (fieldType == 'n'))              {                  tempFieldDescriptors[_dbaseColumns.Length].DbaseType = 'N';                  if (decimalCount < 0)                  {                      tempFieldDescriptors[_dbaseColumns.Length].DecimalCount = 0;                  }                  if (decimalCount > fieldLength - 1)                  {                      tempFieldDescriptors[_dbaseColumns.Length].DecimalCount = fieldLength - 1;                  }              }              else if ((fieldType == 'L') || (fieldType == 'l'))              {                  tempFieldDescriptors[_dbaseColumns.Length].DbaseType = 'L';                  tempFieldDescriptors[_dbaseColumns.Length].Length = 1;              }              else              {                  throw new NotSupportedException("Unsupported field type " + fieldType + " For column " + fieldName);              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,AddColumn,The following statement contains a magic number: if ((fieldType == 'C') || (fieldType == 'c'))              {                  tempFieldDescriptors[_dbaseColumns.Length].DbaseType = 'C';              }              else if ((fieldType == 'S') || (fieldType == 's'))              {                  tempFieldDescriptors[_dbaseColumns.Length].DbaseType = 'C';                  tempFieldDescriptors[_dbaseColumns.Length].Length = 8;              }              else if ((fieldType == 'D') || (fieldType == 'd'))              {                  tempFieldDescriptors[_dbaseColumns.Length].DbaseType = 'D';                  tempFieldDescriptors[_dbaseColumns.Length].Length = 8;              }              else if ((fieldType == 'F') || (fieldType == 'f'))              {                  tempFieldDescriptors[_dbaseColumns.Length].DbaseType = 'F';              }              else if ((fieldType == 'N') || (fieldType == 'n'))              {                  tempFieldDescriptors[_dbaseColumns.Length].DbaseType = 'N';                  if (decimalCount < 0)                  {                      tempFieldDescriptors[_dbaseColumns.Length].DecimalCount = 0;                  }                  if (decimalCount > fieldLength - 1)                  {                      tempFieldDescriptors[_dbaseColumns.Length].DecimalCount = fieldLength - 1;                  }              }              else if ((fieldType == 'L') || (fieldType == 'l'))              {                  tempFieldDescriptors[_dbaseColumns.Length].DbaseType = 'L';                  tempFieldDescriptors[_dbaseColumns.Length].Length = 1;              }              else              {                  throw new NotSupportedException("Unsupported field type " + fieldType + " For column " + fieldName);              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,AddColumn,The following statement contains a magic number: _headerLength = 33 + 32 * _dbaseColumns.Length;
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,AddColumn,The following statement contains a magic number: _headerLength = 33 + 32 * _dbaseColumns.Length;
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,RemoveColumn,The following statement contains a magic number: _headerLength = 33 + 32 * _dbaseColumns.Length;
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,RemoveColumn,The following statement contains a magic number: _headerLength = 33 + 32 * _dbaseColumns.Length;
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Read,The following statement contains a magic number: _updateDate = new DateTime(year + 1900' month' day);
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Read,The following statement contains a magic number: reader.BaseStream.Seek(29' SeekOrigin.Begin);
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Read,The following statement contains a magic number: reader.BaseStream.Seek(32' SeekOrigin.Begin);
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Read,The following statement contains a magic number: for (int i = 0; i < _numFields; i++)              {                  _dbaseColumns[i] = new DbaseFieldDescriptor();                    // read the field name				                  byte[] buffer = reader.ReadBytes(11);                  string name = _encoding.GetString(buffer);                    if (name.Contains("\0"))                      name = name.Substring(0' name.IndexOf('\0'));                    name = name.Replace("\0"' "").Trim();                    int nullPoint = name.IndexOf((char)0);                  if (nullPoint != -1)                      name = name.Substring(0' nullPoint);                  _dbaseColumns[i].Name = name;                    // read the field type                  _dbaseColumns[i].DbaseType = (char)reader.ReadByte();                  _dbaseColumns[i].DataType = DbaseFieldDescriptor.GetDataType(_dbaseColumns[i].DbaseType);                    // read the field data address' offset from the start of the record.                  _dbaseColumns[i].DataAddress = reader.ReadInt32();                    // read the field length in bytes                  int tempLength = (int)reader.ReadByte();                  if (tempLength < 0) tempLength = tempLength + 256;                  _dbaseColumns[i].Length = tempLength;                    // read the field decimal count in bytes                  _dbaseColumns[i].DecimalCount = (int)reader.ReadByte();                  if (_dbaseColumns[i].DecimalCount == 0 && _dbaseColumns[i].DataType == typeof(double))                      if (_dbaseColumns[i].Length <= 2)                          _dbaseColumns[i].DataType = typeof(Int16);                      else if (_dbaseColumns[i].Length <= 4)                          _dbaseColumns[i].DataType = typeof(Int32);                      else                          _dbaseColumns[i].DataType = typeof(Int64);                    // read the reserved bytes.                  //reader.skipBytes(14);                  reader.ReadBytes(14);              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Read,The following statement contains a magic number: for (int i = 0; i < _numFields; i++)              {                  _dbaseColumns[i] = new DbaseFieldDescriptor();                    // read the field name				                  byte[] buffer = reader.ReadBytes(11);                  string name = _encoding.GetString(buffer);                    if (name.Contains("\0"))                      name = name.Substring(0' name.IndexOf('\0'));                    name = name.Replace("\0"' "").Trim();                    int nullPoint = name.IndexOf((char)0);                  if (nullPoint != -1)                      name = name.Substring(0' nullPoint);                  _dbaseColumns[i].Name = name;                    // read the field type                  _dbaseColumns[i].DbaseType = (char)reader.ReadByte();                  _dbaseColumns[i].DataType = DbaseFieldDescriptor.GetDataType(_dbaseColumns[i].DbaseType);                    // read the field data address' offset from the start of the record.                  _dbaseColumns[i].DataAddress = reader.ReadInt32();                    // read the field length in bytes                  int tempLength = (int)reader.ReadByte();                  if (tempLength < 0) tempLength = tempLength + 256;                  _dbaseColumns[i].Length = tempLength;                    // read the field decimal count in bytes                  _dbaseColumns[i].DecimalCount = (int)reader.ReadByte();                  if (_dbaseColumns[i].DecimalCount == 0 && _dbaseColumns[i].DataType == typeof(double))                      if (_dbaseColumns[i].Length <= 2)                          _dbaseColumns[i].DataType = typeof(Int16);                      else if (_dbaseColumns[i].Length <= 4)                          _dbaseColumns[i].DataType = typeof(Int32);                      else                          _dbaseColumns[i].DataType = typeof(Int64);                    // read the reserved bytes.                  //reader.skipBytes(14);                  reader.ReadBytes(14);              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Read,The following statement contains a magic number: for (int i = 0; i < _numFields; i++)              {                  _dbaseColumns[i] = new DbaseFieldDescriptor();                    // read the field name				                  byte[] buffer = reader.ReadBytes(11);                  string name = _encoding.GetString(buffer);                    if (name.Contains("\0"))                      name = name.Substring(0' name.IndexOf('\0'));                    name = name.Replace("\0"' "").Trim();                    int nullPoint = name.IndexOf((char)0);                  if (nullPoint != -1)                      name = name.Substring(0' nullPoint);                  _dbaseColumns[i].Name = name;                    // read the field type                  _dbaseColumns[i].DbaseType = (char)reader.ReadByte();                  _dbaseColumns[i].DataType = DbaseFieldDescriptor.GetDataType(_dbaseColumns[i].DbaseType);                    // read the field data address' offset from the start of the record.                  _dbaseColumns[i].DataAddress = reader.ReadInt32();                    // read the field length in bytes                  int tempLength = (int)reader.ReadByte();                  if (tempLength < 0) tempLength = tempLength + 256;                  _dbaseColumns[i].Length = tempLength;                    // read the field decimal count in bytes                  _dbaseColumns[i].DecimalCount = (int)reader.ReadByte();                  if (_dbaseColumns[i].DecimalCount == 0 && _dbaseColumns[i].DataType == typeof(double))                      if (_dbaseColumns[i].Length <= 2)                          _dbaseColumns[i].DataType = typeof(Int16);                      else if (_dbaseColumns[i].Length <= 4)                          _dbaseColumns[i].DataType = typeof(Int32);                      else                          _dbaseColumns[i].DataType = typeof(Int64);                    // read the reserved bytes.                  //reader.skipBytes(14);                  reader.ReadBytes(14);              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Read,The following statement contains a magic number: for (int i = 0; i < _numFields; i++)              {                  _dbaseColumns[i] = new DbaseFieldDescriptor();                    // read the field name				                  byte[] buffer = reader.ReadBytes(11);                  string name = _encoding.GetString(buffer);                    if (name.Contains("\0"))                      name = name.Substring(0' name.IndexOf('\0'));                    name = name.Replace("\0"' "").Trim();                    int nullPoint = name.IndexOf((char)0);                  if (nullPoint != -1)                      name = name.Substring(0' nullPoint);                  _dbaseColumns[i].Name = name;                    // read the field type                  _dbaseColumns[i].DbaseType = (char)reader.ReadByte();                  _dbaseColumns[i].DataType = DbaseFieldDescriptor.GetDataType(_dbaseColumns[i].DbaseType);                    // read the field data address' offset from the start of the record.                  _dbaseColumns[i].DataAddress = reader.ReadInt32();                    // read the field length in bytes                  int tempLength = (int)reader.ReadByte();                  if (tempLength < 0) tempLength = tempLength + 256;                  _dbaseColumns[i].Length = tempLength;                    // read the field decimal count in bytes                  _dbaseColumns[i].DecimalCount = (int)reader.ReadByte();                  if (_dbaseColumns[i].DecimalCount == 0 && _dbaseColumns[i].DataType == typeof(double))                      if (_dbaseColumns[i].Length <= 2)                          _dbaseColumns[i].DataType = typeof(Int16);                      else if (_dbaseColumns[i].Length <= 4)                          _dbaseColumns[i].DataType = typeof(Int32);                      else                          _dbaseColumns[i].DataType = typeof(Int64);                    // read the reserved bytes.                  //reader.skipBytes(14);                  reader.ReadBytes(14);              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Read,The following statement contains a magic number: for (int i = 0; i < _numFields; i++)              {                  _dbaseColumns[i] = new DbaseFieldDescriptor();                    // read the field name				                  byte[] buffer = reader.ReadBytes(11);                  string name = _encoding.GetString(buffer);                    if (name.Contains("\0"))                      name = name.Substring(0' name.IndexOf('\0'));                    name = name.Replace("\0"' "").Trim();                    int nullPoint = name.IndexOf((char)0);                  if (nullPoint != -1)                      name = name.Substring(0' nullPoint);                  _dbaseColumns[i].Name = name;                    // read the field type                  _dbaseColumns[i].DbaseType = (char)reader.ReadByte();                  _dbaseColumns[i].DataType = DbaseFieldDescriptor.GetDataType(_dbaseColumns[i].DbaseType);                    // read the field data address' offset from the start of the record.                  _dbaseColumns[i].DataAddress = reader.ReadInt32();                    // read the field length in bytes                  int tempLength = (int)reader.ReadByte();                  if (tempLength < 0) tempLength = tempLength + 256;                  _dbaseColumns[i].Length = tempLength;                    // read the field decimal count in bytes                  _dbaseColumns[i].DecimalCount = (int)reader.ReadByte();                  if (_dbaseColumns[i].DecimalCount == 0 && _dbaseColumns[i].DataType == typeof(double))                      if (_dbaseColumns[i].Length <= 2)                          _dbaseColumns[i].DataType = typeof(Int16);                      else if (_dbaseColumns[i].Length <= 4)                          _dbaseColumns[i].DataType = typeof(Int32);                      else                          _dbaseColumns[i].DataType = typeof(Int64);                    // read the reserved bytes.                  //reader.skipBytes(14);                  reader.ReadBytes(14);              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Write,The following statement contains a magic number: writer.Write((byte)(_updateDate.Year - 1900));
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Write,The following statement contains a magic number: writer.BaseStream.Seek(29' SeekOrigin.Begin);
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Write,The following statement contains a magic number: writer.BaseStream.Seek(32' SeekOrigin.Begin);
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Write,The following statement contains a magic number: for (int i = 0; i < _dbaseColumns.Length; i++)              {                  // write the field name                  for (int j = 0; j < 11; j++)                  {                      if (_dbaseColumns[i].Name.Length > j)                          writer.Write((byte)_dbaseColumns[i].Name[j]);                      else writer.Write((byte)0);                  }                    // write the field type                  writer.Write((char)_dbaseColumns[i].DbaseType);                    // write the field data address' offset from the start of the record.                  //!!!                  writer.Write(0);                  tempOffset += _dbaseColumns[i].Length;                    // write the length of the field.                  writer.Write((byte)_dbaseColumns[i].Length);                    // write the decimal count.                  writer.Write((byte)_dbaseColumns[i].DecimalCount);                    // write the reserved bytes.                  //for (int j = 0; j < 14; j++) writer.Write((byte)0);                  //!!!!                  writer.BaseStream.Seek(14' SeekOrigin.Current);              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,Write,The following statement contains a magic number: for (int i = 0; i < _dbaseColumns.Length; i++)              {                  // write the field name                  for (int j = 0; j < 11; j++)                  {                      if (_dbaseColumns[i].Name.Length > j)                          writer.Write((byte)_dbaseColumns[i].Name[j]);                      else writer.Write((byte)0);                  }                    // write the field type                  writer.Write((char)_dbaseColumns[i].DbaseType);                    // write the field data address' offset from the start of the record.                  //!!!                  writer.Write(0);                  tempOffset += _dbaseColumns[i].Length;                    // write the length of the field.                  writer.Write((byte)_dbaseColumns[i].Length);                    // write the decimal count.                  writer.Write((byte)_dbaseColumns[i].DecimalCount);                    // write the reserved bytes.                  //for (int j = 0; j < 14; j++) writer.Write((byte)0);                  //!!!!                  writer.BaseStream.Seek(14' SeekOrigin.Current);              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,RecountColumnLength,The following statement contains a magic number: if (field.DataType == typeof(Double) || field.DataType == typeof(Single) || field.DataType == typeof(Decimal))              {                  if (decimalCount == 0)                  {                      size += 3; // с учетом разделителя                      decimalCount = 2;                  }              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,RecountColumnLength,The following statement contains a magic number: if (field.DataType == typeof(Double) || field.DataType == typeof(Single) || field.DataType == typeof(Decimal))              {                  if (decimalCount == 0)                  {                      size += 3; // с учетом разделителя                      decimalCount = 2;                  }              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 437: return 0x01; //DOS USA code page 437                   case 850: return 0x02; // DOS Multilingual code page 850                   case 1252: return 0x03; // Windows ANSI code page 1252                   case 10000: return 0x04; // Standard Macintosh                   case 865: return 0x08; // Danish OEM                  //case 437: return 0x09; // Dutch OEM                  //case 850: return 0x0A; // Dutch OEM Secondary codepage                  //case 437 : return 0x0B; // Finnish OEM                  //case 437: return 0x0D; // French OEM                  //case 0x0E: return 850); // French OEM Secondary codepage                  //case 0x0F: return 437); // German OEM                  //case 0x10: return 850); // German OEM Secondary codepage                  //case 0x11: return 437); // Italian OEM                  //case 0x12: return 850); // Italian OEM Secondary codepage                  case 932: return 0x13; // Japanese Shift-JIS                  //case 0x14: return 850); // Spanish OEM secondary codepage                  //case 0x15: return 437); // Swedish OEM                  //case 0x16: return 850); // Swedish OEM secondary codepage                  //case 0x17: return 865); // Norwegian OEM                  //case 0x18: return 437); // Spanish OEM                  //case 0x19: return 437); // English OEM (Britain)                  //case 0x1A: return 850); // English OEM (Britain) secondary codepage                  //case 0x1B: return 437); // English OEM (U.S.)                  case 863: return 0x1C; // French OEM (Canada)                  //case 0x1D: return 850); // French OEM secondary codepage                  case 852: return 0x1F; // Czech OEM                  //case 0x22: return 852); // Hungarian OEM                  //case 0x23: return 852); // Polish OEM                  case 860: return 0x24; // Portuguese OEM                  //case 0x25: return 850); // Portuguese OEM secondary codepage                  case 866: return 0x26; // Russian OEM                  //case 0x37: return 850); // English OEM (U.S.) secondary codepage                  //case 0x40: return 852); // Romanian OEM                  case 936: return 0x4D; // Chinese GBK (PRC)                  case 949: return 0x4E; // Korean (ANSI/OEM)                  case 950: return 0x4F; // Chinese Big5 (Taiwan)                  case 874: return 0x50; // Thai (ANSI/OEM)                  //case 1252: return 0x57 ; // ANSI                  //case 0x58: return 1252); // Western European ANSI                  //case 0x59: return 1252); // Spanish ANSI                  //case 0x64: return 852); // Eastern European MS–DOS                  //case 0x65: return 866); // Russian MS–DOS                  //case 0x66: return 865); // Nordic MS–DOS                  case 861: return 0x67; // Icelandic MS–DOS                  case 895: return 0x68; // Kamenicky (Czech) MS-DOS                   case 620: return 0x69; // Mazovia (Polish) MS-DOS                   case 737: return 0x6A; // Greek MS–DOS (437G)                  case 857: return 0x6B; // Turkish MS–DOS                  //case 0x6C: return 863); // French–Canadian MS–DOS                  //case 0x78: return 950); // Taiwan Big 5                  //case 0x79: return 949); // Hangul (Wansung)                  //case 0x7A: return 936); // PRC GBK                  //case 0x7B: return 932); // Japanese Shift-JIS                  //case 0x7C: return 874); // Thai Windows/MS–DOS                  case 1255: return 0x7D; // Hebrew Windows                   case 1256: return 0x7E; // Arabic Windows                   //case 0x86: return 737); // Greek OEM                  //case 0x87: return 852); // Slovenian OEM                  //case 0x88: return 857); // Turkish OEM                  case 10007: return 0x96; // Russian Macintosh                   case 10029: return 0x97; // Eastern European Macintosh                   case 10006: return 0x98; // Greek Macintosh                   case 1250: return 0xC8; // Eastern European Windows                  case 1251: return 0xC9; // Russian Windows                  case 1254: return 0xCA; // Turkish Windows                  case 1253: return 0xCB; // Greek Windows                  case 1257: return 0xCC; // Baltic Windows                                  default:                      return (byte)0;//System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseHeader.cs,getDbaseLanguageDriver,The following statement contains a magic number: switch (dbasecode)              {                  case 0x01: return System.Text.Encoding.GetEncoding(437); //DOS USA code page 437                   case 0x02: return System.Text.Encoding.GetEncoding(850); // DOS Multilingual code page 850                   case 0x03: return System.Text.Encoding.GetEncoding(1252); // Windows ANSI code page 1252                   case 0x04: return System.Text.Encoding.GetEncoding(10000); // Standard Macintosh                   case 0x08: return System.Text.Encoding.GetEncoding(865); // Danish OEM                  case 0x09: return System.Text.Encoding.GetEncoding(437); // Dutch OEM                  case 0x0A: return System.Text.Encoding.GetEncoding(850); // Dutch OEM Secondary codepage                  case 0x0B: return System.Text.Encoding.GetEncoding(437); // Finnish OEM                  case 0x0D: return System.Text.Encoding.GetEncoding(437); // French OEM                  case 0x0E: return System.Text.Encoding.GetEncoding(850); // French OEM Secondary codepage                  case 0x0F: return System.Text.Encoding.GetEncoding(437); // German OEM                  case 0x10: return System.Text.Encoding.GetEncoding(850); // German OEM Secondary codepage                  case 0x11: return System.Text.Encoding.GetEncoding(437); // Italian OEM                  case 0x12: return System.Text.Encoding.GetEncoding(850); // Italian OEM Secondary codepage                  case 0x13: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x14: return System.Text.Encoding.GetEncoding(850); // Spanish OEM secondary codepage                  case 0x15: return System.Text.Encoding.GetEncoding(437); // Swedish OEM                  case 0x16: return System.Text.Encoding.GetEncoding(850); // Swedish OEM secondary codepage                  case 0x17: return System.Text.Encoding.GetEncoding(865); // Norwegian OEM                  case 0x18: return System.Text.Encoding.GetEncoding(437); // Spanish OEM                  case 0x19: return System.Text.Encoding.GetEncoding(437); // English OEM (Britain)                  case 0x1A: return System.Text.Encoding.GetEncoding(850); // English OEM (Britain) secondary codepage                  case 0x1B: return System.Text.Encoding.GetEncoding(437); // English OEM (U.S.)                  case 0x1C: return System.Text.Encoding.GetEncoding(863); // French OEM (Canada)                  case 0x1D: return System.Text.Encoding.GetEncoding(850); // French OEM secondary codepage                  case 0x1F: return System.Text.Encoding.GetEncoding(852); // Czech OEM                  case 0x22: return System.Text.Encoding.GetEncoding(852); // Hungarian OEM                  case 0x23: return System.Text.Encoding.GetEncoding(852); // Polish OEM                  case 0x24: return System.Text.Encoding.GetEncoding(860); // Portuguese OEM                  case 0x25: return System.Text.Encoding.GetEncoding(850); // Portuguese OEM secondary codepage                  case 0x26: return System.Text.Encoding.GetEncoding(866); // Russian OEM                  case 0x37: return System.Text.Encoding.GetEncoding(850); // English OEM (U.S.) secondary codepage                  case 0x40: return System.Text.Encoding.GetEncoding(852); // Romanian OEM                  case 0x4D: return System.Text.Encoding.GetEncoding(936); // Chinese GBK (PRC)                  case 0x4E: return System.Text.Encoding.GetEncoding(949); // Korean (ANSI/OEM)                  case 0x4F: return System.Text.Encoding.GetEncoding(950); // Chinese Big5 (Taiwan)                  case 0x50: return System.Text.Encoding.GetEncoding(874); // Thai (ANSI/OEM)                  case 0x57: return System.Text.Encoding.GetEncoding(1252); // ANSI                  case 0x58: return System.Text.Encoding.GetEncoding(1252); // Western European ANSI                  case 0x59: return System.Text.Encoding.GetEncoding(1252); // Spanish ANSI                  case 0x64: return System.Text.Encoding.GetEncoding(852); // Eastern European MS–DOS                  case 0x65: return System.Text.Encoding.GetEncoding(866); // Russian MS–DOS                  case 0x66: return System.Text.Encoding.GetEncoding(865); // Nordic MS–DOS                  case 0x67: return System.Text.Encoding.GetEncoding(861); // Icelandic MS–DOS                  case 0x68: return System.Text.Encoding.GetEncoding(895); // Kamenicky (Czech) MS-DOS                   case 0x69: return System.Text.Encoding.GetEncoding(620); // Mazovia (Polish) MS-DOS                   case 0x6A: return System.Text.Encoding.GetEncoding(737); // Greek MS–DOS (437G)                  case 0x6B: return System.Text.Encoding.GetEncoding(857); // Turkish MS–DOS                  case 0x6C: return System.Text.Encoding.GetEncoding(863); // French–Canadian MS–DOS                  case 0x78: return System.Text.Encoding.GetEncoding(950); // Taiwan Big 5                  case 0x79: return System.Text.Encoding.GetEncoding(949); // Hangul (Wansung)                  case 0x7A: return System.Text.Encoding.GetEncoding(936); // PRC GBK                  case 0x7B: return System.Text.Encoding.GetEncoding(932); // Japanese Shift-JIS                  case 0x7C: return System.Text.Encoding.GetEncoding(874); // Thai Windows/MS–DOS                  case 0x7D: return System.Text.Encoding.GetEncoding(1255); // Hebrew Windows                   case 0x7E: return System.Text.Encoding.GetEncoding(1256); // Arabic Windows                   case 0x86: return System.Text.Encoding.GetEncoding(737); // Greek OEM                  case 0x87: return System.Text.Encoding.GetEncoding(852); // Slovenian OEM                  case 0x88: return System.Text.Encoding.GetEncoding(857); // Turkish OEM                  case 0x96: return System.Text.Encoding.GetEncoding(10007); // Russian Macintosh                   case 0x97: return System.Text.Encoding.GetEncoding(10029); // Eastern European Macintosh                   case 0x98: return System.Text.Encoding.GetEncoding(10006); // Greek Macintosh                   case 0xC8: return System.Text.Encoding.GetEncoding(1250); // Eastern European Windows                  case 0xC9: return System.Text.Encoding.GetEncoding(1251); // Russian Windows                  case 0xCA: return System.Text.Encoding.GetEncoding(1254); // Turkish Windows                  case 0xCB: return System.Text.Encoding.GetEncoding(1253); // Greek Windows                  case 0xCC: return System.Text.Encoding.GetEncoding(1257); // Baltic Windows                  default:                      return System.Text.Encoding.UTF8;              }
Magic Number,MapAround.IO,DbaseWriter,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseWriter.cs,Write,The following statement contains a magic number: if (date.Year < 10) _writer.Write('0');
Magic Number,MapAround.IO,DbaseWriter,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseWriter.cs,Write,The following statement contains a magic number: if (date.Year < 100) _writer.Write('0');
Magic Number,MapAround.IO,DbaseWriter,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseWriter.cs,Write,The following statement contains a magic number: if (date.Year < 1000) _writer.Write('0');
Magic Number,MapAround.IO,DbaseWriter,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseWriter.cs,Write,The following statement contains a magic number: if (date.Month < 10)                  _writer.Write('0');
Magic Number,MapAround.IO,DbaseWriter,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\DbaseWriter.cs,Write,The following statement contains a magic number: if (date.Day < 10)                  _writer.Write('0');
Magic Number,MapAround.IO,StreamExtensions,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\StreamExtensions.cs,ReadDoubleBE,The following statement contains a magic number: byte[] byteArray = new byte[8];
Magic Number,MapAround.IO,StreamExtensions,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\StreamExtensions.cs,ReadDoubleBE,The following statement contains a magic number: int iBytesRead = stream.Read(byteArray' 0' 8);
Magic Number,MapAround.IO,StreamExtensions,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\StreamExtensions.cs,ReadDouble,The following statement contains a magic number: byte[] doubleBytes = new byte[8];
Magic Number,MapAround.IO,StreamExtensions,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\StreamExtensions.cs,ReadDouble,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  int b = stream.ReadByte();                  if (b == -1)                      throw new EndOfStreamException();                  doubleBytes[i] = (byte)b;              }
Magic Number,MapAround.IO,StreamExtensions,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\StreamExtensions.cs,ReadInt32BE,The following statement contains a magic number: byte[] byteArray = new byte[4];
Magic Number,MapAround.IO,StreamExtensions,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\StreamExtensions.cs,ReadInt32BE,The following statement contains a magic number: int iBytesRead = stream.Read(byteArray' 0' 4);
Magic Number,MapAround.IO,StreamExtensions,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\StreamExtensions.cs,ReadInt32,The following statement contains a magic number: byte[] intBytes = new byte[4];
Magic Number,MapAround.IO,StreamExtensions,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\StreamExtensions.cs,ReadInt32,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int b = stream.ReadByte();                  if (b == -1)                      throw new EndOfStreamException();                  intBytes[i] = (byte)b;              }
Magic Number,MapAround.IO,ShapeFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,Write,The following statement contains a magic number: pos += 4;
Magic Number,MapAround.IO,ShapeFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,Write,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  file.WriteIntBE(0);//Skip unused part of header                  pos += 4;              }
Magic Number,MapAround.IO,ShapeFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,Write,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  file.WriteIntBE(0);//Skip unused part of header                  pos += 4;              }
Magic Number,MapAround.IO,ShapeFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,Write,The following statement contains a magic number: pos += 4;
Magic Number,MapAround.IO,ShapeFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,Write,The following statement contains a magic number: pos += 4;
Magic Number,MapAround.IO,ShapeFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,Write,The following statement contains a magic number: pos += 4;
Magic Number,MapAround.IO,ShapeFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,Write,The following statement contains a magic number: pos += 8 * 4;
Magic Number,MapAround.IO,ShapeFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,Write,The following statement contains a magic number: pos += 8 * 4;
Magic Number,MapAround.IO,ShapeFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,Write,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  file.Write(0.0); // Skip unused part of header                  pos += 8;              }
Magic Number,MapAround.IO,ShapeFileHeader,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,Write,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  file.Write(0.0); // Skip unused part of header                  pos += 8;              }
Magic Number,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadIndex,The following statement contains a magic number: using (FileStream stream = new FileStream(fileName' FileMode.Open' FileAccess.Read))              {                  ReadHeader(stream);                  int featureCount = (2 * this._fileHeader.FileLength - 100) / 8;                    int[] offsets = new int[featureCount];                  stream.Seek(100' 0);                    for (int x = 0; x < featureCount; ++x)                  {                      offsets[x] = 2 * stream.ReadInt32BE();// ReadInt32_BE(stream);                      stream.Seek(stream.Position + 4' 0);                  }                    return offsets;              }
Magic Number,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadIndex,The following statement contains a magic number: using (FileStream stream = new FileStream(fileName' FileMode.Open' FileAccess.Read))              {                  ReadHeader(stream);                  int featureCount = (2 * this._fileHeader.FileLength - 100) / 8;                    int[] offsets = new int[featureCount];                  stream.Seek(100' 0);                    for (int x = 0; x < featureCount; ++x)                  {                      offsets[x] = 2 * stream.ReadInt32BE();// ReadInt32_BE(stream);                      stream.Seek(stream.Position + 4' 0);                  }                    return offsets;              }
Magic Number,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadIndex,The following statement contains a magic number: using (FileStream stream = new FileStream(fileName' FileMode.Open' FileAccess.Read))              {                  ReadHeader(stream);                  int featureCount = (2 * this._fileHeader.FileLength - 100) / 8;                    int[] offsets = new int[featureCount];                  stream.Seek(100' 0);                    for (int x = 0; x < featureCount; ++x)                  {                      offsets[x] = 2 * stream.ReadInt32BE();// ReadInt32_BE(stream);                      stream.Seek(stream.Position + 4' 0);                  }                    return offsets;              }
Magic Number,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadIndex,The following statement contains a magic number: using (FileStream stream = new FileStream(fileName' FileMode.Open' FileAccess.Read))              {                  ReadHeader(stream);                  int featureCount = (2 * this._fileHeader.FileLength - 100) / 8;                    int[] offsets = new int[featureCount];                  stream.Seek(100' 0);                    for (int x = 0; x < featureCount; ++x)                  {                      offsets[x] = 2 * stream.ReadInt32BE();// ReadInt32_BE(stream);                      stream.Seek(stream.Position + 4' 0);                  }                    return offsets;              }
Magic Number,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadIndex,The following statement contains a magic number: using (FileStream stream = new FileStream(fileName' FileMode.Open' FileAccess.Read))              {                  ReadHeader(stream);                  int featureCount = (2 * this._fileHeader.FileLength - 100) / 8;                    int[] offsets = new int[featureCount];                  stream.Seek(100' 0);                    for (int x = 0; x < featureCount; ++x)                  {                      offsets[x] = 2 * stream.ReadInt32BE();// ReadInt32_BE(stream);                      stream.Seek(stream.Position + 4' 0);                  }                    return offsets;              }
Magic Number,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadIndex,The following statement contains a magic number: using (FileStream stream = new FileStream(fileName' FileMode.Open' FileAccess.Read))              {                  ReadHeader(stream);                  int featureCount = (2 * this._fileHeader.FileLength - 100) / 8;                    int[] offsets = new int[featureCount];                  stream.Seek(100' 0);                    for (int x = 0; x < featureCount; ++x)                  {                      offsets[x] = 2 * stream.ReadInt32BE();// ReadInt32_BE(stream);                      stream.Seek(stream.Position + 4' 0);                  }                    return offsets;              }
Magic Number,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadHeader,The following statement contains a magic number: if (Math.Abs(this._fileHeader.MaxX - this._fileHeader.MinX) < 1)              {                  this._fileHeader.MinX -= 5;                  this._fileHeader.MaxX += 5;              }
Magic Number,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadHeader,The following statement contains a magic number: if (Math.Abs(this._fileHeader.MaxX - this._fileHeader.MinX) < 1)              {                  this._fileHeader.MinX -= 5;                  this._fileHeader.MaxX += 5;              }
Magic Number,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadHeader,The following statement contains a magic number: if (Math.Abs(this._fileHeader.MaxY - this._fileHeader.MinY) < 1)              {                  this._fileHeader.MinY -= 5;                  this._fileHeader.MaxY += 5;              }
Magic Number,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadHeader,The following statement contains a magic number: if (Math.Abs(this._fileHeader.MaxY - this._fileHeader.MinY) < 1)              {                  this._fileHeader.MinY -= 5;                  this._fileHeader.MaxY += 5;              }
Magic Number,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,ReadHeader,The following statement contains a magic number: stream.Seek(100' SeekOrigin.Begin);
Magic Number,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteAttributes,The following statement contains a magic number: try                  {                        //this.RecountColumnLengths(this._dbaseHeader' featureCollection);                      dbaseWriter.WriteHeader();//this._dbaseHeader);                      int j = 0;                      foreach (Feature feature in featureCollection)                      {                          ArrayList values = new ArrayList();                          for (int i = 0; i < dbaseWriter.Header.NumFields; i++)                              values.Add(feature[dbaseWriter.Header.DBaseColumns[i].Name]);//   attribs[Header.Fields[i].Name]);                          dbaseWriter.Write(values' j);                          j++;                      }                        //end of file                      dbaseWriter.Write((byte)26);                  }                  finally                  {                      dbaseWriter.Close();                  }
Magic Number,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteShapes,The following statement contains a magic number: using (FileStream shpStream = new FileStream(filename + ".shp"' FileMode.Create))              {                  using (FileStream shxStream = new FileStream(filename + ".shx"' FileMode.Create))                  {                      BigEndianBinaryWriter shpBinaryWriter = new BigEndianBinaryWriter(shpStream);//' Encoding.ASCII);                      BigEndianBinaryWriter shxBinaryWriter = new BigEndianBinaryWriter(shxStream);//' Encoding.ASCII);                        // body type and a handler                      Handlers.ShapeHandler handler = ShapeFile.GetShapeHandler(ShapeFile.GetShapeType(geometryCollection[0]));//.Geometries[0]));                      int numShapes = geometryCollection.Count;                      // calc the length of the shp file' so it can put in the header.                      int shpLength = 50;                      for (int i = 0; i < numShapes; i++)                      {                          IGeometry body = (IGeometry)geometryCollection[i];//.Geometries[i];                          shpLength += 4; // length of header in WORDS                          shpLength += handler.GetLength(body); // length of shape in WORDS                      }                        int shxLength = 50 + (4 * numShapes);                        // write the .shp header                      ShapeFileHeader shpHeader = new ShapeFileHeader();                      shpHeader.FileLength = shpLength;                        // get envelope in external coordinates                      BoundingRectangle bounds = geometryCollection.GetBoundingRectangle();                       shpHeader.SetBounds(bounds);                        shpHeader.FileCode = 9994;                      shpHeader.ShapeType = (int)ShapeFile.GetShapeType(geometryCollection[0]);//.Geometries[0]);                      shpHeader.Write(shpBinaryWriter' ShapeFile.GetShapeType(geometryCollection[0]));                        // write the .shx header                      ShapeFileHeader shxHeader = new ShapeFileHeader();                      shxHeader.FileLength = shxLength;                      shxHeader.SetBounds(shpHeader);//.Bounds = shpHeader.Bounds;                        // assumes Geometry type of the first item will the same for all other items in the collection.                      shxHeader.FileCode = 9994;                      shxHeader.ShapeType = (int)ShapeFile.GetShapeType(geometryCollection[0]);                      shxHeader.Write(shxBinaryWriter' ShapeFile.GetShapeType(geometryCollection[0]));                        // write the individual records.                      int _pos = 50; // header length in WORDS                      for (int i = 0; i < numShapes; i++)                      {                          IGeometry body = geometryCollection[i];//.Geometries[i];                          int recordLength = handler.GetLength(body);                          shpBinaryWriter.WriteIntBE(i + 1);                          shpBinaryWriter.WriteIntBE(recordLength);                            shxBinaryWriter.WriteIntBE(_pos);                          shxBinaryWriter.WriteIntBE(recordLength);                            _pos += 4; // length of header in WORDS                          handler.Write(body' shpBinaryWriter);//' geometryFactory);                          _pos += recordLength; // length of shape in WORDS                      }                        shxBinaryWriter.Flush();                      shxBinaryWriter.Close();                      shpBinaryWriter.Flush();                      shpBinaryWriter.Close();                  }              }
Magic Number,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteShapes,The following statement contains a magic number: using (FileStream shpStream = new FileStream(filename + ".shp"' FileMode.Create))              {                  using (FileStream shxStream = new FileStream(filename + ".shx"' FileMode.Create))                  {                      BigEndianBinaryWriter shpBinaryWriter = new BigEndianBinaryWriter(shpStream);//' Encoding.ASCII);                      BigEndianBinaryWriter shxBinaryWriter = new BigEndianBinaryWriter(shxStream);//' Encoding.ASCII);                        // body type and a handler                      Handlers.ShapeHandler handler = ShapeFile.GetShapeHandler(ShapeFile.GetShapeType(geometryCollection[0]));//.Geometries[0]));                      int numShapes = geometryCollection.Count;                      // calc the length of the shp file' so it can put in the header.                      int shpLength = 50;                      for (int i = 0; i < numShapes; i++)                      {                          IGeometry body = (IGeometry)geometryCollection[i];//.Geometries[i];                          shpLength += 4; // length of header in WORDS                          shpLength += handler.GetLength(body); // length of shape in WORDS                      }                        int shxLength = 50 + (4 * numShapes);                        // write the .shp header                      ShapeFileHeader shpHeader = new ShapeFileHeader();                      shpHeader.FileLength = shpLength;                        // get envelope in external coordinates                      BoundingRectangle bounds = geometryCollection.GetBoundingRectangle();                       shpHeader.SetBounds(bounds);                        shpHeader.FileCode = 9994;                      shpHeader.ShapeType = (int)ShapeFile.GetShapeType(geometryCollection[0]);//.Geometries[0]);                      shpHeader.Write(shpBinaryWriter' ShapeFile.GetShapeType(geometryCollection[0]));                        // write the .shx header                      ShapeFileHeader shxHeader = new ShapeFileHeader();                      shxHeader.FileLength = shxLength;                      shxHeader.SetBounds(shpHeader);//.Bounds = shpHeader.Bounds;                        // assumes Geometry type of the first item will the same for all other items in the collection.                      shxHeader.FileCode = 9994;                      shxHeader.ShapeType = (int)ShapeFile.GetShapeType(geometryCollection[0]);                      shxHeader.Write(shxBinaryWriter' ShapeFile.GetShapeType(geometryCollection[0]));                        // write the individual records.                      int _pos = 50; // header length in WORDS                      for (int i = 0; i < numShapes; i++)                      {                          IGeometry body = geometryCollection[i];//.Geometries[i];                          int recordLength = handler.GetLength(body);                          shpBinaryWriter.WriteIntBE(i + 1);                          shpBinaryWriter.WriteIntBE(recordLength);                            shxBinaryWriter.WriteIntBE(_pos);                          shxBinaryWriter.WriteIntBE(recordLength);                            _pos += 4; // length of header in WORDS                          handler.Write(body' shpBinaryWriter);//' geometryFactory);                          _pos += recordLength; // length of shape in WORDS                      }                        shxBinaryWriter.Flush();                      shxBinaryWriter.Close();                      shpBinaryWriter.Flush();                      shpBinaryWriter.Close();                  }              }
Magic Number,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteShapes,The following statement contains a magic number: using (FileStream shpStream = new FileStream(filename + ".shp"' FileMode.Create))              {                  using (FileStream shxStream = new FileStream(filename + ".shx"' FileMode.Create))                  {                      BigEndianBinaryWriter shpBinaryWriter = new BigEndianBinaryWriter(shpStream);//' Encoding.ASCII);                      BigEndianBinaryWriter shxBinaryWriter = new BigEndianBinaryWriter(shxStream);//' Encoding.ASCII);                        // body type and a handler                      Handlers.ShapeHandler handler = ShapeFile.GetShapeHandler(ShapeFile.GetShapeType(geometryCollection[0]));//.Geometries[0]));                      int numShapes = geometryCollection.Count;                      // calc the length of the shp file' so it can put in the header.                      int shpLength = 50;                      for (int i = 0; i < numShapes; i++)                      {                          IGeometry body = (IGeometry)geometryCollection[i];//.Geometries[i];                          shpLength += 4; // length of header in WORDS                          shpLength += handler.GetLength(body); // length of shape in WORDS                      }                        int shxLength = 50 + (4 * numShapes);                        // write the .shp header                      ShapeFileHeader shpHeader = new ShapeFileHeader();                      shpHeader.FileLength = shpLength;                        // get envelope in external coordinates                      BoundingRectangle bounds = geometryCollection.GetBoundingRectangle();                       shpHeader.SetBounds(bounds);                        shpHeader.FileCode = 9994;                      shpHeader.ShapeType = (int)ShapeFile.GetShapeType(geometryCollection[0]);//.Geometries[0]);                      shpHeader.Write(shpBinaryWriter' ShapeFile.GetShapeType(geometryCollection[0]));                        // write the .shx header                      ShapeFileHeader shxHeader = new ShapeFileHeader();                      shxHeader.FileLength = shxLength;                      shxHeader.SetBounds(shpHeader);//.Bounds = shpHeader.Bounds;                        // assumes Geometry type of the first item will the same for all other items in the collection.                      shxHeader.FileCode = 9994;                      shxHeader.ShapeType = (int)ShapeFile.GetShapeType(geometryCollection[0]);                      shxHeader.Write(shxBinaryWriter' ShapeFile.GetShapeType(geometryCollection[0]));                        // write the individual records.                      int _pos = 50; // header length in WORDS                      for (int i = 0; i < numShapes; i++)                      {                          IGeometry body = geometryCollection[i];//.Geometries[i];                          int recordLength = handler.GetLength(body);                          shpBinaryWriter.WriteIntBE(i + 1);                          shpBinaryWriter.WriteIntBE(recordLength);                            shxBinaryWriter.WriteIntBE(_pos);                          shxBinaryWriter.WriteIntBE(recordLength);                            _pos += 4; // length of header in WORDS                          handler.Write(body' shpBinaryWriter);//' geometryFactory);                          _pos += recordLength; // length of shape in WORDS                      }                        shxBinaryWriter.Flush();                      shxBinaryWriter.Close();                      shpBinaryWriter.Flush();                      shpBinaryWriter.Close();                  }              }
Magic Number,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteShapes,The following statement contains a magic number: using (FileStream shpStream = new FileStream(filename + ".shp"' FileMode.Create))              {                  using (FileStream shxStream = new FileStream(filename + ".shx"' FileMode.Create))                  {                      BigEndianBinaryWriter shpBinaryWriter = new BigEndianBinaryWriter(shpStream);//' Encoding.ASCII);                      BigEndianBinaryWriter shxBinaryWriter = new BigEndianBinaryWriter(shxStream);//' Encoding.ASCII);                        // body type and a handler                      Handlers.ShapeHandler handler = ShapeFile.GetShapeHandler(ShapeFile.GetShapeType(geometryCollection[0]));//.Geometries[0]));                      int numShapes = geometryCollection.Count;                      // calc the length of the shp file' so it can put in the header.                      int shpLength = 50;                      for (int i = 0; i < numShapes; i++)                      {                          IGeometry body = (IGeometry)geometryCollection[i];//.Geometries[i];                          shpLength += 4; // length of header in WORDS                          shpLength += handler.GetLength(body); // length of shape in WORDS                      }                        int shxLength = 50 + (4 * numShapes);                        // write the .shp header                      ShapeFileHeader shpHeader = new ShapeFileHeader();                      shpHeader.FileLength = shpLength;                        // get envelope in external coordinates                      BoundingRectangle bounds = geometryCollection.GetBoundingRectangle();                       shpHeader.SetBounds(bounds);                        shpHeader.FileCode = 9994;                      shpHeader.ShapeType = (int)ShapeFile.GetShapeType(geometryCollection[0]);//.Geometries[0]);                      shpHeader.Write(shpBinaryWriter' ShapeFile.GetShapeType(geometryCollection[0]));                        // write the .shx header                      ShapeFileHeader shxHeader = new ShapeFileHeader();                      shxHeader.FileLength = shxLength;                      shxHeader.SetBounds(shpHeader);//.Bounds = shpHeader.Bounds;                        // assumes Geometry type of the first item will the same for all other items in the collection.                      shxHeader.FileCode = 9994;                      shxHeader.ShapeType = (int)ShapeFile.GetShapeType(geometryCollection[0]);                      shxHeader.Write(shxBinaryWriter' ShapeFile.GetShapeType(geometryCollection[0]));                        // write the individual records.                      int _pos = 50; // header length in WORDS                      for (int i = 0; i < numShapes; i++)                      {                          IGeometry body = geometryCollection[i];//.Geometries[i];                          int recordLength = handler.GetLength(body);                          shpBinaryWriter.WriteIntBE(i + 1);                          shpBinaryWriter.WriteIntBE(recordLength);                            shxBinaryWriter.WriteIntBE(_pos);                          shxBinaryWriter.WriteIntBE(recordLength);                            _pos += 4; // length of header in WORDS                          handler.Write(body' shpBinaryWriter);//' geometryFactory);                          _pos += recordLength; // length of shape in WORDS                      }                        shxBinaryWriter.Flush();                      shxBinaryWriter.Close();                      shpBinaryWriter.Flush();                      shpBinaryWriter.Close();                  }              }
Magic Number,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteShapes,The following statement contains a magic number: using (FileStream shpStream = new FileStream(filename + ".shp"' FileMode.Create))              {                  using (FileStream shxStream = new FileStream(filename + ".shx"' FileMode.Create))                  {                      BigEndianBinaryWriter shpBinaryWriter = new BigEndianBinaryWriter(shpStream);//' Encoding.ASCII);                      BigEndianBinaryWriter shxBinaryWriter = new BigEndianBinaryWriter(shxStream);//' Encoding.ASCII);                        // body type and a handler                      Handlers.ShapeHandler handler = ShapeFile.GetShapeHandler(ShapeFile.GetShapeType(geometryCollection[0]));//.Geometries[0]));                      int numShapes = geometryCollection.Count;                      // calc the length of the shp file' so it can put in the header.                      int shpLength = 50;                      for (int i = 0; i < numShapes; i++)                      {                          IGeometry body = (IGeometry)geometryCollection[i];//.Geometries[i];                          shpLength += 4; // length of header in WORDS                          shpLength += handler.GetLength(body); // length of shape in WORDS                      }                        int shxLength = 50 + (4 * numShapes);                        // write the .shp header                      ShapeFileHeader shpHeader = new ShapeFileHeader();                      shpHeader.FileLength = shpLength;                        // get envelope in external coordinates                      BoundingRectangle bounds = geometryCollection.GetBoundingRectangle();                       shpHeader.SetBounds(bounds);                        shpHeader.FileCode = 9994;                      shpHeader.ShapeType = (int)ShapeFile.GetShapeType(geometryCollection[0]);//.Geometries[0]);                      shpHeader.Write(shpBinaryWriter' ShapeFile.GetShapeType(geometryCollection[0]));                        // write the .shx header                      ShapeFileHeader shxHeader = new ShapeFileHeader();                      shxHeader.FileLength = shxLength;                      shxHeader.SetBounds(shpHeader);//.Bounds = shpHeader.Bounds;                        // assumes Geometry type of the first item will the same for all other items in the collection.                      shxHeader.FileCode = 9994;                      shxHeader.ShapeType = (int)ShapeFile.GetShapeType(geometryCollection[0]);                      shxHeader.Write(shxBinaryWriter' ShapeFile.GetShapeType(geometryCollection[0]));                        // write the individual records.                      int _pos = 50; // header length in WORDS                      for (int i = 0; i < numShapes; i++)                      {                          IGeometry body = geometryCollection[i];//.Geometries[i];                          int recordLength = handler.GetLength(body);                          shpBinaryWriter.WriteIntBE(i + 1);                          shpBinaryWriter.WriteIntBE(recordLength);                            shxBinaryWriter.WriteIntBE(_pos);                          shxBinaryWriter.WriteIntBE(recordLength);                            _pos += 4; // length of header in WORDS                          handler.Write(body' shpBinaryWriter);//' geometryFactory);                          _pos += recordLength; // length of shape in WORDS                      }                        shxBinaryWriter.Flush();                      shxBinaryWriter.Close();                      shpBinaryWriter.Flush();                      shpBinaryWriter.Close();                  }              }
Magic Number,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteShapes,The following statement contains a magic number: using (FileStream shpStream = new FileStream(filename + ".shp"' FileMode.Create))              {                  using (FileStream shxStream = new FileStream(filename + ".shx"' FileMode.Create))                  {                      BigEndianBinaryWriter shpBinaryWriter = new BigEndianBinaryWriter(shpStream);//' Encoding.ASCII);                      BigEndianBinaryWriter shxBinaryWriter = new BigEndianBinaryWriter(shxStream);//' Encoding.ASCII);                        // body type and a handler                      Handlers.ShapeHandler handler = ShapeFile.GetShapeHandler(ShapeFile.GetShapeType(geometryCollection[0]));//.Geometries[0]));                      int numShapes = geometryCollection.Count;                      // calc the length of the shp file' so it can put in the header.                      int shpLength = 50;                      for (int i = 0; i < numShapes; i++)                      {                          IGeometry body = (IGeometry)geometryCollection[i];//.Geometries[i];                          shpLength += 4; // length of header in WORDS                          shpLength += handler.GetLength(body); // length of shape in WORDS                      }                        int shxLength = 50 + (4 * numShapes);                        // write the .shp header                      ShapeFileHeader shpHeader = new ShapeFileHeader();                      shpHeader.FileLength = shpLength;                        // get envelope in external coordinates                      BoundingRectangle bounds = geometryCollection.GetBoundingRectangle();                       shpHeader.SetBounds(bounds);                        shpHeader.FileCode = 9994;                      shpHeader.ShapeType = (int)ShapeFile.GetShapeType(geometryCollection[0]);//.Geometries[0]);                      shpHeader.Write(shpBinaryWriter' ShapeFile.GetShapeType(geometryCollection[0]));                        // write the .shx header                      ShapeFileHeader shxHeader = new ShapeFileHeader();                      shxHeader.FileLength = shxLength;                      shxHeader.SetBounds(shpHeader);//.Bounds = shpHeader.Bounds;                        // assumes Geometry type of the first item will the same for all other items in the collection.                      shxHeader.FileCode = 9994;                      shxHeader.ShapeType = (int)ShapeFile.GetShapeType(geometryCollection[0]);                      shxHeader.Write(shxBinaryWriter' ShapeFile.GetShapeType(geometryCollection[0]));                        // write the individual records.                      int _pos = 50; // header length in WORDS                      for (int i = 0; i < numShapes; i++)                      {                          IGeometry body = geometryCollection[i];//.Geometries[i];                          int recordLength = handler.GetLength(body);                          shpBinaryWriter.WriteIntBE(i + 1);                          shpBinaryWriter.WriteIntBE(recordLength);                            shxBinaryWriter.WriteIntBE(_pos);                          shxBinaryWriter.WriteIntBE(recordLength);                            _pos += 4; // length of header in WORDS                          handler.Write(body' shpBinaryWriter);//' geometryFactory);                          _pos += recordLength; // length of shape in WORDS                      }                        shxBinaryWriter.Flush();                      shxBinaryWriter.Close();                      shpBinaryWriter.Flush();                      shpBinaryWriter.Close();                  }              }
Magic Number,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteShapes,The following statement contains a magic number: using (FileStream shpStream = new FileStream(filename + ".shp"' FileMode.Create))              {                  using (FileStream shxStream = new FileStream(filename + ".shx"' FileMode.Create))                  {                      BigEndianBinaryWriter shpBinaryWriter = new BigEndianBinaryWriter(shpStream);//' Encoding.ASCII);                      BigEndianBinaryWriter shxBinaryWriter = new BigEndianBinaryWriter(shxStream);//' Encoding.ASCII);                        // body type and a handler                      Handlers.ShapeHandler handler = ShapeFile.GetShapeHandler(ShapeFile.GetShapeType(geometryCollection[0]));//.Geometries[0]));                      int numShapes = geometryCollection.Count;                      // calc the length of the shp file' so it can put in the header.                      int shpLength = 50;                      for (int i = 0; i < numShapes; i++)                      {                          IGeometry body = (IGeometry)geometryCollection[i];//.Geometries[i];                          shpLength += 4; // length of header in WORDS                          shpLength += handler.GetLength(body); // length of shape in WORDS                      }                        int shxLength = 50 + (4 * numShapes);                        // write the .shp header                      ShapeFileHeader shpHeader = new ShapeFileHeader();                      shpHeader.FileLength = shpLength;                        // get envelope in external coordinates                      BoundingRectangle bounds = geometryCollection.GetBoundingRectangle();                       shpHeader.SetBounds(bounds);                        shpHeader.FileCode = 9994;                      shpHeader.ShapeType = (int)ShapeFile.GetShapeType(geometryCollection[0]);//.Geometries[0]);                      shpHeader.Write(shpBinaryWriter' ShapeFile.GetShapeType(geometryCollection[0]));                        // write the .shx header                      ShapeFileHeader shxHeader = new ShapeFileHeader();                      shxHeader.FileLength = shxLength;                      shxHeader.SetBounds(shpHeader);//.Bounds = shpHeader.Bounds;                        // assumes Geometry type of the first item will the same for all other items in the collection.                      shxHeader.FileCode = 9994;                      shxHeader.ShapeType = (int)ShapeFile.GetShapeType(geometryCollection[0]);                      shxHeader.Write(shxBinaryWriter' ShapeFile.GetShapeType(geometryCollection[0]));                        // write the individual records.                      int _pos = 50; // header length in WORDS                      for (int i = 0; i < numShapes; i++)                      {                          IGeometry body = geometryCollection[i];//.Geometries[i];                          int recordLength = handler.GetLength(body);                          shpBinaryWriter.WriteIntBE(i + 1);                          shpBinaryWriter.WriteIntBE(recordLength);                            shxBinaryWriter.WriteIntBE(_pos);                          shxBinaryWriter.WriteIntBE(recordLength);                            _pos += 4; // length of header in WORDS                          handler.Write(body' shpBinaryWriter);//' geometryFactory);                          _pos += recordLength; // length of shape in WORDS                      }                        shxBinaryWriter.Flush();                      shxBinaryWriter.Close();                      shpBinaryWriter.Flush();                      shpBinaryWriter.Close();                  }              }
Magic Number,MapAround.IO,ShapeFile,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\ShapeFile.cs,WriteShapes,The following statement contains a magic number: using (FileStream shpStream = new FileStream(filename + ".shp"' FileMode.Create))              {                  using (FileStream shxStream = new FileStream(filename + ".shx"' FileMode.Create))                  {                      BigEndianBinaryWriter shpBinaryWriter = new BigEndianBinaryWriter(shpStream);//' Encoding.ASCII);                      BigEndianBinaryWriter shxBinaryWriter = new BigEndianBinaryWriter(shxStream);//' Encoding.ASCII);                        // body type and a handler                      Handlers.ShapeHandler handler = ShapeFile.GetShapeHandler(ShapeFile.GetShapeType(geometryCollection[0]));//.Geometries[0]));                      int numShapes = geometryCollection.Count;                      // calc the length of the shp file' so it can put in the header.                      int shpLength = 50;                      for (int i = 0; i < numShapes; i++)                      {                          IGeometry body = (IGeometry)geometryCollection[i];//.Geometries[i];                          shpLength += 4; // length of header in WORDS                          shpLength += handler.GetLength(body); // length of shape in WORDS                      }                        int shxLength = 50 + (4 * numShapes);                        // write the .shp header                      ShapeFileHeader shpHeader = new ShapeFileHeader();                      shpHeader.FileLength = shpLength;                        // get envelope in external coordinates                      BoundingRectangle bounds = geometryCollection.GetBoundingRectangle();                       shpHeader.SetBounds(bounds);                        shpHeader.FileCode = 9994;                      shpHeader.ShapeType = (int)ShapeFile.GetShapeType(geometryCollection[0]);//.Geometries[0]);                      shpHeader.Write(shpBinaryWriter' ShapeFile.GetShapeType(geometryCollection[0]));                        // write the .shx header                      ShapeFileHeader shxHeader = new ShapeFileHeader();                      shxHeader.FileLength = shxLength;                      shxHeader.SetBounds(shpHeader);//.Bounds = shpHeader.Bounds;                        // assumes Geometry type of the first item will the same for all other items in the collection.                      shxHeader.FileCode = 9994;                      shxHeader.ShapeType = (int)ShapeFile.GetShapeType(geometryCollection[0]);                      shxHeader.Write(shxBinaryWriter' ShapeFile.GetShapeType(geometryCollection[0]));                        // write the individual records.                      int _pos = 50; // header length in WORDS                      for (int i = 0; i < numShapes; i++)                      {                          IGeometry body = geometryCollection[i];//.Geometries[i];                          int recordLength = handler.GetLength(body);                          shpBinaryWriter.WriteIntBE(i + 1);                          shpBinaryWriter.WriteIntBE(recordLength);                            shxBinaryWriter.WriteIntBE(_pos);                          shxBinaryWriter.WriteIntBE(recordLength);                            _pos += 4; // length of header in WORDS                          handler.Write(body' shpBinaryWriter);//' geometryFactory);                          _pos += recordLength; // length of shape in WORDS                      }                        shxBinaryWriter.Flush();                      shxBinaryWriter.Close();                      shpBinaryWriter.Flush();                      shpBinaryWriter.Close();                  }              }
Magic Number,MapAround.IO.Handlers,MultiLineHandler,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiLineHandler.cs,Read,The following statement contains a magic number: if (!ShapeHandler.IsRecordInView(bounds' record))              {                  file.Seek((long)numPoints * 16 + numParts * 4' SeekOrigin.Current);                  return false;              }
Magic Number,MapAround.IO.Handlers,MultiLineHandler,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiLineHandler.cs,Read,The following statement contains a magic number: if (!ShapeHandler.IsRecordInView(bounds' record))              {                  file.Seek((long)numPoints * 16 + numParts * 4' SeekOrigin.Current);                  return false;              }
Magic Number,MapAround.IO.Handlers,MultiLineHandler,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiLineHandler.cs,GetLength,The following statement contains a magic number: return (22 + (2 * numParts) + geometry.CoordinateCount/*.NumPoints*/ * 8);
Magic Number,MapAround.IO.Handlers,MultiLineHandler,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiLineHandler.cs,GetLength,The following statement contains a magic number: return (22 + (2 * numParts) + geometry.CoordinateCount/*.NumPoints*/ * 8);
Magic Number,MapAround.IO.Handlers,MultiLineHandler,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiLineHandler.cs,GetLength,The following statement contains a magic number: return (22 + (2 * numParts) + geometry.CoordinateCount/*.NumPoints*/ * 8);
Magic Number,MapAround.IO.Handlers,MultiPointHandler,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiPointHandler.cs,Read,The following statement contains a magic number: try              {                  record.MinX = file.ReadDouble();// ShapeFile.ReadDouble64_LE(stream);                  record.MinY = file.ReadDouble();// ShapeFile.ReadDouble64_LE(stream);                  record.MaxX = file.ReadDouble();// ShapeFile.ReadDouble64_LE(stream);                  record.MaxY = file.ReadDouble();// ShapeFile.ReadDouble64_LE(stream);                    int numPoints = file.ReadInt32();// ShapeFile.ReadInt32_LE(stream);                    if (!ShapeHandler.IsRecordInView(bounds' record))                  {                      file.Seek((long)numPoints * 16' SeekOrigin.Current);                      return false;                  }                    for (int i = 0; i < numPoints; i++)                  {                      ICoordinate p =                          PlanimetryEnvironment.NewCoordinate(                          file.ReadDouble()'//ShapeFile.ReadDouble64_LE(stream)'                          file.ReadDouble());//ShapeFile.ReadDouble64_LE(stream));                        record.Points.Add(p);                  }                    return true;              }              catch { throw; }
Magic Number,MapAround.IO.Handlers,MultiPointHandler,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiPointHandler.cs,GetLength,The following statement contains a magic number: return (20 + geometry.ExtractCoordinates().Length /*.NumPoints*/ * 8);
Magic Number,MapAround.IO.Handlers,MultiPointHandler,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\MultiPointHandler.cs,GetLength,The following statement contains a magic number: return (20 + geometry.ExtractCoordinates().Length /*.NumPoints*/ * 8);
Magic Number,MapAround.IO.Handlers,PointHandler,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\PointHandler.cs,GetLength,The following statement contains a magic number: return 10;
Magic Number,MapAround.IO.Handlers,PolygonHandler,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\PolygonHandler.cs,Read,The following statement contains a magic number: if (!ShapeHandler.IsRecordInView(bounds' record))              {                  file.Seek((long)numPoints * 16 + numParts * 4' SeekOrigin.Current);                  return false;              }
Magic Number,MapAround.IO.Handlers,PolygonHandler,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\PolygonHandler.cs,Read,The following statement contains a magic number: if (!ShapeHandler.IsRecordInView(bounds' record))              {                  file.Seek((long)numPoints * 16 + numParts * 4' SeekOrigin.Current);                  return false;              }
Magic Number,MapAround.IO.Handlers,PolygonHandler,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\PolygonHandler.cs,GetLength,The following statement contains a magic number: return (22 + (2 * numParts) + (geometry.CoordinateCount + numParts) * 8);
Magic Number,MapAround.IO.Handlers,PolygonHandler,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\PolygonHandler.cs,GetLength,The following statement contains a magic number: return (22 + (2 * numParts) + (geometry.CoordinateCount + numParts) * 8);
Magic Number,MapAround.IO.Handlers,PolygonHandler,C:\repos\gkrsu_maparound.core\src\MapAround.Core\IO\Handlers\PolygonHandler.cs,GetLength,The following statement contains a magic number: return (22 + (2 * numParts) + (geometry.CoordinateCount + numParts) * 8);
Magic Number,MapAround.Mapping,PolygonStyle,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,brushPatternParamsChanged,The following statement contains a magic number: for(int i = 0; i < _brushPattern.Width; i++)                  for (int j = 0; j < _brushPattern.Height; j++)                  {                      Color c = _originalBrushPattern.GetPixel(i' j);                        Color blendedColor =                           Color.FromArgb(                              RenderingUtils.BlendPixels(_fillBackColor.ToArgb()' Color.FromArgb(255 - c.R' _fillForeColor).ToArgb()));                        _brushPattern.SetPixel(i' j' blendedColor);                  }
Magic Number,MapAround.Mapping,PolygonStyle,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,checkBrushPattern,The following statement contains a magic number: if (bmp.Width > 32 || bmp.Height > 32)                  throw new InvalidOperationException("Fill pattern is too big.");
Magic Number,MapAround.Mapping,PolygonStyle,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,checkBrushPattern,The following statement contains a magic number: if (bmp.Width > 32 || bmp.Height > 32)                  throw new InvalidOperationException("Fill pattern is too big.");
Magic Number,MapAround.Mapping,PolylineStyle,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,GetOutlinePen,The following statement contains a magic number: Pen p = new Pen(_outlineColor' _width + _outlineWidth * 2);
Magic Number,MapAround.Mapping,HatchFillPatternsAcccessor,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,HatchFillPatternsAcccessor,The following statement contains a magic number: for (int i = 0; i < 53; i++)              {                  Bitmap bmp = new Bitmap(8' 8);                  using (Graphics g = Graphics.FromImage(bmp))                  {                      g.SmoothingMode = SmoothingMode.HighSpeed;                      g.PixelOffsetMode = PixelOffsetMode.HighSpeed;                      g.Clear(Color.White);                      using (Brush brush = new HatchBrush((HatchStyle)i' Color.Black' Color.White))                      {                          g.FillRectangle(brush' 0' 0' 8' 8);                      }                  }                    _bitmaps.Add(bmp);              }
Magic Number,MapAround.Mapping,HatchFillPatternsAcccessor,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,HatchFillPatternsAcccessor,The following statement contains a magic number: for (int i = 0; i < 53; i++)              {                  Bitmap bmp = new Bitmap(8' 8);                  using (Graphics g = Graphics.FromImage(bmp))                  {                      g.SmoothingMode = SmoothingMode.HighSpeed;                      g.PixelOffsetMode = PixelOffsetMode.HighSpeed;                      g.Clear(Color.White);                      using (Brush brush = new HatchBrush((HatchStyle)i' Color.Black' Color.White))                      {                          g.FillRectangle(brush' 0' 0' 8' 8);                      }                  }                    _bitmaps.Add(bmp);              }
Magic Number,MapAround.Mapping,HatchFillPatternsAcccessor,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,HatchFillPatternsAcccessor,The following statement contains a magic number: for (int i = 0; i < 53; i++)              {                  Bitmap bmp = new Bitmap(8' 8);                  using (Graphics g = Graphics.FromImage(bmp))                  {                      g.SmoothingMode = SmoothingMode.HighSpeed;                      g.PixelOffsetMode = PixelOffsetMode.HighSpeed;                      g.Clear(Color.White);                      using (Brush brush = new HatchBrush((HatchStyle)i' Color.Black' Color.White))                      {                          g.FillRectangle(brush' 0' 0' 8' 8);                      }                  }                    _bitmaps.Add(bmp);              }
Magic Number,MapAround.Mapping,HatchFillPatternsAcccessor,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,HatchFillPatternsAcccessor,The following statement contains a magic number: for (int i = 0; i < 53; i++)              {                  Bitmap bmp = new Bitmap(8' 8);                  using (Graphics g = Graphics.FromImage(bmp))                  {                      g.SmoothingMode = SmoothingMode.HighSpeed;                      g.PixelOffsetMode = PixelOffsetMode.HighSpeed;                      g.Clear(Color.White);                      using (Brush brush = new HatchBrush((HatchStyle)i' Color.Black' Color.White))                      {                          g.FillRectangle(brush' 0' 0' 8' 8);                      }                  }                    _bitmaps.Add(bmp);              }
Magic Number,MapAround.Mapping,HatchFillPatternsAcccessor,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureAppearance.cs,HatchFillPatternsAcccessor,The following statement contains a magic number: for (int i = 0; i < 53; i++)              {                  Bitmap bmp = new Bitmap(8' 8);                  using (Graphics g = Graphics.FromImage(bmp))                  {                      g.SmoothingMode = SmoothingMode.HighSpeed;                      g.PixelOffsetMode = PixelOffsetMode.HighSpeed;                      g.Clear(Color.White);                      using (Brush brush = new HatchBrush((HatchStyle)i' Color.Black' Color.White))                      {                          g.FillRectangle(brush' 0' 0' 8' 8);                      }                  }                    _bitmaps.Add(bmp);              }
Magic Number,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,Render,The following statement contains a magic number: if (Math.Abs((viewBox.Width / viewBox.Height) -                  ((double)image.Width / (double)image.Height)) > 0.02)                  throw new ArgumentException("The view box and the image should not have different aspect ratios."' "viewBox");
Magic Number,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,MapViewBoxFromPresentationViewBox,The following statement contains a magic number: if (_onTheFlyTransform == null)                  return box;              else              {                  BoundingRectangle result = transformViewBox(box' _onTheFlyTransform.Inverse());                    // We are trying to include the poles. Perhaps one of them is low.                  PointD[] poles = new PointD[4];                  poles[0] = new PointD(89' 0);  //consider the points are sufficiently close to the poles                  poles[1] = new PointD(-89' 0); //because at the poles themselves often features                  poles[2] = new PointD(0' 89);                  poles[3] = new PointD(0' -89);                    for (int i = 0; i < 4; i++)                      try                      {                          if (box.ContainsPoint(GeometryTransformer.TransformPoint(poles[i]' _onTheFlyTransform).Coordinate))                              result.Join(poles[i].Coordinate);                      }                      catch (ApplicationException)                      {                       }                    //TODO: gradient descent                    return result;              }
Magic Number,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,MapViewBoxFromPresentationViewBox,The following statement contains a magic number: if (_onTheFlyTransform == null)                  return box;              else              {                  BoundingRectangle result = transformViewBox(box' _onTheFlyTransform.Inverse());                    // We are trying to include the poles. Perhaps one of them is low.                  PointD[] poles = new PointD[4];                  poles[0] = new PointD(89' 0);  //consider the points are sufficiently close to the poles                  poles[1] = new PointD(-89' 0); //because at the poles themselves often features                  poles[2] = new PointD(0' 89);                  poles[3] = new PointD(0' -89);                    for (int i = 0; i < 4; i++)                      try                      {                          if (box.ContainsPoint(GeometryTransformer.TransformPoint(poles[i]' _onTheFlyTransform).Coordinate))                              result.Join(poles[i].Coordinate);                      }                      catch (ApplicationException)                      {                       }                    //TODO: gradient descent                    return result;              }
Magic Number,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,MapViewBoxFromPresentationViewBox,The following statement contains a magic number: if (_onTheFlyTransform == null)                  return box;              else              {                  BoundingRectangle result = transformViewBox(box' _onTheFlyTransform.Inverse());                    // We are trying to include the poles. Perhaps one of them is low.                  PointD[] poles = new PointD[4];                  poles[0] = new PointD(89' 0);  //consider the points are sufficiently close to the poles                  poles[1] = new PointD(-89' 0); //because at the poles themselves often features                  poles[2] = new PointD(0' 89);                  poles[3] = new PointD(0' -89);                    for (int i = 0; i < 4; i++)                      try                      {                          if (box.ContainsPoint(GeometryTransformer.TransformPoint(poles[i]' _onTheFlyTransform).Coordinate))                              result.Join(poles[i].Coordinate);                      }                      catch (ApplicationException)                      {                       }                    //TODO: gradient descent                    return result;              }
Magic Number,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,MapViewBoxFromPresentationViewBox,The following statement contains a magic number: if (_onTheFlyTransform == null)                  return box;              else              {                  BoundingRectangle result = transformViewBox(box' _onTheFlyTransform.Inverse());                    // We are trying to include the poles. Perhaps one of them is low.                  PointD[] poles = new PointD[4];                  poles[0] = new PointD(89' 0);  //consider the points are sufficiently close to the poles                  poles[1] = new PointD(-89' 0); //because at the poles themselves often features                  poles[2] = new PointD(0' 89);                  poles[3] = new PointD(0' -89);                    for (int i = 0; i < 4; i++)                      try                      {                          if (box.ContainsPoint(GeometryTransformer.TransformPoint(poles[i]' _onTheFlyTransform).Coordinate))                              result.Join(poles[i].Coordinate);                      }                      catch (ApplicationException)                      {                       }                    //TODO: gradient descent                    return result;              }
Magic Number,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,MapViewBoxFromPresentationViewBox,The following statement contains a magic number: if (_onTheFlyTransform == null)                  return box;              else              {                  BoundingRectangle result = transformViewBox(box' _onTheFlyTransform.Inverse());                    // We are trying to include the poles. Perhaps one of them is low.                  PointD[] poles = new PointD[4];                  poles[0] = new PointD(89' 0);  //consider the points are sufficiently close to the poles                  poles[1] = new PointD(-89' 0); //because at the poles themselves often features                  poles[2] = new PointD(0' 89);                  poles[3] = new PointD(0' -89);                    for (int i = 0; i < 4; i++)                      try                      {                          if (box.ContainsPoint(GeometryTransformer.TransformPoint(poles[i]' _onTheFlyTransform).Coordinate))                              result.Join(poles[i].Coordinate);                      }                      catch (ApplicationException)                      {                       }                    //TODO: gradient descent                    return result;              }
Magic Number,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,MapViewBoxFromPresentationViewBox,The following statement contains a magic number: if (_onTheFlyTransform == null)                  return box;              else              {                  BoundingRectangle result = transformViewBox(box' _onTheFlyTransform.Inverse());                    // We are trying to include the poles. Perhaps one of them is low.                  PointD[] poles = new PointD[4];                  poles[0] = new PointD(89' 0);  //consider the points are sufficiently close to the poles                  poles[1] = new PointD(-89' 0); //because at the poles themselves often features                  poles[2] = new PointD(0' 89);                  poles[3] = new PointD(0' -89);                    for (int i = 0; i < 4; i++)                      try                      {                          if (box.ContainsPoint(GeometryTransformer.TransformPoint(poles[i]' _onTheFlyTransform).Coordinate))                              result.Join(poles[i].Coordinate);                      }                      catch (ApplicationException)                      {                       }                    //TODO: gradient descent                    return result;              }
Magic Number,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,MapViewBoxFromPresentationViewBox,The following statement contains a magic number: if (_onTheFlyTransform == null)                  return box;              else              {                  BoundingRectangle result = transformViewBox(box' _onTheFlyTransform.Inverse());                    // We are trying to include the poles. Perhaps one of them is low.                  PointD[] poles = new PointD[4];                  poles[0] = new PointD(89' 0);  //consider the points are sufficiently close to the poles                  poles[1] = new PointD(-89' 0); //because at the poles themselves often features                  poles[2] = new PointD(0' 89);                  poles[3] = new PointD(0' -89);                    for (int i = 0; i < 4; i++)                      try                      {                          if (box.ContainsPoint(GeometryTransformer.TransformPoint(poles[i]' _onTheFlyTransform).Coordinate))                              result.Join(poles[i].Coordinate);                      }                      catch (ApplicationException)                      {                       }                    //TODO: gradient descent                    return result;              }
Magic Number,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,MapViewBoxFromPresentationViewBox,The following statement contains a magic number: if (_onTheFlyTransform == null)                  return box;              else              {                  BoundingRectangle result = transformViewBox(box' _onTheFlyTransform.Inverse());                    // We are trying to include the poles. Perhaps one of them is low.                  PointD[] poles = new PointD[4];                  poles[0] = new PointD(89' 0);  //consider the points are sufficiently close to the poles                  poles[1] = new PointD(-89' 0); //because at the poles themselves often features                  poles[2] = new PointD(0' 89);                  poles[3] = new PointD(0' -89);                    for (int i = 0; i < 4; i++)                      try                      {                          if (box.ContainsPoint(GeometryTransformer.TransformPoint(poles[i]' _onTheFlyTransform).Coordinate))                              result.Join(poles[i].Coordinate);                      }                      catch (ApplicationException)                      {                       }                    //TODO: gradient descent                    return result;              }
Magic Number,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,transformViewBox,The following statement contains a magic number: int segmentCount = 10;
Magic Number,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderPointSampleInternal,The following statement contains a magic number: feature.Point = new PointD(viewBox.Width / 2' viewBox.Height / 2);
Magic Number,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderPointSampleInternal,The following statement contains a magic number: feature.Point = new PointD(viewBox.Width / 2' viewBox.Height / 2);
Magic Number,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderTitleSampleInternal,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  SizeF size = g.MeasureString(sample' f' int.MaxValue' StringFormat.GenericTypographic);                  feature.Point = new PointD(viewBox.Width / 2' viewBox.Height / 2 - size.Height / 2);              }
Magic Number,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderTitleSampleInternal,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  SizeF size = g.MeasureString(sample' f' int.MaxValue' StringFormat.GenericTypographic);                  feature.Point = new PointD(viewBox.Width / 2' viewBox.Height / 2 - size.Height / 2);              }
Magic Number,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderTitleSampleInternal,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  SizeF size = g.MeasureString(sample' f' int.MaxValue' StringFormat.GenericTypographic);                  feature.Point = new PointD(viewBox.Width / 2' viewBox.Height / 2 - size.Height / 2);              }
Magic Number,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderPolylineSample,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(image))              {                  g.SmoothingMode = RenderingSettings.AntiAliasGeometry ? SmoothingMode.AntiAlias : SmoothingMode.HighSpeed;                  RenderPolylineSampleInternal(g' new BoundingRectangle(0' 0' image.Width' image.Height)' polylineStyle' 2);              }
Magic Number,MapAround.Mapping,Map,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderPolygonSample,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(image))              {                  g.SmoothingMode = RenderingSettings.AntiAliasGeometry ? SmoothingMode.AntiAlias : SmoothingMode.HighSpeed;                  RenderPolygonSampleInternal(g' new BoundingRectangle(0' 0' image.Width' image.Height)' polygonStyle' 2);              }
Magic Number,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderFeaturesSample,The following statement contains a magic number: int margin = 2;
Magic Number,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderFeaturesSample,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(image))              {                  g.SmoothingMode = Map.RenderingSettings.AntiAliasGeometry ? SmoothingMode.AntiAlias : SmoothingMode.HighSpeed;                    if (drawPoint)                      Map.RenderPointSampleInternal(g' new BoundingRectangle(0' 0' image.Width / sampleCount' image.Height)' PointStyle);                    if (drawPolyline)                  {                      int minX = 0;                      int maxX = 0;                      switch (sampleCount)                      {                           case 3:                              minX = image.Width / 3;                              maxX = 2 * image.Width / 3;                              break;                          case 2:                              if (drawPoint)                              {                                  minX = image.Width / 2;                                  maxX = image.Width;                              }                              else                                  maxX = image.Width / 2;                              break;                          case 1:                              maxX = image.Width;                              break;                      }                        Map.RenderPolylineSampleInternal(g' new BoundingRectangle(minX' 0' maxX' image.Height)' PolylineStyle' margin);                  }                    if(drawPolygon)                      Map.RenderPolygonSampleInternal(g' new BoundingRectangle((sampleCount - 1) * image.Width / sampleCount' 0' image.Width' image.Height)' PolygonStyle' margin);              }
Magic Number,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderFeaturesSample,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(image))              {                  g.SmoothingMode = Map.RenderingSettings.AntiAliasGeometry ? SmoothingMode.AntiAlias : SmoothingMode.HighSpeed;                    if (drawPoint)                      Map.RenderPointSampleInternal(g' new BoundingRectangle(0' 0' image.Width / sampleCount' image.Height)' PointStyle);                    if (drawPolyline)                  {                      int minX = 0;                      int maxX = 0;                      switch (sampleCount)                      {                           case 3:                              minX = image.Width / 3;                              maxX = 2 * image.Width / 3;                              break;                          case 2:                              if (drawPoint)                              {                                  minX = image.Width / 2;                                  maxX = image.Width;                              }                              else                                  maxX = image.Width / 2;                              break;                          case 1:                              maxX = image.Width;                              break;                      }                        Map.RenderPolylineSampleInternal(g' new BoundingRectangle(minX' 0' maxX' image.Height)' PolylineStyle' margin);                  }                    if(drawPolygon)                      Map.RenderPolygonSampleInternal(g' new BoundingRectangle((sampleCount - 1) * image.Width / sampleCount' 0' image.Width' image.Height)' PolygonStyle' margin);              }
Magic Number,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderFeaturesSample,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(image))              {                  g.SmoothingMode = Map.RenderingSettings.AntiAliasGeometry ? SmoothingMode.AntiAlias : SmoothingMode.HighSpeed;                    if (drawPoint)                      Map.RenderPointSampleInternal(g' new BoundingRectangle(0' 0' image.Width / sampleCount' image.Height)' PointStyle);                    if (drawPolyline)                  {                      int minX = 0;                      int maxX = 0;                      switch (sampleCount)                      {                           case 3:                              minX = image.Width / 3;                              maxX = 2 * image.Width / 3;                              break;                          case 2:                              if (drawPoint)                              {                                  minX = image.Width / 2;                                  maxX = image.Width;                              }                              else                                  maxX = image.Width / 2;                              break;                          case 1:                              maxX = image.Width;                              break;                      }                        Map.RenderPolylineSampleInternal(g' new BoundingRectangle(minX' 0' maxX' image.Height)' PolylineStyle' margin);                  }                    if(drawPolygon)                      Map.RenderPolygonSampleInternal(g' new BoundingRectangle((sampleCount - 1) * image.Width / sampleCount' 0' image.Width' image.Height)' PolygonStyle' margin);              }
Magic Number,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderFeaturesSample,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(image))              {                  g.SmoothingMode = Map.RenderingSettings.AntiAliasGeometry ? SmoothingMode.AntiAlias : SmoothingMode.HighSpeed;                    if (drawPoint)                      Map.RenderPointSampleInternal(g' new BoundingRectangle(0' 0' image.Width / sampleCount' image.Height)' PointStyle);                    if (drawPolyline)                  {                      int minX = 0;                      int maxX = 0;                      switch (sampleCount)                      {                           case 3:                              minX = image.Width / 3;                              maxX = 2 * image.Width / 3;                              break;                          case 2:                              if (drawPoint)                              {                                  minX = image.Width / 2;                                  maxX = image.Width;                              }                              else                                  maxX = image.Width / 2;                              break;                          case 1:                              maxX = image.Width;                              break;                      }                        Map.RenderPolylineSampleInternal(g' new BoundingRectangle(minX' 0' maxX' image.Height)' PolylineStyle' margin);                  }                    if(drawPolygon)                      Map.RenderPolygonSampleInternal(g' new BoundingRectangle((sampleCount - 1) * image.Width / sampleCount' 0' image.Width' image.Height)' PolygonStyle' margin);              }
Magic Number,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderFeaturesSample,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(image))              {                  g.SmoothingMode = Map.RenderingSettings.AntiAliasGeometry ? SmoothingMode.AntiAlias : SmoothingMode.HighSpeed;                    if (drawPoint)                      Map.RenderPointSampleInternal(g' new BoundingRectangle(0' 0' image.Width / sampleCount' image.Height)' PointStyle);                    if (drawPolyline)                  {                      int minX = 0;                      int maxX = 0;                      switch (sampleCount)                      {                           case 3:                              minX = image.Width / 3;                              maxX = 2 * image.Width / 3;                              break;                          case 2:                              if (drawPoint)                              {                                  minX = image.Width / 2;                                  maxX = image.Width;                              }                              else                                  maxX = image.Width / 2;                              break;                          case 1:                              maxX = image.Width;                              break;                      }                        Map.RenderPolylineSampleInternal(g' new BoundingRectangle(minX' 0' maxX' image.Height)' PolylineStyle' margin);                  }                    if(drawPolygon)                      Map.RenderPolygonSampleInternal(g' new BoundingRectangle((sampleCount - 1) * image.Width / sampleCount' 0' image.Width' image.Height)' PolygonStyle' margin);              }
Magic Number,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderFeaturesSample,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(image))              {                  g.SmoothingMode = Map.RenderingSettings.AntiAliasGeometry ? SmoothingMode.AntiAlias : SmoothingMode.HighSpeed;                    if (drawPoint)                      Map.RenderPointSampleInternal(g' new BoundingRectangle(0' 0' image.Width / sampleCount' image.Height)' PointStyle);                    if (drawPolyline)                  {                      int minX = 0;                      int maxX = 0;                      switch (sampleCount)                      {                           case 3:                              minX = image.Width / 3;                              maxX = 2 * image.Width / 3;                              break;                          case 2:                              if (drawPoint)                              {                                  minX = image.Width / 2;                                  maxX = image.Width;                              }                              else                                  maxX = image.Width / 2;                              break;                          case 1:                              maxX = image.Width;                              break;                      }                        Map.RenderPolylineSampleInternal(g' new BoundingRectangle(minX' 0' maxX' image.Height)' PolylineStyle' margin);                  }                    if(drawPolygon)                      Map.RenderPolygonSampleInternal(g' new BoundingRectangle((sampleCount - 1) * image.Width / sampleCount' 0' image.Width' image.Height)' PolygonStyle' margin);              }
Magic Number,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderFeaturesSample,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(image))              {                  g.SmoothingMode = Map.RenderingSettings.AntiAliasGeometry ? SmoothingMode.AntiAlias : SmoothingMode.HighSpeed;                    if (drawPoint)                      Map.RenderPointSampleInternal(g' new BoundingRectangle(0' 0' image.Width / sampleCount' image.Height)' PointStyle);                    if (drawPolyline)                  {                      int minX = 0;                      int maxX = 0;                      switch (sampleCount)                      {                           case 3:                              minX = image.Width / 3;                              maxX = 2 * image.Width / 3;                              break;                          case 2:                              if (drawPoint)                              {                                  minX = image.Width / 2;                                  maxX = image.Width;                              }                              else                                  maxX = image.Width / 2;                              break;                          case 1:                              maxX = image.Width;                              break;                      }                        Map.RenderPolylineSampleInternal(g' new BoundingRectangle(minX' 0' maxX' image.Height)' PolylineStyle' margin);                  }                    if(drawPolygon)                      Map.RenderPolygonSampleInternal(g' new BoundingRectangle((sampleCount - 1) * image.Width / sampleCount' 0' image.Width' image.Height)' PolygonStyle' margin);              }
Magic Number,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,SelectObject,The following statement contains a magic number: switch (contentAlignment)              {                  case ContentAlignment.TopCenter:                   min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width/2' coordinate.Y);                   max = PlanimetryEnvironment.NewCoordinate(coordinate.X + width / 2' coordinate.Y + height); break;                  case ContentAlignment.TopRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height); break;                  case ContentAlignment.TopLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height); break;                  case ContentAlignment.MiddleCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y + height / 2); break;                  case ContentAlignment.MiddleLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - height / 2);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y + height / 2); break;                  case ContentAlignment.BottomCenter:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width / 2' coordinate.Y - height);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width / 2' coordinate.Y); break;                  case ContentAlignment.BottomRight:                      min =    PlanimetryEnvironment.NewCoordinate(coordinate.X' coordinate.Y - height);                       max = PlanimetryEnvironment.NewCoordinate( coordinate.X + width' coordinate.Y); break;                  case ContentAlignment.BottomLeft:                       min =    PlanimetryEnvironment.NewCoordinate(coordinate.X - width' coordinate.Y - width);                      max = PlanimetryEnvironment.NewCoordinate( coordinate.X' coordinate.Y); break;                  default: throw new NotSupportedException();              }
Magic Number,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateOptimalAffineTransformPoints,The following statement contains a magic number: int[] result = new int[3];
Magic Number,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateOptimalAffineTransformPoints,The following statement contains a magic number: for (int i1 = 0; i1 < sourceNodes.Length - 2; i1++)                  for (int i2 = i1 + 1; i2 < sourceNodes.Length - 1; i2++)                      for (int i3 = i2 + 1; i3 < sourceNodes.Length; i3++)                      {                          PointF p01 = new PointF(sourceNodes[i1].X' sourceNodes[i1].Y);                          PointF p02 = new PointF(sourceNodes[i2].X' sourceNodes[i2].Y);                          PointF p03 = new PointF(sourceNodes[i3].X' sourceNodes[i3].Y);                            PointF p11 = new PointF((float)destNodes[i1].X' (float)destNodes[i1].Y);                          PointF p12 = new PointF((float)destNodes[i2].X' (float)destNodes[i2].Y);                          PointF p13 = new PointF((float)destNodes[i3].X' (float)destNodes[i3].Y);                            Matrix m = getAffineTransformMatrix(p01' p02' p03' p11' p12' p13);                          if (m != null)                          {                              PointF[] tempPoints = new PointF[sourceNodes.Length];                              for (int i = 0; i < sourceNodes.Length; i++)                                  tempPoints[i] = new PointF(sourceNodes[i].X' sourceNodes[i].Y);                              m.TransformPoints(tempPoints);                                double currentNorm = 0;                              for (int i = 0; i < tempPoints.Length; i++)                                  currentNorm += PlanimetryAlgorithms.Distance(destNodes[i]' PlanimetryEnvironment.NewCoordinate(tempPoints[i].X' tempPoints[i].Y));                                if (currentNorm < minNorm)                              {                                  minNorm = currentNorm;                                  result[0] = i1;                                  result[1] = i2;                                  result[2] = i3;                              }                          }                      }
Magic Number,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateOptimalAffineTransformPoints,The following statement contains a magic number: for (int i1 = 0; i1 < sourceNodes.Length - 2; i1++)                  for (int i2 = i1 + 1; i2 < sourceNodes.Length - 1; i2++)                      for (int i3 = i2 + 1; i3 < sourceNodes.Length; i3++)                      {                          PointF p01 = new PointF(sourceNodes[i1].X' sourceNodes[i1].Y);                          PointF p02 = new PointF(sourceNodes[i2].X' sourceNodes[i2].Y);                          PointF p03 = new PointF(sourceNodes[i3].X' sourceNodes[i3].Y);                            PointF p11 = new PointF((float)destNodes[i1].X' (float)destNodes[i1].Y);                          PointF p12 = new PointF((float)destNodes[i2].X' (float)destNodes[i2].Y);                          PointF p13 = new PointF((float)destNodes[i3].X' (float)destNodes[i3].Y);                            Matrix m = getAffineTransformMatrix(p01' p02' p03' p11' p12' p13);                          if (m != null)                          {                              PointF[] tempPoints = new PointF[sourceNodes.Length];                              for (int i = 0; i < sourceNodes.Length; i++)                                  tempPoints[i] = new PointF(sourceNodes[i].X' sourceNodes[i].Y);                              m.TransformPoints(tempPoints);                                double currentNorm = 0;                              for (int i = 0; i < tempPoints.Length; i++)                                  currentNorm += PlanimetryAlgorithms.Distance(destNodes[i]' PlanimetryEnvironment.NewCoordinate(tempPoints[i].X' tempPoints[i].Y));                                if (currentNorm < minNorm)                              {                                  minNorm = currentNorm;                                  result[0] = i1;                                  result[1] = i2;                                  result[2] = i3;                              }                          }                      }
Magic Number,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateRubberSheetTransform,The following statement contains a magic number: int startProgressPercent = 30;
Magic Number,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateRubberSheetTransform,The following statement contains a magic number: int endProgressPercent = 70;
Magic Number,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateRubberSheetTransform,The following statement contains a magic number: for (int i = 0; i < width; i++)              {                  for (int j = 0; j < height; j++)                  {                      // проверяем попали ли мы в узел интерполяции                      bool isNode = false;                      for (int k = 0; k < sourceNodes.Length; k++)                      {                          if (sourceNodes[k].X == source[i' j].X &&                               sourceNodes[k].Y == source[i' j].Y)                          {                              // попали                              result[i' j] =                                  PlanimetryEnvironment.NewCoordinate(destNodesShifts[k].X + source[i' j].X'                                      destNodesShifts[k].Y + source[i' j].Y);                              isNode = true;                          }                      }                        if (isNode) continue;                        // расчет расстояний до узлов                      double maxDistance = 0;                      for (int t = 0; t < sourceNodes.Length; t++)                      {                          ICoordinate p = PlanimetryEnvironment.NewCoordinate(sourceNodes[t].X' sourceNodes[t].Y);                          distances[t] = PlanimetryAlgorithms.Distance(p'                                  PlanimetryEnvironment.NewCoordinate(source[i' j].X'                                              source[i' j].Y));                            if (maxDistance < distances[t])                              maxDistance = distances[t];                      }                        // расчет знаменателей весов узловых точек                      double sum = 0;                      for (int k = 0; k < sourceNodes.Length; k++)                      {                          double temp = (maxDistance - distances[k]) / (maxDistance * distances[k]);                          sum += Math.Pow(temp' 2);                      }                        // расчет весов узловых точек                      for (int k = 0; k < sourceNodes.Length; k++)                      {                          double temp = (maxDistance - distances[k]) / (maxDistance * distances[k]);                          w[k] = Math.Pow(temp' 2) / sum;                      }                        // расчет значений новых координат                      result[i' j] = PlanimetryEnvironment.NewCoordinate(source[i' j].X' source[i' j].Y);                      for (int k = 0; k < sourceNodes.Length; k++)                      {                          result[i' j].X += w[k] * destNodesShifts[k].X;                          result[i' j].Y += w[k] * destNodesShifts[k].Y;                      }                  }                    notifyProgessListenerIfNeeded(progress' startProgressPercent' endProgressPercent' ref completed' ref previousPercent' width);              }
Magic Number,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateRubberSheetTransform,The following statement contains a magic number: for (int i = 0; i < width; i++)              {                  for (int j = 0; j < height; j++)                  {                      // проверяем попали ли мы в узел интерполяции                      bool isNode = false;                      for (int k = 0; k < sourceNodes.Length; k++)                      {                          if (sourceNodes[k].X == source[i' j].X &&                               sourceNodes[k].Y == source[i' j].Y)                          {                              // попали                              result[i' j] =                                  PlanimetryEnvironment.NewCoordinate(destNodesShifts[k].X + source[i' j].X'                                      destNodesShifts[k].Y + source[i' j].Y);                              isNode = true;                          }                      }                        if (isNode) continue;                        // расчет расстояний до узлов                      double maxDistance = 0;                      for (int t = 0; t < sourceNodes.Length; t++)                      {                          ICoordinate p = PlanimetryEnvironment.NewCoordinate(sourceNodes[t].X' sourceNodes[t].Y);                          distances[t] = PlanimetryAlgorithms.Distance(p'                                  PlanimetryEnvironment.NewCoordinate(source[i' j].X'                                              source[i' j].Y));                            if (maxDistance < distances[t])                              maxDistance = distances[t];                      }                        // расчет знаменателей весов узловых точек                      double sum = 0;                      for (int k = 0; k < sourceNodes.Length; k++)                      {                          double temp = (maxDistance - distances[k]) / (maxDistance * distances[k]);                          sum += Math.Pow(temp' 2);                      }                        // расчет весов узловых точек                      for (int k = 0; k < sourceNodes.Length; k++)                      {                          double temp = (maxDistance - distances[k]) / (maxDistance * distances[k]);                          w[k] = Math.Pow(temp' 2) / sum;                      }                        // расчет значений новых координат                      result[i' j] = PlanimetryEnvironment.NewCoordinate(source[i' j].X' source[i' j].Y);                      for (int k = 0; k < sourceNodes.Length; k++)                      {                          result[i' j].X += w[k] * destNodesShifts[k].X;                          result[i' j].Y += w[k] * destNodesShifts[k].Y;                      }                  }                    notifyProgessListenerIfNeeded(progress' startProgressPercent' endProgressPercent' ref completed' ref previousPercent' width);              }
Magic Number,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateAffinneTransform,The following statement contains a magic number: PointF p03 = new PointF(sourceNodes[r[2]].X' sourceNodes[r[2]].Y);
Magic Number,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateAffinneTransform,The following statement contains a magic number: PointF p03 = new PointF(sourceNodes[r[2]].X' sourceNodes[r[2]].Y);
Magic Number,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateAffinneTransform,The following statement contains a magic number: PointF p13 = new PointF((float)destNodes[r[2]].X' (float)destNodes[r[2]].Y);
Magic Number,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateAffinneTransform,The following statement contains a magic number: PointF p13 = new PointF((float)destNodes[r[2]].X' (float)destNodes[r[2]].Y);
Magic Number,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calculateAffinneTransform,The following statement contains a magic number: int endProgressPercent = 30;
Magic Number,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,The following statement contains a magic number: int startProgressPercent = 70;
Magic Number,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,The following statement contains a magic number: int endProgressPercent = 80;
Magic Number,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,The following statement contains a magic number: startProgressPercent = 80;
Magic Number,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,The following statement contains a magic number: endProgressPercent = 90;
Magic Number,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,The following statement contains a magic number: startProgressPercent = 90;
Magic Number,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,calcDestRaster,The following statement contains a magic number: endProgressPercent = 100;
Magic Number,MapAround.Mapping,RasterAlgorithms,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\RasterAlgorithms.cs,BindRaster,The following statement contains a magic number: if (sourceControlPoints.Length < 3)                  throw new ArgumentException("Number of control points should not be less than 3");
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,createSelectionTexture,The following statement contains a magic number: lock (HatchFillPatternsAcccessor.SyncRoot)              {                  Bitmap originalPattern = HatchFillPatternsAcccessor.Bitmaps[(int)HatchStyle.Percent50];                    if (_selectionTexture != null)                      _selectionTexture.Dispose();                    _selectionTexture = new Bitmap(originalPattern.Width' originalPattern.Height' System.Drawing.Imaging.PixelFormat.Format32bppArgb);                    for (int i = 0; i < _selectionTexture.Width; i++)                      for (int j = 0; j < _selectionTexture.Height; j++)                      {                          Color c = originalPattern.GetPixel(i' j);                            Color blendedColor =                              Color.FromArgb(                                  RenderingUtils.BlendPixels(Color.Transparent.ToArgb()' Color.FromArgb((255 - c.R) / 2' _selectionColor).ToArgb()));                            _selectionTexture.SetPixel(i' j' blendedColor);                      }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,createSelectionTexture,The following statement contains a magic number: lock (HatchFillPatternsAcccessor.SyncRoot)              {                  Bitmap originalPattern = HatchFillPatternsAcccessor.Bitmaps[(int)HatchStyle.Percent50];                    if (_selectionTexture != null)                      _selectionTexture.Dispose();                    _selectionTexture = new Bitmap(originalPattern.Width' originalPattern.Height' System.Drawing.Imaging.PixelFormat.Format32bppArgb);                    for (int i = 0; i < _selectionTexture.Width; i++)                      for (int j = 0; j < _selectionTexture.Height; j++)                      {                          Color c = originalPattern.GetPixel(i' j);                            Color blendedColor =                              Color.FromArgb(                                  RenderingUtils.BlendPixels(Color.Transparent.ToArgb()' Color.FromArgb((255 - c.R) / 2' _selectionColor).ToArgb()));                            _selectionTexture.SetPixel(i' j' blendedColor);                      }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPrismPolygon,The following statement contains a magic number: using (Pen pen = new Pen(Color.FromArgb(255' Color.White)))              {                  using (GraphicsPath path = new GraphicsPath(FillMode.Alternate))                  {                      path.StartFigure();                        float x = (float)((feature.Polygon.Contours[0].Vertices[0].X - viewBox.MinX) * scaleFactor);                      float y = (float)((viewBox.MaxY - feature.Polygon.Contours[0].Vertices[0].Y) * scaleFactor);                        g.RenderingOrigin = new Point((int)Math.Round(x)' (int)Math.Round(y));                        PointF[][] points = new PointF[feature.Polygon.Contours.Count][];                      int contourIndex = 0;                        foreach (Contour c in feature.Polygon.Contours)                      {                          points[contourIndex] = new PointF[c.Vertices.Count];                            for (int j = 0; j < c.Vertices.Count; j++)                          {                              points[contourIndex][j].X = (float)((c.Vertices[j].X - viewBox.MinX) * scaleFactor);                              points[contourIndex][j].Y = (float)((viewBox.MaxY - c.Vertices[j].Y) * scaleFactor);                          }                            if (points[contourIndex].Length > 2)                              path.AddPolygon(points[contourIndex]);                            contourIndex++;                      }                        path.CloseFigure();                        int prismHeight = 4; //(int)(scaleFactor / 10000.0);                        // boundary of the lower base of the prism                      g.DrawPath(pen' path);                        // Fill the lower base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(50' 225' 225' 225)))                      {                          g.FillPath(b' path);                      }                        // border vertical faces                      foreach (PointF[] contour in points)                          for (int i = 0; i < contour.Length; i++)                              g.DrawLine(pen' contour[i]' new PointF(contour[i].X' contour[i].Y - prismHeight));                        //Fill vertical faces                      using (Brush b = new SolidBrush(Color.FromArgb(50' 60' 60' 60)))                      {                          List<Segment> segments = new List<Segment>();                          List<bool> isForeSegment = new List<bool>();                            foreach (PointF[] contour in points)                              for (int i = 0; i < contour.Length; i++)                              {                                  int j = i < contour.Length - 1 ? i + 1 : 0;                                  if (contour[i].X != contour[i].Y)                                  {                                      segments.Add(new Segment(contour[i].X' contour[i].Y' contour[j].X' contour[j].Y));                                      isForeSegment.Add(true);                                  }                              }                            for(int i = 0 ; i < segments.Count; i++)                          {                              double cX = segments[i].Center().X;                              double cY = segments[i].Center().Y;                                for (int j = 0; j < segments.Count; j++)                              {                                  if (i != j)                                  {                                       double v1x = segments[j].V1.X;                                      double v2x = segments[j].V2.X;                                      double v1y = segments[j].V1.Y;                                      double v2y = segments[j].V2.Y;                                        if(v1x > v2x)                                      {                                          double temp = v1x;                                          v1x = v2x;                                          v2x = temp;                                      }                                        if (v1x < cX && v2x >= cX)                                      {                                          double crossY = v1y + (cX - v1x) / (v2x - v1x) * (v2y - v1y);                                          if(crossY > cY)                                              isForeSegment[i] = !isForeSegment[i];                                      }                                  }                              }                          }                            for (int i = 0; i < segments.Count; i++)                          {                              if (isForeSegment[i])                                  g.FillPolygon(b' new PointF[]                                   {                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y - prismHeight)'                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y - prismHeight)                                  });                          }                      }                        // Fill the upper base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(200' Color.FromArgb(245' 245' 245))))                      {                          path.Transform(new Matrix(1' 0' 0' 1' 0' -prismHeight));                          g.FillPath(b' path);                      }                        // boundary of the upper base of the prism                      g.DrawPath(pen' path);                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPrismPolygon,The following statement contains a magic number: using (Pen pen = new Pen(Color.FromArgb(255' Color.White)))              {                  using (GraphicsPath path = new GraphicsPath(FillMode.Alternate))                  {                      path.StartFigure();                        float x = (float)((feature.Polygon.Contours[0].Vertices[0].X - viewBox.MinX) * scaleFactor);                      float y = (float)((viewBox.MaxY - feature.Polygon.Contours[0].Vertices[0].Y) * scaleFactor);                        g.RenderingOrigin = new Point((int)Math.Round(x)' (int)Math.Round(y));                        PointF[][] points = new PointF[feature.Polygon.Contours.Count][];                      int contourIndex = 0;                        foreach (Contour c in feature.Polygon.Contours)                      {                          points[contourIndex] = new PointF[c.Vertices.Count];                            for (int j = 0; j < c.Vertices.Count; j++)                          {                              points[contourIndex][j].X = (float)((c.Vertices[j].X - viewBox.MinX) * scaleFactor);                              points[contourIndex][j].Y = (float)((viewBox.MaxY - c.Vertices[j].Y) * scaleFactor);                          }                            if (points[contourIndex].Length > 2)                              path.AddPolygon(points[contourIndex]);                            contourIndex++;                      }                        path.CloseFigure();                        int prismHeight = 4; //(int)(scaleFactor / 10000.0);                        // boundary of the lower base of the prism                      g.DrawPath(pen' path);                        // Fill the lower base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(50' 225' 225' 225)))                      {                          g.FillPath(b' path);                      }                        // border vertical faces                      foreach (PointF[] contour in points)                          for (int i = 0; i < contour.Length; i++)                              g.DrawLine(pen' contour[i]' new PointF(contour[i].X' contour[i].Y - prismHeight));                        //Fill vertical faces                      using (Brush b = new SolidBrush(Color.FromArgb(50' 60' 60' 60)))                      {                          List<Segment> segments = new List<Segment>();                          List<bool> isForeSegment = new List<bool>();                            foreach (PointF[] contour in points)                              for (int i = 0; i < contour.Length; i++)                              {                                  int j = i < contour.Length - 1 ? i + 1 : 0;                                  if (contour[i].X != contour[i].Y)                                  {                                      segments.Add(new Segment(contour[i].X' contour[i].Y' contour[j].X' contour[j].Y));                                      isForeSegment.Add(true);                                  }                              }                            for(int i = 0 ; i < segments.Count; i++)                          {                              double cX = segments[i].Center().X;                              double cY = segments[i].Center().Y;                                for (int j = 0; j < segments.Count; j++)                              {                                  if (i != j)                                  {                                       double v1x = segments[j].V1.X;                                      double v2x = segments[j].V2.X;                                      double v1y = segments[j].V1.Y;                                      double v2y = segments[j].V2.Y;                                        if(v1x > v2x)                                      {                                          double temp = v1x;                                          v1x = v2x;                                          v2x = temp;                                      }                                        if (v1x < cX && v2x >= cX)                                      {                                          double crossY = v1y + (cX - v1x) / (v2x - v1x) * (v2y - v1y);                                          if(crossY > cY)                                              isForeSegment[i] = !isForeSegment[i];                                      }                                  }                              }                          }                            for (int i = 0; i < segments.Count; i++)                          {                              if (isForeSegment[i])                                  g.FillPolygon(b' new PointF[]                                   {                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y - prismHeight)'                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y - prismHeight)                                  });                          }                      }                        // Fill the upper base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(200' Color.FromArgb(245' 245' 245))))                      {                          path.Transform(new Matrix(1' 0' 0' 1' 0' -prismHeight));                          g.FillPath(b' path);                      }                        // boundary of the upper base of the prism                      g.DrawPath(pen' path);                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPrismPolygon,The following statement contains a magic number: using (Pen pen = new Pen(Color.FromArgb(255' Color.White)))              {                  using (GraphicsPath path = new GraphicsPath(FillMode.Alternate))                  {                      path.StartFigure();                        float x = (float)((feature.Polygon.Contours[0].Vertices[0].X - viewBox.MinX) * scaleFactor);                      float y = (float)((viewBox.MaxY - feature.Polygon.Contours[0].Vertices[0].Y) * scaleFactor);                        g.RenderingOrigin = new Point((int)Math.Round(x)' (int)Math.Round(y));                        PointF[][] points = new PointF[feature.Polygon.Contours.Count][];                      int contourIndex = 0;                        foreach (Contour c in feature.Polygon.Contours)                      {                          points[contourIndex] = new PointF[c.Vertices.Count];                            for (int j = 0; j < c.Vertices.Count; j++)                          {                              points[contourIndex][j].X = (float)((c.Vertices[j].X - viewBox.MinX) * scaleFactor);                              points[contourIndex][j].Y = (float)((viewBox.MaxY - c.Vertices[j].Y) * scaleFactor);                          }                            if (points[contourIndex].Length > 2)                              path.AddPolygon(points[contourIndex]);                            contourIndex++;                      }                        path.CloseFigure();                        int prismHeight = 4; //(int)(scaleFactor / 10000.0);                        // boundary of the lower base of the prism                      g.DrawPath(pen' path);                        // Fill the lower base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(50' 225' 225' 225)))                      {                          g.FillPath(b' path);                      }                        // border vertical faces                      foreach (PointF[] contour in points)                          for (int i = 0; i < contour.Length; i++)                              g.DrawLine(pen' contour[i]' new PointF(contour[i].X' contour[i].Y - prismHeight));                        //Fill vertical faces                      using (Brush b = new SolidBrush(Color.FromArgb(50' 60' 60' 60)))                      {                          List<Segment> segments = new List<Segment>();                          List<bool> isForeSegment = new List<bool>();                            foreach (PointF[] contour in points)                              for (int i = 0; i < contour.Length; i++)                              {                                  int j = i < contour.Length - 1 ? i + 1 : 0;                                  if (contour[i].X != contour[i].Y)                                  {                                      segments.Add(new Segment(contour[i].X' contour[i].Y' contour[j].X' contour[j].Y));                                      isForeSegment.Add(true);                                  }                              }                            for(int i = 0 ; i < segments.Count; i++)                          {                              double cX = segments[i].Center().X;                              double cY = segments[i].Center().Y;                                for (int j = 0; j < segments.Count; j++)                              {                                  if (i != j)                                  {                                       double v1x = segments[j].V1.X;                                      double v2x = segments[j].V2.X;                                      double v1y = segments[j].V1.Y;                                      double v2y = segments[j].V2.Y;                                        if(v1x > v2x)                                      {                                          double temp = v1x;                                          v1x = v2x;                                          v2x = temp;                                      }                                        if (v1x < cX && v2x >= cX)                                      {                                          double crossY = v1y + (cX - v1x) / (v2x - v1x) * (v2y - v1y);                                          if(crossY > cY)                                              isForeSegment[i] = !isForeSegment[i];                                      }                                  }                              }                          }                            for (int i = 0; i < segments.Count; i++)                          {                              if (isForeSegment[i])                                  g.FillPolygon(b' new PointF[]                                   {                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y - prismHeight)'                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y - prismHeight)                                  });                          }                      }                        // Fill the upper base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(200' Color.FromArgb(245' 245' 245))))                      {                          path.Transform(new Matrix(1' 0' 0' 1' 0' -prismHeight));                          g.FillPath(b' path);                      }                        // boundary of the upper base of the prism                      g.DrawPath(pen' path);                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPrismPolygon,The following statement contains a magic number: using (Pen pen = new Pen(Color.FromArgb(255' Color.White)))              {                  using (GraphicsPath path = new GraphicsPath(FillMode.Alternate))                  {                      path.StartFigure();                        float x = (float)((feature.Polygon.Contours[0].Vertices[0].X - viewBox.MinX) * scaleFactor);                      float y = (float)((viewBox.MaxY - feature.Polygon.Contours[0].Vertices[0].Y) * scaleFactor);                        g.RenderingOrigin = new Point((int)Math.Round(x)' (int)Math.Round(y));                        PointF[][] points = new PointF[feature.Polygon.Contours.Count][];                      int contourIndex = 0;                        foreach (Contour c in feature.Polygon.Contours)                      {                          points[contourIndex] = new PointF[c.Vertices.Count];                            for (int j = 0; j < c.Vertices.Count; j++)                          {                              points[contourIndex][j].X = (float)((c.Vertices[j].X - viewBox.MinX) * scaleFactor);                              points[contourIndex][j].Y = (float)((viewBox.MaxY - c.Vertices[j].Y) * scaleFactor);                          }                            if (points[contourIndex].Length > 2)                              path.AddPolygon(points[contourIndex]);                            contourIndex++;                      }                        path.CloseFigure();                        int prismHeight = 4; //(int)(scaleFactor / 10000.0);                        // boundary of the lower base of the prism                      g.DrawPath(pen' path);                        // Fill the lower base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(50' 225' 225' 225)))                      {                          g.FillPath(b' path);                      }                        // border vertical faces                      foreach (PointF[] contour in points)                          for (int i = 0; i < contour.Length; i++)                              g.DrawLine(pen' contour[i]' new PointF(contour[i].X' contour[i].Y - prismHeight));                        //Fill vertical faces                      using (Brush b = new SolidBrush(Color.FromArgb(50' 60' 60' 60)))                      {                          List<Segment> segments = new List<Segment>();                          List<bool> isForeSegment = new List<bool>();                            foreach (PointF[] contour in points)                              for (int i = 0; i < contour.Length; i++)                              {                                  int j = i < contour.Length - 1 ? i + 1 : 0;                                  if (contour[i].X != contour[i].Y)                                  {                                      segments.Add(new Segment(contour[i].X' contour[i].Y' contour[j].X' contour[j].Y));                                      isForeSegment.Add(true);                                  }                              }                            for(int i = 0 ; i < segments.Count; i++)                          {                              double cX = segments[i].Center().X;                              double cY = segments[i].Center().Y;                                for (int j = 0; j < segments.Count; j++)                              {                                  if (i != j)                                  {                                       double v1x = segments[j].V1.X;                                      double v2x = segments[j].V2.X;                                      double v1y = segments[j].V1.Y;                                      double v2y = segments[j].V2.Y;                                        if(v1x > v2x)                                      {                                          double temp = v1x;                                          v1x = v2x;                                          v2x = temp;                                      }                                        if (v1x < cX && v2x >= cX)                                      {                                          double crossY = v1y + (cX - v1x) / (v2x - v1x) * (v2y - v1y);                                          if(crossY > cY)                                              isForeSegment[i] = !isForeSegment[i];                                      }                                  }                              }                          }                            for (int i = 0; i < segments.Count; i++)                          {                              if (isForeSegment[i])                                  g.FillPolygon(b' new PointF[]                                   {                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y - prismHeight)'                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y - prismHeight)                                  });                          }                      }                        // Fill the upper base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(200' Color.FromArgb(245' 245' 245))))                      {                          path.Transform(new Matrix(1' 0' 0' 1' 0' -prismHeight));                          g.FillPath(b' path);                      }                        // boundary of the upper base of the prism                      g.DrawPath(pen' path);                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPrismPolygon,The following statement contains a magic number: using (Pen pen = new Pen(Color.FromArgb(255' Color.White)))              {                  using (GraphicsPath path = new GraphicsPath(FillMode.Alternate))                  {                      path.StartFigure();                        float x = (float)((feature.Polygon.Contours[0].Vertices[0].X - viewBox.MinX) * scaleFactor);                      float y = (float)((viewBox.MaxY - feature.Polygon.Contours[0].Vertices[0].Y) * scaleFactor);                        g.RenderingOrigin = new Point((int)Math.Round(x)' (int)Math.Round(y));                        PointF[][] points = new PointF[feature.Polygon.Contours.Count][];                      int contourIndex = 0;                        foreach (Contour c in feature.Polygon.Contours)                      {                          points[contourIndex] = new PointF[c.Vertices.Count];                            for (int j = 0; j < c.Vertices.Count; j++)                          {                              points[contourIndex][j].X = (float)((c.Vertices[j].X - viewBox.MinX) * scaleFactor);                              points[contourIndex][j].Y = (float)((viewBox.MaxY - c.Vertices[j].Y) * scaleFactor);                          }                            if (points[contourIndex].Length > 2)                              path.AddPolygon(points[contourIndex]);                            contourIndex++;                      }                        path.CloseFigure();                        int prismHeight = 4; //(int)(scaleFactor / 10000.0);                        // boundary of the lower base of the prism                      g.DrawPath(pen' path);                        // Fill the lower base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(50' 225' 225' 225)))                      {                          g.FillPath(b' path);                      }                        // border vertical faces                      foreach (PointF[] contour in points)                          for (int i = 0; i < contour.Length; i++)                              g.DrawLine(pen' contour[i]' new PointF(contour[i].X' contour[i].Y - prismHeight));                        //Fill vertical faces                      using (Brush b = new SolidBrush(Color.FromArgb(50' 60' 60' 60)))                      {                          List<Segment> segments = new List<Segment>();                          List<bool> isForeSegment = new List<bool>();                            foreach (PointF[] contour in points)                              for (int i = 0; i < contour.Length; i++)                              {                                  int j = i < contour.Length - 1 ? i + 1 : 0;                                  if (contour[i].X != contour[i].Y)                                  {                                      segments.Add(new Segment(contour[i].X' contour[i].Y' contour[j].X' contour[j].Y));                                      isForeSegment.Add(true);                                  }                              }                            for(int i = 0 ; i < segments.Count; i++)                          {                              double cX = segments[i].Center().X;                              double cY = segments[i].Center().Y;                                for (int j = 0; j < segments.Count; j++)                              {                                  if (i != j)                                  {                                       double v1x = segments[j].V1.X;                                      double v2x = segments[j].V2.X;                                      double v1y = segments[j].V1.Y;                                      double v2y = segments[j].V2.Y;                                        if(v1x > v2x)                                      {                                          double temp = v1x;                                          v1x = v2x;                                          v2x = temp;                                      }                                        if (v1x < cX && v2x >= cX)                                      {                                          double crossY = v1y + (cX - v1x) / (v2x - v1x) * (v2y - v1y);                                          if(crossY > cY)                                              isForeSegment[i] = !isForeSegment[i];                                      }                                  }                              }                          }                            for (int i = 0; i < segments.Count; i++)                          {                              if (isForeSegment[i])                                  g.FillPolygon(b' new PointF[]                                   {                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y - prismHeight)'                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y - prismHeight)                                  });                          }                      }                        // Fill the upper base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(200' Color.FromArgb(245' 245' 245))))                      {                          path.Transform(new Matrix(1' 0' 0' 1' 0' -prismHeight));                          g.FillPath(b' path);                      }                        // boundary of the upper base of the prism                      g.DrawPath(pen' path);                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPrismPolygon,The following statement contains a magic number: using (Pen pen = new Pen(Color.FromArgb(255' Color.White)))              {                  using (GraphicsPath path = new GraphicsPath(FillMode.Alternate))                  {                      path.StartFigure();                        float x = (float)((feature.Polygon.Contours[0].Vertices[0].X - viewBox.MinX) * scaleFactor);                      float y = (float)((viewBox.MaxY - feature.Polygon.Contours[0].Vertices[0].Y) * scaleFactor);                        g.RenderingOrigin = new Point((int)Math.Round(x)' (int)Math.Round(y));                        PointF[][] points = new PointF[feature.Polygon.Contours.Count][];                      int contourIndex = 0;                        foreach (Contour c in feature.Polygon.Contours)                      {                          points[contourIndex] = new PointF[c.Vertices.Count];                            for (int j = 0; j < c.Vertices.Count; j++)                          {                              points[contourIndex][j].X = (float)((c.Vertices[j].X - viewBox.MinX) * scaleFactor);                              points[contourIndex][j].Y = (float)((viewBox.MaxY - c.Vertices[j].Y) * scaleFactor);                          }                            if (points[contourIndex].Length > 2)                              path.AddPolygon(points[contourIndex]);                            contourIndex++;                      }                        path.CloseFigure();                        int prismHeight = 4; //(int)(scaleFactor / 10000.0);                        // boundary of the lower base of the prism                      g.DrawPath(pen' path);                        // Fill the lower base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(50' 225' 225' 225)))                      {                          g.FillPath(b' path);                      }                        // border vertical faces                      foreach (PointF[] contour in points)                          for (int i = 0; i < contour.Length; i++)                              g.DrawLine(pen' contour[i]' new PointF(contour[i].X' contour[i].Y - prismHeight));                        //Fill vertical faces                      using (Brush b = new SolidBrush(Color.FromArgb(50' 60' 60' 60)))                      {                          List<Segment> segments = new List<Segment>();                          List<bool> isForeSegment = new List<bool>();                            foreach (PointF[] contour in points)                              for (int i = 0; i < contour.Length; i++)                              {                                  int j = i < contour.Length - 1 ? i + 1 : 0;                                  if (contour[i].X != contour[i].Y)                                  {                                      segments.Add(new Segment(contour[i].X' contour[i].Y' contour[j].X' contour[j].Y));                                      isForeSegment.Add(true);                                  }                              }                            for(int i = 0 ; i < segments.Count; i++)                          {                              double cX = segments[i].Center().X;                              double cY = segments[i].Center().Y;                                for (int j = 0; j < segments.Count; j++)                              {                                  if (i != j)                                  {                                       double v1x = segments[j].V1.X;                                      double v2x = segments[j].V2.X;                                      double v1y = segments[j].V1.Y;                                      double v2y = segments[j].V2.Y;                                        if(v1x > v2x)                                      {                                          double temp = v1x;                                          v1x = v2x;                                          v2x = temp;                                      }                                        if (v1x < cX && v2x >= cX)                                      {                                          double crossY = v1y + (cX - v1x) / (v2x - v1x) * (v2y - v1y);                                          if(crossY > cY)                                              isForeSegment[i] = !isForeSegment[i];                                      }                                  }                              }                          }                            for (int i = 0; i < segments.Count; i++)                          {                              if (isForeSegment[i])                                  g.FillPolygon(b' new PointF[]                                   {                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y - prismHeight)'                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y - prismHeight)                                  });                          }                      }                        // Fill the upper base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(200' Color.FromArgb(245' 245' 245))))                      {                          path.Transform(new Matrix(1' 0' 0' 1' 0' -prismHeight));                          g.FillPath(b' path);                      }                        // boundary of the upper base of the prism                      g.DrawPath(pen' path);                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPrismPolygon,The following statement contains a magic number: using (Pen pen = new Pen(Color.FromArgb(255' Color.White)))              {                  using (GraphicsPath path = new GraphicsPath(FillMode.Alternate))                  {                      path.StartFigure();                        float x = (float)((feature.Polygon.Contours[0].Vertices[0].X - viewBox.MinX) * scaleFactor);                      float y = (float)((viewBox.MaxY - feature.Polygon.Contours[0].Vertices[0].Y) * scaleFactor);                        g.RenderingOrigin = new Point((int)Math.Round(x)' (int)Math.Round(y));                        PointF[][] points = new PointF[feature.Polygon.Contours.Count][];                      int contourIndex = 0;                        foreach (Contour c in feature.Polygon.Contours)                      {                          points[contourIndex] = new PointF[c.Vertices.Count];                            for (int j = 0; j < c.Vertices.Count; j++)                          {                              points[contourIndex][j].X = (float)((c.Vertices[j].X - viewBox.MinX) * scaleFactor);                              points[contourIndex][j].Y = (float)((viewBox.MaxY - c.Vertices[j].Y) * scaleFactor);                          }                            if (points[contourIndex].Length > 2)                              path.AddPolygon(points[contourIndex]);                            contourIndex++;                      }                        path.CloseFigure();                        int prismHeight = 4; //(int)(scaleFactor / 10000.0);                        // boundary of the lower base of the prism                      g.DrawPath(pen' path);                        // Fill the lower base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(50' 225' 225' 225)))                      {                          g.FillPath(b' path);                      }                        // border vertical faces                      foreach (PointF[] contour in points)                          for (int i = 0; i < contour.Length; i++)                              g.DrawLine(pen' contour[i]' new PointF(contour[i].X' contour[i].Y - prismHeight));                        //Fill vertical faces                      using (Brush b = new SolidBrush(Color.FromArgb(50' 60' 60' 60)))                      {                          List<Segment> segments = new List<Segment>();                          List<bool> isForeSegment = new List<bool>();                            foreach (PointF[] contour in points)                              for (int i = 0; i < contour.Length; i++)                              {                                  int j = i < contour.Length - 1 ? i + 1 : 0;                                  if (contour[i].X != contour[i].Y)                                  {                                      segments.Add(new Segment(contour[i].X' contour[i].Y' contour[j].X' contour[j].Y));                                      isForeSegment.Add(true);                                  }                              }                            for(int i = 0 ; i < segments.Count; i++)                          {                              double cX = segments[i].Center().X;                              double cY = segments[i].Center().Y;                                for (int j = 0; j < segments.Count; j++)                              {                                  if (i != j)                                  {                                       double v1x = segments[j].V1.X;                                      double v2x = segments[j].V2.X;                                      double v1y = segments[j].V1.Y;                                      double v2y = segments[j].V2.Y;                                        if(v1x > v2x)                                      {                                          double temp = v1x;                                          v1x = v2x;                                          v2x = temp;                                      }                                        if (v1x < cX && v2x >= cX)                                      {                                          double crossY = v1y + (cX - v1x) / (v2x - v1x) * (v2y - v1y);                                          if(crossY > cY)                                              isForeSegment[i] = !isForeSegment[i];                                      }                                  }                              }                          }                            for (int i = 0; i < segments.Count; i++)                          {                              if (isForeSegment[i])                                  g.FillPolygon(b' new PointF[]                                   {                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y - prismHeight)'                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y - prismHeight)                                  });                          }                      }                        // Fill the upper base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(200' Color.FromArgb(245' 245' 245))))                      {                          path.Transform(new Matrix(1' 0' 0' 1' 0' -prismHeight));                          g.FillPath(b' path);                      }                        // boundary of the upper base of the prism                      g.DrawPath(pen' path);                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPrismPolygon,The following statement contains a magic number: using (Pen pen = new Pen(Color.FromArgb(255' Color.White)))              {                  using (GraphicsPath path = new GraphicsPath(FillMode.Alternate))                  {                      path.StartFigure();                        float x = (float)((feature.Polygon.Contours[0].Vertices[0].X - viewBox.MinX) * scaleFactor);                      float y = (float)((viewBox.MaxY - feature.Polygon.Contours[0].Vertices[0].Y) * scaleFactor);                        g.RenderingOrigin = new Point((int)Math.Round(x)' (int)Math.Round(y));                        PointF[][] points = new PointF[feature.Polygon.Contours.Count][];                      int contourIndex = 0;                        foreach (Contour c in feature.Polygon.Contours)                      {                          points[contourIndex] = new PointF[c.Vertices.Count];                            for (int j = 0; j < c.Vertices.Count; j++)                          {                              points[contourIndex][j].X = (float)((c.Vertices[j].X - viewBox.MinX) * scaleFactor);                              points[contourIndex][j].Y = (float)((viewBox.MaxY - c.Vertices[j].Y) * scaleFactor);                          }                            if (points[contourIndex].Length > 2)                              path.AddPolygon(points[contourIndex]);                            contourIndex++;                      }                        path.CloseFigure();                        int prismHeight = 4; //(int)(scaleFactor / 10000.0);                        // boundary of the lower base of the prism                      g.DrawPath(pen' path);                        // Fill the lower base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(50' 225' 225' 225)))                      {                          g.FillPath(b' path);                      }                        // border vertical faces                      foreach (PointF[] contour in points)                          for (int i = 0; i < contour.Length; i++)                              g.DrawLine(pen' contour[i]' new PointF(contour[i].X' contour[i].Y - prismHeight));                        //Fill vertical faces                      using (Brush b = new SolidBrush(Color.FromArgb(50' 60' 60' 60)))                      {                          List<Segment> segments = new List<Segment>();                          List<bool> isForeSegment = new List<bool>();                            foreach (PointF[] contour in points)                              for (int i = 0; i < contour.Length; i++)                              {                                  int j = i < contour.Length - 1 ? i + 1 : 0;                                  if (contour[i].X != contour[i].Y)                                  {                                      segments.Add(new Segment(contour[i].X' contour[i].Y' contour[j].X' contour[j].Y));                                      isForeSegment.Add(true);                                  }                              }                            for(int i = 0 ; i < segments.Count; i++)                          {                              double cX = segments[i].Center().X;                              double cY = segments[i].Center().Y;                                for (int j = 0; j < segments.Count; j++)                              {                                  if (i != j)                                  {                                       double v1x = segments[j].V1.X;                                      double v2x = segments[j].V2.X;                                      double v1y = segments[j].V1.Y;                                      double v2y = segments[j].V2.Y;                                        if(v1x > v2x)                                      {                                          double temp = v1x;                                          v1x = v2x;                                          v2x = temp;                                      }                                        if (v1x < cX && v2x >= cX)                                      {                                          double crossY = v1y + (cX - v1x) / (v2x - v1x) * (v2y - v1y);                                          if(crossY > cY)                                              isForeSegment[i] = !isForeSegment[i];                                      }                                  }                              }                          }                            for (int i = 0; i < segments.Count; i++)                          {                              if (isForeSegment[i])                                  g.FillPolygon(b' new PointF[]                                   {                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y - prismHeight)'                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y - prismHeight)                                  });                          }                      }                        // Fill the upper base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(200' Color.FromArgb(245' 245' 245))))                      {                          path.Transform(new Matrix(1' 0' 0' 1' 0' -prismHeight));                          g.FillPath(b' path);                      }                        // boundary of the upper base of the prism                      g.DrawPath(pen' path);                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPrismPolygon,The following statement contains a magic number: using (Pen pen = new Pen(Color.FromArgb(255' Color.White)))              {                  using (GraphicsPath path = new GraphicsPath(FillMode.Alternate))                  {                      path.StartFigure();                        float x = (float)((feature.Polygon.Contours[0].Vertices[0].X - viewBox.MinX) * scaleFactor);                      float y = (float)((viewBox.MaxY - feature.Polygon.Contours[0].Vertices[0].Y) * scaleFactor);                        g.RenderingOrigin = new Point((int)Math.Round(x)' (int)Math.Round(y));                        PointF[][] points = new PointF[feature.Polygon.Contours.Count][];                      int contourIndex = 0;                        foreach (Contour c in feature.Polygon.Contours)                      {                          points[contourIndex] = new PointF[c.Vertices.Count];                            for (int j = 0; j < c.Vertices.Count; j++)                          {                              points[contourIndex][j].X = (float)((c.Vertices[j].X - viewBox.MinX) * scaleFactor);                              points[contourIndex][j].Y = (float)((viewBox.MaxY - c.Vertices[j].Y) * scaleFactor);                          }                            if (points[contourIndex].Length > 2)                              path.AddPolygon(points[contourIndex]);                            contourIndex++;                      }                        path.CloseFigure();                        int prismHeight = 4; //(int)(scaleFactor / 10000.0);                        // boundary of the lower base of the prism                      g.DrawPath(pen' path);                        // Fill the lower base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(50' 225' 225' 225)))                      {                          g.FillPath(b' path);                      }                        // border vertical faces                      foreach (PointF[] contour in points)                          for (int i = 0; i < contour.Length; i++)                              g.DrawLine(pen' contour[i]' new PointF(contour[i].X' contour[i].Y - prismHeight));                        //Fill vertical faces                      using (Brush b = new SolidBrush(Color.FromArgb(50' 60' 60' 60)))                      {                          List<Segment> segments = new List<Segment>();                          List<bool> isForeSegment = new List<bool>();                            foreach (PointF[] contour in points)                              for (int i = 0; i < contour.Length; i++)                              {                                  int j = i < contour.Length - 1 ? i + 1 : 0;                                  if (contour[i].X != contour[i].Y)                                  {                                      segments.Add(new Segment(contour[i].X' contour[i].Y' contour[j].X' contour[j].Y));                                      isForeSegment.Add(true);                                  }                              }                            for(int i = 0 ; i < segments.Count; i++)                          {                              double cX = segments[i].Center().X;                              double cY = segments[i].Center().Y;                                for (int j = 0; j < segments.Count; j++)                              {                                  if (i != j)                                  {                                       double v1x = segments[j].V1.X;                                      double v2x = segments[j].V2.X;                                      double v1y = segments[j].V1.Y;                                      double v2y = segments[j].V2.Y;                                        if(v1x > v2x)                                      {                                          double temp = v1x;                                          v1x = v2x;                                          v2x = temp;                                      }                                        if (v1x < cX && v2x >= cX)                                      {                                          double crossY = v1y + (cX - v1x) / (v2x - v1x) * (v2y - v1y);                                          if(crossY > cY)                                              isForeSegment[i] = !isForeSegment[i];                                      }                                  }                              }                          }                            for (int i = 0; i < segments.Count; i++)                          {                              if (isForeSegment[i])                                  g.FillPolygon(b' new PointF[]                                   {                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y - prismHeight)'                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y - prismHeight)                                  });                          }                      }                        // Fill the upper base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(200' Color.FromArgb(245' 245' 245))))                      {                          path.Transform(new Matrix(1' 0' 0' 1' 0' -prismHeight));                          g.FillPath(b' path);                      }                        // boundary of the upper base of the prism                      g.DrawPath(pen' path);                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPrismPolygon,The following statement contains a magic number: using (Pen pen = new Pen(Color.FromArgb(255' Color.White)))              {                  using (GraphicsPath path = new GraphicsPath(FillMode.Alternate))                  {                      path.StartFigure();                        float x = (float)((feature.Polygon.Contours[0].Vertices[0].X - viewBox.MinX) * scaleFactor);                      float y = (float)((viewBox.MaxY - feature.Polygon.Contours[0].Vertices[0].Y) * scaleFactor);                        g.RenderingOrigin = new Point((int)Math.Round(x)' (int)Math.Round(y));                        PointF[][] points = new PointF[feature.Polygon.Contours.Count][];                      int contourIndex = 0;                        foreach (Contour c in feature.Polygon.Contours)                      {                          points[contourIndex] = new PointF[c.Vertices.Count];                            for (int j = 0; j < c.Vertices.Count; j++)                          {                              points[contourIndex][j].X = (float)((c.Vertices[j].X - viewBox.MinX) * scaleFactor);                              points[contourIndex][j].Y = (float)((viewBox.MaxY - c.Vertices[j].Y) * scaleFactor);                          }                            if (points[contourIndex].Length > 2)                              path.AddPolygon(points[contourIndex]);                            contourIndex++;                      }                        path.CloseFigure();                        int prismHeight = 4; //(int)(scaleFactor / 10000.0);                        // boundary of the lower base of the prism                      g.DrawPath(pen' path);                        // Fill the lower base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(50' 225' 225' 225)))                      {                          g.FillPath(b' path);                      }                        // border vertical faces                      foreach (PointF[] contour in points)                          for (int i = 0; i < contour.Length; i++)                              g.DrawLine(pen' contour[i]' new PointF(contour[i].X' contour[i].Y - prismHeight));                        //Fill vertical faces                      using (Brush b = new SolidBrush(Color.FromArgb(50' 60' 60' 60)))                      {                          List<Segment> segments = new List<Segment>();                          List<bool> isForeSegment = new List<bool>();                            foreach (PointF[] contour in points)                              for (int i = 0; i < contour.Length; i++)                              {                                  int j = i < contour.Length - 1 ? i + 1 : 0;                                  if (contour[i].X != contour[i].Y)                                  {                                      segments.Add(new Segment(contour[i].X' contour[i].Y' contour[j].X' contour[j].Y));                                      isForeSegment.Add(true);                                  }                              }                            for(int i = 0 ; i < segments.Count; i++)                          {                              double cX = segments[i].Center().X;                              double cY = segments[i].Center().Y;                                for (int j = 0; j < segments.Count; j++)                              {                                  if (i != j)                                  {                                       double v1x = segments[j].V1.X;                                      double v2x = segments[j].V2.X;                                      double v1y = segments[j].V1.Y;                                      double v2y = segments[j].V2.Y;                                        if(v1x > v2x)                                      {                                          double temp = v1x;                                          v1x = v2x;                                          v2x = temp;                                      }                                        if (v1x < cX && v2x >= cX)                                      {                                          double crossY = v1y + (cX - v1x) / (v2x - v1x) * (v2y - v1y);                                          if(crossY > cY)                                              isForeSegment[i] = !isForeSegment[i];                                      }                                  }                              }                          }                            for (int i = 0; i < segments.Count; i++)                          {                              if (isForeSegment[i])                                  g.FillPolygon(b' new PointF[]                                   {                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y - prismHeight)'                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y - prismHeight)                                  });                          }                      }                        // Fill the upper base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(200' Color.FromArgb(245' 245' 245))))                      {                          path.Transform(new Matrix(1' 0' 0' 1' 0' -prismHeight));                          g.FillPath(b' path);                      }                        // boundary of the upper base of the prism                      g.DrawPath(pen' path);                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPrismPolygon,The following statement contains a magic number: using (Pen pen = new Pen(Color.FromArgb(255' Color.White)))              {                  using (GraphicsPath path = new GraphicsPath(FillMode.Alternate))                  {                      path.StartFigure();                        float x = (float)((feature.Polygon.Contours[0].Vertices[0].X - viewBox.MinX) * scaleFactor);                      float y = (float)((viewBox.MaxY - feature.Polygon.Contours[0].Vertices[0].Y) * scaleFactor);                        g.RenderingOrigin = new Point((int)Math.Round(x)' (int)Math.Round(y));                        PointF[][] points = new PointF[feature.Polygon.Contours.Count][];                      int contourIndex = 0;                        foreach (Contour c in feature.Polygon.Contours)                      {                          points[contourIndex] = new PointF[c.Vertices.Count];                            for (int j = 0; j < c.Vertices.Count; j++)                          {                              points[contourIndex][j].X = (float)((c.Vertices[j].X - viewBox.MinX) * scaleFactor);                              points[contourIndex][j].Y = (float)((viewBox.MaxY - c.Vertices[j].Y) * scaleFactor);                          }                            if (points[contourIndex].Length > 2)                              path.AddPolygon(points[contourIndex]);                            contourIndex++;                      }                        path.CloseFigure();                        int prismHeight = 4; //(int)(scaleFactor / 10000.0);                        // boundary of the lower base of the prism                      g.DrawPath(pen' path);                        // Fill the lower base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(50' 225' 225' 225)))                      {                          g.FillPath(b' path);                      }                        // border vertical faces                      foreach (PointF[] contour in points)                          for (int i = 0; i < contour.Length; i++)                              g.DrawLine(pen' contour[i]' new PointF(contour[i].X' contour[i].Y - prismHeight));                        //Fill vertical faces                      using (Brush b = new SolidBrush(Color.FromArgb(50' 60' 60' 60)))                      {                          List<Segment> segments = new List<Segment>();                          List<bool> isForeSegment = new List<bool>();                            foreach (PointF[] contour in points)                              for (int i = 0; i < contour.Length; i++)                              {                                  int j = i < contour.Length - 1 ? i + 1 : 0;                                  if (contour[i].X != contour[i].Y)                                  {                                      segments.Add(new Segment(contour[i].X' contour[i].Y' contour[j].X' contour[j].Y));                                      isForeSegment.Add(true);                                  }                              }                            for(int i = 0 ; i < segments.Count; i++)                          {                              double cX = segments[i].Center().X;                              double cY = segments[i].Center().Y;                                for (int j = 0; j < segments.Count; j++)                              {                                  if (i != j)                                  {                                       double v1x = segments[j].V1.X;                                      double v2x = segments[j].V2.X;                                      double v1y = segments[j].V1.Y;                                      double v2y = segments[j].V2.Y;                                        if(v1x > v2x)                                      {                                          double temp = v1x;                                          v1x = v2x;                                          v2x = temp;                                      }                                        if (v1x < cX && v2x >= cX)                                      {                                          double crossY = v1y + (cX - v1x) / (v2x - v1x) * (v2y - v1y);                                          if(crossY > cY)                                              isForeSegment[i] = !isForeSegment[i];                                      }                                  }                              }                          }                            for (int i = 0; i < segments.Count; i++)                          {                              if (isForeSegment[i])                                  g.FillPolygon(b' new PointF[]                                   {                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y - prismHeight)'                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y - prismHeight)                                  });                          }                      }                        // Fill the upper base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(200' Color.FromArgb(245' 245' 245))))                      {                          path.Transform(new Matrix(1' 0' 0' 1' 0' -prismHeight));                          g.FillPath(b' path);                      }                        // boundary of the upper base of the prism                      g.DrawPath(pen' path);                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPrismPolygon,The following statement contains a magic number: using (Pen pen = new Pen(Color.FromArgb(255' Color.White)))              {                  using (GraphicsPath path = new GraphicsPath(FillMode.Alternate))                  {                      path.StartFigure();                        float x = (float)((feature.Polygon.Contours[0].Vertices[0].X - viewBox.MinX) * scaleFactor);                      float y = (float)((viewBox.MaxY - feature.Polygon.Contours[0].Vertices[0].Y) * scaleFactor);                        g.RenderingOrigin = new Point((int)Math.Round(x)' (int)Math.Round(y));                        PointF[][] points = new PointF[feature.Polygon.Contours.Count][];                      int contourIndex = 0;                        foreach (Contour c in feature.Polygon.Contours)                      {                          points[contourIndex] = new PointF[c.Vertices.Count];                            for (int j = 0; j < c.Vertices.Count; j++)                          {                              points[contourIndex][j].X = (float)((c.Vertices[j].X - viewBox.MinX) * scaleFactor);                              points[contourIndex][j].Y = (float)((viewBox.MaxY - c.Vertices[j].Y) * scaleFactor);                          }                            if (points[contourIndex].Length > 2)                              path.AddPolygon(points[contourIndex]);                            contourIndex++;                      }                        path.CloseFigure();                        int prismHeight = 4; //(int)(scaleFactor / 10000.0);                        // boundary of the lower base of the prism                      g.DrawPath(pen' path);                        // Fill the lower base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(50' 225' 225' 225)))                      {                          g.FillPath(b' path);                      }                        // border vertical faces                      foreach (PointF[] contour in points)                          for (int i = 0; i < contour.Length; i++)                              g.DrawLine(pen' contour[i]' new PointF(contour[i].X' contour[i].Y - prismHeight));                        //Fill vertical faces                      using (Brush b = new SolidBrush(Color.FromArgb(50' 60' 60' 60)))                      {                          List<Segment> segments = new List<Segment>();                          List<bool> isForeSegment = new List<bool>();                            foreach (PointF[] contour in points)                              for (int i = 0; i < contour.Length; i++)                              {                                  int j = i < contour.Length - 1 ? i + 1 : 0;                                  if (contour[i].X != contour[i].Y)                                  {                                      segments.Add(new Segment(contour[i].X' contour[i].Y' contour[j].X' contour[j].Y));                                      isForeSegment.Add(true);                                  }                              }                            for(int i = 0 ; i < segments.Count; i++)                          {                              double cX = segments[i].Center().X;                              double cY = segments[i].Center().Y;                                for (int j = 0; j < segments.Count; j++)                              {                                  if (i != j)                                  {                                       double v1x = segments[j].V1.X;                                      double v2x = segments[j].V2.X;                                      double v1y = segments[j].V1.Y;                                      double v2y = segments[j].V2.Y;                                        if(v1x > v2x)                                      {                                          double temp = v1x;                                          v1x = v2x;                                          v2x = temp;                                      }                                        if (v1x < cX && v2x >= cX)                                      {                                          double crossY = v1y + (cX - v1x) / (v2x - v1x) * (v2y - v1y);                                          if(crossY > cY)                                              isForeSegment[i] = !isForeSegment[i];                                      }                                  }                              }                          }                            for (int i = 0; i < segments.Count; i++)                          {                              if (isForeSegment[i])                                  g.FillPolygon(b' new PointF[]                                   {                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y - prismHeight)'                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y - prismHeight)                                  });                          }                      }                        // Fill the upper base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(200' Color.FromArgb(245' 245' 245))))                      {                          path.Transform(new Matrix(1' 0' 0' 1' 0' -prismHeight));                          g.FillPath(b' path);                      }                        // boundary of the upper base of the prism                      g.DrawPath(pen' path);                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPrismPolygon,The following statement contains a magic number: using (Pen pen = new Pen(Color.FromArgb(255' Color.White)))              {                  using (GraphicsPath path = new GraphicsPath(FillMode.Alternate))                  {                      path.StartFigure();                        float x = (float)((feature.Polygon.Contours[0].Vertices[0].X - viewBox.MinX) * scaleFactor);                      float y = (float)((viewBox.MaxY - feature.Polygon.Contours[0].Vertices[0].Y) * scaleFactor);                        g.RenderingOrigin = new Point((int)Math.Round(x)' (int)Math.Round(y));                        PointF[][] points = new PointF[feature.Polygon.Contours.Count][];                      int contourIndex = 0;                        foreach (Contour c in feature.Polygon.Contours)                      {                          points[contourIndex] = new PointF[c.Vertices.Count];                            for (int j = 0; j < c.Vertices.Count; j++)                          {                              points[contourIndex][j].X = (float)((c.Vertices[j].X - viewBox.MinX) * scaleFactor);                              points[contourIndex][j].Y = (float)((viewBox.MaxY - c.Vertices[j].Y) * scaleFactor);                          }                            if (points[contourIndex].Length > 2)                              path.AddPolygon(points[contourIndex]);                            contourIndex++;                      }                        path.CloseFigure();                        int prismHeight = 4; //(int)(scaleFactor / 10000.0);                        // boundary of the lower base of the prism                      g.DrawPath(pen' path);                        // Fill the lower base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(50' 225' 225' 225)))                      {                          g.FillPath(b' path);                      }                        // border vertical faces                      foreach (PointF[] contour in points)                          for (int i = 0; i < contour.Length; i++)                              g.DrawLine(pen' contour[i]' new PointF(contour[i].X' contour[i].Y - prismHeight));                        //Fill vertical faces                      using (Brush b = new SolidBrush(Color.FromArgb(50' 60' 60' 60)))                      {                          List<Segment> segments = new List<Segment>();                          List<bool> isForeSegment = new List<bool>();                            foreach (PointF[] contour in points)                              for (int i = 0; i < contour.Length; i++)                              {                                  int j = i < contour.Length - 1 ? i + 1 : 0;                                  if (contour[i].X != contour[i].Y)                                  {                                      segments.Add(new Segment(contour[i].X' contour[i].Y' contour[j].X' contour[j].Y));                                      isForeSegment.Add(true);                                  }                              }                            for(int i = 0 ; i < segments.Count; i++)                          {                              double cX = segments[i].Center().X;                              double cY = segments[i].Center().Y;                                for (int j = 0; j < segments.Count; j++)                              {                                  if (i != j)                                  {                                       double v1x = segments[j].V1.X;                                      double v2x = segments[j].V2.X;                                      double v1y = segments[j].V1.Y;                                      double v2y = segments[j].V2.Y;                                        if(v1x > v2x)                                      {                                          double temp = v1x;                                          v1x = v2x;                                          v2x = temp;                                      }                                        if (v1x < cX && v2x >= cX)                                      {                                          double crossY = v1y + (cX - v1x) / (v2x - v1x) * (v2y - v1y);                                          if(crossY > cY)                                              isForeSegment[i] = !isForeSegment[i];                                      }                                  }                              }                          }                            for (int i = 0; i < segments.Count; i++)                          {                              if (isForeSegment[i])                                  g.FillPolygon(b' new PointF[]                                   {                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y - prismHeight)'                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y - prismHeight)                                  });                          }                      }                        // Fill the upper base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(200' Color.FromArgb(245' 245' 245))))                      {                          path.Transform(new Matrix(1' 0' 0' 1' 0' -prismHeight));                          g.FillPath(b' path);                      }                        // boundary of the upper base of the prism                      g.DrawPath(pen' path);                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPrismPolygon,The following statement contains a magic number: using (Pen pen = new Pen(Color.FromArgb(255' Color.White)))              {                  using (GraphicsPath path = new GraphicsPath(FillMode.Alternate))                  {                      path.StartFigure();                        float x = (float)((feature.Polygon.Contours[0].Vertices[0].X - viewBox.MinX) * scaleFactor);                      float y = (float)((viewBox.MaxY - feature.Polygon.Contours[0].Vertices[0].Y) * scaleFactor);                        g.RenderingOrigin = new Point((int)Math.Round(x)' (int)Math.Round(y));                        PointF[][] points = new PointF[feature.Polygon.Contours.Count][];                      int contourIndex = 0;                        foreach (Contour c in feature.Polygon.Contours)                      {                          points[contourIndex] = new PointF[c.Vertices.Count];                            for (int j = 0; j < c.Vertices.Count; j++)                          {                              points[contourIndex][j].X = (float)((c.Vertices[j].X - viewBox.MinX) * scaleFactor);                              points[contourIndex][j].Y = (float)((viewBox.MaxY - c.Vertices[j].Y) * scaleFactor);                          }                            if (points[contourIndex].Length > 2)                              path.AddPolygon(points[contourIndex]);                            contourIndex++;                      }                        path.CloseFigure();                        int prismHeight = 4; //(int)(scaleFactor / 10000.0);                        // boundary of the lower base of the prism                      g.DrawPath(pen' path);                        // Fill the lower base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(50' 225' 225' 225)))                      {                          g.FillPath(b' path);                      }                        // border vertical faces                      foreach (PointF[] contour in points)                          for (int i = 0; i < contour.Length; i++)                              g.DrawLine(pen' contour[i]' new PointF(contour[i].X' contour[i].Y - prismHeight));                        //Fill vertical faces                      using (Brush b = new SolidBrush(Color.FromArgb(50' 60' 60' 60)))                      {                          List<Segment> segments = new List<Segment>();                          List<bool> isForeSegment = new List<bool>();                            foreach (PointF[] contour in points)                              for (int i = 0; i < contour.Length; i++)                              {                                  int j = i < contour.Length - 1 ? i + 1 : 0;                                  if (contour[i].X != contour[i].Y)                                  {                                      segments.Add(new Segment(contour[i].X' contour[i].Y' contour[j].X' contour[j].Y));                                      isForeSegment.Add(true);                                  }                              }                            for(int i = 0 ; i < segments.Count; i++)                          {                              double cX = segments[i].Center().X;                              double cY = segments[i].Center().Y;                                for (int j = 0; j < segments.Count; j++)                              {                                  if (i != j)                                  {                                       double v1x = segments[j].V1.X;                                      double v2x = segments[j].V2.X;                                      double v1y = segments[j].V1.Y;                                      double v2y = segments[j].V2.Y;                                        if(v1x > v2x)                                      {                                          double temp = v1x;                                          v1x = v2x;                                          v2x = temp;                                      }                                        if (v1x < cX && v2x >= cX)                                      {                                          double crossY = v1y + (cX - v1x) / (v2x - v1x) * (v2y - v1y);                                          if(crossY > cY)                                              isForeSegment[i] = !isForeSegment[i];                                      }                                  }                              }                          }                            for (int i = 0; i < segments.Count; i++)                          {                              if (isForeSegment[i])                                  g.FillPolygon(b' new PointF[]                                   {                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y - prismHeight)'                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y - prismHeight)                                  });                          }                      }                        // Fill the upper base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(200' Color.FromArgb(245' 245' 245))))                      {                          path.Transform(new Matrix(1' 0' 0' 1' 0' -prismHeight));                          g.FillPath(b' path);                      }                        // boundary of the upper base of the prism                      g.DrawPath(pen' path);                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPrismPolygon,The following statement contains a magic number: using (Pen pen = new Pen(Color.FromArgb(255' Color.White)))              {                  using (GraphicsPath path = new GraphicsPath(FillMode.Alternate))                  {                      path.StartFigure();                        float x = (float)((feature.Polygon.Contours[0].Vertices[0].X - viewBox.MinX) * scaleFactor);                      float y = (float)((viewBox.MaxY - feature.Polygon.Contours[0].Vertices[0].Y) * scaleFactor);                        g.RenderingOrigin = new Point((int)Math.Round(x)' (int)Math.Round(y));                        PointF[][] points = new PointF[feature.Polygon.Contours.Count][];                      int contourIndex = 0;                        foreach (Contour c in feature.Polygon.Contours)                      {                          points[contourIndex] = new PointF[c.Vertices.Count];                            for (int j = 0; j < c.Vertices.Count; j++)                          {                              points[contourIndex][j].X = (float)((c.Vertices[j].X - viewBox.MinX) * scaleFactor);                              points[contourIndex][j].Y = (float)((viewBox.MaxY - c.Vertices[j].Y) * scaleFactor);                          }                            if (points[contourIndex].Length > 2)                              path.AddPolygon(points[contourIndex]);                            contourIndex++;                      }                        path.CloseFigure();                        int prismHeight = 4; //(int)(scaleFactor / 10000.0);                        // boundary of the lower base of the prism                      g.DrawPath(pen' path);                        // Fill the lower base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(50' 225' 225' 225)))                      {                          g.FillPath(b' path);                      }                        // border vertical faces                      foreach (PointF[] contour in points)                          for (int i = 0; i < contour.Length; i++)                              g.DrawLine(pen' contour[i]' new PointF(contour[i].X' contour[i].Y - prismHeight));                        //Fill vertical faces                      using (Brush b = new SolidBrush(Color.FromArgb(50' 60' 60' 60)))                      {                          List<Segment> segments = new List<Segment>();                          List<bool> isForeSegment = new List<bool>();                            foreach (PointF[] contour in points)                              for (int i = 0; i < contour.Length; i++)                              {                                  int j = i < contour.Length - 1 ? i + 1 : 0;                                  if (contour[i].X != contour[i].Y)                                  {                                      segments.Add(new Segment(contour[i].X' contour[i].Y' contour[j].X' contour[j].Y));                                      isForeSegment.Add(true);                                  }                              }                            for(int i = 0 ; i < segments.Count; i++)                          {                              double cX = segments[i].Center().X;                              double cY = segments[i].Center().Y;                                for (int j = 0; j < segments.Count; j++)                              {                                  if (i != j)                                  {                                       double v1x = segments[j].V1.X;                                      double v2x = segments[j].V2.X;                                      double v1y = segments[j].V1.Y;                                      double v2y = segments[j].V2.Y;                                        if(v1x > v2x)                                      {                                          double temp = v1x;                                          v1x = v2x;                                          v2x = temp;                                      }                                        if (v1x < cX && v2x >= cX)                                      {                                          double crossY = v1y + (cX - v1x) / (v2x - v1x) * (v2y - v1y);                                          if(crossY > cY)                                              isForeSegment[i] = !isForeSegment[i];                                      }                                  }                              }                          }                            for (int i = 0; i < segments.Count; i++)                          {                              if (isForeSegment[i])                                  g.FillPolygon(b' new PointF[]                                   {                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y)'                                      new PointF((float)segments[i].V2.X' (float)segments[i].V2.Y - prismHeight)'                                      new PointF((float)segments[i].V1.X' (float)segments[i].V1.Y - prismHeight)                                  });                          }                      }                        // Fill the upper base of the prism                      using (Brush b = new SolidBrush(Color.FromArgb(200' Color.FromArgb(245' 245' 245))))                      {                          path.Transform(new Matrix(1' 0' 0' 1' 0' -prismHeight));                          g.FillPath(b' path);                      }                        // boundary of the upper base of the prism                      g.DrawPath(pen' path);                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: using (Font f = new Font(_fontName' style.Size' FontStyle.Regular' GraphicsUnit.Pixel))              {                  using (SolidBrush fontBrush = new SolidBrush(style.Color))                  {                      SizeF size;                      SizeF offset;                      if (style.DisplayKind == PointDisplayKind.Symbol)                          // character size                          size = g.MeasureString(style.Symbol.ToString()' f' new PointF(0' 0)' _symbolStringFormat);                      else                      {                          // image size                          if (style.Image != null)                              size = new SizeF(style.Image.Width' style.Image.Height);                          else                              size = new SizeF(1' 1);                      }                      //Offset relative to the center point                      offset = new SizeF(size.Width/2'size.Height/2);                        switch (style.ContentAlignment)                      {                          case ContentAlignment.TopLeft: offset = new SizeF(0' 0); break;                          case ContentAlignment.TopCenter: offset = new SizeF(size.Width / 2'0); break;                          case ContentAlignment.TopRight: offset = new SizeF(size.Width' 0); break;                                case ContentAlignment.BottomLeft: offset = new SizeF(0' size.Height ); break;                          case ContentAlignment.BottomCenter: offset = new SizeF(size.Width / 2' size.Height); break;                          case ContentAlignment.BottomRight: offset = new SizeF(size.Width' size.Height); break;                                case ContentAlignment.MiddleLeft: offset = new SizeF(0' size.Height / 2); break;                          case ContentAlignment.MiddleCenter: offset = new SizeF(size.Width / 2' size.Height / 2); break;                          case ContentAlignment.MiddleRight: offset = new SizeF(size.Width' size.Height / 2); break;                                default:                              throw new NotSupportedException();                        }                      IEnumerable<ICoordinate> targetPoints = null;                      if (feature.FeatureType == FeatureType.Point)                          targetPoints = new ICoordinate[] {feature.Point.Coordinate};                      else                          targetPoints = feature.MultiPoint.Points;                        foreach (ICoordinate targetPoint in targetPoints)                      {                          if (style.DisplayKind == PointDisplayKind.Symbol)                          {                              // symbol                              using (GraphicsPath path = new GraphicsPath())                              {                                  path.AddString(style.Symbol.ToString()'                                                 f.FontFamily'                                                 (int) f.Style'                                                 f.Size'                                                 new PointF((float) ((targetPoint.X - viewBox.MinX)*scaleFactor-offset.Width)'                                                            (float)                                                            ((viewBox.MaxY - targetPoint.Y)*scaleFactor -offset.Height))'                                                 _symbolStringFormat);                                    g.FillPath(fontBrush' path);                              }                          }                          else                          {                              // image                              if (style.Image != null)                                  g.DrawImageUnscaled(style.Image'                                                      new Point(                                                          (int)                                                          Math.Round(((targetPoint.X - viewBox.MinX)*scaleFactor -                                                                      offset.Width))'                                                          (int)                                                          Math.Round(((viewBox.MaxY - targetPoint.Y)*scaleFactor -                                                                      offset.Height))));                          }                            if (feature.Selected)                          {                              // Frame selected object                              using (Pen p = new Pen(_selectionColor' 2))                                  g.DrawRectangle(p'                                                  (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width + 1)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height + 1)'                                                  size.Width - 2' size.Height - 2);                                using (Brush b = new SolidBrush(Color.FromArgb(50' _selectionColor)))                                  g.FillRectangle(b' (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height)'                                                  size.Width' size.Height);                          }                      }                        // inscription                      if (!string.IsNullOrEmpty(feature.Title) && titleVisible)                      {                          if (feature.FeatureType == FeatureType.Point)                          {                              //Location signs point object can not be determined only by coordinates'                              //without knowing the size of the image of a point object.                               //Therefore' the ordinate of a point object is displaced by half the size of the symbol.                              Feature shp = new Feature(FeatureType.Point);                              shp.Point = new PointD(feature.Point.X' feature.Point.Y + size.Height/2/scaleFactor);                              shp.Title = feature.Title;                              addTitleBufferElement(g' shp' titleStyle' viewBox' scaleFactor);                          }                          if (feature.FeatureType == FeatureType.MultiPoint)                              addTitleBufferElement(g' feature' titleStyle' viewBox' scaleFactor);                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: using (Font f = new Font(_fontName' style.Size' FontStyle.Regular' GraphicsUnit.Pixel))              {                  using (SolidBrush fontBrush = new SolidBrush(style.Color))                  {                      SizeF size;                      SizeF offset;                      if (style.DisplayKind == PointDisplayKind.Symbol)                          // character size                          size = g.MeasureString(style.Symbol.ToString()' f' new PointF(0' 0)' _symbolStringFormat);                      else                      {                          // image size                          if (style.Image != null)                              size = new SizeF(style.Image.Width' style.Image.Height);                          else                              size = new SizeF(1' 1);                      }                      //Offset relative to the center point                      offset = new SizeF(size.Width/2'size.Height/2);                        switch (style.ContentAlignment)                      {                          case ContentAlignment.TopLeft: offset = new SizeF(0' 0); break;                          case ContentAlignment.TopCenter: offset = new SizeF(size.Width / 2'0); break;                          case ContentAlignment.TopRight: offset = new SizeF(size.Width' 0); break;                                case ContentAlignment.BottomLeft: offset = new SizeF(0' size.Height ); break;                          case ContentAlignment.BottomCenter: offset = new SizeF(size.Width / 2' size.Height); break;                          case ContentAlignment.BottomRight: offset = new SizeF(size.Width' size.Height); break;                                case ContentAlignment.MiddleLeft: offset = new SizeF(0' size.Height / 2); break;                          case ContentAlignment.MiddleCenter: offset = new SizeF(size.Width / 2' size.Height / 2); break;                          case ContentAlignment.MiddleRight: offset = new SizeF(size.Width' size.Height / 2); break;                                default:                              throw new NotSupportedException();                        }                      IEnumerable<ICoordinate> targetPoints = null;                      if (feature.FeatureType == FeatureType.Point)                          targetPoints = new ICoordinate[] {feature.Point.Coordinate};                      else                          targetPoints = feature.MultiPoint.Points;                        foreach (ICoordinate targetPoint in targetPoints)                      {                          if (style.DisplayKind == PointDisplayKind.Symbol)                          {                              // symbol                              using (GraphicsPath path = new GraphicsPath())                              {                                  path.AddString(style.Symbol.ToString()'                                                 f.FontFamily'                                                 (int) f.Style'                                                 f.Size'                                                 new PointF((float) ((targetPoint.X - viewBox.MinX)*scaleFactor-offset.Width)'                                                            (float)                                                            ((viewBox.MaxY - targetPoint.Y)*scaleFactor -offset.Height))'                                                 _symbolStringFormat);                                    g.FillPath(fontBrush' path);                              }                          }                          else                          {                              // image                              if (style.Image != null)                                  g.DrawImageUnscaled(style.Image'                                                      new Point(                                                          (int)                                                          Math.Round(((targetPoint.X - viewBox.MinX)*scaleFactor -                                                                      offset.Width))'                                                          (int)                                                          Math.Round(((viewBox.MaxY - targetPoint.Y)*scaleFactor -                                                                      offset.Height))));                          }                            if (feature.Selected)                          {                              // Frame selected object                              using (Pen p = new Pen(_selectionColor' 2))                                  g.DrawRectangle(p'                                                  (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width + 1)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height + 1)'                                                  size.Width - 2' size.Height - 2);                                using (Brush b = new SolidBrush(Color.FromArgb(50' _selectionColor)))                                  g.FillRectangle(b' (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height)'                                                  size.Width' size.Height);                          }                      }                        // inscription                      if (!string.IsNullOrEmpty(feature.Title) && titleVisible)                      {                          if (feature.FeatureType == FeatureType.Point)                          {                              //Location signs point object can not be determined only by coordinates'                              //without knowing the size of the image of a point object.                               //Therefore' the ordinate of a point object is displaced by half the size of the symbol.                              Feature shp = new Feature(FeatureType.Point);                              shp.Point = new PointD(feature.Point.X' feature.Point.Y + size.Height/2/scaleFactor);                              shp.Title = feature.Title;                              addTitleBufferElement(g' shp' titleStyle' viewBox' scaleFactor);                          }                          if (feature.FeatureType == FeatureType.MultiPoint)                              addTitleBufferElement(g' feature' titleStyle' viewBox' scaleFactor);                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: using (Font f = new Font(_fontName' style.Size' FontStyle.Regular' GraphicsUnit.Pixel))              {                  using (SolidBrush fontBrush = new SolidBrush(style.Color))                  {                      SizeF size;                      SizeF offset;                      if (style.DisplayKind == PointDisplayKind.Symbol)                          // character size                          size = g.MeasureString(style.Symbol.ToString()' f' new PointF(0' 0)' _symbolStringFormat);                      else                      {                          // image size                          if (style.Image != null)                              size = new SizeF(style.Image.Width' style.Image.Height);                          else                              size = new SizeF(1' 1);                      }                      //Offset relative to the center point                      offset = new SizeF(size.Width/2'size.Height/2);                        switch (style.ContentAlignment)                      {                          case ContentAlignment.TopLeft: offset = new SizeF(0' 0); break;                          case ContentAlignment.TopCenter: offset = new SizeF(size.Width / 2'0); break;                          case ContentAlignment.TopRight: offset = new SizeF(size.Width' 0); break;                                case ContentAlignment.BottomLeft: offset = new SizeF(0' size.Height ); break;                          case ContentAlignment.BottomCenter: offset = new SizeF(size.Width / 2' size.Height); break;                          case ContentAlignment.BottomRight: offset = new SizeF(size.Width' size.Height); break;                                case ContentAlignment.MiddleLeft: offset = new SizeF(0' size.Height / 2); break;                          case ContentAlignment.MiddleCenter: offset = new SizeF(size.Width / 2' size.Height / 2); break;                          case ContentAlignment.MiddleRight: offset = new SizeF(size.Width' size.Height / 2); break;                                default:                              throw new NotSupportedException();                        }                      IEnumerable<ICoordinate> targetPoints = null;                      if (feature.FeatureType == FeatureType.Point)                          targetPoints = new ICoordinate[] {feature.Point.Coordinate};                      else                          targetPoints = feature.MultiPoint.Points;                        foreach (ICoordinate targetPoint in targetPoints)                      {                          if (style.DisplayKind == PointDisplayKind.Symbol)                          {                              // symbol                              using (GraphicsPath path = new GraphicsPath())                              {                                  path.AddString(style.Symbol.ToString()'                                                 f.FontFamily'                                                 (int) f.Style'                                                 f.Size'                                                 new PointF((float) ((targetPoint.X - viewBox.MinX)*scaleFactor-offset.Width)'                                                            (float)                                                            ((viewBox.MaxY - targetPoint.Y)*scaleFactor -offset.Height))'                                                 _symbolStringFormat);                                    g.FillPath(fontBrush' path);                              }                          }                          else                          {                              // image                              if (style.Image != null)                                  g.DrawImageUnscaled(style.Image'                                                      new Point(                                                          (int)                                                          Math.Round(((targetPoint.X - viewBox.MinX)*scaleFactor -                                                                      offset.Width))'                                                          (int)                                                          Math.Round(((viewBox.MaxY - targetPoint.Y)*scaleFactor -                                                                      offset.Height))));                          }                            if (feature.Selected)                          {                              // Frame selected object                              using (Pen p = new Pen(_selectionColor' 2))                                  g.DrawRectangle(p'                                                  (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width + 1)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height + 1)'                                                  size.Width - 2' size.Height - 2);                                using (Brush b = new SolidBrush(Color.FromArgb(50' _selectionColor)))                                  g.FillRectangle(b' (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height)'                                                  size.Width' size.Height);                          }                      }                        // inscription                      if (!string.IsNullOrEmpty(feature.Title) && titleVisible)                      {                          if (feature.FeatureType == FeatureType.Point)                          {                              //Location signs point object can not be determined only by coordinates'                              //without knowing the size of the image of a point object.                               //Therefore' the ordinate of a point object is displaced by half the size of the symbol.                              Feature shp = new Feature(FeatureType.Point);                              shp.Point = new PointD(feature.Point.X' feature.Point.Y + size.Height/2/scaleFactor);                              shp.Title = feature.Title;                              addTitleBufferElement(g' shp' titleStyle' viewBox' scaleFactor);                          }                          if (feature.FeatureType == FeatureType.MultiPoint)                              addTitleBufferElement(g' feature' titleStyle' viewBox' scaleFactor);                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: using (Font f = new Font(_fontName' style.Size' FontStyle.Regular' GraphicsUnit.Pixel))              {                  using (SolidBrush fontBrush = new SolidBrush(style.Color))                  {                      SizeF size;                      SizeF offset;                      if (style.DisplayKind == PointDisplayKind.Symbol)                          // character size                          size = g.MeasureString(style.Symbol.ToString()' f' new PointF(0' 0)' _symbolStringFormat);                      else                      {                          // image size                          if (style.Image != null)                              size = new SizeF(style.Image.Width' style.Image.Height);                          else                              size = new SizeF(1' 1);                      }                      //Offset relative to the center point                      offset = new SizeF(size.Width/2'size.Height/2);                        switch (style.ContentAlignment)                      {                          case ContentAlignment.TopLeft: offset = new SizeF(0' 0); break;                          case ContentAlignment.TopCenter: offset = new SizeF(size.Width / 2'0); break;                          case ContentAlignment.TopRight: offset = new SizeF(size.Width' 0); break;                                case ContentAlignment.BottomLeft: offset = new SizeF(0' size.Height ); break;                          case ContentAlignment.BottomCenter: offset = new SizeF(size.Width / 2' size.Height); break;                          case ContentAlignment.BottomRight: offset = new SizeF(size.Width' size.Height); break;                                case ContentAlignment.MiddleLeft: offset = new SizeF(0' size.Height / 2); break;                          case ContentAlignment.MiddleCenter: offset = new SizeF(size.Width / 2' size.Height / 2); break;                          case ContentAlignment.MiddleRight: offset = new SizeF(size.Width' size.Height / 2); break;                                default:                              throw new NotSupportedException();                        }                      IEnumerable<ICoordinate> targetPoints = null;                      if (feature.FeatureType == FeatureType.Point)                          targetPoints = new ICoordinate[] {feature.Point.Coordinate};                      else                          targetPoints = feature.MultiPoint.Points;                        foreach (ICoordinate targetPoint in targetPoints)                      {                          if (style.DisplayKind == PointDisplayKind.Symbol)                          {                              // symbol                              using (GraphicsPath path = new GraphicsPath())                              {                                  path.AddString(style.Symbol.ToString()'                                                 f.FontFamily'                                                 (int) f.Style'                                                 f.Size'                                                 new PointF((float) ((targetPoint.X - viewBox.MinX)*scaleFactor-offset.Width)'                                                            (float)                                                            ((viewBox.MaxY - targetPoint.Y)*scaleFactor -offset.Height))'                                                 _symbolStringFormat);                                    g.FillPath(fontBrush' path);                              }                          }                          else                          {                              // image                              if (style.Image != null)                                  g.DrawImageUnscaled(style.Image'                                                      new Point(                                                          (int)                                                          Math.Round(((targetPoint.X - viewBox.MinX)*scaleFactor -                                                                      offset.Width))'                                                          (int)                                                          Math.Round(((viewBox.MaxY - targetPoint.Y)*scaleFactor -                                                                      offset.Height))));                          }                            if (feature.Selected)                          {                              // Frame selected object                              using (Pen p = new Pen(_selectionColor' 2))                                  g.DrawRectangle(p'                                                  (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width + 1)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height + 1)'                                                  size.Width - 2' size.Height - 2);                                using (Brush b = new SolidBrush(Color.FromArgb(50' _selectionColor)))                                  g.FillRectangle(b' (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height)'                                                  size.Width' size.Height);                          }                      }                        // inscription                      if (!string.IsNullOrEmpty(feature.Title) && titleVisible)                      {                          if (feature.FeatureType == FeatureType.Point)                          {                              //Location signs point object can not be determined only by coordinates'                              //without knowing the size of the image of a point object.                               //Therefore' the ordinate of a point object is displaced by half the size of the symbol.                              Feature shp = new Feature(FeatureType.Point);                              shp.Point = new PointD(feature.Point.X' feature.Point.Y + size.Height/2/scaleFactor);                              shp.Title = feature.Title;                              addTitleBufferElement(g' shp' titleStyle' viewBox' scaleFactor);                          }                          if (feature.FeatureType == FeatureType.MultiPoint)                              addTitleBufferElement(g' feature' titleStyle' viewBox' scaleFactor);                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: using (Font f = new Font(_fontName' style.Size' FontStyle.Regular' GraphicsUnit.Pixel))              {                  using (SolidBrush fontBrush = new SolidBrush(style.Color))                  {                      SizeF size;                      SizeF offset;                      if (style.DisplayKind == PointDisplayKind.Symbol)                          // character size                          size = g.MeasureString(style.Symbol.ToString()' f' new PointF(0' 0)' _symbolStringFormat);                      else                      {                          // image size                          if (style.Image != null)                              size = new SizeF(style.Image.Width' style.Image.Height);                          else                              size = new SizeF(1' 1);                      }                      //Offset relative to the center point                      offset = new SizeF(size.Width/2'size.Height/2);                        switch (style.ContentAlignment)                      {                          case ContentAlignment.TopLeft: offset = new SizeF(0' 0); break;                          case ContentAlignment.TopCenter: offset = new SizeF(size.Width / 2'0); break;                          case ContentAlignment.TopRight: offset = new SizeF(size.Width' 0); break;                                case ContentAlignment.BottomLeft: offset = new SizeF(0' size.Height ); break;                          case ContentAlignment.BottomCenter: offset = new SizeF(size.Width / 2' size.Height); break;                          case ContentAlignment.BottomRight: offset = new SizeF(size.Width' size.Height); break;                                case ContentAlignment.MiddleLeft: offset = new SizeF(0' size.Height / 2); break;                          case ContentAlignment.MiddleCenter: offset = new SizeF(size.Width / 2' size.Height / 2); break;                          case ContentAlignment.MiddleRight: offset = new SizeF(size.Width' size.Height / 2); break;                                default:                              throw new NotSupportedException();                        }                      IEnumerable<ICoordinate> targetPoints = null;                      if (feature.FeatureType == FeatureType.Point)                          targetPoints = new ICoordinate[] {feature.Point.Coordinate};                      else                          targetPoints = feature.MultiPoint.Points;                        foreach (ICoordinate targetPoint in targetPoints)                      {                          if (style.DisplayKind == PointDisplayKind.Symbol)                          {                              // symbol                              using (GraphicsPath path = new GraphicsPath())                              {                                  path.AddString(style.Symbol.ToString()'                                                 f.FontFamily'                                                 (int) f.Style'                                                 f.Size'                                                 new PointF((float) ((targetPoint.X - viewBox.MinX)*scaleFactor-offset.Width)'                                                            (float)                                                            ((viewBox.MaxY - targetPoint.Y)*scaleFactor -offset.Height))'                                                 _symbolStringFormat);                                    g.FillPath(fontBrush' path);                              }                          }                          else                          {                              // image                              if (style.Image != null)                                  g.DrawImageUnscaled(style.Image'                                                      new Point(                                                          (int)                                                          Math.Round(((targetPoint.X - viewBox.MinX)*scaleFactor -                                                                      offset.Width))'                                                          (int)                                                          Math.Round(((viewBox.MaxY - targetPoint.Y)*scaleFactor -                                                                      offset.Height))));                          }                            if (feature.Selected)                          {                              // Frame selected object                              using (Pen p = new Pen(_selectionColor' 2))                                  g.DrawRectangle(p'                                                  (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width + 1)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height + 1)'                                                  size.Width - 2' size.Height - 2);                                using (Brush b = new SolidBrush(Color.FromArgb(50' _selectionColor)))                                  g.FillRectangle(b' (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height)'                                                  size.Width' size.Height);                          }                      }                        // inscription                      if (!string.IsNullOrEmpty(feature.Title) && titleVisible)                      {                          if (feature.FeatureType == FeatureType.Point)                          {                              //Location signs point object can not be determined only by coordinates'                              //without knowing the size of the image of a point object.                               //Therefore' the ordinate of a point object is displaced by half the size of the symbol.                              Feature shp = new Feature(FeatureType.Point);                              shp.Point = new PointD(feature.Point.X' feature.Point.Y + size.Height/2/scaleFactor);                              shp.Title = feature.Title;                              addTitleBufferElement(g' shp' titleStyle' viewBox' scaleFactor);                          }                          if (feature.FeatureType == FeatureType.MultiPoint)                              addTitleBufferElement(g' feature' titleStyle' viewBox' scaleFactor);                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: using (Font f = new Font(_fontName' style.Size' FontStyle.Regular' GraphicsUnit.Pixel))              {                  using (SolidBrush fontBrush = new SolidBrush(style.Color))                  {                      SizeF size;                      SizeF offset;                      if (style.DisplayKind == PointDisplayKind.Symbol)                          // character size                          size = g.MeasureString(style.Symbol.ToString()' f' new PointF(0' 0)' _symbolStringFormat);                      else                      {                          // image size                          if (style.Image != null)                              size = new SizeF(style.Image.Width' style.Image.Height);                          else                              size = new SizeF(1' 1);                      }                      //Offset relative to the center point                      offset = new SizeF(size.Width/2'size.Height/2);                        switch (style.ContentAlignment)                      {                          case ContentAlignment.TopLeft: offset = new SizeF(0' 0); break;                          case ContentAlignment.TopCenter: offset = new SizeF(size.Width / 2'0); break;                          case ContentAlignment.TopRight: offset = new SizeF(size.Width' 0); break;                                case ContentAlignment.BottomLeft: offset = new SizeF(0' size.Height ); break;                          case ContentAlignment.BottomCenter: offset = new SizeF(size.Width / 2' size.Height); break;                          case ContentAlignment.BottomRight: offset = new SizeF(size.Width' size.Height); break;                                case ContentAlignment.MiddleLeft: offset = new SizeF(0' size.Height / 2); break;                          case ContentAlignment.MiddleCenter: offset = new SizeF(size.Width / 2' size.Height / 2); break;                          case ContentAlignment.MiddleRight: offset = new SizeF(size.Width' size.Height / 2); break;                                default:                              throw new NotSupportedException();                        }                      IEnumerable<ICoordinate> targetPoints = null;                      if (feature.FeatureType == FeatureType.Point)                          targetPoints = new ICoordinate[] {feature.Point.Coordinate};                      else                          targetPoints = feature.MultiPoint.Points;                        foreach (ICoordinate targetPoint in targetPoints)                      {                          if (style.DisplayKind == PointDisplayKind.Symbol)                          {                              // symbol                              using (GraphicsPath path = new GraphicsPath())                              {                                  path.AddString(style.Symbol.ToString()'                                                 f.FontFamily'                                                 (int) f.Style'                                                 f.Size'                                                 new PointF((float) ((targetPoint.X - viewBox.MinX)*scaleFactor-offset.Width)'                                                            (float)                                                            ((viewBox.MaxY - targetPoint.Y)*scaleFactor -offset.Height))'                                                 _symbolStringFormat);                                    g.FillPath(fontBrush' path);                              }                          }                          else                          {                              // image                              if (style.Image != null)                                  g.DrawImageUnscaled(style.Image'                                                      new Point(                                                          (int)                                                          Math.Round(((targetPoint.X - viewBox.MinX)*scaleFactor -                                                                      offset.Width))'                                                          (int)                                                          Math.Round(((viewBox.MaxY - targetPoint.Y)*scaleFactor -                                                                      offset.Height))));                          }                            if (feature.Selected)                          {                              // Frame selected object                              using (Pen p = new Pen(_selectionColor' 2))                                  g.DrawRectangle(p'                                                  (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width + 1)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height + 1)'                                                  size.Width - 2' size.Height - 2);                                using (Brush b = new SolidBrush(Color.FromArgb(50' _selectionColor)))                                  g.FillRectangle(b' (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height)'                                                  size.Width' size.Height);                          }                      }                        // inscription                      if (!string.IsNullOrEmpty(feature.Title) && titleVisible)                      {                          if (feature.FeatureType == FeatureType.Point)                          {                              //Location signs point object can not be determined only by coordinates'                              //without knowing the size of the image of a point object.                               //Therefore' the ordinate of a point object is displaced by half the size of the symbol.                              Feature shp = new Feature(FeatureType.Point);                              shp.Point = new PointD(feature.Point.X' feature.Point.Y + size.Height/2/scaleFactor);                              shp.Title = feature.Title;                              addTitleBufferElement(g' shp' titleStyle' viewBox' scaleFactor);                          }                          if (feature.FeatureType == FeatureType.MultiPoint)                              addTitleBufferElement(g' feature' titleStyle' viewBox' scaleFactor);                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: using (Font f = new Font(_fontName' style.Size' FontStyle.Regular' GraphicsUnit.Pixel))              {                  using (SolidBrush fontBrush = new SolidBrush(style.Color))                  {                      SizeF size;                      SizeF offset;                      if (style.DisplayKind == PointDisplayKind.Symbol)                          // character size                          size = g.MeasureString(style.Symbol.ToString()' f' new PointF(0' 0)' _symbolStringFormat);                      else                      {                          // image size                          if (style.Image != null)                              size = new SizeF(style.Image.Width' style.Image.Height);                          else                              size = new SizeF(1' 1);                      }                      //Offset relative to the center point                      offset = new SizeF(size.Width/2'size.Height/2);                        switch (style.ContentAlignment)                      {                          case ContentAlignment.TopLeft: offset = new SizeF(0' 0); break;                          case ContentAlignment.TopCenter: offset = new SizeF(size.Width / 2'0); break;                          case ContentAlignment.TopRight: offset = new SizeF(size.Width' 0); break;                                case ContentAlignment.BottomLeft: offset = new SizeF(0' size.Height ); break;                          case ContentAlignment.BottomCenter: offset = new SizeF(size.Width / 2' size.Height); break;                          case ContentAlignment.BottomRight: offset = new SizeF(size.Width' size.Height); break;                                case ContentAlignment.MiddleLeft: offset = new SizeF(0' size.Height / 2); break;                          case ContentAlignment.MiddleCenter: offset = new SizeF(size.Width / 2' size.Height / 2); break;                          case ContentAlignment.MiddleRight: offset = new SizeF(size.Width' size.Height / 2); break;                                default:                              throw new NotSupportedException();                        }                      IEnumerable<ICoordinate> targetPoints = null;                      if (feature.FeatureType == FeatureType.Point)                          targetPoints = new ICoordinate[] {feature.Point.Coordinate};                      else                          targetPoints = feature.MultiPoint.Points;                        foreach (ICoordinate targetPoint in targetPoints)                      {                          if (style.DisplayKind == PointDisplayKind.Symbol)                          {                              // symbol                              using (GraphicsPath path = new GraphicsPath())                              {                                  path.AddString(style.Symbol.ToString()'                                                 f.FontFamily'                                                 (int) f.Style'                                                 f.Size'                                                 new PointF((float) ((targetPoint.X - viewBox.MinX)*scaleFactor-offset.Width)'                                                            (float)                                                            ((viewBox.MaxY - targetPoint.Y)*scaleFactor -offset.Height))'                                                 _symbolStringFormat);                                    g.FillPath(fontBrush' path);                              }                          }                          else                          {                              // image                              if (style.Image != null)                                  g.DrawImageUnscaled(style.Image'                                                      new Point(                                                          (int)                                                          Math.Round(((targetPoint.X - viewBox.MinX)*scaleFactor -                                                                      offset.Width))'                                                          (int)                                                          Math.Round(((viewBox.MaxY - targetPoint.Y)*scaleFactor -                                                                      offset.Height))));                          }                            if (feature.Selected)                          {                              // Frame selected object                              using (Pen p = new Pen(_selectionColor' 2))                                  g.DrawRectangle(p'                                                  (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width + 1)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height + 1)'                                                  size.Width - 2' size.Height - 2);                                using (Brush b = new SolidBrush(Color.FromArgb(50' _selectionColor)))                                  g.FillRectangle(b' (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height)'                                                  size.Width' size.Height);                          }                      }                        // inscription                      if (!string.IsNullOrEmpty(feature.Title) && titleVisible)                      {                          if (feature.FeatureType == FeatureType.Point)                          {                              //Location signs point object can not be determined only by coordinates'                              //without knowing the size of the image of a point object.                               //Therefore' the ordinate of a point object is displaced by half the size of the symbol.                              Feature shp = new Feature(FeatureType.Point);                              shp.Point = new PointD(feature.Point.X' feature.Point.Y + size.Height/2/scaleFactor);                              shp.Title = feature.Title;                              addTitleBufferElement(g' shp' titleStyle' viewBox' scaleFactor);                          }                          if (feature.FeatureType == FeatureType.MultiPoint)                              addTitleBufferElement(g' feature' titleStyle' viewBox' scaleFactor);                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: using (Font f = new Font(_fontName' style.Size' FontStyle.Regular' GraphicsUnit.Pixel))              {                  using (SolidBrush fontBrush = new SolidBrush(style.Color))                  {                      SizeF size;                      SizeF offset;                      if (style.DisplayKind == PointDisplayKind.Symbol)                          // character size                          size = g.MeasureString(style.Symbol.ToString()' f' new PointF(0' 0)' _symbolStringFormat);                      else                      {                          // image size                          if (style.Image != null)                              size = new SizeF(style.Image.Width' style.Image.Height);                          else                              size = new SizeF(1' 1);                      }                      //Offset relative to the center point                      offset = new SizeF(size.Width/2'size.Height/2);                        switch (style.ContentAlignment)                      {                          case ContentAlignment.TopLeft: offset = new SizeF(0' 0); break;                          case ContentAlignment.TopCenter: offset = new SizeF(size.Width / 2'0); break;                          case ContentAlignment.TopRight: offset = new SizeF(size.Width' 0); break;                                case ContentAlignment.BottomLeft: offset = new SizeF(0' size.Height ); break;                          case ContentAlignment.BottomCenter: offset = new SizeF(size.Width / 2' size.Height); break;                          case ContentAlignment.BottomRight: offset = new SizeF(size.Width' size.Height); break;                                case ContentAlignment.MiddleLeft: offset = new SizeF(0' size.Height / 2); break;                          case ContentAlignment.MiddleCenter: offset = new SizeF(size.Width / 2' size.Height / 2); break;                          case ContentAlignment.MiddleRight: offset = new SizeF(size.Width' size.Height / 2); break;                                default:                              throw new NotSupportedException();                        }                      IEnumerable<ICoordinate> targetPoints = null;                      if (feature.FeatureType == FeatureType.Point)                          targetPoints = new ICoordinate[] {feature.Point.Coordinate};                      else                          targetPoints = feature.MultiPoint.Points;                        foreach (ICoordinate targetPoint in targetPoints)                      {                          if (style.DisplayKind == PointDisplayKind.Symbol)                          {                              // symbol                              using (GraphicsPath path = new GraphicsPath())                              {                                  path.AddString(style.Symbol.ToString()'                                                 f.FontFamily'                                                 (int) f.Style'                                                 f.Size'                                                 new PointF((float) ((targetPoint.X - viewBox.MinX)*scaleFactor-offset.Width)'                                                            (float)                                                            ((viewBox.MaxY - targetPoint.Y)*scaleFactor -offset.Height))'                                                 _symbolStringFormat);                                    g.FillPath(fontBrush' path);                              }                          }                          else                          {                              // image                              if (style.Image != null)                                  g.DrawImageUnscaled(style.Image'                                                      new Point(                                                          (int)                                                          Math.Round(((targetPoint.X - viewBox.MinX)*scaleFactor -                                                                      offset.Width))'                                                          (int)                                                          Math.Round(((viewBox.MaxY - targetPoint.Y)*scaleFactor -                                                                      offset.Height))));                          }                            if (feature.Selected)                          {                              // Frame selected object                              using (Pen p = new Pen(_selectionColor' 2))                                  g.DrawRectangle(p'                                                  (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width + 1)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height + 1)'                                                  size.Width - 2' size.Height - 2);                                using (Brush b = new SolidBrush(Color.FromArgb(50' _selectionColor)))                                  g.FillRectangle(b' (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height)'                                                  size.Width' size.Height);                          }                      }                        // inscription                      if (!string.IsNullOrEmpty(feature.Title) && titleVisible)                      {                          if (feature.FeatureType == FeatureType.Point)                          {                              //Location signs point object can not be determined only by coordinates'                              //without knowing the size of the image of a point object.                               //Therefore' the ordinate of a point object is displaced by half the size of the symbol.                              Feature shp = new Feature(FeatureType.Point);                              shp.Point = new PointD(feature.Point.X' feature.Point.Y + size.Height/2/scaleFactor);                              shp.Title = feature.Title;                              addTitleBufferElement(g' shp' titleStyle' viewBox' scaleFactor);                          }                          if (feature.FeatureType == FeatureType.MultiPoint)                              addTitleBufferElement(g' feature' titleStyle' viewBox' scaleFactor);                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: using (Font f = new Font(_fontName' style.Size' FontStyle.Regular' GraphicsUnit.Pixel))              {                  using (SolidBrush fontBrush = new SolidBrush(style.Color))                  {                      SizeF size;                      SizeF offset;                      if (style.DisplayKind == PointDisplayKind.Symbol)                          // character size                          size = g.MeasureString(style.Symbol.ToString()' f' new PointF(0' 0)' _symbolStringFormat);                      else                      {                          // image size                          if (style.Image != null)                              size = new SizeF(style.Image.Width' style.Image.Height);                          else                              size = new SizeF(1' 1);                      }                      //Offset relative to the center point                      offset = new SizeF(size.Width/2'size.Height/2);                        switch (style.ContentAlignment)                      {                          case ContentAlignment.TopLeft: offset = new SizeF(0' 0); break;                          case ContentAlignment.TopCenter: offset = new SizeF(size.Width / 2'0); break;                          case ContentAlignment.TopRight: offset = new SizeF(size.Width' 0); break;                                case ContentAlignment.BottomLeft: offset = new SizeF(0' size.Height ); break;                          case ContentAlignment.BottomCenter: offset = new SizeF(size.Width / 2' size.Height); break;                          case ContentAlignment.BottomRight: offset = new SizeF(size.Width' size.Height); break;                                case ContentAlignment.MiddleLeft: offset = new SizeF(0' size.Height / 2); break;                          case ContentAlignment.MiddleCenter: offset = new SizeF(size.Width / 2' size.Height / 2); break;                          case ContentAlignment.MiddleRight: offset = new SizeF(size.Width' size.Height / 2); break;                                default:                              throw new NotSupportedException();                        }                      IEnumerable<ICoordinate> targetPoints = null;                      if (feature.FeatureType == FeatureType.Point)                          targetPoints = new ICoordinate[] {feature.Point.Coordinate};                      else                          targetPoints = feature.MultiPoint.Points;                        foreach (ICoordinate targetPoint in targetPoints)                      {                          if (style.DisplayKind == PointDisplayKind.Symbol)                          {                              // symbol                              using (GraphicsPath path = new GraphicsPath())                              {                                  path.AddString(style.Symbol.ToString()'                                                 f.FontFamily'                                                 (int) f.Style'                                                 f.Size'                                                 new PointF((float) ((targetPoint.X - viewBox.MinX)*scaleFactor-offset.Width)'                                                            (float)                                                            ((viewBox.MaxY - targetPoint.Y)*scaleFactor -offset.Height))'                                                 _symbolStringFormat);                                    g.FillPath(fontBrush' path);                              }                          }                          else                          {                              // image                              if (style.Image != null)                                  g.DrawImageUnscaled(style.Image'                                                      new Point(                                                          (int)                                                          Math.Round(((targetPoint.X - viewBox.MinX)*scaleFactor -                                                                      offset.Width))'                                                          (int)                                                          Math.Round(((viewBox.MaxY - targetPoint.Y)*scaleFactor -                                                                      offset.Height))));                          }                            if (feature.Selected)                          {                              // Frame selected object                              using (Pen p = new Pen(_selectionColor' 2))                                  g.DrawRectangle(p'                                                  (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width + 1)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height + 1)'                                                  size.Width - 2' size.Height - 2);                                using (Brush b = new SolidBrush(Color.FromArgb(50' _selectionColor)))                                  g.FillRectangle(b' (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height)'                                                  size.Width' size.Height);                          }                      }                        // inscription                      if (!string.IsNullOrEmpty(feature.Title) && titleVisible)                      {                          if (feature.FeatureType == FeatureType.Point)                          {                              //Location signs point object can not be determined only by coordinates'                              //without knowing the size of the image of a point object.                               //Therefore' the ordinate of a point object is displaced by half the size of the symbol.                              Feature shp = new Feature(FeatureType.Point);                              shp.Point = new PointD(feature.Point.X' feature.Point.Y + size.Height/2/scaleFactor);                              shp.Title = feature.Title;                              addTitleBufferElement(g' shp' titleStyle' viewBox' scaleFactor);                          }                          if (feature.FeatureType == FeatureType.MultiPoint)                              addTitleBufferElement(g' feature' titleStyle' viewBox' scaleFactor);                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: using (Font f = new Font(_fontName' style.Size' FontStyle.Regular' GraphicsUnit.Pixel))              {                  using (SolidBrush fontBrush = new SolidBrush(style.Color))                  {                      SizeF size;                      SizeF offset;                      if (style.DisplayKind == PointDisplayKind.Symbol)                          // character size                          size = g.MeasureString(style.Symbol.ToString()' f' new PointF(0' 0)' _symbolStringFormat);                      else                      {                          // image size                          if (style.Image != null)                              size = new SizeF(style.Image.Width' style.Image.Height);                          else                              size = new SizeF(1' 1);                      }                      //Offset relative to the center point                      offset = new SizeF(size.Width/2'size.Height/2);                        switch (style.ContentAlignment)                      {                          case ContentAlignment.TopLeft: offset = new SizeF(0' 0); break;                          case ContentAlignment.TopCenter: offset = new SizeF(size.Width / 2'0); break;                          case ContentAlignment.TopRight: offset = new SizeF(size.Width' 0); break;                                case ContentAlignment.BottomLeft: offset = new SizeF(0' size.Height ); break;                          case ContentAlignment.BottomCenter: offset = new SizeF(size.Width / 2' size.Height); break;                          case ContentAlignment.BottomRight: offset = new SizeF(size.Width' size.Height); break;                                case ContentAlignment.MiddleLeft: offset = new SizeF(0' size.Height / 2); break;                          case ContentAlignment.MiddleCenter: offset = new SizeF(size.Width / 2' size.Height / 2); break;                          case ContentAlignment.MiddleRight: offset = new SizeF(size.Width' size.Height / 2); break;                                default:                              throw new NotSupportedException();                        }                      IEnumerable<ICoordinate> targetPoints = null;                      if (feature.FeatureType == FeatureType.Point)                          targetPoints = new ICoordinate[] {feature.Point.Coordinate};                      else                          targetPoints = feature.MultiPoint.Points;                        foreach (ICoordinate targetPoint in targetPoints)                      {                          if (style.DisplayKind == PointDisplayKind.Symbol)                          {                              // symbol                              using (GraphicsPath path = new GraphicsPath())                              {                                  path.AddString(style.Symbol.ToString()'                                                 f.FontFamily'                                                 (int) f.Style'                                                 f.Size'                                                 new PointF((float) ((targetPoint.X - viewBox.MinX)*scaleFactor-offset.Width)'                                                            (float)                                                            ((viewBox.MaxY - targetPoint.Y)*scaleFactor -offset.Height))'                                                 _symbolStringFormat);                                    g.FillPath(fontBrush' path);                              }                          }                          else                          {                              // image                              if (style.Image != null)                                  g.DrawImageUnscaled(style.Image'                                                      new Point(                                                          (int)                                                          Math.Round(((targetPoint.X - viewBox.MinX)*scaleFactor -                                                                      offset.Width))'                                                          (int)                                                          Math.Round(((viewBox.MaxY - targetPoint.Y)*scaleFactor -                                                                      offset.Height))));                          }                            if (feature.Selected)                          {                              // Frame selected object                              using (Pen p = new Pen(_selectionColor' 2))                                  g.DrawRectangle(p'                                                  (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width + 1)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height + 1)'                                                  size.Width - 2' size.Height - 2);                                using (Brush b = new SolidBrush(Color.FromArgb(50' _selectionColor)))                                  g.FillRectangle(b' (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height)'                                                  size.Width' size.Height);                          }                      }                        // inscription                      if (!string.IsNullOrEmpty(feature.Title) && titleVisible)                      {                          if (feature.FeatureType == FeatureType.Point)                          {                              //Location signs point object can not be determined only by coordinates'                              //without knowing the size of the image of a point object.                               //Therefore' the ordinate of a point object is displaced by half the size of the symbol.                              Feature shp = new Feature(FeatureType.Point);                              shp.Point = new PointD(feature.Point.X' feature.Point.Y + size.Height/2/scaleFactor);                              shp.Title = feature.Title;                              addTitleBufferElement(g' shp' titleStyle' viewBox' scaleFactor);                          }                          if (feature.FeatureType == FeatureType.MultiPoint)                              addTitleBufferElement(g' feature' titleStyle' viewBox' scaleFactor);                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: using (Font f = new Font(_fontName' style.Size' FontStyle.Regular' GraphicsUnit.Pixel))              {                  using (SolidBrush fontBrush = new SolidBrush(style.Color))                  {                      SizeF size;                      SizeF offset;                      if (style.DisplayKind == PointDisplayKind.Symbol)                          // character size                          size = g.MeasureString(style.Symbol.ToString()' f' new PointF(0' 0)' _symbolStringFormat);                      else                      {                          // image size                          if (style.Image != null)                              size = new SizeF(style.Image.Width' style.Image.Height);                          else                              size = new SizeF(1' 1);                      }                      //Offset relative to the center point                      offset = new SizeF(size.Width/2'size.Height/2);                        switch (style.ContentAlignment)                      {                          case ContentAlignment.TopLeft: offset = new SizeF(0' 0); break;                          case ContentAlignment.TopCenter: offset = new SizeF(size.Width / 2'0); break;                          case ContentAlignment.TopRight: offset = new SizeF(size.Width' 0); break;                                case ContentAlignment.BottomLeft: offset = new SizeF(0' size.Height ); break;                          case ContentAlignment.BottomCenter: offset = new SizeF(size.Width / 2' size.Height); break;                          case ContentAlignment.BottomRight: offset = new SizeF(size.Width' size.Height); break;                                case ContentAlignment.MiddleLeft: offset = new SizeF(0' size.Height / 2); break;                          case ContentAlignment.MiddleCenter: offset = new SizeF(size.Width / 2' size.Height / 2); break;                          case ContentAlignment.MiddleRight: offset = new SizeF(size.Width' size.Height / 2); break;                                default:                              throw new NotSupportedException();                        }                      IEnumerable<ICoordinate> targetPoints = null;                      if (feature.FeatureType == FeatureType.Point)                          targetPoints = new ICoordinate[] {feature.Point.Coordinate};                      else                          targetPoints = feature.MultiPoint.Points;                        foreach (ICoordinate targetPoint in targetPoints)                      {                          if (style.DisplayKind == PointDisplayKind.Symbol)                          {                              // symbol                              using (GraphicsPath path = new GraphicsPath())                              {                                  path.AddString(style.Symbol.ToString()'                                                 f.FontFamily'                                                 (int) f.Style'                                                 f.Size'                                                 new PointF((float) ((targetPoint.X - viewBox.MinX)*scaleFactor-offset.Width)'                                                            (float)                                                            ((viewBox.MaxY - targetPoint.Y)*scaleFactor -offset.Height))'                                                 _symbolStringFormat);                                    g.FillPath(fontBrush' path);                              }                          }                          else                          {                              // image                              if (style.Image != null)                                  g.DrawImageUnscaled(style.Image'                                                      new Point(                                                          (int)                                                          Math.Round(((targetPoint.X - viewBox.MinX)*scaleFactor -                                                                      offset.Width))'                                                          (int)                                                          Math.Round(((viewBox.MaxY - targetPoint.Y)*scaleFactor -                                                                      offset.Height))));                          }                            if (feature.Selected)                          {                              // Frame selected object                              using (Pen p = new Pen(_selectionColor' 2))                                  g.DrawRectangle(p'                                                  (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width + 1)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height + 1)'                                                  size.Width - 2' size.Height - 2);                                using (Brush b = new SolidBrush(Color.FromArgb(50' _selectionColor)))                                  g.FillRectangle(b' (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height)'                                                  size.Width' size.Height);                          }                      }                        // inscription                      if (!string.IsNullOrEmpty(feature.Title) && titleVisible)                      {                          if (feature.FeatureType == FeatureType.Point)                          {                              //Location signs point object can not be determined only by coordinates'                              //without knowing the size of the image of a point object.                               //Therefore' the ordinate of a point object is displaced by half the size of the symbol.                              Feature shp = new Feature(FeatureType.Point);                              shp.Point = new PointD(feature.Point.X' feature.Point.Y + size.Height/2/scaleFactor);                              shp.Title = feature.Title;                              addTitleBufferElement(g' shp' titleStyle' viewBox' scaleFactor);                          }                          if (feature.FeatureType == FeatureType.MultiPoint)                              addTitleBufferElement(g' feature' titleStyle' viewBox' scaleFactor);                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: using (Font f = new Font(_fontName' style.Size' FontStyle.Regular' GraphicsUnit.Pixel))              {                  using (SolidBrush fontBrush = new SolidBrush(style.Color))                  {                      SizeF size;                      SizeF offset;                      if (style.DisplayKind == PointDisplayKind.Symbol)                          // character size                          size = g.MeasureString(style.Symbol.ToString()' f' new PointF(0' 0)' _symbolStringFormat);                      else                      {                          // image size                          if (style.Image != null)                              size = new SizeF(style.Image.Width' style.Image.Height);                          else                              size = new SizeF(1' 1);                      }                      //Offset relative to the center point                      offset = new SizeF(size.Width/2'size.Height/2);                        switch (style.ContentAlignment)                      {                          case ContentAlignment.TopLeft: offset = new SizeF(0' 0); break;                          case ContentAlignment.TopCenter: offset = new SizeF(size.Width / 2'0); break;                          case ContentAlignment.TopRight: offset = new SizeF(size.Width' 0); break;                                case ContentAlignment.BottomLeft: offset = new SizeF(0' size.Height ); break;                          case ContentAlignment.BottomCenter: offset = new SizeF(size.Width / 2' size.Height); break;                          case ContentAlignment.BottomRight: offset = new SizeF(size.Width' size.Height); break;                                case ContentAlignment.MiddleLeft: offset = new SizeF(0' size.Height / 2); break;                          case ContentAlignment.MiddleCenter: offset = new SizeF(size.Width / 2' size.Height / 2); break;                          case ContentAlignment.MiddleRight: offset = new SizeF(size.Width' size.Height / 2); break;                                default:                              throw new NotSupportedException();                        }                      IEnumerable<ICoordinate> targetPoints = null;                      if (feature.FeatureType == FeatureType.Point)                          targetPoints = new ICoordinate[] {feature.Point.Coordinate};                      else                          targetPoints = feature.MultiPoint.Points;                        foreach (ICoordinate targetPoint in targetPoints)                      {                          if (style.DisplayKind == PointDisplayKind.Symbol)                          {                              // symbol                              using (GraphicsPath path = new GraphicsPath())                              {                                  path.AddString(style.Symbol.ToString()'                                                 f.FontFamily'                                                 (int) f.Style'                                                 f.Size'                                                 new PointF((float) ((targetPoint.X - viewBox.MinX)*scaleFactor-offset.Width)'                                                            (float)                                                            ((viewBox.MaxY - targetPoint.Y)*scaleFactor -offset.Height))'                                                 _symbolStringFormat);                                    g.FillPath(fontBrush' path);                              }                          }                          else                          {                              // image                              if (style.Image != null)                                  g.DrawImageUnscaled(style.Image'                                                      new Point(                                                          (int)                                                          Math.Round(((targetPoint.X - viewBox.MinX)*scaleFactor -                                                                      offset.Width))'                                                          (int)                                                          Math.Round(((viewBox.MaxY - targetPoint.Y)*scaleFactor -                                                                      offset.Height))));                          }                            if (feature.Selected)                          {                              // Frame selected object                              using (Pen p = new Pen(_selectionColor' 2))                                  g.DrawRectangle(p'                                                  (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width + 1)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height + 1)'                                                  size.Width - 2' size.Height - 2);                                using (Brush b = new SolidBrush(Color.FromArgb(50' _selectionColor)))                                  g.FillRectangle(b' (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height)'                                                  size.Width' size.Height);                          }                      }                        // inscription                      if (!string.IsNullOrEmpty(feature.Title) && titleVisible)                      {                          if (feature.FeatureType == FeatureType.Point)                          {                              //Location signs point object can not be determined only by coordinates'                              //without knowing the size of the image of a point object.                               //Therefore' the ordinate of a point object is displaced by half the size of the symbol.                              Feature shp = new Feature(FeatureType.Point);                              shp.Point = new PointD(feature.Point.X' feature.Point.Y + size.Height/2/scaleFactor);                              shp.Title = feature.Title;                              addTitleBufferElement(g' shp' titleStyle' viewBox' scaleFactor);                          }                          if (feature.FeatureType == FeatureType.MultiPoint)                              addTitleBufferElement(g' feature' titleStyle' viewBox' scaleFactor);                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPoint,The following statement contains a magic number: using (Font f = new Font(_fontName' style.Size' FontStyle.Regular' GraphicsUnit.Pixel))              {                  using (SolidBrush fontBrush = new SolidBrush(style.Color))                  {                      SizeF size;                      SizeF offset;                      if (style.DisplayKind == PointDisplayKind.Symbol)                          // character size                          size = g.MeasureString(style.Symbol.ToString()' f' new PointF(0' 0)' _symbolStringFormat);                      else                      {                          // image size                          if (style.Image != null)                              size = new SizeF(style.Image.Width' style.Image.Height);                          else                              size = new SizeF(1' 1);                      }                      //Offset relative to the center point                      offset = new SizeF(size.Width/2'size.Height/2);                        switch (style.ContentAlignment)                      {                          case ContentAlignment.TopLeft: offset = new SizeF(0' 0); break;                          case ContentAlignment.TopCenter: offset = new SizeF(size.Width / 2'0); break;                          case ContentAlignment.TopRight: offset = new SizeF(size.Width' 0); break;                                case ContentAlignment.BottomLeft: offset = new SizeF(0' size.Height ); break;                          case ContentAlignment.BottomCenter: offset = new SizeF(size.Width / 2' size.Height); break;                          case ContentAlignment.BottomRight: offset = new SizeF(size.Width' size.Height); break;                                case ContentAlignment.MiddleLeft: offset = new SizeF(0' size.Height / 2); break;                          case ContentAlignment.MiddleCenter: offset = new SizeF(size.Width / 2' size.Height / 2); break;                          case ContentAlignment.MiddleRight: offset = new SizeF(size.Width' size.Height / 2); break;                                default:                              throw new NotSupportedException();                        }                      IEnumerable<ICoordinate> targetPoints = null;                      if (feature.FeatureType == FeatureType.Point)                          targetPoints = new ICoordinate[] {feature.Point.Coordinate};                      else                          targetPoints = feature.MultiPoint.Points;                        foreach (ICoordinate targetPoint in targetPoints)                      {                          if (style.DisplayKind == PointDisplayKind.Symbol)                          {                              // symbol                              using (GraphicsPath path = new GraphicsPath())                              {                                  path.AddString(style.Symbol.ToString()'                                                 f.FontFamily'                                                 (int) f.Style'                                                 f.Size'                                                 new PointF((float) ((targetPoint.X - viewBox.MinX)*scaleFactor-offset.Width)'                                                            (float)                                                            ((viewBox.MaxY - targetPoint.Y)*scaleFactor -offset.Height))'                                                 _symbolStringFormat);                                    g.FillPath(fontBrush' path);                              }                          }                          else                          {                              // image                              if (style.Image != null)                                  g.DrawImageUnscaled(style.Image'                                                      new Point(                                                          (int)                                                          Math.Round(((targetPoint.X - viewBox.MinX)*scaleFactor -                                                                      offset.Width))'                                                          (int)                                                          Math.Round(((viewBox.MaxY - targetPoint.Y)*scaleFactor -                                                                      offset.Height))));                          }                            if (feature.Selected)                          {                              // Frame selected object                              using (Pen p = new Pen(_selectionColor' 2))                                  g.DrawRectangle(p'                                                  (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width + 1)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height + 1)'                                                  size.Width - 2' size.Height - 2);                                using (Brush b = new SolidBrush(Color.FromArgb(50' _selectionColor)))                                  g.FillRectangle(b' (float)((targetPoint.X - viewBox.MinX) * scaleFactor - offset.Width)'                                                  (float)((viewBox.MaxY - targetPoint.Y) * scaleFactor - offset.Height)'                                                  size.Width' size.Height);                          }                      }                        // inscription                      if (!string.IsNullOrEmpty(feature.Title) && titleVisible)                      {                          if (feature.FeatureType == FeatureType.Point)                          {                              //Location signs point object can not be determined only by coordinates'                              //without knowing the size of the image of a point object.                               //Therefore' the ordinate of a point object is displaced by half the size of the symbol.                              Feature shp = new Feature(FeatureType.Point);                              shp.Point = new PointD(feature.Point.X' feature.Point.Y + size.Height/2/scaleFactor);                              shp.Title = feature.Title;                              addTitleBufferElement(g' shp' titleStyle' viewBox' scaleFactor);                          }                          if (feature.FeatureType == FeatureType.MultiPoint)                              addTitleBufferElement(g' feature' titleStyle' viewBox' scaleFactor);                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolyline,The following statement contains a magic number: using (Pen pen = style.GetPen())              {                  if (Math.Min(viewBox.Width/(feature.BoundingRectangle.Width)'                               viewBox.Height/(feature.BoundingRectangle.Height)) < 2)                      drawPolylineWithIntersectCalculation(g' feature' style' viewBox' scaleFactor);                  else                      drawPolylineSimple(g' feature' style' viewBox' scaleFactor);                    // inscription                  if (!string.IsNullOrEmpty(feature.Title) && titleVisible)                      addTitleBufferElement(g' feature' titleStyle' viewBox' scaleFactor);              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolygon,The following statement contains a magic number: using (Pen pen = style.GetPen())              {                  using (GraphicsPath path = new GraphicsPath(FillMode.Alternate))                  {                      path.StartFigure();                        float x = (float) ((feature.Polygon.Contours[0].Vertices[0].X - viewBox.MinX)*scaleFactor);                      float y = (float) ((viewBox.MaxY - feature.Polygon.Contours[0].Vertices[0].Y)*scaleFactor);                        g.RenderingOrigin = new Point((int) Math.Round(x)' (int) Math.Round(y));                        foreach (Contour c in feature.Polygon.Contours)                      {                          // there is no point in trying to draw the contours of the degenerate                          if (c.Vertices.Count <= 2)                              continue;                            PointF[] points = new PointF[c.Vertices.Count];                            for (int j = 0; j < c.Vertices.Count; j++)                          {                              points[j].X = (float) ((c.Vertices[j].X - viewBox.MinX)*scaleFactor);                              points[j].Y = (float) ((viewBox.MaxY - c.Vertices[j].Y)*scaleFactor);                          }                            if (points.Length > 2)                              path.AddPolygon(points);                      }                        path.CloseFigure();                        // Fill polygon                      using (Brush b = style.GetBrush())                      {                          if (style.FillPatternInternal != null)                          {                              int w = style.FillPatternInternal.Width;                              int h = style.FillPatternInternal.Height;                              ((TextureBrush) b).TranslateTransform(g.RenderingOrigin.X%w' g.RenderingOrigin.Y%h);                          }                          g.FillPath(b' path);                      }                        if (feature.Selected)                      {                          //Fills the selected polygon                            //Color color = Color.FromArgb(50' _selectionColor);                          //using (Brush b = new HatchBrush(HatchStyle.Percent70' color' Color.Transparent))                            if (_selectionColorChanged || _selectionTexture == null)                              createSelectionTexture();                            using (Brush b = new TextureBrush(_selectionTexture))                          {                              ((TextureBrush) b).TranslateTransform(g.RenderingOrigin.X%8' g.RenderingOrigin.Y%8);                              g.FillPath(b' path);                          }                            // boundary of the selected polygons                          using (Pen p = new Pen(_selectionColor' style.BorderWidth + 3))                          {                              p.LineJoin = LineJoin.Bevel;                              g.DrawPath(p' path);                          }                      }                        //boundary of the landfill                      if (style.BorderVisible)                          g.DrawPath(pen' path);                  }                    // inscription                  if (!string.IsNullOrEmpty(feature.Title) && titleVisible)                      addTitleBufferElement(g' feature' titleStyle' viewBox' scaleFactor);              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolygon,The following statement contains a magic number: using (Pen pen = style.GetPen())              {                  using (GraphicsPath path = new GraphicsPath(FillMode.Alternate))                  {                      path.StartFigure();                        float x = (float) ((feature.Polygon.Contours[0].Vertices[0].X - viewBox.MinX)*scaleFactor);                      float y = (float) ((viewBox.MaxY - feature.Polygon.Contours[0].Vertices[0].Y)*scaleFactor);                        g.RenderingOrigin = new Point((int) Math.Round(x)' (int) Math.Round(y));                        foreach (Contour c in feature.Polygon.Contours)                      {                          // there is no point in trying to draw the contours of the degenerate                          if (c.Vertices.Count <= 2)                              continue;                            PointF[] points = new PointF[c.Vertices.Count];                            for (int j = 0; j < c.Vertices.Count; j++)                          {                              points[j].X = (float) ((c.Vertices[j].X - viewBox.MinX)*scaleFactor);                              points[j].Y = (float) ((viewBox.MaxY - c.Vertices[j].Y)*scaleFactor);                          }                            if (points.Length > 2)                              path.AddPolygon(points);                      }                        path.CloseFigure();                        // Fill polygon                      using (Brush b = style.GetBrush())                      {                          if (style.FillPatternInternal != null)                          {                              int w = style.FillPatternInternal.Width;                              int h = style.FillPatternInternal.Height;                              ((TextureBrush) b).TranslateTransform(g.RenderingOrigin.X%w' g.RenderingOrigin.Y%h);                          }                          g.FillPath(b' path);                      }                        if (feature.Selected)                      {                          //Fills the selected polygon                            //Color color = Color.FromArgb(50' _selectionColor);                          //using (Brush b = new HatchBrush(HatchStyle.Percent70' color' Color.Transparent))                            if (_selectionColorChanged || _selectionTexture == null)                              createSelectionTexture();                            using (Brush b = new TextureBrush(_selectionTexture))                          {                              ((TextureBrush) b).TranslateTransform(g.RenderingOrigin.X%8' g.RenderingOrigin.Y%8);                              g.FillPath(b' path);                          }                            // boundary of the selected polygons                          using (Pen p = new Pen(_selectionColor' style.BorderWidth + 3))                          {                              p.LineJoin = LineJoin.Bevel;                              g.DrawPath(p' path);                          }                      }                        //boundary of the landfill                      if (style.BorderVisible)                          g.DrawPath(pen' path);                  }                    // inscription                  if (!string.IsNullOrEmpty(feature.Title) && titleVisible)                      addTitleBufferElement(g' feature' titleStyle' viewBox' scaleFactor);              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolygon,The following statement contains a magic number: using (Pen pen = style.GetPen())              {                  using (GraphicsPath path = new GraphicsPath(FillMode.Alternate))                  {                      path.StartFigure();                        float x = (float) ((feature.Polygon.Contours[0].Vertices[0].X - viewBox.MinX)*scaleFactor);                      float y = (float) ((viewBox.MaxY - feature.Polygon.Contours[0].Vertices[0].Y)*scaleFactor);                        g.RenderingOrigin = new Point((int) Math.Round(x)' (int) Math.Round(y));                        foreach (Contour c in feature.Polygon.Contours)                      {                          // there is no point in trying to draw the contours of the degenerate                          if (c.Vertices.Count <= 2)                              continue;                            PointF[] points = new PointF[c.Vertices.Count];                            for (int j = 0; j < c.Vertices.Count; j++)                          {                              points[j].X = (float) ((c.Vertices[j].X - viewBox.MinX)*scaleFactor);                              points[j].Y = (float) ((viewBox.MaxY - c.Vertices[j].Y)*scaleFactor);                          }                            if (points.Length > 2)                              path.AddPolygon(points);                      }                        path.CloseFigure();                        // Fill polygon                      using (Brush b = style.GetBrush())                      {                          if (style.FillPatternInternal != null)                          {                              int w = style.FillPatternInternal.Width;                              int h = style.FillPatternInternal.Height;                              ((TextureBrush) b).TranslateTransform(g.RenderingOrigin.X%w' g.RenderingOrigin.Y%h);                          }                          g.FillPath(b' path);                      }                        if (feature.Selected)                      {                          //Fills the selected polygon                            //Color color = Color.FromArgb(50' _selectionColor);                          //using (Brush b = new HatchBrush(HatchStyle.Percent70' color' Color.Transparent))                            if (_selectionColorChanged || _selectionTexture == null)                              createSelectionTexture();                            using (Brush b = new TextureBrush(_selectionTexture))                          {                              ((TextureBrush) b).TranslateTransform(g.RenderingOrigin.X%8' g.RenderingOrigin.Y%8);                              g.FillPath(b' path);                          }                            // boundary of the selected polygons                          using (Pen p = new Pen(_selectionColor' style.BorderWidth + 3))                          {                              p.LineJoin = LineJoin.Bevel;                              g.DrawPath(p' path);                          }                      }                        //boundary of the landfill                      if (style.BorderVisible)                          g.DrawPath(pen' path);                  }                    // inscription                  if (!string.IsNullOrEmpty(feature.Title) && titleVisible)                      addTitleBufferElement(g' feature' titleStyle' viewBox' scaleFactor);              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolygon,The following statement contains a magic number: using (Pen pen = style.GetPen())              {                  using (GraphicsPath path = new GraphicsPath(FillMode.Alternate))                  {                      path.StartFigure();                        float x = (float) ((feature.Polygon.Contours[0].Vertices[0].X - viewBox.MinX)*scaleFactor);                      float y = (float) ((viewBox.MaxY - feature.Polygon.Contours[0].Vertices[0].Y)*scaleFactor);                        g.RenderingOrigin = new Point((int) Math.Round(x)' (int) Math.Round(y));                        foreach (Contour c in feature.Polygon.Contours)                      {                          // there is no point in trying to draw the contours of the degenerate                          if (c.Vertices.Count <= 2)                              continue;                            PointF[] points = new PointF[c.Vertices.Count];                            for (int j = 0; j < c.Vertices.Count; j++)                          {                              points[j].X = (float) ((c.Vertices[j].X - viewBox.MinX)*scaleFactor);                              points[j].Y = (float) ((viewBox.MaxY - c.Vertices[j].Y)*scaleFactor);                          }                            if (points.Length > 2)                              path.AddPolygon(points);                      }                        path.CloseFigure();                        // Fill polygon                      using (Brush b = style.GetBrush())                      {                          if (style.FillPatternInternal != null)                          {                              int w = style.FillPatternInternal.Width;                              int h = style.FillPatternInternal.Height;                              ((TextureBrush) b).TranslateTransform(g.RenderingOrigin.X%w' g.RenderingOrigin.Y%h);                          }                          g.FillPath(b' path);                      }                        if (feature.Selected)                      {                          //Fills the selected polygon                            //Color color = Color.FromArgb(50' _selectionColor);                          //using (Brush b = new HatchBrush(HatchStyle.Percent70' color' Color.Transparent))                            if (_selectionColorChanged || _selectionTexture == null)                              createSelectionTexture();                            using (Brush b = new TextureBrush(_selectionTexture))                          {                              ((TextureBrush) b).TranslateTransform(g.RenderingOrigin.X%8' g.RenderingOrigin.Y%8);                              g.FillPath(b' path);                          }                            // boundary of the selected polygons                          using (Pen p = new Pen(_selectionColor' style.BorderWidth + 3))                          {                              p.LineJoin = LineJoin.Bevel;                              g.DrawPath(p' path);                          }                      }                        //boundary of the landfill                      if (style.BorderVisible)                          g.DrawPath(pen' path);                  }                    // inscription                  if (!string.IsNullOrEmpty(feature.Title) && titleVisible)                      addTitleBufferElement(g' feature' titleStyle' viewBox' scaleFactor);              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,DrawPolygon,The following statement contains a magic number: using (Pen pen = style.GetPen())              {                  using (GraphicsPath path = new GraphicsPath(FillMode.Alternate))                  {                      path.StartFigure();                        float x = (float) ((feature.Polygon.Contours[0].Vertices[0].X - viewBox.MinX)*scaleFactor);                      float y = (float) ((viewBox.MaxY - feature.Polygon.Contours[0].Vertices[0].Y)*scaleFactor);                        g.RenderingOrigin = new Point((int) Math.Round(x)' (int) Math.Round(y));                        foreach (Contour c in feature.Polygon.Contours)                      {                          // there is no point in trying to draw the contours of the degenerate                          if (c.Vertices.Count <= 2)                              continue;                            PointF[] points = new PointF[c.Vertices.Count];                            for (int j = 0; j < c.Vertices.Count; j++)                          {                              points[j].X = (float) ((c.Vertices[j].X - viewBox.MinX)*scaleFactor);                              points[j].Y = (float) ((viewBox.MaxY - c.Vertices[j].Y)*scaleFactor);                          }                            if (points.Length > 2)                              path.AddPolygon(points);                      }                        path.CloseFigure();                        // Fill polygon                      using (Brush b = style.GetBrush())                      {                          if (style.FillPatternInternal != null)                          {                              int w = style.FillPatternInternal.Width;                              int h = style.FillPatternInternal.Height;                              ((TextureBrush) b).TranslateTransform(g.RenderingOrigin.X%w' g.RenderingOrigin.Y%h);                          }                          g.FillPath(b' path);                      }                        if (feature.Selected)                      {                          //Fills the selected polygon                            //Color color = Color.FromArgb(50' _selectionColor);                          //using (Brush b = new HatchBrush(HatchStyle.Percent70' color' Color.Transparent))                            if (_selectionColorChanged || _selectionTexture == null)                              createSelectionTexture();                            using (Brush b = new TextureBrush(_selectionTexture))                          {                              ((TextureBrush) b).TranslateTransform(g.RenderingOrigin.X%8' g.RenderingOrigin.Y%8);                              g.FillPath(b' path);                          }                            // boundary of the selected polygons                          using (Pen p = new Pen(_selectionColor' style.BorderWidth + 3))                          {                              p.LineJoin = LineJoin.Bevel;                              g.DrawPath(p' path);                          }                      }                        //boundary of the landfill                      if (style.BorderVisible)                          g.DrawPath(pen' path);                  }                    // inscription                  if (!string.IsNullOrEmpty(feature.Title) && titleVisible)                      addTitleBufferElement(g' feature' titleStyle' viewBox' scaleFactor);              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawTitle,The following statement contains a magic number: using (Font f = title.Style.GetFont())                  using (SolidBrush fontBrush = new SolidBrush(title.Style.Color))                  {                      SizeF size = g.MeasureString(title.Title' f' new PointF(0' 0)' _titleStringFormat);                      ICoordinate originPoint = PlanimetryEnvironment.NewCoordinate((title.Box.V1.X + title.Box.V2.X) / 2' title.Box.V2.Y);                        using (GraphicsPath path = new GraphicsPath())                      {                          if (title.IsSimple)                          {                              path.AddString(title.Title'                                             f.FontFamily'                                             (int)f.Style'                                             f.Size'                                             new PointF((float)((originPoint.X - viewBox.MinX) * scaleFactor)'                                                        (float)((viewBox.MaxY - originPoint.Y) * scaleFactor))'                                             _titleStringFormat);                                if (title.Style.UseOutline)                                  using (Pen pen = new Pen(_titleOutlineColor' title.Style.OutlineSize))                                  {                                      pen.MiterLimit = 1;                                      g.DrawPath(pen' path);                                  }                              g.FillPath(fontBrush' path);                          }                          else                          {                              g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;                                if (title.Style.UseOutline)                                  using (Pen pen = new Pen(_titleOutlineColor' title.Style.OutlineSize))                                  {                                      pen.MiterLimit = 1;                                      foreach (FollowingTitleElement element in title.FollowingTitle.Elements)                                      {                                          g.TranslateTransform(element.TranslationPoint.X' element.TranslationPoint.Y);                                          g.RotateTransform(element.RotationAngle);                                            path.Reset();                                          path.AddString(element.Substring' f.FontFamily' (int)f.Style' f.Size' element.TitleOrigin' StringFormat.GenericTypographic);                                          g.DrawPath(pen' path);                                          g.ResetTransform();                                      }                                  }                                using (Brush b = new SolidBrush(title.Style.Color))                                  foreach (FollowingTitleElement element in title.FollowingTitle.Elements)                                  {                                      g.TranslateTransform(element.TranslationPoint.X' element.TranslationPoint.Y);                                      g.RotateTransform(element.RotationAngle);                                        path.Reset();                                      path.AddString(element.Substring' f.FontFamily' (int)f.Style' f.Size' element.TitleOrigin' StringFormat.GenericTypographic);                                      g.FillPath(fontBrush' path);                                      g.ResetTransform();                                  }                          }                      }                  }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,addTitleBufferElement,The following statement contains a magic number: switch (feature.FeatureType)              {                  case FeatureType.Polyline:                      if (!titleStyle.LeadAlong)                      {                          foreach (LinePath path in feature.Polyline.Paths)                          {                              if (path.Vertices.Count > 2)                                  targetCoordinate = path.Vertices[path.Vertices.Count / 2 - 1];                              else                              {                                  s = new Segment(path.Vertices[0].X' path.Vertices[0].Y'                                                  path.Vertices[1].X' path.Vertices[1].Y);                                    targetCoordinate = s.Center();                              }                              addTitleBufferElement(titleStyle' targetCoordinate' size' scaleFactor' feature);                          }                      }                      else                      {                          int i = 0;                          foreach (LinePath path in feature.Polyline.Paths)                          {                              FollowingTitle followingTitle =                                   getFollowingTitle(g' path' feature.PolylinePartLengths[i]' feature.Title' titleStyle' viewBox' scaleFactor);                              if (followingTitle != null)                                  _titleBuffer.Add(new TitleBufferElement(followingTitle' titleStyle' _titleCount++));                              i++;                          }                      }                      return;                  case FeatureType.Polygon:                      //if (feature.Polygon.Contours.Count > 0)                      //    targetPoint = feature.Polygon.Contours[0].RibsCentroid();                      //else                      //    return;                      //break;                        if (feature.Polygon.Contours.Count > 0)                          try                          {                              targetCoordinate = feature.Polygon.PointOnSurface();                          }                          catch(InvalidOperationException)                          {                              //interior point of the polygon for some reason (usually singular) can not be found                              return;                          }                      else                          return;                      break;                                        case FeatureType.Point:                      targetCoordinate = feature.Point.Coordinate;                      //targetPoint.Y += size.Height / scaleFactor / 2;                      break;                  case FeatureType.MultiPoint:                      if (titleStyle.LeadAlong)                      {                          foreach (ICoordinate p in feature.MultiPoint.Points)                          {                              targetCoordinate = p;                              targetCoordinate.Y += size.Height / scaleFactor / 2;                              addTitleBufferElement(titleStyle' targetCoordinate' size' scaleFactor' feature);                          }                          return;                      }                      else                          targetCoordinate = PlanimetryAlgorithms.GetCentroid(feature.MultiPoint.Points);                      break;              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,addTitleBufferElement,The following statement contains a magic number: switch (feature.FeatureType)              {                  case FeatureType.Polyline:                      if (!titleStyle.LeadAlong)                      {                          foreach (LinePath path in feature.Polyline.Paths)                          {                              if (path.Vertices.Count > 2)                                  targetCoordinate = path.Vertices[path.Vertices.Count / 2 - 1];                              else                              {                                  s = new Segment(path.Vertices[0].X' path.Vertices[0].Y'                                                  path.Vertices[1].X' path.Vertices[1].Y);                                    targetCoordinate = s.Center();                              }                              addTitleBufferElement(titleStyle' targetCoordinate' size' scaleFactor' feature);                          }                      }                      else                      {                          int i = 0;                          foreach (LinePath path in feature.Polyline.Paths)                          {                              FollowingTitle followingTitle =                                   getFollowingTitle(g' path' feature.PolylinePartLengths[i]' feature.Title' titleStyle' viewBox' scaleFactor);                              if (followingTitle != null)                                  _titleBuffer.Add(new TitleBufferElement(followingTitle' titleStyle' _titleCount++));                              i++;                          }                      }                      return;                  case FeatureType.Polygon:                      //if (feature.Polygon.Contours.Count > 0)                      //    targetPoint = feature.Polygon.Contours[0].RibsCentroid();                      //else                      //    return;                      //break;                        if (feature.Polygon.Contours.Count > 0)                          try                          {                              targetCoordinate = feature.Polygon.PointOnSurface();                          }                          catch(InvalidOperationException)                          {                              //interior point of the polygon for some reason (usually singular) can not be found                              return;                          }                      else                          return;                      break;                                        case FeatureType.Point:                      targetCoordinate = feature.Point.Coordinate;                      //targetPoint.Y += size.Height / scaleFactor / 2;                      break;                  case FeatureType.MultiPoint:                      if (titleStyle.LeadAlong)                      {                          foreach (ICoordinate p in feature.MultiPoint.Points)                          {                              targetCoordinate = p;                              targetCoordinate.Y += size.Height / scaleFactor / 2;                              addTitleBufferElement(titleStyle' targetCoordinate' size' scaleFactor' feature);                          }                          return;                      }                      else                          targetCoordinate = PlanimetryAlgorithms.GetCentroid(feature.MultiPoint.Points);                      break;              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,addTitleBufferElement,The following statement contains a magic number: switch (feature.FeatureType)              {                  case FeatureType.Polyline:                      if (!titleStyle.LeadAlong)                      {                          foreach (LinePath path in feature.Polyline.Paths)                          {                              if (path.Vertices.Count > 2)                                  targetCoordinate = path.Vertices[path.Vertices.Count / 2 - 1];                              else                              {                                  s = new Segment(path.Vertices[0].X' path.Vertices[0].Y'                                                  path.Vertices[1].X' path.Vertices[1].Y);                                    targetCoordinate = s.Center();                              }                              addTitleBufferElement(titleStyle' targetCoordinate' size' scaleFactor' feature);                          }                      }                      else                      {                          int i = 0;                          foreach (LinePath path in feature.Polyline.Paths)                          {                              FollowingTitle followingTitle =                                   getFollowingTitle(g' path' feature.PolylinePartLengths[i]' feature.Title' titleStyle' viewBox' scaleFactor);                              if (followingTitle != null)                                  _titleBuffer.Add(new TitleBufferElement(followingTitle' titleStyle' _titleCount++));                              i++;                          }                      }                      return;                  case FeatureType.Polygon:                      //if (feature.Polygon.Contours.Count > 0)                      //    targetPoint = feature.Polygon.Contours[0].RibsCentroid();                      //else                      //    return;                      //break;                        if (feature.Polygon.Contours.Count > 0)                          try                          {                              targetCoordinate = feature.Polygon.PointOnSurface();                          }                          catch(InvalidOperationException)                          {                              //interior point of the polygon for some reason (usually singular) can not be found                              return;                          }                      else                          return;                      break;                                        case FeatureType.Point:                      targetCoordinate = feature.Point.Coordinate;                      //targetPoint.Y += size.Height / scaleFactor / 2;                      break;                  case FeatureType.MultiPoint:                      if (titleStyle.LeadAlong)                      {                          foreach (ICoordinate p in feature.MultiPoint.Points)                          {                              targetCoordinate = p;                              targetCoordinate.Y += size.Height / scaleFactor / 2;                              addTitleBufferElement(titleStyle' targetCoordinate' size' scaleFactor' feature);                          }                          return;                      }                      else                          targetCoordinate = PlanimetryAlgorithms.GetCentroid(feature.MultiPoint.Points);                      break;              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,addTitleBufferElement,The following statement contains a magic number: _titleBuffer.Add(new TitleBufferElement(titleStyle'                                          new Segment(targetPoint.X - size.Width / scaleFactor / 2'                                                      targetPoint.Y - size.Height / scaleFactor / 2'                                                      targetPoint.X + size.Width / scaleFactor / 2'                                                      targetPoint.Y + size.Height / scaleFactor / 2)'                                          feature.Title'                                          _titleCount++));
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,addTitleBufferElement,The following statement contains a magic number: _titleBuffer.Add(new TitleBufferElement(titleStyle'                                          new Segment(targetPoint.X - size.Width / scaleFactor / 2'                                                      targetPoint.Y - size.Height / scaleFactor / 2'                                                      targetPoint.X + size.Width / scaleFactor / 2'                                                      targetPoint.Y + size.Height / scaleFactor / 2)'                                          feature.Title'                                          _titleCount++));
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,addTitleBufferElement,The following statement contains a magic number: _titleBuffer.Add(new TitleBufferElement(titleStyle'                                          new Segment(targetPoint.X - size.Width / scaleFactor / 2'                                                      targetPoint.Y - size.Height / scaleFactor / 2'                                                      targetPoint.X + size.Width / scaleFactor / 2'                                                      targetPoint.Y + size.Height / scaleFactor / 2)'                                          feature.Title'                                          _titleCount++));
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,addTitleBufferElement,The following statement contains a magic number: _titleBuffer.Add(new TitleBufferElement(titleStyle'                                          new Segment(targetPoint.X - size.Width / scaleFactor / 2'                                                      targetPoint.Y - size.Height / scaleFactor / 2'                                                      targetPoint.X + size.Width / scaleFactor / 2'                                                      targetPoint.Y + size.Height / scaleFactor / 2)'                                          feature.Title'                                          _titleCount++));
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getFollowingTitle,The following statement contains a magic number: using (Font f = titleStyle.GetFont())              {                  sizeF = g.MeasureString(label' f' zeroPoint' format);                    // label length must be less than the length of the line                  if (sizeF.Width / scaleFactor < length)                  {                      LinePath tempPart = new LinePath();                      foreach (ICoordinate p in part.Vertices)                          tempPart.Vertices.Add(p);                        int vertexNumber = 0;                      ICoordinate centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        // if the point of the proposed mid-label misses the display area of ​​the map' the inscription does not appear                      if (!viewBox.ContainsPoint(centerPoint))                          return null;                        // simplify the line                      tempPart.Weed(sizeF.Height / scaleFactor / 2);                        //get the center point of the simplified line                      centerPoint = getDistantPoint(tempPart.Vertices' length / 2' out vertexNumber);                        List<double> leftPointsRotationDeltas = new List<double>();                      List<double> rightPointsRotationDeltas = new List<double>();                        // coordinates of points on the left of the middle of the inscription                      IList<ICoordinate> leftPoints =                          getLeftPoints(tempPart.Vertices'                                        centerPoint'                                        sizeF.Width / 2 / scaleFactor'                                        vertexNumber'                                        sizeF.Height / 2 / scaleFactor'                                        leftPointsRotationDeltas);                        // coordinates of the points to the right of the middle of the inscription                      IList<ICoordinate> rightPoints =                          getRightPoints(tempPart.Vertices'                                         centerPoint'                                         sizeF.Width / 2 / scaleFactor'                                         vertexNumber'                                         sizeF.Height / 2 / scaleFactor'                                         rightPointsRotationDeltas);                        //coordinates of the vertices of the broken line' which will be located along the inscription                      List<ICoordinate> points = leftPoints.ToList();                      points.AddRange(rightPoints);                        // shifts of the inscriptions associated with break lines                      List<double> rotationDeltas = leftPointsRotationDeltas;                      rotationDeltas.AddRange(rightPointsRotationDeltas);                        for (int i = 0; i < points.Count; i++)                          points[i] = PlanimetryEnvironment.NewCoordinate((points[i].X - viewBox.MinX) * scaleFactor'                                                 (viewBox.MaxY - points[i].Y) * scaleFactor);                        for (int i = 0; i < rotationDeltas.Count; i++)                          rotationDeltas[i] = rotationDeltas[i] * scaleFactor;                        //determine the direction of following labels (direct or reverse)                      double forwardWeight = 0;                      double backwardWeight = 0;                        for (int i = 1; i < points.Count; i++)                      {                          Segment s = new Segment(PlanimetryEnvironment.NewCoordinate(points[i].X' points[i].Y)'                                                  PlanimetryEnvironment.NewCoordinate(points[i - 1].X' points[i - 1].Y));                          int quadNumber = pointQuadrantNumber(PlanimetryEnvironment.NewCoordinate(s.V1.X - s.V2.X' s.V1.Y - s.V2.Y));                          if (quadNumber == 1 || quadNumber == 4)                              forwardWeight += s.Length();                          else                              backwardWeight += s.Length();                      }                        if (backwardWeight > forwardWeight)                      {                          points.Reverse();                          rotationDeltas.Reverse();                      }                        // inscriptions along the route should not be a large number of points                      if (label.Length > points.Count - 2)                      {                          List<int> subStringLengths = new List<int>();                          List<double> deltas = new List<double>();                            LinePath p1 = new LinePath(points.ToArray());                          double l = p1.Length();                            // partition of the inscription on the straight parts' the calculation of displacement                          int startIndex = 0;                          for (int i = 1; i < points.Count; i++)                          {                              double currentDistance = PlanimetryAlgorithms.Distance(points[i - 1]' points[i]);                                if (deltas.Count > 0)                                  if (deltas[deltas.Count - 1] < currentDistance)                                      currentDistance -= deltas[deltas.Count - 1];                                //subtract the offset associated with line breaks                              currentDistance -= rotationDeltas[i - 1];                              if (i < rotationDeltas.Count)                                  currentDistance -= rotationDeltas[i];                                int currentLength = (int)(currentDistance / l * label.Length);                                if (startIndex + currentLength > label.Length)                                  currentLength = label.Length - startIndex;                                subStringLengths.Add(currentLength > 0 ? currentLength : 0);                                string subString;                              if (subStringLengths[i - 1] > 0)                                  subString = label.Substring(startIndex' subStringLengths[i - 1]);                              else                                  subString = string.Empty;                                float width1' width2' width3;                              width1 = width2 = width3 = g.MeasureString(subString' f' zeroPoint' format).Width;                                if (!string.IsNullOrEmpty(subString))                              {                                  if (subStringLengths[i - 1] > 1)                                  {                                      width2 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] - 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width2 - currentDistance) < Math.Abs(width1 - currentDistance))                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] - 1;                                          width1 = width2;                                      }                                  }                                    if (label.Length > subStringLengths[i - 1] + startIndex)                                  {                                      width3 = g.MeasureString(label.Substring(startIndex' subStringLengths[i - 1] + 1)' f' zeroPoint' format).Width;                                      if (Math.Abs(width3 - currentDistance) < Math.Abs(width1 - currentDistance) &&                                          Math.Abs(width3 - currentDistance) < sizeF.Width / label.Length / 6)                                      {                                          subStringLengths[i - 1] = subStringLengths[i - 1] + 1;                                          width1 = width3;                                      }                                  }                              }                                deltas.Add(0.5 * (width1 - currentDistance));                              if (currentLength > 0)                                  startIndex += currentLength;                          }                            int sum = 0;                          int maxZeroLengths = 0;                          int zeroLengthsCount = 0;                          foreach (int k in subStringLengths)                          {                              if (k <= 0)                              {                                  zeroLengthsCount++;                                  if (maxZeroLengths < zeroLengthsCount)                                      maxZeroLengths = zeroLengthsCount;                              }                              else                                  zeroLengthsCount = 0;                              sum += k;                          }                            if (maxZeroLengths > 1)                              return null;                            int lastIndex = subStringLengths.Count() - 1;                          if (lastIndex >= 0)                          {                              subStringLengths[lastIndex] += label.Length - sum;                              if (subStringLengths[lastIndex] < 0)                              {                                  subStringLengths[lastIndex - 1] -= subStringLengths[lastIndex];                                  subStringLengths[lastIndex] = 0;                              }                          }                            FollowingTitle followingTitle = new FollowingTitle();                            startIndex = 0;                          double? previousAngle = null;                          for (int i = 0; i < subStringLengths.Count(); i++)                          {                              if (subStringLengths[i] <= 0)                                  continue;                                if (startIndex + subStringLengths[i] > label.Length)                                  return null;                                SizeF size;                              size = g.MeasureString(label.Substring(startIndex' subStringLengths[i])' f' zeroPoint' format);                                int x0 = (i == 0 ? 0 : (int)Math.Round(deltas[i - 1] + rotationDeltas[i - 1]));                                PointF[] v = new PointF[4];                              v[0].X = x0;                              v[0].Y = -size.Height / 2;                                v[1].X = size.Width + x0;                              v[1].Y = -size.Height / 2;                                v[2].X = size.Width + x0;                              v[2].Y = size.Height / 2;                                v[3].X = x0;                              v[3].Y = size.Height / 2;                                float angle = (float)(180 / Math.PI * getAngle(PlanimetryEnvironment.NewCoordinate(Math.Abs(points[i].X * 2)' points[i].Y)'                                                                             points[i]'                                                                             points[i + 1]'                                                    false));                                if (previousAngle != null)                              {                                  double angleDelta = Math.Abs(angle - previousAngle.Value);                                  if (angleDelta > 45 && 360 - angleDelta > 45)                                      return null;                              }                                previousAngle = angle;                                g.TranslateTransform((float)points[i].X' (float)points[i].Y);                              g.RotateTransform(-(angle % 360));                                g.Transform.TransformPoints(v);                              for (int j = 0; j < 4; j++)                              {                                  v[j].X = (float)(v[j].X / scaleFactor + viewBox.MinX);                                  v[j].Y = (float)(viewBox.MaxY - v[j].Y / scaleFactor);                              }                                FollowingTitleElement element =                                  new FollowingTitleElement(new PointF((float)points[i].X' (float)points[i].Y)'                                                            -(angle % 360)'                                                            new PointF(x0' -size.Height / 2)'                                                            label.Substring(startIndex' subStringLengths[i])'                                                            v[0]' v[1]' v[2]' v[3]);                                startIndex += subStringLengths[i];                                followingTitle.AddElement(element);                                g.ResetTransform();                          }                          return followingTitle.EnvelopePolygon == null ? null : followingTitle;                      }                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getLeftPoints,The following statement contains a magic number: for (int i = vertexNumber - 1; i >= 0; i--)              {                  double segmentLength = PlanimetryAlgorithms.Distance(previousPoint' points[i]);                  if (segmentLength + currentDistance > targetDistance)                  {                      double remainderDistance = targetDistance - currentDistance;                      double l = remainderDistance / (segmentLength - remainderDistance);                      ICoordinate lastPoint = PlanimetryEnvironment.NewCoordinate(                                      (previousPoint.X + l * points[i].X) / (1 + l)'                                      (previousPoint.Y + l * points[i].Y) / (1 + l));                      result.Add(lastPoint);                      rotationDeltas.Add(0);                      if (prePreviousPoint != previousPoint && previousPoint != lastPoint)                      {                          double angle = Math.PI - getAngle(prePreviousPoint' previousPoint' lastPoint' false);                          double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle < 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin);                          rotationDeltas[rotationDeltas.Count - 2] = delta;                      }                      break;                  }                  result.Add(points[i]);                  rotationDeltas.Add(0);                    if (prePreviousPoint != previousPoint && previousPoint != points[i])                  {                      double angle = Math.PI - getAngle(prePreviousPoint' previousPoint' points[i]' false);                      double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle < 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin);                      rotationDeltas[rotationDeltas.Count - 2] = delta;                      currentDistance -= delta * 2;                  }                    currentDistance += segmentLength;                  prePreviousPoint = previousPoint;                  previousPoint = points[i];              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getLeftPoints,The following statement contains a magic number: for (int i = vertexNumber - 1; i >= 0; i--)              {                  double segmentLength = PlanimetryAlgorithms.Distance(previousPoint' points[i]);                  if (segmentLength + currentDistance > targetDistance)                  {                      double remainderDistance = targetDistance - currentDistance;                      double l = remainderDistance / (segmentLength - remainderDistance);                      ICoordinate lastPoint = PlanimetryEnvironment.NewCoordinate(                                      (previousPoint.X + l * points[i].X) / (1 + l)'                                      (previousPoint.Y + l * points[i].Y) / (1 + l));                      result.Add(lastPoint);                      rotationDeltas.Add(0);                      if (prePreviousPoint != previousPoint && previousPoint != lastPoint)                      {                          double angle = Math.PI - getAngle(prePreviousPoint' previousPoint' lastPoint' false);                          double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle < 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin);                          rotationDeltas[rotationDeltas.Count - 2] = delta;                      }                      break;                  }                  result.Add(points[i]);                  rotationDeltas.Add(0);                    if (prePreviousPoint != previousPoint && previousPoint != points[i])                  {                      double angle = Math.PI - getAngle(prePreviousPoint' previousPoint' points[i]' false);                      double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle < 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin);                      rotationDeltas[rotationDeltas.Count - 2] = delta;                      currentDistance -= delta * 2;                  }                    currentDistance += segmentLength;                  prePreviousPoint = previousPoint;                  previousPoint = points[i];              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getLeftPoints,The following statement contains a magic number: for (int i = vertexNumber - 1; i >= 0; i--)              {                  double segmentLength = PlanimetryAlgorithms.Distance(previousPoint' points[i]);                  if (segmentLength + currentDistance > targetDistance)                  {                      double remainderDistance = targetDistance - currentDistance;                      double l = remainderDistance / (segmentLength - remainderDistance);                      ICoordinate lastPoint = PlanimetryEnvironment.NewCoordinate(                                      (previousPoint.X + l * points[i].X) / (1 + l)'                                      (previousPoint.Y + l * points[i].Y) / (1 + l));                      result.Add(lastPoint);                      rotationDeltas.Add(0);                      if (prePreviousPoint != previousPoint && previousPoint != lastPoint)                      {                          double angle = Math.PI - getAngle(prePreviousPoint' previousPoint' lastPoint' false);                          double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle < 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin);                          rotationDeltas[rotationDeltas.Count - 2] = delta;                      }                      break;                  }                  result.Add(points[i]);                  rotationDeltas.Add(0);                    if (prePreviousPoint != previousPoint && previousPoint != points[i])                  {                      double angle = Math.PI - getAngle(prePreviousPoint' previousPoint' points[i]' false);                      double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle < 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin);                      rotationDeltas[rotationDeltas.Count - 2] = delta;                      currentDistance -= delta * 2;                  }                    currentDistance += segmentLength;                  prePreviousPoint = previousPoint;                  previousPoint = points[i];              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRightPoints,The following statement contains a magic number: for (int i = vertexNumber; i < points.Count; i++)              {                  double segmentLength = PlanimetryAlgorithms.Distance(previousPoint' points[i]);                  if (segmentLength + currentDistance > targetDistance)                  {                      double remainderDistance = targetDistance - currentDistance;                      double l = remainderDistance / (segmentLength - remainderDistance);                      ICoordinate lastPoint = PlanimetryEnvironment.NewCoordinate(                                      (previousPoint.X + l * points[i].X) / (1 + l)'                                      (previousPoint.Y + l * points[i].Y) / (1 + l));                      result.Add(lastPoint);                      if (prePreviousPoint != previousPoint && previousPoint != lastPoint)                      {                          double angle = Math.PI - getAngle(prePreviousPoint' previousPoint' lastPoint' false);                          double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle > 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin);                          if (rotationDeltas.Count > 2)                              rotationDeltas[rotationDeltas.Count - 2] = delta;                      }                      break;                  }                  result.Add(points[i]);                  rotationDeltas.Add(0);                    if (prePreviousPoint != previousPoint && previousPoint != points[i])                  {                      double angle = Math.PI - getAngle(prePreviousPoint' previousPoint' points[i]' false);                      double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle > 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin);                      if (rotationDeltas.Count > 2)                          rotationDeltas[rotationDeltas.Count - 2] = delta;                      currentDistance -= delta * 2;                  }                  currentDistance += segmentLength;                  prePreviousPoint = previousPoint;                  previousPoint = points[i];              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRightPoints,The following statement contains a magic number: for (int i = vertexNumber; i < points.Count; i++)              {                  double segmentLength = PlanimetryAlgorithms.Distance(previousPoint' points[i]);                  if (segmentLength + currentDistance > targetDistance)                  {                      double remainderDistance = targetDistance - currentDistance;                      double l = remainderDistance / (segmentLength - remainderDistance);                      ICoordinate lastPoint = PlanimetryEnvironment.NewCoordinate(                                      (previousPoint.X + l * points[i].X) / (1 + l)'                                      (previousPoint.Y + l * points[i].Y) / (1 + l));                      result.Add(lastPoint);                      if (prePreviousPoint != previousPoint && previousPoint != lastPoint)                      {                          double angle = Math.PI - getAngle(prePreviousPoint' previousPoint' lastPoint' false);                          double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle > 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin);                          if (rotationDeltas.Count > 2)                              rotationDeltas[rotationDeltas.Count - 2] = delta;                      }                      break;                  }                  result.Add(points[i]);                  rotationDeltas.Add(0);                    if (prePreviousPoint != previousPoint && previousPoint != points[i])                  {                      double angle = Math.PI - getAngle(prePreviousPoint' previousPoint' points[i]' false);                      double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle > 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin);                      if (rotationDeltas.Count > 2)                          rotationDeltas[rotationDeltas.Count - 2] = delta;                      currentDistance -= delta * 2;                  }                  currentDistance += segmentLength;                  prePreviousPoint = previousPoint;                  previousPoint = points[i];              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRightPoints,The following statement contains a magic number: for (int i = vertexNumber; i < points.Count; i++)              {                  double segmentLength = PlanimetryAlgorithms.Distance(previousPoint' points[i]);                  if (segmentLength + currentDistance > targetDistance)                  {                      double remainderDistance = targetDistance - currentDistance;                      double l = remainderDistance / (segmentLength - remainderDistance);                      ICoordinate lastPoint = PlanimetryEnvironment.NewCoordinate(                                      (previousPoint.X + l * points[i].X) / (1 + l)'                                      (previousPoint.Y + l * points[i].Y) / (1 + l));                      result.Add(lastPoint);                      if (prePreviousPoint != previousPoint && previousPoint != lastPoint)                      {                          double angle = Math.PI - getAngle(prePreviousPoint' previousPoint' lastPoint' false);                          double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle > 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin);                          if (rotationDeltas.Count > 2)                              rotationDeltas[rotationDeltas.Count - 2] = delta;                      }                      break;                  }                  result.Add(points[i]);                  rotationDeltas.Add(0);                    if (prePreviousPoint != previousPoint && previousPoint != points[i])                  {                      double angle = Math.PI - getAngle(prePreviousPoint' previousPoint' points[i]' false);                      double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle > 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin);                      if (rotationDeltas.Count > 2)                          rotationDeltas[rotationDeltas.Count - 2] = delta;                      currentDistance -= delta * 2;                  }                  currentDistance += segmentLength;                  prePreviousPoint = previousPoint;                  previousPoint = points[i];              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRightPoints,The following statement contains a magic number: for (int i = vertexNumber; i < points.Count; i++)              {                  double segmentLength = PlanimetryAlgorithms.Distance(previousPoint' points[i]);                  if (segmentLength + currentDistance > targetDistance)                  {                      double remainderDistance = targetDistance - currentDistance;                      double l = remainderDistance / (segmentLength - remainderDistance);                      ICoordinate lastPoint = PlanimetryEnvironment.NewCoordinate(                                      (previousPoint.X + l * points[i].X) / (1 + l)'                                      (previousPoint.Y + l * points[i].Y) / (1 + l));                      result.Add(lastPoint);                      if (prePreviousPoint != previousPoint && previousPoint != lastPoint)                      {                          double angle = Math.PI - getAngle(prePreviousPoint' previousPoint' lastPoint' false);                          double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle > 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin);                          if (rotationDeltas.Count > 2)                              rotationDeltas[rotationDeltas.Count - 2] = delta;                      }                      break;                  }                  result.Add(points[i]);                  rotationDeltas.Add(0);                    if (prePreviousPoint != previousPoint && previousPoint != points[i])                  {                      double angle = Math.PI - getAngle(prePreviousPoint' previousPoint' points[i]' false);                      double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle > 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin);                      if (rotationDeltas.Count > 2)                          rotationDeltas[rotationDeltas.Count - 2] = delta;                      currentDistance -= delta * 2;                  }                  currentDistance += segmentLength;                  prePreviousPoint = previousPoint;                  previousPoint = points[i];              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRightPoints,The following statement contains a magic number: for (int i = vertexNumber; i < points.Count; i++)              {                  double segmentLength = PlanimetryAlgorithms.Distance(previousPoint' points[i]);                  if (segmentLength + currentDistance > targetDistance)                  {                      double remainderDistance = targetDistance - currentDistance;                      double l = remainderDistance / (segmentLength - remainderDistance);                      ICoordinate lastPoint = PlanimetryEnvironment.NewCoordinate(                                      (previousPoint.X + l * points[i].X) / (1 + l)'                                      (previousPoint.Y + l * points[i].Y) / (1 + l));                      result.Add(lastPoint);                      if (prePreviousPoint != previousPoint && previousPoint != lastPoint)                      {                          double angle = Math.PI - getAngle(prePreviousPoint' previousPoint' lastPoint' false);                          double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle > 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin);                          if (rotationDeltas.Count > 2)                              rotationDeltas[rotationDeltas.Count - 2] = delta;                      }                      break;                  }                  result.Add(points[i]);                  rotationDeltas.Add(0);                    if (prePreviousPoint != previousPoint && previousPoint != points[i])                  {                      double angle = Math.PI - getAngle(prePreviousPoint' previousPoint' points[i]' false);                      double delta = halfFontHeight * Math.Tan(Math.Abs(angle)) * (angle > 0 ? _labelRotationDeltaMax : _labelRotationDeltaMin);                      if (rotationDeltas.Count > 2)                          rotationDeltas[rotationDeltas.Count - 2] = delta;                      currentDistance -= delta * 2;                  }                  currentDistance += segmentLength;                  prePreviousPoint = previousPoint;                  previousPoint = points[i];              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getAngle,The following statement contains a magic number: double alpha = p1.X != 0 ? Math.Atan(Math.Abs(p1.Y / p1.X)) : 0.5 * Math.PI;
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getAngle,The following statement contains a magic number: double betta = p3.X != 0 ? Math.Atan(Math.Abs(p3.Y / p3.X)) : 0.5 * Math.PI;
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getAngle,The following statement contains a magic number: if (counterClockwise)                  return alpha < betta ? (betta - alpha) : (2 * Math.PI - alpha + betta);              else                  return alpha > betta ? (alpha - betta) : (2 * Math.PI - betta + alpha);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getAngle,The following statement contains a magic number: if (counterClockwise)                  return alpha < betta ? (betta - alpha) : (2 * Math.PI - alpha + betta);              else                  return alpha > betta ? (alpha - betta) : (2 * Math.PI - betta + alpha);
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,translateAngleQuadrant,The following statement contains a magic number: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return 2 * Math.PI - angle; }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,translateAngleQuadrant,The following statement contains a magic number: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return 2 * Math.PI - angle; }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,translateAngleQuadrant,The following statement contains a magic number: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return 2 * Math.PI - angle; }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,translateAngleQuadrant,The following statement contains a magic number: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return 2 * Math.PI - angle; }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,pointQuadrantNumber,The following statement contains a magic number: if (p.X > 0)              {                  if (p.Y > 0) return 1; else return 4;              }              else              {                  if (p.Y > 0) return 2; else return 3;              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,pointQuadrantNumber,The following statement contains a magic number: if (p.X > 0)              {                  if (p.Y > 0) return 1; else return 4;              }              else              {                  if (p.Y > 0) return 2; else return 3;              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,pointQuadrantNumber,The following statement contains a magic number: if (p.X > 0)              {                  if (p.Y > 0) return 1; else return 4;              }              else              {                  if (p.Y > 0) return 2; else return 3;              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRelativeDashSize,The following statement contains a magic number: switch (pen.DashStyle)              {                  case DashStyle.Dot:                      relativeDashSize = 2;                      break;                    case DashStyle.Dash:                      relativeDashSize = 4;                      break;                    case DashStyle.DashDot:                      relativeDashSize = 6;                      break;                    case DashStyle.DashDotDot:                      relativeDashSize = 8;                      break;                    case DashStyle.Custom:                      relativeDashSize = 0;                      foreach (float d in pen.DashPattern)                          relativeDashSize += d;                      break;              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRelativeDashSize,The following statement contains a magic number: switch (pen.DashStyle)              {                  case DashStyle.Dot:                      relativeDashSize = 2;                      break;                    case DashStyle.Dash:                      relativeDashSize = 4;                      break;                    case DashStyle.DashDot:                      relativeDashSize = 6;                      break;                    case DashStyle.DashDotDot:                      relativeDashSize = 8;                      break;                    case DashStyle.Custom:                      relativeDashSize = 0;                      foreach (float d in pen.DashPattern)                          relativeDashSize += d;                      break;              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRelativeDashSize,The following statement contains a magic number: switch (pen.DashStyle)              {                  case DashStyle.Dot:                      relativeDashSize = 2;                      break;                    case DashStyle.Dash:                      relativeDashSize = 4;                      break;                    case DashStyle.DashDot:                      relativeDashSize = 6;                      break;                    case DashStyle.DashDotDot:                      relativeDashSize = 8;                      break;                    case DashStyle.Custom:                      relativeDashSize = 0;                      foreach (float d in pen.DashPattern)                          relativeDashSize += d;                      break;              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRelativeDashSize,The following statement contains a magic number: switch (pen.DashStyle)              {                  case DashStyle.Dot:                      relativeDashSize = 2;                      break;                    case DashStyle.Dash:                      relativeDashSize = 4;                      break;                    case DashStyle.DashDot:                      relativeDashSize = 6;                      break;                    case DashStyle.DashDotDot:                      relativeDashSize = 8;                      break;                    case DashStyle.Custom:                      relativeDashSize = 0;                      foreach (float d in pen.DashPattern)                          relativeDashSize += d;                      break;              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPolylineWithIntersectCalculation,The following statement contains a magic number: using (Pen pen = style.GetPen())              {                  using(Pen annexPen = style.GetAnnexPen())                  foreach (LinePath path in feature.Polyline.Paths)                  {                      if (path.Vertices.Count < 2)                          continue;                        currentPath.Clear();                      double currentLength = 0;                      bool isInternalPath = viewBox.ContainsPoint(path.Vertices[0]);                      ICoordinate previousPoint = path.Vertices[0];                      IList<ICoordinate> vertices = path.Vertices;                        for (int j = 0; j < path.Vertices.Count; j++)                      {                          if (isInternalPath) // the inside of the polyline                          {                              if (viewBox.ContainsPoint(vertices[j])) //stay inside                              {                                  currentPath.Add(vertices[j]);                                  continue;                              }                              else // go outside                              {                                  // add a point of intersection                                  List<ICoordinate> crossPoints = getCrossPoints(vertices[j]' vertices[j - 1]' viewBox);                                  currentPath.Add(crossPoints[0]);                                    //draw                                  drawVisiblePolylinePartWithStyleDetection(g' currentPath' style' pen' annexPen' feature.Selected' viewBox' scaleFactor' currentLength);                                    // are counting the length of a past                                  currentLength += getPathLength(currentPath);                                    // initialize the array outside of the points' polylines and continue execution                                  currentPath.Clear();                                  currentPath.Add(crossPoints[0]);                                  currentPath.Add(vertices[j]);                                  isInternalPath = false;                                  continue;                              }                          }                          else //the outer part of the polyline                          {                              if (viewBox.ContainsPoint(vertices[j])) // go inside                              {                                  //add a point of intersection                                  List<ICoordinate> crossPoints = getCrossPoints(vertices[j]' vertices[j - 1]' viewBox);                                  currentPath.Add(crossPoints[0]);                                    //are counting the length of a past                                  currentLength += getPathLength(currentPath);                                    // initialize the array of points inside the polyline and continue execution                                  currentPath.Clear();                                  currentPath.Add(crossPoints[0]);                                  currentPath.Add(vertices[j]);                                  isInternalPath = true;                                  continue;                              }                              else // cross twice' or remain outside                              {                                  // look for the point of intersection                                  if (j > 0)                                  {                                      List<ICoordinate> crossPoints = getCrossPoints(vertices[j]' vertices[j - 1]' viewBox);                                      if (crossPoints.Count == 0) // remained outside                                      {                                          currentPath.Add(vertices[j]);                                          continue;                                      }                                      if (crossPoints.Count == 2) // crossed 2 times                                      {                                          //determine which of the points of intersection must be added to the current path                                          double d0 = PlanimetryAlgorithms.Distance(crossPoints[0]' vertices[j - 1]);                                          double d1 = PlanimetryAlgorithms.Distance(crossPoints[1]' vertices[j - 1]);                                          if (d0 < d1)                                              currentPath.Add(crossPoints[0]);                                          else                                              currentPath.Add(crossPoints[1]);                                            // are counting the length of a past                                          currentLength += getPathLength(currentPath);                                            currentPath.Clear();                                            currentPath.Add(crossPoints[d0 < d1 ? 0 : 1]);                                          currentPath.Add(crossPoints[d0 < d1 ? 1 : 0]);                                            //draw a segment                                          drawVisiblePolylinePartWithStyleDetection(g' currentPath' style' pen' annexPen' feature.Selected' viewBox' scaleFactor' currentLength);                                          // consider the length                                          currentLength += PlanimetryAlgorithms.Distance(crossPoints[0]' crossPoints[1]);                                            // initialize the external part of the polyline                                          currentPath.Clear();                                          if (d0 < d1)                                              currentPath.Add(crossPoints[1]);                                          else                                              currentPath.Add(crossPoints[0]);                                          currentPath.Add(vertices[j]);                                          isInternalPath = false;                                          continue;                                      }                                  }                                  else // 1st point you just need to add to the list                                  {                                      currentPath.Add(vertices[j]);                                      continue;                                  }                              }                          }                      }                        //Draw a polyline part' if the internal                      if (isInternalPath)                          drawVisiblePolylinePartWithStyleDetection(g' currentPath' style' pen' annexPen' feature.Selected' viewBox' scaleFactor' currentLength);                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPolylineWithIntersectCalculation,The following statement contains a magic number: using (Pen pen = style.GetPen())              {                  using(Pen annexPen = style.GetAnnexPen())                  foreach (LinePath path in feature.Polyline.Paths)                  {                      if (path.Vertices.Count < 2)                          continue;                        currentPath.Clear();                      double currentLength = 0;                      bool isInternalPath = viewBox.ContainsPoint(path.Vertices[0]);                      ICoordinate previousPoint = path.Vertices[0];                      IList<ICoordinate> vertices = path.Vertices;                        for (int j = 0; j < path.Vertices.Count; j++)                      {                          if (isInternalPath) // the inside of the polyline                          {                              if (viewBox.ContainsPoint(vertices[j])) //stay inside                              {                                  currentPath.Add(vertices[j]);                                  continue;                              }                              else // go outside                              {                                  // add a point of intersection                                  List<ICoordinate> crossPoints = getCrossPoints(vertices[j]' vertices[j - 1]' viewBox);                                  currentPath.Add(crossPoints[0]);                                    //draw                                  drawVisiblePolylinePartWithStyleDetection(g' currentPath' style' pen' annexPen' feature.Selected' viewBox' scaleFactor' currentLength);                                    // are counting the length of a past                                  currentLength += getPathLength(currentPath);                                    // initialize the array outside of the points' polylines and continue execution                                  currentPath.Clear();                                  currentPath.Add(crossPoints[0]);                                  currentPath.Add(vertices[j]);                                  isInternalPath = false;                                  continue;                              }                          }                          else //the outer part of the polyline                          {                              if (viewBox.ContainsPoint(vertices[j])) // go inside                              {                                  //add a point of intersection                                  List<ICoordinate> crossPoints = getCrossPoints(vertices[j]' vertices[j - 1]' viewBox);                                  currentPath.Add(crossPoints[0]);                                    //are counting the length of a past                                  currentLength += getPathLength(currentPath);                                    // initialize the array of points inside the polyline and continue execution                                  currentPath.Clear();                                  currentPath.Add(crossPoints[0]);                                  currentPath.Add(vertices[j]);                                  isInternalPath = true;                                  continue;                              }                              else // cross twice' or remain outside                              {                                  // look for the point of intersection                                  if (j > 0)                                  {                                      List<ICoordinate> crossPoints = getCrossPoints(vertices[j]' vertices[j - 1]' viewBox);                                      if (crossPoints.Count == 0) // remained outside                                      {                                          currentPath.Add(vertices[j]);                                          continue;                                      }                                      if (crossPoints.Count == 2) // crossed 2 times                                      {                                          //determine which of the points of intersection must be added to the current path                                          double d0 = PlanimetryAlgorithms.Distance(crossPoints[0]' vertices[j - 1]);                                          double d1 = PlanimetryAlgorithms.Distance(crossPoints[1]' vertices[j - 1]);                                          if (d0 < d1)                                              currentPath.Add(crossPoints[0]);                                          else                                              currentPath.Add(crossPoints[1]);                                            // are counting the length of a past                                          currentLength += getPathLength(currentPath);                                            currentPath.Clear();                                            currentPath.Add(crossPoints[d0 < d1 ? 0 : 1]);                                          currentPath.Add(crossPoints[d0 < d1 ? 1 : 0]);                                            //draw a segment                                          drawVisiblePolylinePartWithStyleDetection(g' currentPath' style' pen' annexPen' feature.Selected' viewBox' scaleFactor' currentLength);                                          // consider the length                                          currentLength += PlanimetryAlgorithms.Distance(crossPoints[0]' crossPoints[1]);                                            // initialize the external part of the polyline                                          currentPath.Clear();                                          if (d0 < d1)                                              currentPath.Add(crossPoints[1]);                                          else                                              currentPath.Add(crossPoints[0]);                                          currentPath.Add(vertices[j]);                                          isInternalPath = false;                                          continue;                                      }                                  }                                  else // 1st point you just need to add to the list                                  {                                      currentPath.Add(vertices[j]);                                      continue;                                  }                              }                          }                      }                        //Draw a polyline part' if the internal                      if (isInternalPath)                          drawVisiblePolylinePartWithStyleDetection(g' currentPath' style' pen' annexPen' feature.Selected' viewBox' scaleFactor' currentLength);                  }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawLinePathSelectionAndOutline,The following statement contains a magic number: if (selected)              {                  // allocation                  float w = style.Width + (style.UseOutline ? style.OutlineWidth * 2 + 2 : 3);                  using (Pen p = new Pen(_selectionColor' w))                  {                      p.MiterLimit = 3;                      g.DrawLines(p' pathPoints);                  }              }              else              {                  // Stroke                  if (style.UseOutline)                      using (Pen p = style.GetOutlinePen())                      {                          p.MiterLimit = 3;                          g.DrawLines(p' pathPoints);                      }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawLinePathSelectionAndOutline,The following statement contains a magic number: if (selected)              {                  // allocation                  float w = style.Width + (style.UseOutline ? style.OutlineWidth * 2 + 2 : 3);                  using (Pen p = new Pen(_selectionColor' w))                  {                      p.MiterLimit = 3;                      g.DrawLines(p' pathPoints);                  }              }              else              {                  // Stroke                  if (style.UseOutline)                      using (Pen p = style.GetOutlinePen())                      {                          p.MiterLimit = 3;                          g.DrawLines(p' pathPoints);                      }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawLinePathSelectionAndOutline,The following statement contains a magic number: if (selected)              {                  // allocation                  float w = style.Width + (style.UseOutline ? style.OutlineWidth * 2 + 2 : 3);                  using (Pen p = new Pen(_selectionColor' w))                  {                      p.MiterLimit = 3;                      g.DrawLines(p' pathPoints);                  }              }              else              {                  // Stroke                  if (style.UseOutline)                      using (Pen p = style.GetOutlinePen())                      {                          p.MiterLimit = 3;                          g.DrawLines(p' pathPoints);                      }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawLinePathSelectionAndOutline,The following statement contains a magic number: if (selected)              {                  // allocation                  float w = style.Width + (style.UseOutline ? style.OutlineWidth * 2 + 2 : 3);                  using (Pen p = new Pen(_selectionColor' w))                  {                      p.MiterLimit = 3;                      g.DrawLines(p' pathPoints);                  }              }              else              {                  // Stroke                  if (style.UseOutline)                      using (Pen p = style.GetOutlinePen())                      {                          p.MiterLimit = 3;                          g.DrawLines(p' pathPoints);                      }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawLinePathSelectionAndOutline,The following statement contains a magic number: if (selected)              {                  // allocation                  float w = style.Width + (style.UseOutline ? style.OutlineWidth * 2 + 2 : 3);                  using (Pen p = new Pen(_selectionColor' w))                  {                      p.MiterLimit = 3;                      g.DrawLines(p' pathPoints);                  }              }              else              {                  // Stroke                  if (style.UseOutline)                      using (Pen p = style.GetOutlinePen())                      {                          p.MiterLimit = 3;                          g.DrawLines(p' pathPoints);                      }              }
Magic Number,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,drawPolylineSimple,The following statement contains a magic number: foreach (LinePath path in feature.Polyline.Paths)              {                  if (path.Vertices.Count < 2)                      continue;                    PointF[] points = new PointF[path.Vertices.Count];                    for (int j = 0; j < path.Vertices.Count; j++)                  {                      points[j].X = (float)((path.Vertices[j].X - viewBox.MinX) * scaleFactor);                      points[j].Y = (float)((viewBox.MaxY - path.Vertices[j].Y) * scaleFactor);                  }                    //selection and Stroke                  if (style.UseOutline || feature.Selected)                      drawLinePathSelectionAndOutline(g' feature.Selected' points' style);                    using (Pen pen = style.GetPen())                  {                      pen.DashOffset = 0;                        //main polyline                      g.DrawLines(pen' points);                      if (style.UseAnnexLine)                          using (Pen annexPen = style.GetAnnexPen())                          {                              // additional line                              g.DrawLines(annexPen' points);                          }                  }              }
Magic Number,MapAround.Mapping,TitleBufferElement,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,intersectsWithComplexTitle,The following statement contains a magic number: Segment[] segments = new Segment[4]                  {                      new Segment(_box.V1' PlanimetryEnvironment.NewCoordinate(_box.V1.X' _box.V2.Y))'                      new Segment(PlanimetryEnvironment.NewCoordinate(_box.V1.X' _box.V2.Y)' _box.V2)'                      new Segment(_box.V2' PlanimetryEnvironment.NewCoordinate(_box.V2.X' _box.V1.Y))'                      new Segment(PlanimetryEnvironment.NewCoordinate(_box.V2.X' _box.V1.Y)' _box.V1)                  };
Magic Number,MapAround.Mapping,TitleBufferElement,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,intersectsWithComplexTitle,The following statement contains a magic number: foreach (Contour c in complexOne._followingTitle.EnvelopePolygon.Contours)                  {                      Segment segment1 = new Segment(c.Vertices[0]' c.Vertices[1]);                      Segment segment2 = new Segment(c.Vertices[2]' c.Vertices[3]);                      for(int i = 0; i < 4; i++)                          if (PlanimetryAlgorithms.SegmentsIntersection(segment1' segments[i]' out pointStub' out segmentStub) != Dimension.None ||                              PlanimetryAlgorithms.SegmentsIntersection(segment2' segments[i]' out pointStub' out segmentStub) != Dimension.None)                              return true;                  }
Magic Number,MapAround.Mapping,TitleBufferElement,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,intersectsWithComplexTitle,The following statement contains a magic number: foreach (Contour c in complexOne._followingTitle.EnvelopePolygon.Contours)                  {                      Segment segment1 = new Segment(c.Vertices[0]' c.Vertices[1]);                      Segment segment2 = new Segment(c.Vertices[2]' c.Vertices[3]);                      for(int i = 0; i < 4; i++)                          if (PlanimetryAlgorithms.SegmentsIntersection(segment1' segments[i]' out pointStub' out segmentStub) != Dimension.None ||                              PlanimetryAlgorithms.SegmentsIntersection(segment2' segments[i]' out pointStub' out segmentStub) != Dimension.None)                              return true;                  }
Magic Number,MapAround.Mapping,TitleBufferElement,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,intersectsWithComplexTitle,The following statement contains a magic number: foreach (Contour c in complexOne._followingTitle.EnvelopePolygon.Contours)                  {                      Segment segment1 = new Segment(c.Vertices[0]' c.Vertices[1]);                      Segment segment2 = new Segment(c.Vertices[2]' c.Vertices[3]);                      for(int i = 0; i < 4; i++)                          if (PlanimetryAlgorithms.SegmentsIntersection(segment1' segments[i]' out pointStub' out segmentStub) != Dimension.None ||                              PlanimetryAlgorithms.SegmentsIntersection(segment2' segments[i]' out pointStub' out segmentStub) != Dimension.None)                              return true;                  }
Magic Number,MapAround.Mapping,TitleBufferElement,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,contoursIntersect,The following statement contains a magic number: Segment segment2 = new Segment(c1.Vertices[2]' c1.Vertices[3]);
Magic Number,MapAround.Mapping,TitleBufferElement,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,contoursIntersect,The following statement contains a magic number: Segment segment2 = new Segment(c1.Vertices[2]' c1.Vertices[3]);
Magic Number,MapAround.Mapping,TitleBufferElement,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,contoursIntersect,The following statement contains a magic number: Segment segment4 = new Segment(c2.Vertices[3]' c2.Vertices[3]);
Magic Number,MapAround.Mapping,TitleBufferElement,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,contoursIntersect,The following statement contains a magic number: Segment segment4 = new Segment(c2.Vertices[3]' c2.Vertices[3]);
Magic Number,MapAround.Mapping,RenderingUtils,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: byte alpha = (byte)(pixelData2 >> 24 & 0xFF);
Magic Number,MapAround.Mapping,RenderingUtils,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: if (alpha == 255) return pixelData2;
Magic Number,MapAround.Mapping,RenderingUtils,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: byte oldAlpha = (byte)((oldPixelData >> 24 & 0xFF));
Magic Number,MapAround.Mapping,RenderingUtils,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: Int32 b1 = newAlpha << 24;
Magic Number,MapAround.Mapping,RenderingUtils,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData2 >> 16 & 0xFF) * a1) << 16;
Magic Number,MapAround.Mapping,RenderingUtils,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData2 >> 16 & 0xFF) * a1) << 16;
Magic Number,MapAround.Mapping,RenderingUtils,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData2 >> 16 & 0xFF) * a1) << 16;
Magic Number,MapAround.Mapping,RenderingUtils,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData2 >> 8 & 0xFF) * a1) << 8;
Magic Number,MapAround.Mapping,RenderingUtils,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData2 >> 8 & 0xFF) * a1) << 8;
Magic Number,MapAround.Mapping,RenderingUtils,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,BlendPixels,The following statement contains a magic number: Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData2 >> 8 & 0xFF) * a1) << 8;
Magic Number,MapAround.MathUtils,Radians,C:\repos\gkrsu_maparound.core\src\MapAround.Core\MathUtils\MathUtils.cs,ToDegrees,The following statement contains a magic number: return radians * 57.295779513082320876798154814105;
Magic Number,MapAround.MathUtils,Degrees,C:\repos\gkrsu_maparound.core\src\MapAround.Core\MathUtils\MathUtils.cs,ToRadians,The following statement contains a magic number: return degrees / 57.295779513082320876798154814105;
Magic Number,MapAround.MathUtils,SvdDecomposer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\MathUtils\MathUtils.cs,svdLeastSquares,The following statement contains a magic number: for (j = 0; j < n; j++)              {                  s = 0.0;                  if (Math.Abs(w[j]) > 1e-7)                  {                      for (i = 0; i < m; i++)                          s += U[i' j] * b[i];                        s /= w[j];                  }                  tmp[j] = s;              }
Magic Number,MapAround.MathUtils,SvdDecomposer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\MathUtils\MathUtils.cs,CalcDecomposition,The following statement contains a magic number: for (kk = n; kk > 0; kk--)              {                  k = kk - 1;                  k1 = k - 1;                  its = 0;                  // Οπξβεπκΰ βξημξζνξρςθ πΰρωεολενθ                    splittingTest:                    for (ll = k + 1; ll > 0; ll--)                  {                      l = ll - 1;                      l1 = l - 1;                      if (Math.Abs(rv1[l]) + anorm == anorm) goto convergenceTest;                      // rv1[0] βρεγδΰ πΰβνξ νσλώ' οξύςξμσ                      // βϋυξδΰ χεπεη κξνεφ φθκλΰ νε ασδες                       if (Math.Abs(w[l1]) + anorm == anorm) break;                  }                  // Ερλθ l αξλόψε χεμ 0' ςξ rv1[l] οπθρβΰθβΰεςρ νσλεβξε ηνΰχενθε                    c = 0;                  s = 1;                    for (i = l; i <= k; i++)                  {                      f = s * rv1[i];                      rv1[i] *= c;                        if (Math.Abs(f) + anorm == anorm) goto convergenceTest;                        g = w[i];                      h = Math.Sqrt(f * f + g * g);                      //assert(h > 0);                      w[i] = h;                      c = g / h;                      s = -f / h;                      if (matu > 0)                          for (j = 0; j < m; j++)                          {                              y = U[j' l1];                              z = U[j' i];                              U[j' l1] = y * c + z * s;                              U[j' i] = -y * s + z * c;                          }                  }                       // Οπξβεπκΰ ρυξδθμξρςθ                    convergenceTest:                    z = w[k];                    if (l != k)                  {                      // ρδβθγ βϋαθπΰεςρ θη νθζνεγξ σγλξβξγξ μθνξπΰ οξπδκΰ 2                      if (its == 30)                      {                          ierr = k;                          break;                      }                      its++;                      x = w[l];                      y = w[k1];                      g = rv1[k1];                      h = rv1[k];                      f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);                      g = Math.Sqrt(f * f + 1.0);                      f = ((x - z) * (x + z) + h * (y / (f + dSign(g' f)) - h)) / x;                        // QR-οπεξαπΰηξβΰνθε                      c = 1.0;                      s = 1.0;                        for (i1 = l; i1 <= k1; i1++)                      {                          i = i1 + 1;                          g = rv1[i];                          y = w[i];                          h = s * g;                          g = c * g;                          z = Math.Sqrt(f * f + h * h);                          rv1[i1] = z;                          c = f / z;                          s = h / z;                          f = x * c + g * s;                          g = -x * s + g * c;                          h = y * s;                          y = y * c;                          if (matv > 0)                              for (j = 0; j < n; j++)                              {                                  x = V[j' i1];                                  z = V[j' i];                                  V[j' i1] = x * c + z * s;                                  V[j' i] = -x * s + z * c;                              }                            z = Math.Sqrt(f * f + h * h);                          //assert(z > 0);                          w[i1] = z;                            // βπΰωενθε μξζες αϋςό οπξθηβξλόνϋμ' ερλθ z πΰβνξ νσλώ                            if (z != 0.0)                          {                              c = f / z;                              s = h / z;                          }                            f = c * g + s * y;                          x = -s * g + c * y;                            if (matu > 0)                                for (j = 0; j < m; j++)                              {                                  y = U[j' i1];                                  z = U[j' i];                                  U[j' i1] = y * c + z * s;                                  U[j' i] = -y * s + z * c;                              }                        }                        rv1[l] = 0;                      rv1[k] = f;                      w[k] = x;                      goto splittingTest;                  }                    // Ρυξδθμξρςό                    if (z < 0)                  {                      // w[k] δελΰεςρ νεξςπθφΰςελόνϋμ                      w[k] = -z;                      if (matv > 0)                          for (j = 0; j < n; j++)                              V[j' k] = -V[j' k];                  }              }
Magic Number,MapAround.MathUtils,SvdDecomposer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\MathUtils\MathUtils.cs,CalcDecomposition,The following statement contains a magic number: for (kk = n; kk > 0; kk--)              {                  k = kk - 1;                  k1 = k - 1;                  its = 0;                  // Οπξβεπκΰ βξημξζνξρςθ πΰρωεολενθ                    splittingTest:                    for (ll = k + 1; ll > 0; ll--)                  {                      l = ll - 1;                      l1 = l - 1;                      if (Math.Abs(rv1[l]) + anorm == anorm) goto convergenceTest;                      // rv1[0] βρεγδΰ πΰβνξ νσλώ' οξύςξμσ                      // βϋυξδΰ χεπεη κξνεφ φθκλΰ νε ασδες                       if (Math.Abs(w[l1]) + anorm == anorm) break;                  }                  // Ερλθ l αξλόψε χεμ 0' ςξ rv1[l] οπθρβΰθβΰεςρ νσλεβξε ηνΰχενθε                    c = 0;                  s = 1;                    for (i = l; i <= k; i++)                  {                      f = s * rv1[i];                      rv1[i] *= c;                        if (Math.Abs(f) + anorm == anorm) goto convergenceTest;                        g = w[i];                      h = Math.Sqrt(f * f + g * g);                      //assert(h > 0);                      w[i] = h;                      c = g / h;                      s = -f / h;                      if (matu > 0)                          for (j = 0; j < m; j++)                          {                              y = U[j' l1];                              z = U[j' i];                              U[j' l1] = y * c + z * s;                              U[j' i] = -y * s + z * c;                          }                  }                       // Οπξβεπκΰ ρυξδθμξρςθ                    convergenceTest:                    z = w[k];                    if (l != k)                  {                      // ρδβθγ βϋαθπΰεςρ θη νθζνεγξ σγλξβξγξ μθνξπΰ οξπδκΰ 2                      if (its == 30)                      {                          ierr = k;                          break;                      }                      its++;                      x = w[l];                      y = w[k1];                      g = rv1[k1];                      h = rv1[k];                      f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);                      g = Math.Sqrt(f * f + 1.0);                      f = ((x - z) * (x + z) + h * (y / (f + dSign(g' f)) - h)) / x;                        // QR-οπεξαπΰηξβΰνθε                      c = 1.0;                      s = 1.0;                        for (i1 = l; i1 <= k1; i1++)                      {                          i = i1 + 1;                          g = rv1[i];                          y = w[i];                          h = s * g;                          g = c * g;                          z = Math.Sqrt(f * f + h * h);                          rv1[i1] = z;                          c = f / z;                          s = h / z;                          f = x * c + g * s;                          g = -x * s + g * c;                          h = y * s;                          y = y * c;                          if (matv > 0)                              for (j = 0; j < n; j++)                              {                                  x = V[j' i1];                                  z = V[j' i];                                  V[j' i1] = x * c + z * s;                                  V[j' i] = -x * s + z * c;                              }                            z = Math.Sqrt(f * f + h * h);                          //assert(z > 0);                          w[i1] = z;                            // βπΰωενθε μξζες αϋςό οπξθηβξλόνϋμ' ερλθ z πΰβνξ νσλώ                            if (z != 0.0)                          {                              c = f / z;                              s = h / z;                          }                            f = c * g + s * y;                          x = -s * g + c * y;                            if (matu > 0)                                for (j = 0; j < m; j++)                              {                                  y = U[j' i1];                                  z = U[j' i];                                  U[j' i1] = y * c + z * s;                                  U[j' i] = -y * s + z * c;                              }                        }                        rv1[l] = 0;                      rv1[k] = f;                      w[k] = x;                      goto splittingTest;                  }                    // Ρυξδθμξρςό                    if (z < 0)                  {                      // w[k] δελΰεςρ νεξςπθφΰςελόνϋμ                      w[k] = -z;                      if (matv > 0)                          for (j = 0; j < n; j++)                              V[j' k] = -V[j' k];                  }              }
Magic Number,MapAround.Geography,UnitSphere,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,LatLonToGeocentric,The following statement contains a magic number: if (Math.Abs(latRad) > Math.PI / 2)                  throw new ArgumentOutOfRangeException("Math.Abs(latitudeRad) > Math.PI / 2");
Magic Number,MapAround.Geography,GnomonicProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,getMinEntryIndex,The following statement contains a magic number: if (Math.Abs(values[2]) < Math.Abs(values[i]))                  i = 2;
Magic Number,MapAround.Geography,GnomonicProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,getMinEntryIndex,The following statement contains a magic number: if (Math.Abs(values[2]) < Math.Abs(values[i]))                  i = 2;
Magic Number,MapAround.Geography,GnomonicProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,Project,The following statement contains a magic number: if (r < 1e-8)                  throw new ArgumentOutOfRangeException("The point is located too far from the center of projection");
Magic Number,MapAround.Geography,GnomonicProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,GetCenter,The following statement contains a magic number: if (latLonSequence.Length % 2 != 0)                  throw new ArgumentException("The array should contain an even number of elements"' "values");
Magic Number,MapAround.Geography,GnomonicProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,GetCenter,The following statement contains a magic number: int n = latLonSequence.Length / 2;
Magic Number,MapAround.Geography,GnomonicProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,GetCenter,The following statement contains a magic number: for (int i = 0; i < latLonSequence.Length; i += 2)              {                  Vector3 v = UnitSphere.LatLonToGeocentric(latLonSequence[i]' latLonSequence[i + 1]);                  x += v.X / n;                  y += v.Y / n;                  z += v.Z / n;              }
Magic Number,MapAround.Geography,GnomonicProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,GetCenter,The following statement contains a magic number: double[] latLonSequence = new double[count * 2];
Magic Number,MapAround.Geography,GnomonicProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,GnomonicProjection,The following statement contains a magic number: double[] vector = new double[3];
Magic Number,MapAround.Geography,GnomonicProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,GnomonicProjection,The following statement contains a magic number: int j = (k + 2) % 3;
Magic Number,MapAround.Geography,GnomonicProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,GnomonicProjection,The following statement contains a magic number: int j = (k + 2) % 3;
Magic Number,MapAround.Geography,GnomonicProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,GnomonicProjection,The following statement contains a magic number: int i = (j + 2) % 3;
Magic Number,MapAround.Geography,GnomonicProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,GnomonicProjection,The following statement contains a magic number: int i = (j + 2) % 3;
Magic Number,MapAround.Geography,GnomonicProjection,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,GnomonicProjection,The following statement contains a magic number: _xAxis = (new Vector3(vector[0]' vector[1]' vector[2])).Unitize();
Magic Number,MapAround.Geography,Vector3,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,Angle,The following statement contains a magic number: return 2 * Math.Asin(this.Distance(a) / (2 * a.Length()));
Magic Number,MapAround.Geography,Vector3,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticAlgorithms.cs,Angle,The following statement contains a magic number: return 2 * Math.Asin(this.Distance(a) / (2 * a.Length()));
Magic Number,MapAround.Geography,GeoPath,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,Reverse,The following statement contains a magic number: for (int i = 0' j = Vertices.Count - 1; i < Vertices.Count / 2; i++' j--)              {                  GeoPoint temp = Vertices[i];                  Vertices[i] = Vertices[j];                  Vertices[j] = temp;              }
Magic Number,MapAround.Geography,GeoContour,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,Reverse,The following statement contains a magic number: for (int i = 0' j = Vertices.Count - 1; i < Vertices.Count / 2; i++' j--)              {                  GeoPoint temp = Vertices[i];                  Vertices[i] = Vertices[j];                  Vertices[j] = temp;              }
Magic Number,MapAround.Geography,GeoContour,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,PlaneAreaInLambertProjection,The following statement contains a magic number: double qp = 1 + 0.5 * (1 - e * e) / e * Math.Log((1 + e) / (1 - e));
Magic Number,MapAround.Geography,GeoContour,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,PlaneAreaInLambertProjection,The following statement contains a magic number: foreach (GeoPoint p in c.Vertices)              {                  double sinPhi = Math.Sin(p.Phi);                  double q = (1 - e * e) *                       (sinPhi / (1 - e * e * sinPhi * sinPhi) -                        0.5 / e * Math.Log((1 - e * sinPhi) / (1 + e * sinPhi)));                    p.Phi = Math.Asin(q / qp);                    vectors.Add(UnitSphere.LatLonToGeocentric(p.Phi' p.L));              }
Magic Number,MapAround.Geography,GeoContour,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,PlaneAreaInLambertProjection,The following statement contains a magic number: double rq = a * Math.Sqrt(0.5 * qp);
Magic Number,MapAround.Geography,GeoContour,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,PlaneAreaInLambertProjection,The following statement contains a magic number: foreach (Vector3 v in vectors)              {                  double f = Math.Sqrt(2 / (1 + sign * v.Z));                  planeContour.Vertices.Add(PlanimetryEnvironment.NewCoordinate(f * v.X * rq' f * v.Y * rq));              }
Magic Number,MapAround.Geography,GeoContour,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,Area,The following statement contains a magic number: return EllipticAlgorithms.Ellipsoid.SurfaceArea() / (4 * Math.PI * aa) * planeArea;
Magic Number,MapAround.Geography,GeoPolygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\EllipticGeometries.cs,Area,The following statement contains a magic number: return EllipticAlgorithms.Ellipsoid.SurfaceArea() / (4 * Math.PI * aa) * planeArea;
Magic Number,MapAround.Geography,GeoBufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeoBuffer.cs,mergePartialBuffers,The following statement contains a magic number: while (buffers.Count > 1)              {                  List<Polygon> tempBuffers = new List<Polygon>();                  for (int i = 0; i < buffers.Count; i += 2)                  {                      if (i + 1 == buffers.Count)                          tempBuffers.Add(buffers[i]);                      else                      {                          gc = buffers[i].Union(buffers[i + 1]);                          if (gc.Count > 0)                              temp = (Polygon)((GeometryCollection)gc)[0];                          tempBuffers.Add(temp);                      }                  }                  buffers = tempBuffers;              }
Magic Number,MapAround.Geography,GeoBufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeoBuffer.cs,mergePartialBuffers,The following statement contains a magic number: if (!allowParallels || buffers.Count < 20)                  return mergePartialBuffers(buffers);              else              {                  Thread t = new Thread(mergePartialBuffers);                  List<Polygon> buffersForAnotherThread = new List<Polygon>();                  List<Polygon> buffersForThisThread = new List<Polygon>();                  for (int i = 0; i < buffers.Count; i++)                  {                      if (i > buffers.Count / 2)                          buffersForAnotherThread.Add(buffers[i]);                      else                          buffersForThisThread.Add(buffers[i]);                  }                    ThreadStartData tsd = new ThreadStartData();                  tsd.Buffers = buffersForAnotherThread;                  t.Start(tsd);                  Polygon p = mergePartialBuffers(buffersForThisThread);                  t.Join();                  ICollection<IGeometry> gc = p.Union(tsd.Result);                    if (gc.Count > 0)                      return (Polygon)((GeometryCollection)gc)[0];                  else                      return null;              }
Magic Number,MapAround.Geography,GeoBufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeoBuffer.cs,mergePartialBuffers,The following statement contains a magic number: if (!allowParallels || buffers.Count < 20)                  return mergePartialBuffers(buffers);              else              {                  Thread t = new Thread(mergePartialBuffers);                  List<Polygon> buffersForAnotherThread = new List<Polygon>();                  List<Polygon> buffersForThisThread = new List<Polygon>();                  for (int i = 0; i < buffers.Count; i++)                  {                      if (i > buffers.Count / 2)                          buffersForAnotherThread.Add(buffers[i]);                      else                          buffersForThisThread.Add(buffers[i]);                  }                    ThreadStartData tsd = new ThreadStartData();                  tsd.Buffers = buffersForAnotherThread;                  t.Start(tsd);                  Polygon p = mergePartialBuffers(buffersForThisThread);                  t.Join();                  ICollection<IGeometry> gc = p.Union(tsd.Result);                    if (gc.Count > 0)                      return (Polygon)((GeometryCollection)gc)[0];                  else                      return null;              }
Magic Number,MapAround.Geography,GeoBufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeoBuffer.cs,getBoundsBuffer,The following statement contains a magic number: foreach (GeoContour contour in polygon.Contours)              {                  for (int i = 0; i < contour.Vertices.Count; i++)                  {                      GeoPoint p = contour.Vertices[i];                        GeoPolygon tempPolygon = getPointBuffer(p' Math.Abs(distance)' pointsPerCircle);                      geographyCollection.Clear();                      geographyCollection.Add(tempPolygon);                        GeometryCollection gc = GeometrySpreader.GetGeometries(geographyCollection' projection);                      if(gc[0] is Polygon)                          unionResult = temp.Union((Polygon)gc[0]);                      if (unionResult.Count > 0)                          temp = (Polygon)((GeometryCollection)unionResult)[0];                        c++;                      if (c == 3)                      {                          partialBuffers.Add(temp);                          temp = new Polygon();                          c = 0;                      }                  }              }
Magic Number,MapAround.Geography,GeoBufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeoBuffer.cs,getPolylineBuffer,The following statement contains a magic number: foreach (GeoPath path in geoPolyline.Paths)              {                  for (int i = 0; i < path.Vertices.Count - 1; i++)                  {                      GeoPoint p = path.Vertices[i];                        GeoPolygon tempPolygon = getPointBuffer(p' angleDistance' pointsPerCircle);                      geographyCollection.Clear();                      geographyCollection.Add(tempPolygon);                        GeometryCollection gc = GeometrySpreader.GetGeometries(geographyCollection' projection);                      if (gc[0] is Polygon)                          unionResult = temp.Union((Polygon)gc[0]);                      if (unionResult.Count > 0)                          temp = (Polygon)((GeometryCollection)unionResult)[0];                        c++;                      if (c == 3)                      {                          partialBuffers.Add(temp);                          temp = new Polygon();                          c = 0;                      }                  }              }
Magic Number,MapAround.Geography,GeoBufferBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeoBuffer.cs,GetBuffer,The following statement contains a magic number: if (pointsPerCircle <= 2)                  throw new ArgumentOutOfRangeException("pointsPerCircle");
Magic Number,MapAround.Geography,Angle,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Angle,The following statement contains a magic number: _degrees = minutes / 60.0;
Magic Number,MapAround.Geography,Angle,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Angle,The following statement contains a magic number: _degrees = (seconds / 3600.0) + (minutes / 60.0);
Magic Number,MapAround.Geography,Angle,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Angle,The following statement contains a magic number: _degrees = (seconds / 3600.0) + (minutes / 60.0);
Magic Number,MapAround.Geography,Angle,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,GetHashCode,The following statement contains a magic number: return (int)(_degrees * 1000033);
Magic Number,MapAround.Geography,GlobalCoordinates,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: latitude = (latitude + 180) % 360;
Magic Number,MapAround.Geography,GlobalCoordinates,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: latitude = (latitude + 180) % 360;
Magic Number,MapAround.Geography,GlobalCoordinates,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: if (latitude < 0) latitude += 360;
Magic Number,MapAround.Geography,GlobalCoordinates,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: latitude -= 180;
Magic Number,MapAround.Geography,GlobalCoordinates,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: if (latitude > 90)              {                  latitude = 180 - latitude;                  longitude += 180;              }              else if (latitude < -90)              {                  latitude = -180 - latitude;                  longitude += 180;              }
Magic Number,MapAround.Geography,GlobalCoordinates,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: if (latitude > 90)              {                  latitude = 180 - latitude;                  longitude += 180;              }              else if (latitude < -90)              {                  latitude = -180 - latitude;                  longitude += 180;              }
Magic Number,MapAround.Geography,GlobalCoordinates,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: if (latitude > 90)              {                  latitude = 180 - latitude;                  longitude += 180;              }              else if (latitude < -90)              {                  latitude = -180 - latitude;                  longitude += 180;              }
Magic Number,MapAround.Geography,GlobalCoordinates,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: if (latitude > 90)              {                  latitude = 180 - latitude;                  longitude += 180;              }              else if (latitude < -90)              {                  latitude = -180 - latitude;                  longitude += 180;              }
Magic Number,MapAround.Geography,GlobalCoordinates,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: if (latitude > 90)              {                  latitude = 180 - latitude;                  longitude += 180;              }              else if (latitude < -90)              {                  latitude = -180 - latitude;                  longitude += 180;              }
Magic Number,MapAround.Geography,GlobalCoordinates,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: if (latitude > 90)              {                  latitude = 180 - latitude;                  longitude += 180;              }              else if (latitude < -90)              {                  latitude = -180 - latitude;                  longitude += 180;              }
Magic Number,MapAround.Geography,GlobalCoordinates,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: longitude = ((longitude + 180) % 360);
Magic Number,MapAround.Geography,GlobalCoordinates,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: longitude = ((longitude + 180) % 360);
Magic Number,MapAround.Geography,GlobalCoordinates,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: if (longitude <= 0) longitude += 360;
Magic Number,MapAround.Geography,GlobalCoordinates,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,Canonicalize,The following statement contains a magic number: longitude -= 180;
Magic Number,MapAround.Geography,GlobalCoordinates,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,GetHashCode,The following statement contains a magic number: return ((int)(_longitude.GetHashCode() * (_latitude.GetHashCode() + 1021))) * 1000033;
Magic Number,MapAround.Geography,GlobalCoordinates,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,GetHashCode,The following statement contains a magic number: return ((int)(_longitude.GetHashCode() * (_latitude.GetHashCode() + 1021))) * 1000033;
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double A = 1 + (uSquared / 16384) * (4096 + uSquared * (-768 + uSquared * (320 - 175 * uSquared)));
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double A = 1 + (uSquared / 16384) * (4096 + uSquared * (-768 + uSquared * (320 - 175 * uSquared)));
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double A = 1 + (uSquared / 16384) * (4096 + uSquared * (-768 + uSquared * (320 - 175 * uSquared)));
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double A = 1 + (uSquared / 16384) * (4096 + uSquared * (-768 + uSquared * (320 - 175 * uSquared)));
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double A = 1 + (uSquared / 16384) * (4096 + uSquared * (-768 + uSquared * (320 - 175 * uSquared)));
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double B = (uSquared / 1024) * (256 + uSquared * (-128 + uSquared * (74 - 47 * uSquared)));
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double B = (uSquared / 1024) * (256 + uSquared * (-128 + uSquared * (74 - 47 * uSquared)));
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double B = (uSquared / 1024) * (256 + uSquared * (-128 + uSquared * (74 - 47 * uSquared)));
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double B = (uSquared / 1024) * (256 + uSquared * (-128 + uSquared * (74 - 47 * uSquared)));
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double B = (uSquared / 1024) * (256 + uSquared * (-128 + uSquared * (74 - 47 * uSquared)));
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: while (true)              {                  // eq. 5                  sigmaM2 = 2.0 * sigma1 + sigma;                  cosSigmaM2 = Math.Cos(sigmaM2);                  cos2SigmaM2 = cosSigmaM2 * cosSigmaM2;                  sinSigma = Math.Sin(sigma);                  double cosSignma = Math.Cos(sigma);                    // eq. 6                  deltaSigma = B * sinSigma * (cosSigmaM2 + (B / 4.0) * (cosSignma * (-1 + 2 * cos2SigmaM2)                      - (B / 6.0) * cosSigmaM2 * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM2)));                    // eq. 7                  sigma = sOverbA + deltaSigma;                    // break after converging to tolerance                  if (Math.Abs(sigma - prevSigma) < 1e-13)                       break;                    prevSigma = sigma;              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: while (true)              {                  // eq. 5                  sigmaM2 = 2.0 * sigma1 + sigma;                  cosSigmaM2 = Math.Cos(sigmaM2);                  cos2SigmaM2 = cosSigmaM2 * cosSigmaM2;                  sinSigma = Math.Sin(sigma);                  double cosSignma = Math.Cos(sigma);                    // eq. 6                  deltaSigma = B * sinSigma * (cosSigmaM2 + (B / 4.0) * (cosSignma * (-1 + 2 * cos2SigmaM2)                      - (B / 6.0) * cosSigmaM2 * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM2)));                    // eq. 7                  sigma = sOverbA + deltaSigma;                    // break after converging to tolerance                  if (Math.Abs(sigma - prevSigma) < 1e-13)                       break;                    prevSigma = sigma;              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: while (true)              {                  // eq. 5                  sigmaM2 = 2.0 * sigma1 + sigma;                  cosSigmaM2 = Math.Cos(sigmaM2);                  cos2SigmaM2 = cosSigmaM2 * cosSigmaM2;                  sinSigma = Math.Sin(sigma);                  double cosSignma = Math.Cos(sigma);                    // eq. 6                  deltaSigma = B * sinSigma * (cosSigmaM2 + (B / 4.0) * (cosSignma * (-1 + 2 * cos2SigmaM2)                      - (B / 6.0) * cosSigmaM2 * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM2)));                    // eq. 7                  sigma = sOverbA + deltaSigma;                    // break after converging to tolerance                  if (Math.Abs(sigma - prevSigma) < 1e-13)                       break;                    prevSigma = sigma;              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: while (true)              {                  // eq. 5                  sigmaM2 = 2.0 * sigma1 + sigma;                  cosSigmaM2 = Math.Cos(sigmaM2);                  cos2SigmaM2 = cosSigmaM2 * cosSigmaM2;                  sinSigma = Math.Sin(sigma);                  double cosSignma = Math.Cos(sigma);                    // eq. 6                  deltaSigma = B * sinSigma * (cosSigmaM2 + (B / 4.0) * (cosSignma * (-1 + 2 * cos2SigmaM2)                      - (B / 6.0) * cosSigmaM2 * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM2)));                    // eq. 7                  sigma = sOverbA + deltaSigma;                    // break after converging to tolerance                  if (Math.Abs(sigma - prevSigma) < 1e-13)                       break;                    prevSigma = sigma;              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: while (true)              {                  // eq. 5                  sigmaM2 = 2.0 * sigma1 + sigma;                  cosSigmaM2 = Math.Cos(sigmaM2);                  cos2SigmaM2 = cosSigmaM2 * cosSigmaM2;                  sinSigma = Math.Sin(sigma);                  double cosSignma = Math.Cos(sigma);                    // eq. 6                  deltaSigma = B * sinSigma * (cosSigmaM2 + (B / 4.0) * (cosSignma * (-1 + 2 * cos2SigmaM2)                      - (B / 6.0) * cosSigmaM2 * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM2)));                    // eq. 7                  sigma = sOverbA + deltaSigma;                    // break after converging to tolerance                  if (Math.Abs(sigma - prevSigma) < 1e-13)                       break;                    prevSigma = sigma;              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: while (true)              {                  // eq. 5                  sigmaM2 = 2.0 * sigma1 + sigma;                  cosSigmaM2 = Math.Cos(sigmaM2);                  cos2SigmaM2 = cosSigmaM2 * cosSigmaM2;                  sinSigma = Math.Sin(sigma);                  double cosSignma = Math.Cos(sigma);                    // eq. 6                  deltaSigma = B * sinSigma * (cosSigmaM2 + (B / 4.0) * (cosSignma * (-1 + 2 * cos2SigmaM2)                      - (B / 6.0) * cosSigmaM2 * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM2)));                    // eq. 7                  sigma = sOverbA + deltaSigma;                    // break after converging to tolerance                  if (Math.Abs(sigma - prevSigma) < 1e-13)                       break;                    prevSigma = sigma;              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: while (true)              {                  // eq. 5                  sigmaM2 = 2.0 * sigma1 + sigma;                  cosSigmaM2 = Math.Cos(sigmaM2);                  cos2SigmaM2 = cosSigmaM2 * cosSigmaM2;                  sinSigma = Math.Sin(sigma);                  double cosSignma = Math.Cos(sigma);                    // eq. 6                  deltaSigma = B * sinSigma * (cosSigmaM2 + (B / 4.0) * (cosSignma * (-1 + 2 * cos2SigmaM2)                      - (B / 6.0) * cosSigmaM2 * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM2)));                    // eq. 7                  sigma = sOverbA + deltaSigma;                    // break after converging to tolerance                  if (Math.Abs(sigma - prevSigma) < 1e-13)                       break;                    prevSigma = sigma;              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: while (true)              {                  // eq. 5                  sigmaM2 = 2.0 * sigma1 + sigma;                  cosSigmaM2 = Math.Cos(sigmaM2);                  cos2SigmaM2 = cosSigmaM2 * cosSigmaM2;                  sinSigma = Math.Sin(sigma);                  double cosSignma = Math.Cos(sigma);                    // eq. 6                  deltaSigma = B * sinSigma * (cosSigmaM2 + (B / 4.0) * (cosSignma * (-1 + 2 * cos2SigmaM2)                      - (B / 6.0) * cosSigmaM2 * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM2)));                    // eq. 7                  sigma = sOverbA + deltaSigma;                    // break after converging to tolerance                  if (Math.Abs(sigma - prevSigma) < 1e-13)                       break;                    prevSigma = sigma;              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: while (true)              {                  // eq. 5                  sigmaM2 = 2.0 * sigma1 + sigma;                  cosSigmaM2 = Math.Cos(sigmaM2);                  cos2SigmaM2 = cosSigmaM2 * cosSigmaM2;                  sinSigma = Math.Sin(sigma);                  double cosSignma = Math.Cos(sigma);                    // eq. 6                  deltaSigma = B * sinSigma * (cosSigmaM2 + (B / 4.0) * (cosSignma * (-1 + 2 * cos2SigmaM2)                      - (B / 6.0) * cosSigmaM2 * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM2)));                    // eq. 7                  sigma = sOverbA + deltaSigma;                    // break after converging to tolerance                  if (Math.Abs(sigma - prevSigma) < 1e-13)                       break;                    prevSigma = sigma;              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: sigmaM2 = 2.0 * sigma1 + sigma;
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double phi2 = Math.Atan2(sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1'                                       (1.0 - f) * Math.Sqrt(sin2Alpha + Math.Pow(sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1' 2.0)));
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double C = (f / 16) * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha));
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double C = (f / 16) * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha));
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double C = (f / 16) * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha));
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double C = (f / 16) * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha));
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateEndingGlobalCoordinates,The following statement contains a magic number: double L = lambda - (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cosSigmaM2 + C * cosSigma * (-1 + 2 * cos2SigmaM2)));
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  lambda0 = lambda;                    double sinlambda = Math.Sin(lambda);                  double coslambda = Math.Cos(lambda);                    // eq. 14                  double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + Math.Pow(cosU1sinU2 - sinU1cosU2 * coslambda' 2.0);                  double sinsigma = Math.Sqrt(sin2sigma);                    // eq. 15                  double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);                    // eq. 16                  sigma = Math.Atan2(sinsigma' cossigma);                    // eq. 17    Careful!  sin2sigma might be almost 0!                  double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;                  double alpha = Math.Asin(sinalpha);                  double cosalpha = Math.Cos(alpha);                  double cos2alpha = cosalpha * cosalpha;                    // eq. 18    Careful!  cos2alpha might be almost 0!                  double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;                  double u2 = cos2alpha * a2b2b2;                    double cos2sigmam2 = cos2sigmam * cos2sigmam;                    // eq. 3                  A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));                    // eq. 4                  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));                    // eq. 6                  deltasigma = B * sinsigma * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));                    // eq. 10                  double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));                    // eq. 11 (modified)                  lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));                    // see how much improvement we got                  double change = Math.Abs((lambda - lambda0) / lambda);                    if ((i > 1) && (change < 1e-13))                  {                      converged = true;                      break;                  }              }
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: if (alpha1 >= 360.0) alpha1 -= 360.0;
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: if (alpha1 >= 360.0) alpha1 -= 360.0;
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: if (alpha2 >= 360.0) alpha2 -= 360.0;
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticCurve,The following statement contains a magic number: if (alpha2 >= 360.0) alpha2 -= 360.0;
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticMeasurement,The following statement contains a magic number: double elev12 = (elev1 + elev2) / 2.0;
Magic Number,MapAround.Geography,GeodeticCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geography\GeodeticCalculator.cs,CalculateGeodeticMeasurement,The following statement contains a magic number: double phi12 = (phi1 + phi2) / 2.0;
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getArcIntersections,The following statement contains a magic number: if (ly == p2.Y)                  return new ICoordinate[] { PlanimetryEnvironment.NewCoordinate((p1.X + p2.X) / 2' double.PositiveInfinity) };
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getArcIntersections,The following statement contains a magic number: if (a == 0)              {                  double x = 0.5 * (p1.X + p2.X);                  double y = (yn - x * x + 2 * p2.X * x) / (ly - p2.Y);                  return new ICoordinate[] { PlanimetryEnvironment.NewCoordinate(x' y) };              }
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getArcIntersections,The following statement contains a magic number: if (a == 0)              {                  double x = 0.5 * (p1.X + p2.X);                  double y = (yn - x * x + 2 * p2.X * x) / (ly - p2.Y);                  return new ICoordinate[] { PlanimetryEnvironment.NewCoordinate(x' y) };              }
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getArcIntersections,The following statement contains a magic number: double b = 2 * (p2.X * f - p1.X);
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getArcIntersections,The following statement contains a magic number: double d = b * b - 4 * a * c;
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getArcIntersections,The following statement contains a magic number: if (d < 0)                  // no real roots                  return new ICoordinate[] { };              else              {                  double sb = b == 0 ? 1 : Math.Sign(b);                    // This "trick" to avoid loss of accuracy in the calculation                   // of one of the roots due to the subtraction of large numbers                  double x1 = 0.5 * (-b + sb * Math.Sqrt(d)) / a;                  double x2 = (x1 != 0 ? c / a / x1 : 0);                    double p1ypow2 = p1.Y * p1.Y;                  double den = 2 * (p1.Y - ly);                    double y1 = (p1ypow2 + (p1.X - x1) * (p1.X - x1) - lpow2) / den;                  double y2 = (p1ypow2 + (p1.X - x2) * (p1.X - x2) - lpow2) / den;                    return new ICoordinate[]                       {                           PlanimetryEnvironment.NewCoordinate(x1' y1)'                           PlanimetryEnvironment.NewCoordinate(x2' y2)                       };              }
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getArcIntersections,The following statement contains a magic number: if (d < 0)                  // no real roots                  return new ICoordinate[] { };              else              {                  double sb = b == 0 ? 1 : Math.Sign(b);                    // This "trick" to avoid loss of accuracy in the calculation                   // of one of the roots due to the subtraction of large numbers                  double x1 = 0.5 * (-b + sb * Math.Sqrt(d)) / a;                  double x2 = (x1 != 0 ? c / a / x1 : 0);                    double p1ypow2 = p1.Y * p1.Y;                  double den = 2 * (p1.Y - ly);                    double y1 = (p1ypow2 + (p1.X - x1) * (p1.X - x1) - lpow2) / den;                  double y2 = (p1ypow2 + (p1.X - x2) * (p1.X - x2) - lpow2) / den;                    return new ICoordinate[]                       {                           PlanimetryEnvironment.NewCoordinate(x1' y1)'                           PlanimetryEnvironment.NewCoordinate(x2' y2)                       };              }
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getDistanceToArc,The following statement contains a magic number: double qy = ly + arcPoint.Y + (arcPoint.X - x) * 0.5 * (arcPoint.X - x) / (ly - arcPoint.Y);
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,FindArc,The following statement contains a magic number: while (true)              {                  if (currentArc.Left == null && currentArc.Right == null)                      return currentArc;                    if (currentArc.Site.Cell.DataPoint.Y == ly)                  {                      currentArc = currentArc.Site.Cell.DataPoint.X < eventX ? currentArc.Right : currentArc.Left;                      continue;                  }                    //find the boundaries of the left and right subtrees                  FortuneArc leftNeighbor = currentArc.LeftSubtreeBound;                  FortuneArc rightNeighbor = currentArc.RightSubtreeBound;                    ICoordinate[] pointsPrev = null;                  ICoordinate[] pointsNext = null;                    if (leftNeighbor != null)                  {                      pointsPrev = getArcIntersections(leftNeighbor.Site.Cell.DataPoint' currentArc.Site.Cell.DataPoint' ly);                      if (pointsPrev.Length == 2)                          if ((pointsPrev[1].X < pointsPrev[0].X ^ leftNeighbor.Site.Cell.DataPoint.Y < currentArc.Site.Cell.DataPoint.Y))                              pointsPrev[0] = pointsPrev[1];                  }                    if (rightNeighbor != null)                  {                      pointsNext = getArcIntersections(rightNeighbor.Site.Cell.DataPoint' currentArc.Site.Cell.DataPoint' ly);                      if (pointsNext.Length == 2)                          if ((pointsNext[1].X < pointsNext[0].X ^ rightNeighbor.Site.Cell.DataPoint.Y > currentArc.Site.Cell.DataPoint.Y))                              pointsNext[0] = pointsNext[1];                  }                    if ((currentArc.Left == null || pointsPrev[0].X <= eventX) &&                      (currentArc.Right == null || pointsNext[0].X >= eventX))                      return currentArc;                    if (leftNeighbor != null && pointsPrev[0].X > eventX)                  {                      currentArc = currentArc.Left;                      continue;                  }                    if (rightNeighbor != null && pointsNext[0].X < eventX)                  {                      currentArc = currentArc.Right;                      continue;                  }              }
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,FindArc,The following statement contains a magic number: while (true)              {                  if (currentArc.Left == null && currentArc.Right == null)                      return currentArc;                    if (currentArc.Site.Cell.DataPoint.Y == ly)                  {                      currentArc = currentArc.Site.Cell.DataPoint.X < eventX ? currentArc.Right : currentArc.Left;                      continue;                  }                    //find the boundaries of the left and right subtrees                  FortuneArc leftNeighbor = currentArc.LeftSubtreeBound;                  FortuneArc rightNeighbor = currentArc.RightSubtreeBound;                    ICoordinate[] pointsPrev = null;                  ICoordinate[] pointsNext = null;                    if (leftNeighbor != null)                  {                      pointsPrev = getArcIntersections(leftNeighbor.Site.Cell.DataPoint' currentArc.Site.Cell.DataPoint' ly);                      if (pointsPrev.Length == 2)                          if ((pointsPrev[1].X < pointsPrev[0].X ^ leftNeighbor.Site.Cell.DataPoint.Y < currentArc.Site.Cell.DataPoint.Y))                              pointsPrev[0] = pointsPrev[1];                  }                    if (rightNeighbor != null)                  {                      pointsNext = getArcIntersections(rightNeighbor.Site.Cell.DataPoint' currentArc.Site.Cell.DataPoint' ly);                      if (pointsNext.Length == 2)                          if ((pointsNext[1].X < pointsNext[0].X ^ rightNeighbor.Site.Cell.DataPoint.Y > currentArc.Site.Cell.DataPoint.Y))                              pointsNext[0] = pointsNext[1];                  }                    if ((currentArc.Left == null || pointsPrev[0].X <= eventX) &&                      (currentArc.Right == null || pointsNext[0].X >= eventX))                      return currentArc;                    if (leftNeighbor != null && pointsPrev[0].X > eventX)                  {                      currentArc = currentArc.Left;                      continue;                  }                    if (rightNeighbor != null && pointsNext[0].X < eventX)                  {                      currentArc = currentArc.Right;                      continue;                  }              }
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,Finish,The following statement contains a magic number: while (arc != null)              {                  FortuneArc rn = arc.RightNeighbor;                    if (rn != null)                  {                      ICoordinate[] points =                          getArcIntersections(arc.Site.Cell.DataPoint' rn.Site.Cell.DataPoint' 2 * l);                        if (points.Length == 2)                      {                          ICoordinate p1 = points[0].X < points[1].X ? points[0] : points[1];                          ICoordinate p2 = points[0].X < points[1].X ? points[1] : points[0];                            if (arc.RightNode != null && arc.RightNode.IsInfinit)                          {                              if (arc.Site.Cell.DataPoint.Y > rn.Site.Cell.DataPoint.Y)                                  arc.RightNode.Point = p1;                              else                                  arc.RightNode.Point = p2;                          }                      }                        if (points.Length == 1)                          if (arc.RightNode != null && arc.RightNode.IsInfinit)                              arc.RightNode.Point = points[0];                  }                    arc = rn;              }
Magic Number,MapAround.Geometry.Tessellations,FortuneShoreLine,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,Finish,The following statement contains a magic number: while (arc != null)              {                  FortuneArc rn = arc.RightNeighbor;                    if (rn != null)                  {                      ICoordinate[] points =                          getArcIntersections(arc.Site.Cell.DataPoint' rn.Site.Cell.DataPoint' 2 * l);                        if (points.Length == 2)                      {                          ICoordinate p1 = points[0].X < points[1].X ? points[0] : points[1];                          ICoordinate p2 = points[0].X < points[1].X ? points[1] : points[0];                            if (arc.RightNode != null && arc.RightNode.IsInfinit)                          {                              if (arc.Site.Cell.DataPoint.Y > rn.Site.Cell.DataPoint.Y)                                  arc.RightNode.Point = p1;                              else                                  arc.RightNode.Point = p2;                          }                      }                        if (points.Length == 1)                          if (arc.RightNode != null && arc.RightNode.IsInfinit)                              arc.RightNode.Point = points[0];                  }                    arc = rn;              }
Magic Number,MapAround.Geometry.Tessellations,VoronoiBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getCircleCenter,The following statement contains a magic number: double x = 0.5 * (ma * mb * (p1.Y - p3.Y) + mb * (p1.X + p2.X) - ma * (p2.X + p3.X)) / (mb - ma);
Magic Number,MapAround.Geometry.Tessellations,VoronoiBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getCircleCenter,The following statement contains a magic number: if(ma != 0 && !double.IsInfinity(ma))                  y = -1 / ma * (x - 0.5 * (p1.X + p2.X)) + 0.5 * (p1.Y + p2.Y);              else                  y = -1 / mb * (x - 0.5 * (p2.X + p3.X)) + 0.5 * (p2.Y + p3.Y);
Magic Number,MapAround.Geometry.Tessellations,VoronoiBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getCircleCenter,The following statement contains a magic number: if(ma != 0 && !double.IsInfinity(ma))                  y = -1 / ma * (x - 0.5 * (p1.X + p2.X)) + 0.5 * (p1.Y + p2.Y);              else                  y = -1 / mb * (x - 0.5 * (p2.X + p3.X)) + 0.5 * (p2.Y + p3.Y);
Magic Number,MapAround.Geometry.Tessellations,VoronoiBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getCircleCenter,The following statement contains a magic number: if(ma != 0 && !double.IsInfinity(ma))                  y = -1 / ma * (x - 0.5 * (p1.X + p2.X)) + 0.5 * (p1.Y + p2.Y);              else                  y = -1 / mb * (x - 0.5 * (p2.X + p3.X)) + 0.5 * (p2.Y + p3.Y);
Magic Number,MapAround.Geometry.Tessellations,VoronoiBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,getCircleCenter,The following statement contains a magic number: if(ma != 0 && !double.IsInfinity(ma))                  y = -1 / ma * (x - 0.5 * (p1.X + p2.X)) + 0.5 * (p1.Y + p2.Y);              else                  y = -1 / mb * (x - 0.5 * (p2.X + p3.X)) + 0.5 * (p2.Y + p3.Y);
Magic Number,MapAround.Geometry.Tessellations,VoronoiBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,handleCircleEvent,The following statement contains a magic number: edge.Node2 = new VoronoiNode((ln.Site.Cell.DataPoint.X + rn.Site.Cell.DataPoint.X) / 2'                                           (ln.Site.Cell.DataPoint.Y + rn.Site.Cell.DataPoint.Y) / 2);
Magic Number,MapAround.Geometry.Tessellations,VoronoiBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,handleCircleEvent,The following statement contains a magic number: edge.Node2 = new VoronoiNode((ln.Site.Cell.DataPoint.X + rn.Site.Cell.DataPoint.X) / 2'                                           (ln.Site.Cell.DataPoint.Y + rn.Site.Cell.DataPoint.Y) / 2);
Magic Number,MapAround.Geometry.Tessellations,VoronoiBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,init,The following statement contains a magic number: if (lastMaxYIndex > 0)              {                  VoronoiNode previousNode = null;                  FortuneArc currentArc = null;                  skipEventCount = lastMaxYIndex + 1;                  for (int i = 0; i <= lastMaxYIndex; i++)                  {                      // add an arc of coastline                      FortuneArc arc = new FortuneArc();                      FortuneSite site = new FortuneSite();                      site.Cell = cells[i];                      arc.Site = site;                        if (currentArc != null)                          currentArc.Right = arc;                        currentArc = arc;                      if (_shoreLine.Root == null)                          _shoreLine.Root = arc;                        if (previousNode != null)                          arc.LeftNode = previousNode;                        // add the vertical edges of the Voronoi diagram                      if (i < lastMaxYIndex)                      {                          VoronoiEdge edge = new VoronoiEdge(cells[i]' cells[i + 1]);                          double middleX = (cells[i].DataPoint.X + cells[i + 1].DataPoint.X) / 2;                          double middleY = cells[i].DataPoint.Y;                            edge.Node1 = new VoronoiNode(middleX' middleY);                          edge.Node1.IsInfinit = true;                          _startVerticalNodes.Add(edge.Node1);                            edge.Node2 = new VoronoiNode(middleX' middleY);                          edge.Node2.IsInfinit = true;                            previousNode = edge.Node2;                            arc.RightNode = edge.Node2;                            cells[i].AddEdge(edge);                          cells[i + 1].AddEdge(edge);                      }                  }              }
Magic Number,MapAround.Geometry.Tessellations,VoronoiBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,Build,The following statement contains a magic number: if (sourcePoints.Count < 3)                  throw new ArgumentException("Voronoi tesselation building for this number of point is not supported"' "points");
Magic Number,MapAround.Indexing,KDTreeNode,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\KDTree.cs,ClearChildren,The following statement contains a magic number: if (_child0 != null && _child1 != null)                  {                      _child0.ClearChildren();                      _child1.ClearChildren();                      _parent._nodeCount -= 2;                  }
Magic Number,MapAround.Indexing,QuadTree,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Indexing\QuadTree.cs,getMinBoundingQuad,The following statement contains a magic number: double maxHalfSize = Math.Max(rectangle.Width' rectangle.Height) / 2;
Magic Number,MapAround.Rendering,LineTransformationSequence,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\LineTransformations.cs,GetLines,The following statement contains a magic number: foreach (ILineTransformer transformer in _transformers)              {                  result.Clear();                  foreach (IGeometry g in tempSource)                  {                      if (g.CoordinateCount < 2)                          continue;                        GeometryCollection gc = null;                      if (g is LinePath)                      {                          gc = transformer.GetLines((LinePath)g);                      }                      else if (g is Contour)                      {                          gc = transformer.GetLines((Contour)g);                      }                      else                          throw new ArgumentException("Source collection should contain only contours and linepaths."' "sourceGeometries");                        foreach(IGeometry g1 in gc)                      {                          if(!(g1 is LinePath || g1 is Contour))                              throw new InvalidOperationException("LineTransformation \"" + transformer.GetType().FullName + "\" has wrong output.");                            result.Add(g1);                      }                  }                    tempSource.Clear();                  foreach (IGeometry g in result)                      tempSource.Add(g);              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getSegmentAngle,The following statement contains a magic number: if (x1 == x2)                  result = y1 < y2 ? Math.PI / 2 : 1.5 * Math.PI;              else                  if (y1 == y2)                      result = x1 < x2 ? 0 : Math.PI;                  else                  {                      result = Math.Atan(Math.Abs(y2 - y1) / Math.Abs(x2 - x1));                      if (x1 > x2 && y1 < y2)                          result = Math.PI - result;                      if (x1 > x2 && y1 > y2)                          result += Math.PI;                      if (x1 < x2 && y1 > y2)                          result = _twoPi - result;                  }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getSegmentAngle,The following statement contains a magic number: if (x1 == x2)                  result = y1 < y2 ? Math.PI / 2 : 1.5 * Math.PI;              else                  if (y1 == y2)                      result = x1 < x2 ? 0 : Math.PI;                  else                  {                      result = Math.Atan(Math.Abs(y2 - y1) / Math.Abs(x2 - x1));                      if (x1 > x2 && y1 < y2)                          result = Math.PI - result;                      if (x1 > x2 && y1 > y2)                          result += Math.PI;                      if (x1 < x2 && y1 > y2)                          result = _twoPi - result;                  }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The following statement contains a magic number: switch (capLocation)              {                   case CapLocation.Start:                      angle += Math.PI / 2;                      startPoint.X = x1;                      startPoint.Y = y1;                      break;                  case CapLocation.End:                      angle -= Math.PI / 2;                      startPoint.X = x2;                      startPoint.Y = y2;                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The following statement contains a magic number: switch (capLocation)              {                   case CapLocation.Start:                      angle += Math.PI / 2;                      startPoint.X = x1;                      startPoint.Y = y1;                      break;                  case CapLocation.End:                      angle -= Math.PI / 2;                      startPoint.X = x2;                      startPoint.Y = y2;                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The following statement contains a magic number: switch (cap)              {                   case LineCap.Flat:                      ICoordinate[] points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' 2);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Round:                      int pointsPerCircle = (int)(Math.Round(Width * Math.PI) / 2);                      points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' pointsPerCircle);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Square:                      double r = _width * _sqrt2 / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle + _squareCapAngle)'                                                startPoint.Y + r * Math.Sin(angle + _squareCapAngle)));                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle - _squareCapAngle + Math.PI)'                                                startPoint.Y + r * Math.Sin(angle - _squareCapAngle + Math.PI)));                      break;                  case LineCap.Triangle:                      double halfWidth = _width / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle)'                            startPoint.Y + halfWidth * Math.Sin(angle)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + _halfPI)'                            startPoint.Y + halfWidth * Math.Sin(angle + _halfPI)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + Math.PI)'                            startPoint.Y + halfWidth * Math.Sin(angle + Math.PI)));                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The following statement contains a magic number: switch (cap)              {                   case LineCap.Flat:                      ICoordinate[] points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' 2);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Round:                      int pointsPerCircle = (int)(Math.Round(Width * Math.PI) / 2);                      points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' pointsPerCircle);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Square:                      double r = _width * _sqrt2 / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle + _squareCapAngle)'                                                startPoint.Y + r * Math.Sin(angle + _squareCapAngle)));                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle - _squareCapAngle + Math.PI)'                                                startPoint.Y + r * Math.Sin(angle - _squareCapAngle + Math.PI)));                      break;                  case LineCap.Triangle:                      double halfWidth = _width / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle)'                            startPoint.Y + halfWidth * Math.Sin(angle)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + _halfPI)'                            startPoint.Y + halfWidth * Math.Sin(angle + _halfPI)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + Math.PI)'                            startPoint.Y + halfWidth * Math.Sin(angle + Math.PI)));                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The following statement contains a magic number: switch (cap)              {                   case LineCap.Flat:                      ICoordinate[] points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' 2);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Round:                      int pointsPerCircle = (int)(Math.Round(Width * Math.PI) / 2);                      points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' pointsPerCircle);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Square:                      double r = _width * _sqrt2 / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle + _squareCapAngle)'                                                startPoint.Y + r * Math.Sin(angle + _squareCapAngle)));                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle - _squareCapAngle + Math.PI)'                                                startPoint.Y + r * Math.Sin(angle - _squareCapAngle + Math.PI)));                      break;                  case LineCap.Triangle:                      double halfWidth = _width / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle)'                            startPoint.Y + halfWidth * Math.Sin(angle)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + _halfPI)'                            startPoint.Y + halfWidth * Math.Sin(angle + _halfPI)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + Math.PI)'                            startPoint.Y + halfWidth * Math.Sin(angle + Math.PI)));                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The following statement contains a magic number: switch (cap)              {                   case LineCap.Flat:                      ICoordinate[] points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' 2);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Round:                      int pointsPerCircle = (int)(Math.Round(Width * Math.PI) / 2);                      points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' pointsPerCircle);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Square:                      double r = _width * _sqrt2 / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle + _squareCapAngle)'                                                startPoint.Y + r * Math.Sin(angle + _squareCapAngle)));                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle - _squareCapAngle + Math.PI)'                                                startPoint.Y + r * Math.Sin(angle - _squareCapAngle + Math.PI)));                      break;                  case LineCap.Triangle:                      double halfWidth = _width / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle)'                            startPoint.Y + halfWidth * Math.Sin(angle)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + _halfPI)'                            startPoint.Y + halfWidth * Math.Sin(angle + _halfPI)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + Math.PI)'                            startPoint.Y + halfWidth * Math.Sin(angle + Math.PI)));                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The following statement contains a magic number: switch (cap)              {                   case LineCap.Flat:                      ICoordinate[] points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' 2);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Round:                      int pointsPerCircle = (int)(Math.Round(Width * Math.PI) / 2);                      points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' pointsPerCircle);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Square:                      double r = _width * _sqrt2 / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle + _squareCapAngle)'                                                startPoint.Y + r * Math.Sin(angle + _squareCapAngle)));                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle - _squareCapAngle + Math.PI)'                                                startPoint.Y + r * Math.Sin(angle - _squareCapAngle + Math.PI)));                      break;                  case LineCap.Triangle:                      double halfWidth = _width / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle)'                            startPoint.Y + halfWidth * Math.Sin(angle)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + _halfPI)'                            startPoint.Y + halfWidth * Math.Sin(angle + _halfPI)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + Math.PI)'                            startPoint.Y + halfWidth * Math.Sin(angle + Math.PI)));                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The following statement contains a magic number: switch (cap)              {                   case LineCap.Flat:                      ICoordinate[] points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' 2);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Round:                      int pointsPerCircle = (int)(Math.Round(Width * Math.PI) / 2);                      points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' pointsPerCircle);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Square:                      double r = _width * _sqrt2 / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle + _squareCapAngle)'                                                startPoint.Y + r * Math.Sin(angle + _squareCapAngle)));                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle - _squareCapAngle + Math.PI)'                                                startPoint.Y + r * Math.Sin(angle - _squareCapAngle + Math.PI)));                      break;                  case LineCap.Triangle:                      double halfWidth = _width / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle)'                            startPoint.Y + halfWidth * Math.Sin(angle)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + _halfPI)'                            startPoint.Y + halfWidth * Math.Sin(angle + _halfPI)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + Math.PI)'                            startPoint.Y + halfWidth * Math.Sin(angle + Math.PI)));                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,translateAngleQuadrant,The following statement contains a magic number: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return _twoPi - angle; }              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,translateAngleQuadrant,The following statement contains a magic number: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return _twoPi - angle; }              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,translateAngleQuadrant,The following statement contains a magic number: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return _twoPi - angle; }              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,pointQuadrantNumber,The following statement contains a magic number: if (p.X > 0)              {                  if (p.Y > 0) return 1; else return 4;              }              else              {                  if (p.Y > 0) return 2; else return 3;              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,pointQuadrantNumber,The following statement contains a magic number: if (p.X > 0)              {                  if (p.Y > 0) return 1; else return 4;              }              else              {                  if (p.Y > 0) return 2; else return 3;              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,pointQuadrantNumber,The following statement contains a magic number: if (p.X > 0)              {                  if (p.Y > 0) return 1; else return 4;              }              else              {                  if (p.Y > 0) return 2; else return 3;              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addInteriorJoin,The following statement contains a magic number: double distance = _width / 2;
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addJoin,The following statement contains a magic number: if (join == LineJoin.Round && _width <= 2)                  join = LineJoin.Bevel;
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addJoin,The following statement contains a magic number: double halfWidth = _width / 2;
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addJoin,The following statement contains a magic number: switch (join)              {                   case LineJoin.Bevel:                      vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                      vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                      break;                  case LineJoin.Round:                      ICoordinate[] points =                          getCirclePoints(PlanimetryEnvironment.NewCoordinate(x2' y2)'                          angle1'                          angle1 - Math.PI + angleBetweenSegments'                           halfWidth'                          (int)(Math.Round(_width * Math.PI) / 2));                        foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineJoin.Miter:                  case LineJoin.MiterClipped:                        Segment s1 = new Segment(pointOnCircle(x1' y1' halfWidth' angle1)' pointOnCircle(x2' y2' halfWidth' angle1));                      Segment s2 = new Segment(pointOnCircle(x3' y3' halfWidth' angle2)' pointOnCircle(x2' y2' halfWidth' angle2));                        ICoordinate miterPoint = null;                        if (PlanimetryAlgorithms.DirectsIntersection(s1' s2' ref miterPoint) == Dimension.Zero)                      {                          double miterDistance2 = PlanimetryAlgorithms.Distance(miterPoint' PlanimetryEnvironment.NewCoordinate(x2' y2));                          if (miterDistance2 < _miterLimit * _width / 2)                              vertexList.Add(miterPoint);                          else                          {                              if (join == LineJoin.MiterClipped)                              {                                  vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                                  vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                              }                              else                              {                                  double l = _miterLimit * _width * 0.5;                                  double miterDistance1 = PlanimetryAlgorithms.Distance(s1.V2' miterPoint);                                  double clipDistance = ((miterDistance2 - l) * (miterDistance2 - l) + l) / miterDistance1;                                    double f = clipDistance / (miterDistance1 - clipDistance);                                  vertexList.Add(PlanimetryEnvironment.NewCoordinate((f * s1.V2.X + miterPoint.X) / (1 + f)'                                                            (f * s1.V2.Y + miterPoint.Y) / (1 + f)));                                  vertexList.Add(PlanimetryEnvironment.NewCoordinate((f * s2.V2.X + miterPoint.X) / (1 + f)'                                                            (f * s2.V2.Y + miterPoint.Y) / (1 + f)));                              }                          }                      }                      else                      {                          if (join == LineJoin.MiterClipped)                          {                              vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                              vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                          }                          else                          {                              double d = Math.Sqrt(_width * _width / 4 + _miterLimit * _miterLimit);                              double alpha = Math.Atan(1 / _miterLimit);                              vertexList.Add(pointOnCircle(x2' y2' d' angle1 - alpha));                              vertexList.Add(pointOnCircle(x2' y2' d' angle1 + alpha));                          }                      }                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addJoin,The following statement contains a magic number: switch (join)              {                   case LineJoin.Bevel:                      vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                      vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                      break;                  case LineJoin.Round:                      ICoordinate[] points =                          getCirclePoints(PlanimetryEnvironment.NewCoordinate(x2' y2)'                          angle1'                          angle1 - Math.PI + angleBetweenSegments'                           halfWidth'                          (int)(Math.Round(_width * Math.PI) / 2));                        foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineJoin.Miter:                  case LineJoin.MiterClipped:                        Segment s1 = new Segment(pointOnCircle(x1' y1' halfWidth' angle1)' pointOnCircle(x2' y2' halfWidth' angle1));                      Segment s2 = new Segment(pointOnCircle(x3' y3' halfWidth' angle2)' pointOnCircle(x2' y2' halfWidth' angle2));                        ICoordinate miterPoint = null;                        if (PlanimetryAlgorithms.DirectsIntersection(s1' s2' ref miterPoint) == Dimension.Zero)                      {                          double miterDistance2 = PlanimetryAlgorithms.Distance(miterPoint' PlanimetryEnvironment.NewCoordinate(x2' y2));                          if (miterDistance2 < _miterLimit * _width / 2)                              vertexList.Add(miterPoint);                          else                          {                              if (join == LineJoin.MiterClipped)                              {                                  vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                                  vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                              }                              else                              {                                  double l = _miterLimit * _width * 0.5;                                  double miterDistance1 = PlanimetryAlgorithms.Distance(s1.V2' miterPoint);                                  double clipDistance = ((miterDistance2 - l) * (miterDistance2 - l) + l) / miterDistance1;                                    double f = clipDistance / (miterDistance1 - clipDistance);                                  vertexList.Add(PlanimetryEnvironment.NewCoordinate((f * s1.V2.X + miterPoint.X) / (1 + f)'                                                            (f * s1.V2.Y + miterPoint.Y) / (1 + f)));                                  vertexList.Add(PlanimetryEnvironment.NewCoordinate((f * s2.V2.X + miterPoint.X) / (1 + f)'                                                            (f * s2.V2.Y + miterPoint.Y) / (1 + f)));                              }                          }                      }                      else                      {                          if (join == LineJoin.MiterClipped)                          {                              vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                              vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                          }                          else                          {                              double d = Math.Sqrt(_width * _width / 4 + _miterLimit * _miterLimit);                              double alpha = Math.Atan(1 / _miterLimit);                              vertexList.Add(pointOnCircle(x2' y2' d' angle1 - alpha));                              vertexList.Add(pointOnCircle(x2' y2' d' angle1 + alpha));                          }                      }                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addJoin,The following statement contains a magic number: switch (join)              {                   case LineJoin.Bevel:                      vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                      vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                      break;                  case LineJoin.Round:                      ICoordinate[] points =                          getCirclePoints(PlanimetryEnvironment.NewCoordinate(x2' y2)'                          angle1'                          angle1 - Math.PI + angleBetweenSegments'                           halfWidth'                          (int)(Math.Round(_width * Math.PI) / 2));                        foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineJoin.Miter:                  case LineJoin.MiterClipped:                        Segment s1 = new Segment(pointOnCircle(x1' y1' halfWidth' angle1)' pointOnCircle(x2' y2' halfWidth' angle1));                      Segment s2 = new Segment(pointOnCircle(x3' y3' halfWidth' angle2)' pointOnCircle(x2' y2' halfWidth' angle2));                        ICoordinate miterPoint = null;                        if (PlanimetryAlgorithms.DirectsIntersection(s1' s2' ref miterPoint) == Dimension.Zero)                      {                          double miterDistance2 = PlanimetryAlgorithms.Distance(miterPoint' PlanimetryEnvironment.NewCoordinate(x2' y2));                          if (miterDistance2 < _miterLimit * _width / 2)                              vertexList.Add(miterPoint);                          else                          {                              if (join == LineJoin.MiterClipped)                              {                                  vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                                  vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                              }                              else                              {                                  double l = _miterLimit * _width * 0.5;                                  double miterDistance1 = PlanimetryAlgorithms.Distance(s1.V2' miterPoint);                                  double clipDistance = ((miterDistance2 - l) * (miterDistance2 - l) + l) / miterDistance1;                                    double f = clipDistance / (miterDistance1 - clipDistance);                                  vertexList.Add(PlanimetryEnvironment.NewCoordinate((f * s1.V2.X + miterPoint.X) / (1 + f)'                                                            (f * s1.V2.Y + miterPoint.Y) / (1 + f)));                                  vertexList.Add(PlanimetryEnvironment.NewCoordinate((f * s2.V2.X + miterPoint.X) / (1 + f)'                                                            (f * s2.V2.Y + miterPoint.Y) / (1 + f)));                              }                          }                      }                      else                      {                          if (join == LineJoin.MiterClipped)                          {                              vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                              vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                          }                          else                          {                              double d = Math.Sqrt(_width * _width / 4 + _miterLimit * _miterLimit);                              double alpha = Math.Atan(1 / _miterLimit);                              vertexList.Add(pointOnCircle(x2' y2' d' angle1 - alpha));                              vertexList.Add(pointOnCircle(x2' y2' d' angle1 + alpha));                          }                      }                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addJoin,The following statement contains a magic number: switch (join)              {                   case LineJoin.Bevel:                      vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                      vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                      break;                  case LineJoin.Round:                      ICoordinate[] points =                          getCirclePoints(PlanimetryEnvironment.NewCoordinate(x2' y2)'                          angle1'                          angle1 - Math.PI + angleBetweenSegments'                           halfWidth'                          (int)(Math.Round(_width * Math.PI) / 2));                        foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineJoin.Miter:                  case LineJoin.MiterClipped:                        Segment s1 = new Segment(pointOnCircle(x1' y1' halfWidth' angle1)' pointOnCircle(x2' y2' halfWidth' angle1));                      Segment s2 = new Segment(pointOnCircle(x3' y3' halfWidth' angle2)' pointOnCircle(x2' y2' halfWidth' angle2));                        ICoordinate miterPoint = null;                        if (PlanimetryAlgorithms.DirectsIntersection(s1' s2' ref miterPoint) == Dimension.Zero)                      {                          double miterDistance2 = PlanimetryAlgorithms.Distance(miterPoint' PlanimetryEnvironment.NewCoordinate(x2' y2));                          if (miterDistance2 < _miterLimit * _width / 2)                              vertexList.Add(miterPoint);                          else                          {                              if (join == LineJoin.MiterClipped)                              {                                  vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                                  vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                              }                              else                              {                                  double l = _miterLimit * _width * 0.5;                                  double miterDistance1 = PlanimetryAlgorithms.Distance(s1.V2' miterPoint);                                  double clipDistance = ((miterDistance2 - l) * (miterDistance2 - l) + l) / miterDistance1;                                    double f = clipDistance / (miterDistance1 - clipDistance);                                  vertexList.Add(PlanimetryEnvironment.NewCoordinate((f * s1.V2.X + miterPoint.X) / (1 + f)'                                                            (f * s1.V2.Y + miterPoint.Y) / (1 + f)));                                  vertexList.Add(PlanimetryEnvironment.NewCoordinate((f * s2.V2.X + miterPoint.X) / (1 + f)'                                                            (f * s2.V2.Y + miterPoint.Y) / (1 + f)));                              }                          }                      }                      else                      {                          if (join == LineJoin.MiterClipped)                          {                              vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                              vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                          }                          else                          {                              double d = Math.Sqrt(_width * _width / 4 + _miterLimit * _miterLimit);                              double alpha = Math.Atan(1 / _miterLimit);                              vertexList.Add(pointOnCircle(x2' y2' d' angle1 - alpha));                              vertexList.Add(pointOnCircle(x2' y2' d' angle1 + alpha));                          }                      }                      break;              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getPathContour,The following statement contains a magic number: if (pv.Count > 1)              {                  // начало линии                  addCap(_lineStartCap'                      c.Vertices'                      CapLocation.Start'                      pv[0].X' pv[0].Y'                      pv[1].X' pv[1].Y);                    int cnt = path.Vertices.Count;                  for (int i = 0; i < cnt - 2; i++)                      addJoin(_lineJoin'                          c.Vertices'                          pv[i].X' pv[i].Y'                          pv[i + 1].X' pv[i + 1].Y'                          pv[i + 2].X' pv[i + 2].Y);                    // окончание линии                  addCap(_lineEndCap'                      c.Vertices'                      CapLocation.End'                      pv[cnt - 2].X' pv[cnt - 2].Y'                      pv[cnt - 1].X' pv[cnt - 1].Y);                    // соединения линий "по правую сторону"                  for (int i = cnt - 1; i > 1; i--)                      addJoin(_lineJoin'                          c.Vertices'                          pv[i].X' pv[i].Y'                          pv[i - 1].X' pv[i - 1].Y'                          pv[i - 2].X' pv[i - 2].Y);              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getPathContour,The following statement contains a magic number: if (pv.Count > 1)              {                  // начало линии                  addCap(_lineStartCap'                      c.Vertices'                      CapLocation.Start'                      pv[0].X' pv[0].Y'                      pv[1].X' pv[1].Y);                    int cnt = path.Vertices.Count;                  for (int i = 0; i < cnt - 2; i++)                      addJoin(_lineJoin'                          c.Vertices'                          pv[i].X' pv[i].Y'                          pv[i + 1].X' pv[i + 1].Y'                          pv[i + 2].X' pv[i + 2].Y);                    // окончание линии                  addCap(_lineEndCap'                      c.Vertices'                      CapLocation.End'                      pv[cnt - 2].X' pv[cnt - 2].Y'                      pv[cnt - 1].X' pv[cnt - 1].Y);                    // соединения линий "по правую сторону"                  for (int i = cnt - 1; i > 1; i--)                      addJoin(_lineJoin'                          c.Vertices'                          pv[i].X' pv[i].Y'                          pv[i - 1].X' pv[i - 1].Y'                          pv[i - 2].X' pv[i - 2].Y);              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getPathContour,The following statement contains a magic number: if (pv.Count > 1)              {                  // начало линии                  addCap(_lineStartCap'                      c.Vertices'                      CapLocation.Start'                      pv[0].X' pv[0].Y'                      pv[1].X' pv[1].Y);                    int cnt = path.Vertices.Count;                  for (int i = 0; i < cnt - 2; i++)                      addJoin(_lineJoin'                          c.Vertices'                          pv[i].X' pv[i].Y'                          pv[i + 1].X' pv[i + 1].Y'                          pv[i + 2].X' pv[i + 2].Y);                    // окончание линии                  addCap(_lineEndCap'                      c.Vertices'                      CapLocation.End'                      pv[cnt - 2].X' pv[cnt - 2].Y'                      pv[cnt - 1].X' pv[cnt - 1].Y);                    // соединения линий "по правую сторону"                  for (int i = cnt - 1; i > 1; i--)                      addJoin(_lineJoin'                          c.Vertices'                          pv[i].X' pv[i].Y'                          pv[i - 1].X' pv[i - 1].Y'                          pv[i - 2].X' pv[i - 2].Y);              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getPathContour,The following statement contains a magic number: if (pv.Count > 1)              {                  // начало линии                  addCap(_lineStartCap'                      c.Vertices'                      CapLocation.Start'                      pv[0].X' pv[0].Y'                      pv[1].X' pv[1].Y);                    int cnt = path.Vertices.Count;                  for (int i = 0; i < cnt - 2; i++)                      addJoin(_lineJoin'                          c.Vertices'                          pv[i].X' pv[i].Y'                          pv[i + 1].X' pv[i + 1].Y'                          pv[i + 2].X' pv[i + 2].Y);                    // окончание линии                  addCap(_lineEndCap'                      c.Vertices'                      CapLocation.End'                      pv[cnt - 2].X' pv[cnt - 2].Y'                      pv[cnt - 1].X' pv[cnt - 1].Y);                    // соединения линий "по правую сторону"                  for (int i = cnt - 1; i > 1; i--)                      addJoin(_lineJoin'                          c.Vertices'                          pv[i].X' pv[i].Y'                          pv[i - 1].X' pv[i - 1].Y'                          pv[i - 2].X' pv[i - 2].Y);              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getPathContour,The following statement contains a magic number: if (pv.Count > 1)              {                  // начало линии                  addCap(_lineStartCap'                      c.Vertices'                      CapLocation.Start'                      pv[0].X' pv[0].Y'                      pv[1].X' pv[1].Y);                    int cnt = path.Vertices.Count;                  for (int i = 0; i < cnt - 2; i++)                      addJoin(_lineJoin'                          c.Vertices'                          pv[i].X' pv[i].Y'                          pv[i + 1].X' pv[i + 1].Y'                          pv[i + 2].X' pv[i + 2].Y);                    // окончание линии                  addCap(_lineEndCap'                      c.Vertices'                      CapLocation.End'                      pv[cnt - 2].X' pv[cnt - 2].Y'                      pv[cnt - 1].X' pv[cnt - 1].Y);                    // соединения линий "по правую сторону"                  for (int i = cnt - 1; i > 1; i--)                      addJoin(_lineJoin'                          c.Vertices'                          pv[i].X' pv[i].Y'                          pv[i - 1].X' pv[i - 1].Y'                          pv[i - 2].X' pv[i - 2].Y);              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getPathContour,The following statement contains a magic number: if (pv.Count > 1)              {                  // начало линии                  addCap(_lineStartCap'                      c.Vertices'                      CapLocation.Start'                      pv[0].X' pv[0].Y'                      pv[1].X' pv[1].Y);                    int cnt = path.Vertices.Count;                  for (int i = 0; i < cnt - 2; i++)                      addJoin(_lineJoin'                          c.Vertices'                          pv[i].X' pv[i].Y'                          pv[i + 1].X' pv[i + 1].Y'                          pv[i + 2].X' pv[i + 2].Y);                    // окончание линии                  addCap(_lineEndCap'                      c.Vertices'                      CapLocation.End'                      pv[cnt - 2].X' pv[cnt - 2].Y'                      pv[cnt - 1].X' pv[cnt - 1].Y);                    // соединения линий "по правую сторону"                  for (int i = cnt - 1; i > 1; i--)                      addJoin(_lineJoin'                          c.Vertices'                          pv[i].X' pv[i].Y'                          pv[i - 1].X' pv[i - 1].Y'                          pv[i - 2].X' pv[i - 2].Y);              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,getPathContour,The following statement contains a magic number: if (pv.Count > 1)              {                  // начало линии                  addCap(_lineStartCap'                      c.Vertices'                      CapLocation.Start'                      pv[0].X' pv[0].Y'                      pv[1].X' pv[1].Y);                    int cnt = path.Vertices.Count;                  for (int i = 0; i < cnt - 2; i++)                      addJoin(_lineJoin'                          c.Vertices'                          pv[i].X' pv[i].Y'                          pv[i + 1].X' pv[i + 1].Y'                          pv[i + 2].X' pv[i + 2].Y);                    // окончание линии                  addCap(_lineEndCap'                      c.Vertices'                      CapLocation.End'                      pv[cnt - 2].X' pv[cnt - 2].Y'                      pv[cnt - 1].X' pv[cnt - 1].Y);                    // соединения линий "по правую сторону"                  for (int i = cnt - 1; i > 1; i--)                      addJoin(_lineJoin'                          c.Vertices'                          pv[i].X' pv[i].Y'                          pv[i - 1].X' pv[i - 1].Y'                          pv[i - 2].X' pv[i - 2].Y);              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,geContourContour,The following statement contains a magic number: if (cv.Count > 2)              {                  // начало линии                  addCap(LineCap.Flat'                      c.Vertices'                      CapLocation.Start'                      cv[0].X' cv[0].Y'                      cv[1].X' cv[1].Y);                    int cnt = contour.Vertices.Count;                  for (int i = 0; i < cnt; i++)                  {                      int i1 = i < cnt - 1 ? i + 1 : 0;                      int i2 = i1 < cnt - 1 ? i1 + 1 : 0;                      addJoin(_lineJoin'                          c.Vertices'                          cv[i].X' cv[i].Y'                          cv[i1].X' cv[i1].Y'                          cv[i2].X' cv[i2].Y);                  }                    // окончание линии                  addCap(LineCap.Flat'                      c.Vertices'                      CapLocation.End'                      cv[0].X' cv[0].Y'                      cv[1].X' cv[1].Y);                      int ii = 2;                      for (int j = 0; j < cnt; j++)                  {                      ii--;                      if (ii == -1)                          ii = cnt - 1;                      int i1 = ii > 0 ? ii - 1 : cnt - 1;                      int i2 = i1 > 0 ? i1 - 1 : cnt - 1;                        addJoin(_lineJoin'                          c.Vertices'                          cv[ii].X' cv[ii].Y'                          cv[i1].X' cv[i1].Y'                          cv[i2].X' cv[i2].Y);                  }              }
Magic Number,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,geContourContour,The following statement contains a magic number: if (cv.Count > 2)              {                  // начало линии                  addCap(LineCap.Flat'                      c.Vertices'                      CapLocation.Start'                      cv[0].X' cv[0].Y'                      cv[1].X' cv[1].Y);                    int cnt = contour.Vertices.Count;                  for (int i = 0; i < cnt; i++)                  {                      int i1 = i < cnt - 1 ? i + 1 : 0;                      int i2 = i1 < cnt - 1 ? i1 + 1 : 0;                      addJoin(_lineJoin'                          c.Vertices'                          cv[i].X' cv[i].Y'                          cv[i1].X' cv[i1].Y'                          cv[i2].X' cv[i2].Y);                  }                    // окончание линии                  addCap(LineCap.Flat'                      c.Vertices'                      CapLocation.End'                      cv[0].X' cv[0].Y'                      cv[1].X' cv[1].Y);                      int ii = 2;                      for (int j = 0; j < cnt; j++)                  {                      ii--;                      if (ii == -1)                          ii = cnt - 1;                      int i1 = ii > 0 ? ii - 1 : cnt - 1;                      int i2 = i1 > 0 ? i1 - 1 : cnt - 1;                        addJoin(_lineJoin'                          c.Vertices'                          cv[ii].X' cv[ii].Y'                          cv[i1].X' cv[i1].Y'                          cv[i2].X' cv[i2].Y);                  }              }
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,SetPixel,The following statement contains a magic number: _buffer[shift] =                  (int)a << 24 |                           (int)r << 16 |                           (int)g << 8 |                           (int)b;
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,SetPixel,The following statement contains a magic number: _buffer[shift] =                  (int)a << 24 |                           (int)r << 16 |                           (int)g << 8 |                           (int)b;
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,SetPixel,The following statement contains a magic number: _buffer[shift] =                  (int)a << 24 |                           (int)r << 16 |                           (int)g << 8 |                           (int)b;
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: byte alpha = (byte)(pixelData >> 24 & 0xFF);
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: if (alpha == 255)              {                  _buffer[shift] = pixelData;                  return;              }
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: byte oldAlpha = (byte)((oldPixelData >> 24 & 0xFF));
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: Int32 b1 = newAlpha << 24;
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData >> 16 & 0xFF) * a1) << 16;
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData >> 16 & 0xFF) * a1) << 16;
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData >> 16 & 0xFF) * a1) << 16;
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData >> 8 & 0xFF) * a1) << 8;
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData >> 8 & 0xFF) * a1) << 8;
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendPixel,The following statement contains a magic number: Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData >> 8 & 0xFF) * a1) << 8;
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 pixelData = spanPixels[i];                    byte alpha = (byte)(pixelData >> 24 & 0xFF);                    if (alpha == 255)                  {                      _buffer[shift] = pixelData;                      shift += shiftIncrement;                      continue;                  }                    // целесообразность проверки под вопросом                  if (alpha == 0)                  {                      shift += shiftIncrement;                      continue;                  }                    Int32 oldPixelData = _buffer[shift];                  byte oldAlpha = (byte)((oldPixelData >> 24 & 0xFF));                    if (oldAlpha == 0)                  {                      _buffer[shift] = pixelData;                      shift += shiftIncrement;                      continue;                  }                    byte newAlpha = (byte)(alpha + oldAlpha - alpha * oldAlpha / 255f);                    float a1 = alpha / 255f;                  float a0 = (1 - a1) * oldAlpha / 255f;                  a0 = a0 / (a1 + a0);                  a1 = 1 - a0;                    Int32 b1 = newAlpha << 24;                  Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData >> 16 & 0xFF) * a1) << 16;                  Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData >> 8 & 0xFF) * a1) << 8;                  Int32 b4 = (byte)((oldPixelData & 0xFF) * a0 + (pixelData & 0xFF) * a1);                    _buffer[shift] = b1 | b2 | b3 | b4;                  shift += shiftIncrement;              }
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 pixelData = spanPixels[i];                    byte alpha = (byte)(pixelData >> 24 & 0xFF);                    if (alpha == 255)                  {                      _buffer[shift] = pixelData;                      shift += shiftIncrement;                      continue;                  }                    // целесообразность проверки под вопросом                  if (alpha == 0)                  {                      shift += shiftIncrement;                      continue;                  }                    Int32 oldPixelData = _buffer[shift];                  byte oldAlpha = (byte)((oldPixelData >> 24 & 0xFF));                    if (oldAlpha == 0)                  {                      _buffer[shift] = pixelData;                      shift += shiftIncrement;                      continue;                  }                    byte newAlpha = (byte)(alpha + oldAlpha - alpha * oldAlpha / 255f);                    float a1 = alpha / 255f;                  float a0 = (1 - a1) * oldAlpha / 255f;                  a0 = a0 / (a1 + a0);                  a1 = 1 - a0;                    Int32 b1 = newAlpha << 24;                  Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData >> 16 & 0xFF) * a1) << 16;                  Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData >> 8 & 0xFF) * a1) << 8;                  Int32 b4 = (byte)((oldPixelData & 0xFF) * a0 + (pixelData & 0xFF) * a1);                    _buffer[shift] = b1 | b2 | b3 | b4;                  shift += shiftIncrement;              }
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 pixelData = spanPixels[i];                    byte alpha = (byte)(pixelData >> 24 & 0xFF);                    if (alpha == 255)                  {                      _buffer[shift] = pixelData;                      shift += shiftIncrement;                      continue;                  }                    // целесообразность проверки под вопросом                  if (alpha == 0)                  {                      shift += shiftIncrement;                      continue;                  }                    Int32 oldPixelData = _buffer[shift];                  byte oldAlpha = (byte)((oldPixelData >> 24 & 0xFF));                    if (oldAlpha == 0)                  {                      _buffer[shift] = pixelData;                      shift += shiftIncrement;                      continue;                  }                    byte newAlpha = (byte)(alpha + oldAlpha - alpha * oldAlpha / 255f);                    float a1 = alpha / 255f;                  float a0 = (1 - a1) * oldAlpha / 255f;                  a0 = a0 / (a1 + a0);                  a1 = 1 - a0;                    Int32 b1 = newAlpha << 24;                  Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData >> 16 & 0xFF) * a1) << 16;                  Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData >> 8 & 0xFF) * a1) << 8;                  Int32 b4 = (byte)((oldPixelData & 0xFF) * a0 + (pixelData & 0xFF) * a1);                    _buffer[shift] = b1 | b2 | b3 | b4;                  shift += shiftIncrement;              }
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 pixelData = spanPixels[i];                    byte alpha = (byte)(pixelData >> 24 & 0xFF);                    if (alpha == 255)                  {                      _buffer[shift] = pixelData;                      shift += shiftIncrement;                      continue;                  }                    // целесообразность проверки под вопросом                  if (alpha == 0)                  {                      shift += shiftIncrement;                      continue;                  }                    Int32 oldPixelData = _buffer[shift];                  byte oldAlpha = (byte)((oldPixelData >> 24 & 0xFF));                    if (oldAlpha == 0)                  {                      _buffer[shift] = pixelData;                      shift += shiftIncrement;                      continue;                  }                    byte newAlpha = (byte)(alpha + oldAlpha - alpha * oldAlpha / 255f);                    float a1 = alpha / 255f;                  float a0 = (1 - a1) * oldAlpha / 255f;                  a0 = a0 / (a1 + a0);                  a1 = 1 - a0;                    Int32 b1 = newAlpha << 24;                  Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData >> 16 & 0xFF) * a1) << 16;                  Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData >> 8 & 0xFF) * a1) << 8;                  Int32 b4 = (byte)((oldPixelData & 0xFF) * a0 + (pixelData & 0xFF) * a1);                    _buffer[shift] = b1 | b2 | b3 | b4;                  shift += shiftIncrement;              }
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 pixelData = spanPixels[i];                    byte alpha = (byte)(pixelData >> 24 & 0xFF);                    if (alpha == 255)                  {                      _buffer[shift] = pixelData;                      shift += shiftIncrement;                      continue;                  }                    // целесообразность проверки под вопросом                  if (alpha == 0)                  {                      shift += shiftIncrement;                      continue;                  }                    Int32 oldPixelData = _buffer[shift];                  byte oldAlpha = (byte)((oldPixelData >> 24 & 0xFF));                    if (oldAlpha == 0)                  {                      _buffer[shift] = pixelData;                      shift += shiftIncrement;                      continue;                  }                    byte newAlpha = (byte)(alpha + oldAlpha - alpha * oldAlpha / 255f);                    float a1 = alpha / 255f;                  float a0 = (1 - a1) * oldAlpha / 255f;                  a0 = a0 / (a1 + a0);                  a1 = 1 - a0;                    Int32 b1 = newAlpha << 24;                  Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData >> 16 & 0xFF) * a1) << 16;                  Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData >> 8 & 0xFF) * a1) << 8;                  Int32 b4 = (byte)((oldPixelData & 0xFF) * a0 + (pixelData & 0xFF) * a1);                    _buffer[shift] = b1 | b2 | b3 | b4;                  shift += shiftIncrement;              }
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 pixelData = spanPixels[i];                    byte alpha = (byte)(pixelData >> 24 & 0xFF);                    if (alpha == 255)                  {                      _buffer[shift] = pixelData;                      shift += shiftIncrement;                      continue;                  }                    // целесообразность проверки под вопросом                  if (alpha == 0)                  {                      shift += shiftIncrement;                      continue;                  }                    Int32 oldPixelData = _buffer[shift];                  byte oldAlpha = (byte)((oldPixelData >> 24 & 0xFF));                    if (oldAlpha == 0)                  {                      _buffer[shift] = pixelData;                      shift += shiftIncrement;                      continue;                  }                    byte newAlpha = (byte)(alpha + oldAlpha - alpha * oldAlpha / 255f);                    float a1 = alpha / 255f;                  float a0 = (1 - a1) * oldAlpha / 255f;                  a0 = a0 / (a1 + a0);                  a1 = 1 - a0;                    Int32 b1 = newAlpha << 24;                  Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData >> 16 & 0xFF) * a1) << 16;                  Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData >> 8 & 0xFF) * a1) << 8;                  Int32 b4 = (byte)((oldPixelData & 0xFF) * a0 + (pixelData & 0xFF) * a1);                    _buffer[shift] = b1 | b2 | b3 | b4;                  shift += shiftIncrement;              }
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 pixelData = spanPixels[i];                    byte alpha = (byte)(pixelData >> 24 & 0xFF);                    if (alpha == 255)                  {                      _buffer[shift] = pixelData;                      shift += shiftIncrement;                      continue;                  }                    // целесообразность проверки под вопросом                  if (alpha == 0)                  {                      shift += shiftIncrement;                      continue;                  }                    Int32 oldPixelData = _buffer[shift];                  byte oldAlpha = (byte)((oldPixelData >> 24 & 0xFF));                    if (oldAlpha == 0)                  {                      _buffer[shift] = pixelData;                      shift += shiftIncrement;                      continue;                  }                    byte newAlpha = (byte)(alpha + oldAlpha - alpha * oldAlpha / 255f);                    float a1 = alpha / 255f;                  float a0 = (1 - a1) * oldAlpha / 255f;                  a0 = a0 / (a1 + a0);                  a1 = 1 - a0;                    Int32 b1 = newAlpha << 24;                  Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData >> 16 & 0xFF) * a1) << 16;                  Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData >> 8 & 0xFF) * a1) << 8;                  Int32 b4 = (byte)((oldPixelData & 0xFF) * a0 + (pixelData & 0xFF) * a1);                    _buffer[shift] = b1 | b2 | b3 | b4;                  shift += shiftIncrement;              }
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 pixelData = spanPixels[i];                    byte alpha = (byte)(pixelData >> 24 & 0xFF);                    if (alpha == 255)                  {                      _buffer[shift] = pixelData;                      shift += shiftIncrement;                      continue;                  }                    // целесообразность проверки под вопросом                  if (alpha == 0)                  {                      shift += shiftIncrement;                      continue;                  }                    Int32 oldPixelData = _buffer[shift];                  byte oldAlpha = (byte)((oldPixelData >> 24 & 0xFF));                    if (oldAlpha == 0)                  {                      _buffer[shift] = pixelData;                      shift += shiftIncrement;                      continue;                  }                    byte newAlpha = (byte)(alpha + oldAlpha - alpha * oldAlpha / 255f);                    float a1 = alpha / 255f;                  float a0 = (1 - a1) * oldAlpha / 255f;                  a0 = a0 / (a1 + a0);                  a1 = 1 - a0;                    Int32 b1 = newAlpha << 24;                  Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData >> 16 & 0xFF) * a1) << 16;                  Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData >> 8 & 0xFF) * a1) << 8;                  Int32 b4 = (byte)((oldPixelData & 0xFF) * a0 + (pixelData & 0xFF) * a1);                    _buffer[shift] = b1 | b2 | b3 | b4;                  shift += shiftIncrement;              }
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 pixelData = spanPixels[i];                    byte alpha = (byte)(pixelData >> 24 & 0xFF);                    if (alpha == 255)                  {                      _buffer[shift] = pixelData;                      shift += shiftIncrement;                      continue;                  }                    // целесообразность проверки под вопросом                  if (alpha == 0)                  {                      shift += shiftIncrement;                      continue;                  }                    Int32 oldPixelData = _buffer[shift];                  byte oldAlpha = (byte)((oldPixelData >> 24 & 0xFF));                    if (oldAlpha == 0)                  {                      _buffer[shift] = pixelData;                      shift += shiftIncrement;                      continue;                  }                    byte newAlpha = (byte)(alpha + oldAlpha - alpha * oldAlpha / 255f);                    float a1 = alpha / 255f;                  float a0 = (1 - a1) * oldAlpha / 255f;                  a0 = a0 / (a1 + a0);                  a1 = 1 - a0;                    Int32 b1 = newAlpha << 24;                  Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData >> 16 & 0xFF) * a1) << 16;                  Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData >> 8 & 0xFF) * a1) << 8;                  Int32 b4 = (byte)((oldPixelData & 0xFF) * a0 + (pixelData & 0xFF) * a1);                    _buffer[shift] = b1 | b2 | b3 | b4;                  shift += shiftIncrement;              }
Magic Number,MapAround.Rendering,RasterData,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Rasterization.cs,BlendSpan,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 pixelData = spanPixels[i];                    byte alpha = (byte)(pixelData >> 24 & 0xFF);                    if (alpha == 255)                  {                      _buffer[shift] = pixelData;                      shift += shiftIncrement;                      continue;                  }                    // целесообразность проверки под вопросом                  if (alpha == 0)                  {                      shift += shiftIncrement;                      continue;                  }                    Int32 oldPixelData = _buffer[shift];                  byte oldAlpha = (byte)((oldPixelData >> 24 & 0xFF));                    if (oldAlpha == 0)                  {                      _buffer[shift] = pixelData;                      shift += shiftIncrement;                      continue;                  }                    byte newAlpha = (byte)(alpha + oldAlpha - alpha * oldAlpha / 255f);                    float a1 = alpha / 255f;                  float a0 = (1 - a1) * oldAlpha / 255f;                  a0 = a0 / (a1 + a0);                  a1 = 1 - a0;                    Int32 b1 = newAlpha << 24;                  Int32 b2 = (byte)((oldPixelData >> 16 & 0xFF) * a0 + (pixelData >> 16 & 0xFF) * a1) << 16;                  Int32 b3 = (byte)((oldPixelData >> 8 & 0xFF) * a0 + (pixelData >> 8 & 0xFF) * a1) << 8;                  Int32 b4 = (byte)((oldPixelData & 0xFF) * a0 + (pixelData & 0xFF) * a1);                    _buffer[shift] = b1 | b2 | b3 | b4;                  shift += shiftIncrement;              }
Magic Number,MapAround.Rendering,RenderingPipeline,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following statement contains a magic number: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Magic Number,MapAround.Rendering,RenderingPipeline,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following statement contains a magic number: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Magic Number,MapAround.Rendering,RenderingPipeline,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following statement contains a magic number: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Magic Number,MapAround.Rendering,RenderingPipeline,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following statement contains a magic number: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Magic Number,MapAround.Rendering,RenderingPipeline,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following statement contains a magic number: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Magic Number,MapAround.Rendering,RenderingPipeline,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following statement contains a magic number: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Magic Number,MapAround.Rendering,RenderingPipeline,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following statement contains a magic number: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Magic Number,MapAround.Rendering,RenderingPipeline,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following statement contains a magic number: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Magic Number,MapAround.Rendering,RenderingPipeline,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following statement contains a magic number: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Magic Number,MapAround.Rendering,RenderingPipeline,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following statement contains a magic number: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Magic Number,MapAround.Rendering,SpanGenerator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,addSpans,The following statement contains a magic number: float[] pixelCoverage = new float[(int)(max + 2) - (int)min];
Magic Number,MapAround.Rendering,SpanGenerator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,addSpans,The following statement contains a magic number: foreach (float[] subPixelSpan in pixelScanIntersections)              {                  int subPixelSpanLength = subPixelSpan.Length;                   if (subPixelSpanLength > 0)                  {                      for (int k = 0; k < subPixelSpanLength; k += 2)                      {                          float spanStart = subPixelSpan[k];                          float spanEnd = subPixelSpan[k + 1];                            // длина пересечения сканирующего отрезка с объектом меньше единицы                          // и это пересечение не пересекает границы пикселей                          if ((int)spanEnd == (int)spanStart ||                              (int)spanEnd == (int)spanStart + 1)                              if (spanEnd - spanStart < 1)                              {                                  pixelCoverage[(int)spanStart - shift] += spanEnd - spanStart;                                  continue;                              }                            // пиксели' пересеченные сканирующим отрезком "насквозь"                          float hv = spanEnd - shift - 1;                          for (int pixelIndex = (int)spanStart + 1 - shift; pixelIndex < hv; pixelIndex++)                              pixelCoverage[pixelIndex]++;                            // пиксель' в котором начался сканирующий отрезок                          pixelCoverage[(int)spanStart - shift] += 1 - (spanStart - (int)spanStart);                            // пиксель' в котором закончился сканирующий отрезок                          if (hv == (int)hv)                              pixelCoverage[(int)hv] += 1;                          else                              pixelCoverage[(int)hv + 1] += spanEnd - (int)spanEnd;                      }                  }              }
Magic Number,MapAround.Rendering,SpanGenerator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,addSpans,The following statement contains a magic number: for (int i = 0; i <= coverageArrayHiIndex; i++)              {                  if (!spanStarted)                  {                      if (pixelCoverage[i] > 0)                      {                          spanStartIndex = i;                          spanStarted = true;                      }                  }                  else                  {                      if (pixelCoverage[i] == 0 || i == coverageArrayHiIndex)                      {                          Int32[] pixelValues = new int[i - spanStartIndex];                          int f = 0;                          switch(orientation)                          {                              case Orientation.Horizontal:                                  for (int k = spanStartIndex; k < i; k++)                                  {                                      double coverage = pixelCoverage[k];                                      if (coverage > _subPixelLevel)                                          coverage = _subPixelLevel;                                        double antiAliasingAlpha = _alphaTable[(int)(coverage / _subPixelLevel * 254f)];                                        Int32 color = fill.GetPixelColor((int)min + f + spanStartIndex' scanPosition);                                      byte fillAlpha = (byte)(color >> 24 & 0xFF);                                      if (fillAlpha == 0)                                          pixelValues[f] = (byte)(antiAliasingAlpha * 255f) << 24 | color;                                      else                                          pixelValues[f] = (byte)(antiAliasingAlpha * fillAlpha) << 24 | (color & 0x00FFFFFF);                                        f++;                                  }                                  spans.Add(new PixelSpan(Orientation.Horizontal' (int)min + spanStartIndex' scanPosition' pixelValues));                                  break;                                case Orientation.Vertical:                                  for (int k = spanStartIndex; k < i; k++)                                  {                                      double coverage = pixelCoverage[k];                                      if (coverage > _subPixelLevel)                                          coverage = _subPixelLevel;                                        double antiAliasingAlpha = _alphaTable[(int)(coverage / _subPixelLevel * 254f)];                                        Int32 color = fill.GetPixelColor(scanPosition' (int)min + f + spanStartIndex);                                      byte fillAlpha = (byte)(color >> 24 & 0xFF);                                      if (fillAlpha == 0)                                          pixelValues[f] = (byte)(antiAliasingAlpha * 255f) << 24 | color;                                      else                                          pixelValues[f] = (byte)(antiAliasingAlpha * fillAlpha) << 24 | (color & 0x00FFFFFF);                                        f++;                                  }                                  spans.Add(new PixelSpan(Orientation.Vertical' scanPosition' (int)min + spanStartIndex' pixelValues));                                  break;                          }                          spanStarted = false;                      }                  }              }
Magic Number,MapAround.Rendering,SpanGenerator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,addSpans,The following statement contains a magic number: for (int i = 0; i <= coverageArrayHiIndex; i++)              {                  if (!spanStarted)                  {                      if (pixelCoverage[i] > 0)                      {                          spanStartIndex = i;                          spanStarted = true;                      }                  }                  else                  {                      if (pixelCoverage[i] == 0 || i == coverageArrayHiIndex)                      {                          Int32[] pixelValues = new int[i - spanStartIndex];                          int f = 0;                          switch(orientation)                          {                              case Orientation.Horizontal:                                  for (int k = spanStartIndex; k < i; k++)                                  {                                      double coverage = pixelCoverage[k];                                      if (coverage > _subPixelLevel)                                          coverage = _subPixelLevel;                                        double antiAliasingAlpha = _alphaTable[(int)(coverage / _subPixelLevel * 254f)];                                        Int32 color = fill.GetPixelColor((int)min + f + spanStartIndex' scanPosition);                                      byte fillAlpha = (byte)(color >> 24 & 0xFF);                                      if (fillAlpha == 0)                                          pixelValues[f] = (byte)(antiAliasingAlpha * 255f) << 24 | color;                                      else                                          pixelValues[f] = (byte)(antiAliasingAlpha * fillAlpha) << 24 | (color & 0x00FFFFFF);                                        f++;                                  }                                  spans.Add(new PixelSpan(Orientation.Horizontal' (int)min + spanStartIndex' scanPosition' pixelValues));                                  break;                                case Orientation.Vertical:                                  for (int k = spanStartIndex; k < i; k++)                                  {                                      double coverage = pixelCoverage[k];                                      if (coverage > _subPixelLevel)                                          coverage = _subPixelLevel;                                        double antiAliasingAlpha = _alphaTable[(int)(coverage / _subPixelLevel * 254f)];                                        Int32 color = fill.GetPixelColor(scanPosition' (int)min + f + spanStartIndex);                                      byte fillAlpha = (byte)(color >> 24 & 0xFF);                                      if (fillAlpha == 0)                                          pixelValues[f] = (byte)(antiAliasingAlpha * 255f) << 24 | color;                                      else                                          pixelValues[f] = (byte)(antiAliasingAlpha * fillAlpha) << 24 | (color & 0x00FFFFFF);                                        f++;                                  }                                  spans.Add(new PixelSpan(Orientation.Vertical' scanPosition' (int)min + spanStartIndex' pixelValues));                                  break;                          }                          spanStarted = false;                      }                  }              }
Magic Number,MapAround.Rendering,SpanGenerator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,addSpans,The following statement contains a magic number: for (int i = 0; i <= coverageArrayHiIndex; i++)              {                  if (!spanStarted)                  {                      if (pixelCoverage[i] > 0)                      {                          spanStartIndex = i;                          spanStarted = true;                      }                  }                  else                  {                      if (pixelCoverage[i] == 0 || i == coverageArrayHiIndex)                      {                          Int32[] pixelValues = new int[i - spanStartIndex];                          int f = 0;                          switch(orientation)                          {                              case Orientation.Horizontal:                                  for (int k = spanStartIndex; k < i; k++)                                  {                                      double coverage = pixelCoverage[k];                                      if (coverage > _subPixelLevel)                                          coverage = _subPixelLevel;                                        double antiAliasingAlpha = _alphaTable[(int)(coverage / _subPixelLevel * 254f)];                                        Int32 color = fill.GetPixelColor((int)min + f + spanStartIndex' scanPosition);                                      byte fillAlpha = (byte)(color >> 24 & 0xFF);                                      if (fillAlpha == 0)                                          pixelValues[f] = (byte)(antiAliasingAlpha * 255f) << 24 | color;                                      else                                          pixelValues[f] = (byte)(antiAliasingAlpha * fillAlpha) << 24 | (color & 0x00FFFFFF);                                        f++;                                  }                                  spans.Add(new PixelSpan(Orientation.Horizontal' (int)min + spanStartIndex' scanPosition' pixelValues));                                  break;                                case Orientation.Vertical:                                  for (int k = spanStartIndex; k < i; k++)                                  {                                      double coverage = pixelCoverage[k];                                      if (coverage > _subPixelLevel)                                          coverage = _subPixelLevel;                                        double antiAliasingAlpha = _alphaTable[(int)(coverage / _subPixelLevel * 254f)];                                        Int32 color = fill.GetPixelColor(scanPosition' (int)min + f + spanStartIndex);                                      byte fillAlpha = (byte)(color >> 24 & 0xFF);                                      if (fillAlpha == 0)                                          pixelValues[f] = (byte)(antiAliasingAlpha * 255f) << 24 | color;                                      else                                          pixelValues[f] = (byte)(antiAliasingAlpha * fillAlpha) << 24 | (color & 0x00FFFFFF);                                        f++;                                  }                                  spans.Add(new PixelSpan(Orientation.Vertical' scanPosition' (int)min + spanStartIndex' pixelValues));                                  break;                          }                          spanStarted = false;                      }                  }              }
Magic Number,MapAround.Rendering,SpanGenerator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,addSpans,The following statement contains a magic number: for (int i = 0; i <= coverageArrayHiIndex; i++)              {                  if (!spanStarted)                  {                      if (pixelCoverage[i] > 0)                      {                          spanStartIndex = i;                          spanStarted = true;                      }                  }                  else                  {                      if (pixelCoverage[i] == 0 || i == coverageArrayHiIndex)                      {                          Int32[] pixelValues = new int[i - spanStartIndex];                          int f = 0;                          switch(orientation)                          {                              case Orientation.Horizontal:                                  for (int k = spanStartIndex; k < i; k++)                                  {                                      double coverage = pixelCoverage[k];                                      if (coverage > _subPixelLevel)                                          coverage = _subPixelLevel;                                        double antiAliasingAlpha = _alphaTable[(int)(coverage / _subPixelLevel * 254f)];                                        Int32 color = fill.GetPixelColor((int)min + f + spanStartIndex' scanPosition);                                      byte fillAlpha = (byte)(color >> 24 & 0xFF);                                      if (fillAlpha == 0)                                          pixelValues[f] = (byte)(antiAliasingAlpha * 255f) << 24 | color;                                      else                                          pixelValues[f] = (byte)(antiAliasingAlpha * fillAlpha) << 24 | (color & 0x00FFFFFF);                                        f++;                                  }                                  spans.Add(new PixelSpan(Orientation.Horizontal' (int)min + spanStartIndex' scanPosition' pixelValues));                                  break;                                case Orientation.Vertical:                                  for (int k = spanStartIndex; k < i; k++)                                  {                                      double coverage = pixelCoverage[k];                                      if (coverage > _subPixelLevel)                                          coverage = _subPixelLevel;                                        double antiAliasingAlpha = _alphaTable[(int)(coverage / _subPixelLevel * 254f)];                                        Int32 color = fill.GetPixelColor(scanPosition' (int)min + f + spanStartIndex);                                      byte fillAlpha = (byte)(color >> 24 & 0xFF);                                      if (fillAlpha == 0)                                          pixelValues[f] = (byte)(antiAliasingAlpha * 255f) << 24 | color;                                      else                                          pixelValues[f] = (byte)(antiAliasingAlpha * fillAlpha) << 24 | (color & 0x00FFFFFF);                                        f++;                                  }                                  spans.Add(new PixelSpan(Orientation.Vertical' scanPosition' (int)min + spanStartIndex' pixelValues));                                  break;                          }                          spanStarted = false;                      }                  }              }
Magic Number,MapAround.Rendering,SpanGenerator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,addSpans,The following statement contains a magic number: for (int i = 0; i <= coverageArrayHiIndex; i++)              {                  if (!spanStarted)                  {                      if (pixelCoverage[i] > 0)                      {                          spanStartIndex = i;                          spanStarted = true;                      }                  }                  else                  {                      if (pixelCoverage[i] == 0 || i == coverageArrayHiIndex)                      {                          Int32[] pixelValues = new int[i - spanStartIndex];                          int f = 0;                          switch(orientation)                          {                              case Orientation.Horizontal:                                  for (int k = spanStartIndex; k < i; k++)                                  {                                      double coverage = pixelCoverage[k];                                      if (coverage > _subPixelLevel)                                          coverage = _subPixelLevel;                                        double antiAliasingAlpha = _alphaTable[(int)(coverage / _subPixelLevel * 254f)];                                        Int32 color = fill.GetPixelColor((int)min + f + spanStartIndex' scanPosition);                                      byte fillAlpha = (byte)(color >> 24 & 0xFF);                                      if (fillAlpha == 0)                                          pixelValues[f] = (byte)(antiAliasingAlpha * 255f) << 24 | color;                                      else                                          pixelValues[f] = (byte)(antiAliasingAlpha * fillAlpha) << 24 | (color & 0x00FFFFFF);                                        f++;                                  }                                  spans.Add(new PixelSpan(Orientation.Horizontal' (int)min + spanStartIndex' scanPosition' pixelValues));                                  break;                                case Orientation.Vertical:                                  for (int k = spanStartIndex; k < i; k++)                                  {                                      double coverage = pixelCoverage[k];                                      if (coverage > _subPixelLevel)                                          coverage = _subPixelLevel;                                        double antiAliasingAlpha = _alphaTable[(int)(coverage / _subPixelLevel * 254f)];                                        Int32 color = fill.GetPixelColor(scanPosition' (int)min + f + spanStartIndex);                                      byte fillAlpha = (byte)(color >> 24 & 0xFF);                                      if (fillAlpha == 0)                                          pixelValues[f] = (byte)(antiAliasingAlpha * 255f) << 24 | color;                                      else                                          pixelValues[f] = (byte)(antiAliasingAlpha * fillAlpha) << 24 | (color & 0x00FFFFFF);                                        f++;                                  }                                  spans.Add(new PixelSpan(Orientation.Vertical' scanPosition' (int)min + spanStartIndex' pixelValues));                                  break;                          }                          spanStarted = false;                      }                  }              }
Magic Number,MapAround.Rendering,SpanGenerator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,addSpans,The following statement contains a magic number: for (int i = 0; i <= coverageArrayHiIndex; i++)              {                  if (!spanStarted)                  {                      if (pixelCoverage[i] > 0)                      {                          spanStartIndex = i;                          spanStarted = true;                      }                  }                  else                  {                      if (pixelCoverage[i] == 0 || i == coverageArrayHiIndex)                      {                          Int32[] pixelValues = new int[i - spanStartIndex];                          int f = 0;                          switch(orientation)                          {                              case Orientation.Horizontal:                                  for (int k = spanStartIndex; k < i; k++)                                  {                                      double coverage = pixelCoverage[k];                                      if (coverage > _subPixelLevel)                                          coverage = _subPixelLevel;                                        double antiAliasingAlpha = _alphaTable[(int)(coverage / _subPixelLevel * 254f)];                                        Int32 color = fill.GetPixelColor((int)min + f + spanStartIndex' scanPosition);                                      byte fillAlpha = (byte)(color >> 24 & 0xFF);                                      if (fillAlpha == 0)                                          pixelValues[f] = (byte)(antiAliasingAlpha * 255f) << 24 | color;                                      else                                          pixelValues[f] = (byte)(antiAliasingAlpha * fillAlpha) << 24 | (color & 0x00FFFFFF);                                        f++;                                  }                                  spans.Add(new PixelSpan(Orientation.Horizontal' (int)min + spanStartIndex' scanPosition' pixelValues));                                  break;                                case Orientation.Vertical:                                  for (int k = spanStartIndex; k < i; k++)                                  {                                      double coverage = pixelCoverage[k];                                      if (coverage > _subPixelLevel)                                          coverage = _subPixelLevel;                                        double antiAliasingAlpha = _alphaTable[(int)(coverage / _subPixelLevel * 254f)];                                        Int32 color = fill.GetPixelColor(scanPosition' (int)min + f + spanStartIndex);                                      byte fillAlpha = (byte)(color >> 24 & 0xFF);                                      if (fillAlpha == 0)                                          pixelValues[f] = (byte)(antiAliasingAlpha * 255f) << 24 | color;                                      else                                          pixelValues[f] = (byte)(antiAliasingAlpha * fillAlpha) << 24 | (color & 0x00FFFFFF);                                        f++;                                  }                                  spans.Add(new PixelSpan(Orientation.Vertical' scanPosition' (int)min + spanStartIndex' pixelValues));                                  break;                          }                          spanStarted = false;                      }                  }              }
Magic Number,MapAround.Rendering,Region,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,containsPoint,The following statement contains a magic number: return crossCount % 2 == 1;
Magic Number,MapAround.Rendering,Region,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeHorizontalWindingIntersections,The following statement contains a magic number: if (crosses.Count % 2 == 1)              {                  intersections = new float[0];                  return;              }
Magic Number,MapAround.Rendering,Region,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeHorizontalWindingIntersections,The following statement contains a magic number: for (int i = 0; i < indices.Count; i++)              {                  if (stack.Count == 0)                      stack.Push(indices[i]);                  else                  {                       int top = stack.Peek();                      if (top % 2 == indices[i] % 2)                          stack.Push(indices[i]);                      else                      {                          stack.Pop();                          if(stack.Count == 0)                          {                              tempList.Add(crosses[top]);                              tempList.Add(crosses[indices[i]]);                          }                      }                  }              }
Magic Number,MapAround.Rendering,Region,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeHorizontalWindingIntersections,The following statement contains a magic number: for (int i = 0; i < indices.Count; i++)              {                  if (stack.Count == 0)                      stack.Push(indices[i]);                  else                  {                       int top = stack.Peek();                      if (top % 2 == indices[i] % 2)                          stack.Push(indices[i]);                      else                      {                          stack.Pop();                          if(stack.Count == 0)                          {                              tempList.Add(crosses[top]);                              tempList.Add(crosses[indices[i]]);                          }                      }                  }              }
Magic Number,MapAround.Rendering,Region,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeHorizontalWindingIntersections,The following statement contains a magic number: for (int i = 0; i < cnt; i++)              {                  double currentItem = tempList[i];                  if (currentItem < _minX)                      needToAddMinX = !needToAddMinX;                  else                  {                      if (currentItem > _maxX)                      {                          needToAddMaxX = (cnt - i + 1) % 2 == 0;                          break;                      }                        crosses.Add(currentItem);                  }              }
Magic Number,MapAround.Rendering,Region,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeHorizontalAlternateIntersections,The following statement contains a magic number: if (crosses.Count % 2 == 1)              {                  if (containsPoint(_maxX' scanY))                      crosses.Add(_maxX);                  else                  {                      intersections = new float[0];                      return;                  }              }
Magic Number,MapAround.Rendering,Region,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeVerticalWindingIntersections,The following statement contains a magic number: if (crosses.Count % 2 == 1)              {                  intersections = new float[0];                  return;              }
Magic Number,MapAround.Rendering,Region,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeVerticalWindingIntersections,The following statement contains a magic number: for (int i = 0; i < indices.Count; i++)              {                  if (stack.Count == 0)                      stack.Push(indices[i]);                  else                  {                      int top = stack.Peek();                      if (top % 2 == indices[i] % 2)                          stack.Push(indices[i]);                      else                      {                          stack.Pop();                          if (stack.Count == 0)                          {                              tempList.Add(crosses[top]);                              tempList.Add(crosses[indices[i]]);                          }                      }                  }              }
Magic Number,MapAround.Rendering,Region,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeVerticalWindingIntersections,The following statement contains a magic number: for (int i = 0; i < indices.Count; i++)              {                  if (stack.Count == 0)                      stack.Push(indices[i]);                  else                  {                      int top = stack.Peek();                      if (top % 2 == indices[i] % 2)                          stack.Push(indices[i]);                      else                      {                          stack.Pop();                          if (stack.Count == 0)                          {                              tempList.Add(crosses[top]);                              tempList.Add(crosses[indices[i]]);                          }                      }                  }              }
Magic Number,MapAround.Rendering,Region,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeVerticalWindingIntersections,The following statement contains a magic number: for (int i = 0; i < cnt; i++)              {                  double currentItem = tempList[i];                  if (currentItem < _minY)                      needToAddMinY = !needToAddMinY;                  else                  {                      if (currentItem > _maxY)                      {                          needToAddMaxY = (cnt - i + 1) % 2 == 0;                          break;                      }                        crosses.Add(currentItem);                  }              }
Magic Number,MapAround.Rendering,Region,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,computeVerticalAlternateIntersections,The following statement contains a magic number: if (crosses.Count % 2 == 1)              {                  if (containsPoint(scanX' _maxY))                      crosses.Add(_maxY);                  else                  {                      intersections = new float[0];                      return;                  }              }
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,readDouble,The following statement contains a magic number: byte[] doubleBytes = new byte[8];
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,readDouble,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  int b = stream.ReadByte();                  if (b == -1)                      throw new EndOfStreamException();                  doubleBytes[i] = (byte)b;              }
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,writeDouble,The following statement contains a magic number: byte[] doubleBytes = new byte[8];
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,writeDouble,The following statement contains a magic number: for (int i = 0; i < 8; i++)                  stream.WriteByte(doubleBytes[i]);
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,readInt,The following statement contains a magic number: byte[] intBytes = new byte[4];
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,readInt,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int b = stream.ReadByte();                  if (b == -1)                      throw new EndOfStreamException();                  intBytes[i] = (byte)b;              }
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,writeInt,The following statement contains a magic number: byte[] intBytes = new byte[4];
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,writeInt,The following statement contains a magic number: for (int i = 0; i < 4; i++)                  stream.WriteByte(intBytes[i]);
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,DeserializeGeometry,The following statement contains a magic number: switch (featureType)              {                  case 1: //Point                      return BinaryGeometrySerializer.DeserializePoint(stream);                  case 2: //Polyline                      return BinaryGeometrySerializer.DeserializePolyline(stream);                  case 3: //Polygon                      return BinaryGeometrySerializer.DeserializePolygon(stream);                  case 4: //MultiPoint                      return BinaryGeometrySerializer.DeserializeMultiPoint(stream);              }
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,DeserializeGeometry,The following statement contains a magic number: switch (featureType)              {                  case 1: //Point                      return BinaryGeometrySerializer.DeserializePoint(stream);                  case 2: //Polyline                      return BinaryGeometrySerializer.DeserializePolyline(stream);                  case 3: //Polygon                      return BinaryGeometrySerializer.DeserializePolygon(stream);                  case 4: //MultiPoint                      return BinaryGeometrySerializer.DeserializeMultiPoint(stream);              }
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,DeserializeGeometry,The following statement contains a magic number: switch (featureType)              {                  case 1: //Point                      return BinaryGeometrySerializer.DeserializePoint(stream);                  case 2: //Polyline                      return BinaryGeometrySerializer.DeserializePolyline(stream);                  case 3: //Polygon                      return BinaryGeometrySerializer.DeserializePolygon(stream);                  case 4: //MultiPoint                      return BinaryGeometrySerializer.DeserializeMultiPoint(stream);              }
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,SerializeGeometry,The following statement contains a magic number: if (geometry is Polyline)              {                  writeInt(stream' 2);                  SerializePolyline(stream' (Polyline)geometry);                  return;              }
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,SerializeGeometry,The following statement contains a magic number: if (geometry is Polygon)              {                  writeInt(stream' 3);                  SerializePolygon(stream' (Polygon)geometry);                  return;              }
Magic Number,MapAround.Serialization,BinaryGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,SerializeGeometry,The following statement contains a magic number: if (geometry is MultiPoint)              {                  writeInt(stream' 4);                  SerializeMultiPoint(stream' (MultiPoint)geometry);                  return;              }
Magic Number,MapAround.Serialization,WKTGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,GetPolylineWKT,The following statement contains a magic number: if (polyline.Paths.Count == 1)              {                  StringBuilder sb = new StringBuilder("LineString (");                  IList<ICoordinate> points = polyline.Paths[0].Vertices;                  int cnt = points.Count;                  if(cnt < 2)                      throw new ArgumentException(_wrongPolylinePart' "polyline");                    for (int i = 0; i < cnt - 1; i++)                      sb.Append(pointCoordsString(points[i]) + "' ");                    sb.Append(pointCoordsString(points[cnt - 1]) + ")");                  return sb.ToString();              }              else              {                  StringBuilder sb = new StringBuilder("MultiLineString (");                  for (int i = 0; i < polyline.Paths.Count; i++)                  {                      sb.Append("(");                      IList<ICoordinate> points = polyline.Paths[i].Vertices;                      int cnt = points.Count;                      if (cnt < 2)                          throw new ArgumentException(_wrongPolylinePart' "polyline");                      for (int j = 0; j < cnt - 1; j++)                          sb.Append(pointCoordsString(points[j]) + "' ");                        sb.Append(pointCoordsString(points[cnt - 1]) + ")");                      if (i < polyline.Paths.Count - 1)                          sb.Append("' "); ;                  }                  sb.Append(")");                    return sb.ToString();              }
Magic Number,MapAround.Serialization,WKTGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,GetPolylineWKT,The following statement contains a magic number: if (polyline.Paths.Count == 1)              {                  StringBuilder sb = new StringBuilder("LineString (");                  IList<ICoordinate> points = polyline.Paths[0].Vertices;                  int cnt = points.Count;                  if(cnt < 2)                      throw new ArgumentException(_wrongPolylinePart' "polyline");                    for (int i = 0; i < cnt - 1; i++)                      sb.Append(pointCoordsString(points[i]) + "' ");                    sb.Append(pointCoordsString(points[cnt - 1]) + ")");                  return sb.ToString();              }              else              {                  StringBuilder sb = new StringBuilder("MultiLineString (");                  for (int i = 0; i < polyline.Paths.Count; i++)                  {                      sb.Append("(");                      IList<ICoordinate> points = polyline.Paths[i].Vertices;                      int cnt = points.Count;                      if (cnt < 2)                          throw new ArgumentException(_wrongPolylinePart' "polyline");                      for (int j = 0; j < cnt - 1; j++)                          sb.Append(pointCoordsString(points[j]) + "' ");                        sb.Append(pointCoordsString(points[cnt - 1]) + ")");                      if (i < polyline.Paths.Count - 1)                          sb.Append("' "); ;                  }                  sb.Append(")");                    return sb.ToString();              }
Magic Number,MapAround.Serialization,WKTGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,contourString,The following statement contains a magic number: if (contour.Vertices.Count <= 2)                  throw new ArgumentException("Degenerate contour"' "contour");
Magic Number,MapAround.Serialization,CoordinateSystemWktDeserializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\SpatialReferenceSerializers.cs,ReadProjectedCoordinateSystem,The following statement contains a magic number: List<AxisInfo> axes = new List<AxisInfo>(2);
Magic Number,MapAround.Serialization,CoordinateSystemWktDeserializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\SpatialReferenceSerializers.cs,ReadGeographicCoordinateSystem,The following statement contains a magic number: List<AxisInfo> info = new List<AxisInfo>(2);
Magic Number,MapAround.UI,ImageLegend,C:\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,checkElementWidth,The following statement contains a magic number: int width = element.Image.Width + _margin * 2 + _elementHorizontalSpacing;
Magic Number,MapAround.UI,ImageLegend,C:\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,checkElementHeight,The following statement contains a magic number: int currentHeight = _margin * 2 + (int)getCaptionSize().Height + _elementsVerticalSpacing;
Magic Number,MapAround.UI,ImageLegend,C:\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,CheckCaption,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(bmp))              {                  SizeF captionSize = g.MeasureString(caption' _captionFont);                  _width = Math.Max((int)captionSize.Width + _margin * 2' _width);                  _height = Math.Max((int)captionSize.Height + _margin * 2' _height);              }
Magic Number,MapAround.UI,ImageLegend,C:\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,CheckCaption,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(bmp))              {                  SizeF captionSize = g.MeasureString(caption' _captionFont);                  _width = Math.Max((int)captionSize.Width + _margin * 2' _width);                  _height = Math.Max((int)captionSize.Height + _margin * 2' _height);              }
Magic Number,MapAround.UI,ImageLegend,C:\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,drawElement,The following statement contains a magic number: if (element.Image.Height < labelSize.Height)                  imageHeightSpacing = (int)labelSize.Height / 2 - element.Image.Height / 2;
Magic Number,MapAround.UI,ImageLegend,C:\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,drawElement,The following statement contains a magic number: if (element.Image.Height < labelSize.Height)                  imageHeightSpacing = (int)labelSize.Height / 2 - element.Image.Height / 2;
Magic Number,MapAround.UI,ImageLegend,C:\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,drawElement,The following statement contains a magic number: if (element.Image.Height > labelSize.Height)                  labelHeightSpacing = element.Image.Height / 2 - (int)labelSize.Height / 2;
Magic Number,MapAround.UI,ImageLegend,C:\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,drawElement,The following statement contains a magic number: if (element.Image.Height > labelSize.Height)                  labelHeightSpacing = element.Image.Height / 2 - (int)labelSize.Height / 2;
Magic Number,MapAround.UI,ImageLegend,C:\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,DrawLegend,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(bmp))              {                  g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;                    // фон                  g.Clear(_backgroundColor);                    // заголовок                  SizeF captionSize = g.MeasureString(Caption' _captionFont);                  g.DrawString(Caption' _captionFont' new SolidBrush(_captionColor)' new PointF(_width / 2 - captionSize.Width / 2' _margin));                    int currentHieght = _margin + (int)captionSize.Height + _elementsVerticalSpacing;                    // элементы                  foreach (LegendElement el in Elements)                  {                      currentHieght += drawElement(g' el' currentHieght) + _elementsVerticalSpacing;                  }              }
Magic Number,MapAround.UI,ImageLegend,C:\repos\gkrsu_maparound.core\src\MapAround.Core\UI\Legend.cs,DrawLegend,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(bmp))              {                  g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;                    // фон                  g.Clear(_backgroundColor);                    // заголовок                  SizeF captionSize = g.MeasureString(Caption' _captionFont);                  g.DrawString(Caption' _captionFont' new SolidBrush(_captionColor)' new PointF(_width / 2 - captionSize.Width / 2' _margin));                    int currentHieght = _margin + (int)captionSize.Height + _elementsVerticalSpacing;                    // элементы                  foreach (LegendElement el in Elements)                  {                      currentHieght += drawElement(g' el' currentHieght) + _elementsVerticalSpacing;                  }              }
Magic Number,MapAround.Web,MapServerBase,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,GetImage,The following statement contains a magic number: try              {                  bool cacheable = true;                  string allLayerKey = "";                    foreach (var layer in useLayers.OrderBy(x=>x.Alias))                  {                      cacheable &= layer.Cacheable;                      allLayerKey += layer.Alias;                  }                    if (cacheable)                  {                      Image res = GetImage(bboxWithGutters' allLayerKey);                                                if (!ReferenceEquals(res'null))                          {                                return res;                          }                                        }                  //Πενδεπ δλ νΰδοθρει.                  var wmsFeatureRender = new WmsFeatureRender(_map.RenderingSettings);                    using (Image bmpWithGutters = new Bitmap(width + _gutterSize * 2' height + _gutterSize * 2))                  {                      // πθρσεμ τξν                      using (Graphics g = Graphics.FromImage(bmpWithGutters))                          g.Clear(backColor);                      int i = 0;                      //Οπξβεπκΰ' χςξ βξξαωε ερςό χςξ ξςξαπΰζΰςό.                      if (!ReferenceEquals(useLayers' null) && (useLayers.Length > 0))                          do                          {                              IFeatureRenderer _oldFeatureRender = null;                              try                              {                                    //Νΰχθνΰεμ πθρξβΰςό νξβϋι ρλξι.                                  wmsFeatureRender.BeginLayerRender();                                    //Δελΰεμ ρλξι βθδθμϋμ. Βρε ξρςΰλόνϋε ρλξθ μϋ ξςκλώχθλθ βϋψε.                                  useLayers[i].Visible = true;                                    //Νΰρςπξικΰ ρλξ οεπεδ πενδεπθνγξμ.                                  if (useLayers[i] is FeatureLayer)                                      OnPrepareRenderFeatureLayer(new PrepareRenderFeatureLayerArgs((FeatureLayer)useLayers[i]));                                    //Σρςΰνΰβλθβΰεμ ρβξι πενδεπ' χςξ αϋ οεπεκπϋςό ξςπθρξβκσ νΰηβΰνθι                                  if (useLayers[i] is FeatureLayer)                                  {                                      _oldFeatureRender = (useLayers[i] as FeatureLayer).FeatureRenderer;                                      (useLayers[i] as FeatureLayer).FeatureRenderer = wmsFeatureRender;                                  }                                    byte[] titleInfo = null;                                    //Ρμξςπθμ β κύψε.                                  using (Image bmpLayer = GetImageFromChach(useLayers[i]' out titleInfo' bboxWithGutters))                                  {                                      if (!ReferenceEquals(bmpLayer' null))                                      {                                          //Δξαΰβλεμ δΰννϋε ξ νΰηβΰνθυ β wmsFeatureRender.                                          wmsFeatureRender.AddTitleInfo(titleInfo);                                          //Κξοθπσεμ κΰπςθνκσ β πεησλόςθπσώωθι ςΰιλ.                                          CopyImage(bmpLayer' bmpWithGutters);                                          continue;                                      }                                  }                                    //Ερλθ οπξμΰυ οξ κύψ                                  using (                                      Image bmpLayer = new Bitmap(width + _gutterSize * 2' height + _gutterSize * 2'                                                                  PixelFormat.Format32bppArgb))                                  {                                      //Ηΰγπσζΰεμ δΰννϋε (οξχεμσ ύςξ δελΰεςρ βνε WMS ρΰμ νε οξνθμΰώ).                                        OnBeforeRenderNewImage(new RenderNewImageEventArgs(bboxWithGutters'useLayers[i]));                                      //MapAround ηΰγπσηθς ςξλόκξ βθδθμϋε ρλξθ' οξ ύςξμσ νε ηΰμξπΰχθβΰεμρ νΰ ηΰγπσηκθ ρλξεβ οξ ξςδελόνξρςθ.                                             // πθρσεμ κΰπςσ                                      //MapAround ξςπενδεπθς ςξλόκξ βθδθμϋε ρλξθ.                                      //ΰκζε ξν οξοϋςΰεςρ ξςπενδεπθςό κξρμεςθχερκθι ρλξι' οξ ύςξι οπθχθνε μϋ οπξβεπεμ βϋψε' χςξ αϋ ξν νε αϋλ ηΰδΰν.                                      _map.Render(bmpLayer' bboxWithGutters);                                        //Κξοθπσεμ πεησλόςΰς νΰ πεησλόςθπσώωθι πΰρςπ.                                      CopyImage(bmpLayer' bmpWithGutters);                                        // Κλΰδεμ β κύψ πΰρςπ ρλξ + θντξπμΰφθώ ξ νΰηβΰνθυ.                                      SetImageToChach(useLayers[i]' bmpLayer' wmsFeatureRender.CurrentTitleInfo' bboxWithGutters);                                    }                              }                              finally                              {                                    i++;                                  //Δελΰεμ ρλξι νε βθδθμϋμ.                                  useLayers[i - 1].Visible = false;                                    if (useLayers[i - 1] is FeatureLayer)                                  {                                      //Μενεμ πενδεπ νΰ ρςΰπϋι                                      (useLayers[i - 1] as FeatureLayer).FeatureRenderer = _oldFeatureRender;                                  }                              }                          } while (i < useLayers.Length);                        //Οξρλε ςξγξ κΰκ οξλσχθλθ βρε ρλξθ ηΰοπξρΰ πενδεπθμ νΰηβΰνθ.                      wmsFeatureRender.RenderTitle(bmpWithGutters' bboxWithGutters);                        //Οξδγξςΰβλθβΰεμ θ ξςοπΰβλεμ πεησλόςΰς.                      Image bmp = new Bitmap(width' height);                                         CopyImageClipped(bmp' bmpWithGutters' width' height);                       if (cacheable)                       {                           SetImage(bboxWithGutters'bmp'allLayerKey);                       }                      return bmp;                  }              }              finally              {                  // ξρβξαξζδΰεμ περσπρϋ' ρβηΰννϋε ρ πθρξβΰνθεμ κΰπςϋ                  if (_drawingRequestSemaphore != null)                      _drawingRequestSemaphore.Release();              }
Magic Number,MapAround.Web,MapServerBase,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,GetImage,The following statement contains a magic number: try              {                  bool cacheable = true;                  string allLayerKey = "";                    foreach (var layer in useLayers.OrderBy(x=>x.Alias))                  {                      cacheable &= layer.Cacheable;                      allLayerKey += layer.Alias;                  }                    if (cacheable)                  {                      Image res = GetImage(bboxWithGutters' allLayerKey);                                                if (!ReferenceEquals(res'null))                          {                                return res;                          }                                        }                  //Πενδεπ δλ νΰδοθρει.                  var wmsFeatureRender = new WmsFeatureRender(_map.RenderingSettings);                    using (Image bmpWithGutters = new Bitmap(width + _gutterSize * 2' height + _gutterSize * 2))                  {                      // πθρσεμ τξν                      using (Graphics g = Graphics.FromImage(bmpWithGutters))                          g.Clear(backColor);                      int i = 0;                      //Οπξβεπκΰ' χςξ βξξαωε ερςό χςξ ξςξαπΰζΰςό.                      if (!ReferenceEquals(useLayers' null) && (useLayers.Length > 0))                          do                          {                              IFeatureRenderer _oldFeatureRender = null;                              try                              {                                    //Νΰχθνΰεμ πθρξβΰςό νξβϋι ρλξι.                                  wmsFeatureRender.BeginLayerRender();                                    //Δελΰεμ ρλξι βθδθμϋμ. Βρε ξρςΰλόνϋε ρλξθ μϋ ξςκλώχθλθ βϋψε.                                  useLayers[i].Visible = true;                                    //Νΰρςπξικΰ ρλξ οεπεδ πενδεπθνγξμ.                                  if (useLayers[i] is FeatureLayer)                                      OnPrepareRenderFeatureLayer(new PrepareRenderFeatureLayerArgs((FeatureLayer)useLayers[i]));                                    //Σρςΰνΰβλθβΰεμ ρβξι πενδεπ' χςξ αϋ οεπεκπϋςό ξςπθρξβκσ νΰηβΰνθι                                  if (useLayers[i] is FeatureLayer)                                  {                                      _oldFeatureRender = (useLayers[i] as FeatureLayer).FeatureRenderer;                                      (useLayers[i] as FeatureLayer).FeatureRenderer = wmsFeatureRender;                                  }                                    byte[] titleInfo = null;                                    //Ρμξςπθμ β κύψε.                                  using (Image bmpLayer = GetImageFromChach(useLayers[i]' out titleInfo' bboxWithGutters))                                  {                                      if (!ReferenceEquals(bmpLayer' null))                                      {                                          //Δξαΰβλεμ δΰννϋε ξ νΰηβΰνθυ β wmsFeatureRender.                                          wmsFeatureRender.AddTitleInfo(titleInfo);                                          //Κξοθπσεμ κΰπςθνκσ β πεησλόςθπσώωθι ςΰιλ.                                          CopyImage(bmpLayer' bmpWithGutters);                                          continue;                                      }                                  }                                    //Ερλθ οπξμΰυ οξ κύψ                                  using (                                      Image bmpLayer = new Bitmap(width + _gutterSize * 2' height + _gutterSize * 2'                                                                  PixelFormat.Format32bppArgb))                                  {                                      //Ηΰγπσζΰεμ δΰννϋε (οξχεμσ ύςξ δελΰεςρ βνε WMS ρΰμ νε οξνθμΰώ).                                        OnBeforeRenderNewImage(new RenderNewImageEventArgs(bboxWithGutters'useLayers[i]));                                      //MapAround ηΰγπσηθς ςξλόκξ βθδθμϋε ρλξθ' οξ ύςξμσ νε ηΰμξπΰχθβΰεμρ νΰ ηΰγπσηκθ ρλξεβ οξ ξςδελόνξρςθ.                                             // πθρσεμ κΰπςσ                                      //MapAround ξςπενδεπθς ςξλόκξ βθδθμϋε ρλξθ.                                      //ΰκζε ξν οξοϋςΰεςρ ξςπενδεπθςό κξρμεςθχερκθι ρλξι' οξ ύςξι οπθχθνε μϋ οπξβεπεμ βϋψε' χςξ αϋ ξν νε αϋλ ηΰδΰν.                                      _map.Render(bmpLayer' bboxWithGutters);                                        //Κξοθπσεμ πεησλόςΰς νΰ πεησλόςθπσώωθι πΰρςπ.                                      CopyImage(bmpLayer' bmpWithGutters);                                        // Κλΰδεμ β κύψ πΰρςπ ρλξ + θντξπμΰφθώ ξ νΰηβΰνθυ.                                      SetImageToChach(useLayers[i]' bmpLayer' wmsFeatureRender.CurrentTitleInfo' bboxWithGutters);                                    }                              }                              finally                              {                                    i++;                                  //Δελΰεμ ρλξι νε βθδθμϋμ.                                  useLayers[i - 1].Visible = false;                                    if (useLayers[i - 1] is FeatureLayer)                                  {                                      //Μενεμ πενδεπ νΰ ρςΰπϋι                                      (useLayers[i - 1] as FeatureLayer).FeatureRenderer = _oldFeatureRender;                                  }                              }                          } while (i < useLayers.Length);                        //Οξρλε ςξγξ κΰκ οξλσχθλθ βρε ρλξθ ηΰοπξρΰ πενδεπθμ νΰηβΰνθ.                      wmsFeatureRender.RenderTitle(bmpWithGutters' bboxWithGutters);                        //Οξδγξςΰβλθβΰεμ θ ξςοπΰβλεμ πεησλόςΰς.                      Image bmp = new Bitmap(width' height);                                         CopyImageClipped(bmp' bmpWithGutters' width' height);                       if (cacheable)                       {                           SetImage(bboxWithGutters'bmp'allLayerKey);                       }                      return bmp;                  }              }              finally              {                  // ξρβξαξζδΰεμ περσπρϋ' ρβηΰννϋε ρ πθρξβΰνθεμ κΰπςϋ                  if (_drawingRequestSemaphore != null)                      _drawingRequestSemaphore.Release();              }
Magic Number,MapAround.Web,MapServerBase,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,GetImage,The following statement contains a magic number: try              {                  bool cacheable = true;                  string allLayerKey = "";                    foreach (var layer in useLayers.OrderBy(x=>x.Alias))                  {                      cacheable &= layer.Cacheable;                      allLayerKey += layer.Alias;                  }                    if (cacheable)                  {                      Image res = GetImage(bboxWithGutters' allLayerKey);                                                if (!ReferenceEquals(res'null))                          {                                return res;                          }                                        }                  //Πενδεπ δλ νΰδοθρει.                  var wmsFeatureRender = new WmsFeatureRender(_map.RenderingSettings);                    using (Image bmpWithGutters = new Bitmap(width + _gutterSize * 2' height + _gutterSize * 2))                  {                      // πθρσεμ τξν                      using (Graphics g = Graphics.FromImage(bmpWithGutters))                          g.Clear(backColor);                      int i = 0;                      //Οπξβεπκΰ' χςξ βξξαωε ερςό χςξ ξςξαπΰζΰςό.                      if (!ReferenceEquals(useLayers' null) && (useLayers.Length > 0))                          do                          {                              IFeatureRenderer _oldFeatureRender = null;                              try                              {                                    //Νΰχθνΰεμ πθρξβΰςό νξβϋι ρλξι.                                  wmsFeatureRender.BeginLayerRender();                                    //Δελΰεμ ρλξι βθδθμϋμ. Βρε ξρςΰλόνϋε ρλξθ μϋ ξςκλώχθλθ βϋψε.                                  useLayers[i].Visible = true;                                    //Νΰρςπξικΰ ρλξ οεπεδ πενδεπθνγξμ.                                  if (useLayers[i] is FeatureLayer)                                      OnPrepareRenderFeatureLayer(new PrepareRenderFeatureLayerArgs((FeatureLayer)useLayers[i]));                                    //Σρςΰνΰβλθβΰεμ ρβξι πενδεπ' χςξ αϋ οεπεκπϋςό ξςπθρξβκσ νΰηβΰνθι                                  if (useLayers[i] is FeatureLayer)                                  {                                      _oldFeatureRender = (useLayers[i] as FeatureLayer).FeatureRenderer;                                      (useLayers[i] as FeatureLayer).FeatureRenderer = wmsFeatureRender;                                  }                                    byte[] titleInfo = null;                                    //Ρμξςπθμ β κύψε.                                  using (Image bmpLayer = GetImageFromChach(useLayers[i]' out titleInfo' bboxWithGutters))                                  {                                      if (!ReferenceEquals(bmpLayer' null))                                      {                                          //Δξαΰβλεμ δΰννϋε ξ νΰηβΰνθυ β wmsFeatureRender.                                          wmsFeatureRender.AddTitleInfo(titleInfo);                                          //Κξοθπσεμ κΰπςθνκσ β πεησλόςθπσώωθι ςΰιλ.                                          CopyImage(bmpLayer' bmpWithGutters);                                          continue;                                      }                                  }                                    //Ερλθ οπξμΰυ οξ κύψ                                  using (                                      Image bmpLayer = new Bitmap(width + _gutterSize * 2' height + _gutterSize * 2'                                                                  PixelFormat.Format32bppArgb))                                  {                                      //Ηΰγπσζΰεμ δΰννϋε (οξχεμσ ύςξ δελΰεςρ βνε WMS ρΰμ νε οξνθμΰώ).                                        OnBeforeRenderNewImage(new RenderNewImageEventArgs(bboxWithGutters'useLayers[i]));                                      //MapAround ηΰγπσηθς ςξλόκξ βθδθμϋε ρλξθ' οξ ύςξμσ νε ηΰμξπΰχθβΰεμρ νΰ ηΰγπσηκθ ρλξεβ οξ ξςδελόνξρςθ.                                             // πθρσεμ κΰπςσ                                      //MapAround ξςπενδεπθς ςξλόκξ βθδθμϋε ρλξθ.                                      //ΰκζε ξν οξοϋςΰεςρ ξςπενδεπθςό κξρμεςθχερκθι ρλξι' οξ ύςξι οπθχθνε μϋ οπξβεπεμ βϋψε' χςξ αϋ ξν νε αϋλ ηΰδΰν.                                      _map.Render(bmpLayer' bboxWithGutters);                                        //Κξοθπσεμ πεησλόςΰς νΰ πεησλόςθπσώωθι πΰρςπ.                                      CopyImage(bmpLayer' bmpWithGutters);                                        // Κλΰδεμ β κύψ πΰρςπ ρλξ + θντξπμΰφθώ ξ νΰηβΰνθυ.                                      SetImageToChach(useLayers[i]' bmpLayer' wmsFeatureRender.CurrentTitleInfo' bboxWithGutters);                                    }                              }                              finally                              {                                    i++;                                  //Δελΰεμ ρλξι νε βθδθμϋμ.                                  useLayers[i - 1].Visible = false;                                    if (useLayers[i - 1] is FeatureLayer)                                  {                                      //Μενεμ πενδεπ νΰ ρςΰπϋι                                      (useLayers[i - 1] as FeatureLayer).FeatureRenderer = _oldFeatureRender;                                  }                              }                          } while (i < useLayers.Length);                        //Οξρλε ςξγξ κΰκ οξλσχθλθ βρε ρλξθ ηΰοπξρΰ πενδεπθμ νΰηβΰνθ.                      wmsFeatureRender.RenderTitle(bmpWithGutters' bboxWithGutters);                        //Οξδγξςΰβλθβΰεμ θ ξςοπΰβλεμ πεησλόςΰς.                      Image bmp = new Bitmap(width' height);                                         CopyImageClipped(bmp' bmpWithGutters' width' height);                       if (cacheable)                       {                           SetImage(bboxWithGutters'bmp'allLayerKey);                       }                      return bmp;                  }              }              finally              {                  // ξρβξαξζδΰεμ περσπρϋ' ρβηΰννϋε ρ πθρξβΰνθεμ κΰπςϋ                  if (_drawingRequestSemaphore != null)                      _drawingRequestSemaphore.Release();              }
Magic Number,MapAround.Web,MapServerBase,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,GetImage,The following statement contains a magic number: try              {                  bool cacheable = true;                  string allLayerKey = "";                    foreach (var layer in useLayers.OrderBy(x=>x.Alias))                  {                      cacheable &= layer.Cacheable;                      allLayerKey += layer.Alias;                  }                    if (cacheable)                  {                      Image res = GetImage(bboxWithGutters' allLayerKey);                                                if (!ReferenceEquals(res'null))                          {                                return res;                          }                                        }                  //Πενδεπ δλ νΰδοθρει.                  var wmsFeatureRender = new WmsFeatureRender(_map.RenderingSettings);                    using (Image bmpWithGutters = new Bitmap(width + _gutterSize * 2' height + _gutterSize * 2))                  {                      // πθρσεμ τξν                      using (Graphics g = Graphics.FromImage(bmpWithGutters))                          g.Clear(backColor);                      int i = 0;                      //Οπξβεπκΰ' χςξ βξξαωε ερςό χςξ ξςξαπΰζΰςό.                      if (!ReferenceEquals(useLayers' null) && (useLayers.Length > 0))                          do                          {                              IFeatureRenderer _oldFeatureRender = null;                              try                              {                                    //Νΰχθνΰεμ πθρξβΰςό νξβϋι ρλξι.                                  wmsFeatureRender.BeginLayerRender();                                    //Δελΰεμ ρλξι βθδθμϋμ. Βρε ξρςΰλόνϋε ρλξθ μϋ ξςκλώχθλθ βϋψε.                                  useLayers[i].Visible = true;                                    //Νΰρςπξικΰ ρλξ οεπεδ πενδεπθνγξμ.                                  if (useLayers[i] is FeatureLayer)                                      OnPrepareRenderFeatureLayer(new PrepareRenderFeatureLayerArgs((FeatureLayer)useLayers[i]));                                    //Σρςΰνΰβλθβΰεμ ρβξι πενδεπ' χςξ αϋ οεπεκπϋςό ξςπθρξβκσ νΰηβΰνθι                                  if (useLayers[i] is FeatureLayer)                                  {                                      _oldFeatureRender = (useLayers[i] as FeatureLayer).FeatureRenderer;                                      (useLayers[i] as FeatureLayer).FeatureRenderer = wmsFeatureRender;                                  }                                    byte[] titleInfo = null;                                    //Ρμξςπθμ β κύψε.                                  using (Image bmpLayer = GetImageFromChach(useLayers[i]' out titleInfo' bboxWithGutters))                                  {                                      if (!ReferenceEquals(bmpLayer' null))                                      {                                          //Δξαΰβλεμ δΰννϋε ξ νΰηβΰνθυ β wmsFeatureRender.                                          wmsFeatureRender.AddTitleInfo(titleInfo);                                          //Κξοθπσεμ κΰπςθνκσ β πεησλόςθπσώωθι ςΰιλ.                                          CopyImage(bmpLayer' bmpWithGutters);                                          continue;                                      }                                  }                                    //Ερλθ οπξμΰυ οξ κύψ                                  using (                                      Image bmpLayer = new Bitmap(width + _gutterSize * 2' height + _gutterSize * 2'                                                                  PixelFormat.Format32bppArgb))                                  {                                      //Ηΰγπσζΰεμ δΰννϋε (οξχεμσ ύςξ δελΰεςρ βνε WMS ρΰμ νε οξνθμΰώ).                                        OnBeforeRenderNewImage(new RenderNewImageEventArgs(bboxWithGutters'useLayers[i]));                                      //MapAround ηΰγπσηθς ςξλόκξ βθδθμϋε ρλξθ' οξ ύςξμσ νε ηΰμξπΰχθβΰεμρ νΰ ηΰγπσηκθ ρλξεβ οξ ξςδελόνξρςθ.                                             // πθρσεμ κΰπςσ                                      //MapAround ξςπενδεπθς ςξλόκξ βθδθμϋε ρλξθ.                                      //ΰκζε ξν οξοϋςΰεςρ ξςπενδεπθςό κξρμεςθχερκθι ρλξι' οξ ύςξι οπθχθνε μϋ οπξβεπεμ βϋψε' χςξ αϋ ξν νε αϋλ ηΰδΰν.                                      _map.Render(bmpLayer' bboxWithGutters);                                        //Κξοθπσεμ πεησλόςΰς νΰ πεησλόςθπσώωθι πΰρςπ.                                      CopyImage(bmpLayer' bmpWithGutters);                                        // Κλΰδεμ β κύψ πΰρςπ ρλξ + θντξπμΰφθώ ξ νΰηβΰνθυ.                                      SetImageToChach(useLayers[i]' bmpLayer' wmsFeatureRender.CurrentTitleInfo' bboxWithGutters);                                    }                              }                              finally                              {                                    i++;                                  //Δελΰεμ ρλξι νε βθδθμϋμ.                                  useLayers[i - 1].Visible = false;                                    if (useLayers[i - 1] is FeatureLayer)                                  {                                      //Μενεμ πενδεπ νΰ ρςΰπϋι                                      (useLayers[i - 1] as FeatureLayer).FeatureRenderer = _oldFeatureRender;                                  }                              }                          } while (i < useLayers.Length);                        //Οξρλε ςξγξ κΰκ οξλσχθλθ βρε ρλξθ ηΰοπξρΰ πενδεπθμ νΰηβΰνθ.                      wmsFeatureRender.RenderTitle(bmpWithGutters' bboxWithGutters);                        //Οξδγξςΰβλθβΰεμ θ ξςοπΰβλεμ πεησλόςΰς.                      Image bmp = new Bitmap(width' height);                                         CopyImageClipped(bmp' bmpWithGutters' width' height);                       if (cacheable)                       {                           SetImage(bboxWithGutters'bmp'allLayerKey);                       }                      return bmp;                  }              }              finally              {                  // ξρβξαξζδΰεμ περσπρϋ' ρβηΰννϋε ρ πθρξβΰνθεμ κΰπςϋ                  if (_drawingRequestSemaphore != null)                      _drawingRequestSemaphore.Release();              }
Magic Number,MapAround.Web,MapServerBase,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,ParseBbox,The following statement contains a magic number: if (strVals.Length != 4)                  return null;
Magic Number,MapAround.Web,MapServerBase,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,ParseBbox,The following statement contains a magic number: if (!double.TryParse(strVals[2]' NumberStyles.Float' CultureInfo.InvariantCulture' out maxx))                  return null;
Magic Number,MapAround.Web,MapServerBase,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,ParseBbox,The following statement contains a magic number: if (!double.TryParse(strVals[3]' NumberStyles.Float' CultureInfo.InvariantCulture' out maxy))                  return null;
Magic Number,MapAround.Web,JSONMpHelper,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,drawVisiblePolylinePart,The following statement contains a magic number: for (int k = 0; k < path.Count; k++)              {                  points[k] = new double[2];                  points[k][0] =  ((path[k].X - viewBox.MinX)*scaleFactor);                  points[k][1] =  ((viewBox.MaxY - path[k].Y)*scaleFactor);              }
Magic Number,MapAround.Web,JSONMpHelper,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,drawPolylineWithIntersectCalculation,The following statement contains a magic number: foreach (LinePath path in feature.Polyline.Paths)                      {                          if (path.Vertices.Count < 2)                              continue;                            currentPath.Clear();                                                  bool isInternalPath = viewBox.ContainsPoint(path.Vertices[0]);                                                  IList<ICoordinate> vertices = path.Vertices;                            for (int j = 0; j < path.Vertices.Count; j++)                          {                              if (isInternalPath) // βνσςπενν χΰρςό οξλθλθνθθ                              {                                  if (viewBox.ContainsPoint(vertices[j])) // ξρςΰεμρ βνσςπθ                                  {                                      currentPath.Add(vertices[j]);                                      continue;                                  }                                  else // βϋυξδθμ νΰπσζσ                                  {                                      // δξαΰβλεμ ςξχκσ οεπερεχενθ                                      List<ICoordinate> crossPoints = getCrossPoints(vertices[j]' vertices[j - 1]' viewBox);                                      currentPath.Add(crossPoints[0]);                                        //πθρσεμ                                      drawVisiblePolylinePartWithStyleDetection(g' currentPath'                                                                                 viewBox' scaleFactor);                                          // θνθφθΰλθηθπσεμ μΰρρθβ ςξχεκ βνεψνει χΰρςθ οξλθλθνθθ                                      // θ οπξδξλζΰεμ βϋοξλνενθε                                      currentPath.Clear();                                      currentPath.Add(crossPoints[0]);                                      currentPath.Add(vertices[j]);                                      isInternalPath = false;                                      continue;                                  }                              }                              else // βνεψν χΰρςό οξλθλθνθθ                              {                                  if (viewBox.ContainsPoint(vertices[j])) // βυξδθμ βνσςπό                                  {                                      // δξαΰβλεμ ςξχκσ οεπερεχενθ                                      List<ICoordinate> crossPoints = getCrossPoints(vertices[j]' vertices[j - 1]' viewBox);                                      currentPath.Add(crossPoints[0]);                                          // θνθφθΰλθηθπσεμ μΰρρθβ ςξχεκ βνσςπεννει χΰρςθ οξλθλθνθθ                                      // θ οπξδξλζΰεμ βϋοξλνενθε                                      currentPath.Clear();                                      currentPath.Add(crossPoints[0]);                                      currentPath.Add(vertices[j]);                                      isInternalPath = true;                                      continue;                                  }                                  else // οεπερεκΰεμ δβΰζδϋ' λθαξ ξρςΰεμρ ρνΰπσζθ                                  {                                      // θωεμ ςξχκθ οεπερεχενθ                                      if (j > 0)                                      {                                          List<ICoordinate> crossPoints = getCrossPoints(vertices[j]' vertices[j - 1]'                                                                                         viewBox);                                          if (crossPoints.Count == 0) // ξρςΰλθρό ρνΰπσζθ                                          {                                              currentPath.Add(vertices[j]);                                              continue;                                          }                                          if (crossPoints.Count == 2) // οεπερεκλθ 2 πΰηΰ                                          {                                              // ξοπεδελεμ κΰκσώ θη ςξχεκ οεπερεχενθ νσζνξ δξαΰβθςό κ ςεκσωεμσ οσςθ                                              double d0 = PlanimetryAlgorithms.Distance(crossPoints[0]' vertices[j - 1]);                                              double d1 = PlanimetryAlgorithms.Distance(crossPoints[1]' vertices[j - 1]);                                              if (d0 < d1)                                                  currentPath.Add(crossPoints[0]);                                              else                                                  currentPath.Add(crossPoints[1]);                                                  currentPath.Clear();                                                currentPath.Add(crossPoints[d0 < d1 ? 0 : 1]);                                              currentPath.Add(crossPoints[d0 < d1 ? 1 : 0]);                                                // πθρσεμ ξςπεηξκ                                              drawVisiblePolylinePartWithStyleDetection(g' currentPath'                                                                                         viewBox' scaleFactor                                                                                        );                                                                                         // θνθφθΰλθηθπσεμ βνεψνώώ χΰρςό οξλθλθνθθ                                              currentPath.Clear();                                              if (d0 < d1)                                                  currentPath.Add(crossPoints[1]);                                              else                                                  currentPath.Add(crossPoints[0]);                                              currentPath.Add(vertices[j]);                                              isInternalPath = false;                                              continue;                                          }                                      }                                      else // 1-ώ ςξχκσ νσζνξ οπξρςξ δξαΰβθςό β ροθρξκ                                      {                                          currentPath.Add(vertices[j]);                                          continue;                                      }                                  }                              }                          }                            // πθρσεμ χΰρςό οξλθλθνθθ' ερλθ ξνΰ βνσςπενν                          if (isInternalPath)                              drawVisiblePolylinePartWithStyleDetection(g' currentPath'                                                                        viewBox' scaleFactor);                      }
Magic Number,MapAround.Web,JSONMpHelper,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,drawPolylineWithIntersectCalculation,The following statement contains a magic number: foreach (LinePath path in feature.Polyline.Paths)                      {                          if (path.Vertices.Count < 2)                              continue;                            currentPath.Clear();                                                  bool isInternalPath = viewBox.ContainsPoint(path.Vertices[0]);                                                  IList<ICoordinate> vertices = path.Vertices;                            for (int j = 0; j < path.Vertices.Count; j++)                          {                              if (isInternalPath) // βνσςπενν χΰρςό οξλθλθνθθ                              {                                  if (viewBox.ContainsPoint(vertices[j])) // ξρςΰεμρ βνσςπθ                                  {                                      currentPath.Add(vertices[j]);                                      continue;                                  }                                  else // βϋυξδθμ νΰπσζσ                                  {                                      // δξαΰβλεμ ςξχκσ οεπερεχενθ                                      List<ICoordinate> crossPoints = getCrossPoints(vertices[j]' vertices[j - 1]' viewBox);                                      currentPath.Add(crossPoints[0]);                                        //πθρσεμ                                      drawVisiblePolylinePartWithStyleDetection(g' currentPath'                                                                                 viewBox' scaleFactor);                                          // θνθφθΰλθηθπσεμ μΰρρθβ ςξχεκ βνεψνει χΰρςθ οξλθλθνθθ                                      // θ οπξδξλζΰεμ βϋοξλνενθε                                      currentPath.Clear();                                      currentPath.Add(crossPoints[0]);                                      currentPath.Add(vertices[j]);                                      isInternalPath = false;                                      continue;                                  }                              }                              else // βνεψν χΰρςό οξλθλθνθθ                              {                                  if (viewBox.ContainsPoint(vertices[j])) // βυξδθμ βνσςπό                                  {                                      // δξαΰβλεμ ςξχκσ οεπερεχενθ                                      List<ICoordinate> crossPoints = getCrossPoints(vertices[j]' vertices[j - 1]' viewBox);                                      currentPath.Add(crossPoints[0]);                                          // θνθφθΰλθηθπσεμ μΰρρθβ ςξχεκ βνσςπεννει χΰρςθ οξλθλθνθθ                                      // θ οπξδξλζΰεμ βϋοξλνενθε                                      currentPath.Clear();                                      currentPath.Add(crossPoints[0]);                                      currentPath.Add(vertices[j]);                                      isInternalPath = true;                                      continue;                                  }                                  else // οεπερεκΰεμ δβΰζδϋ' λθαξ ξρςΰεμρ ρνΰπσζθ                                  {                                      // θωεμ ςξχκθ οεπερεχενθ                                      if (j > 0)                                      {                                          List<ICoordinate> crossPoints = getCrossPoints(vertices[j]' vertices[j - 1]'                                                                                         viewBox);                                          if (crossPoints.Count == 0) // ξρςΰλθρό ρνΰπσζθ                                          {                                              currentPath.Add(vertices[j]);                                              continue;                                          }                                          if (crossPoints.Count == 2) // οεπερεκλθ 2 πΰηΰ                                          {                                              // ξοπεδελεμ κΰκσώ θη ςξχεκ οεπερεχενθ νσζνξ δξαΰβθςό κ ςεκσωεμσ οσςθ                                              double d0 = PlanimetryAlgorithms.Distance(crossPoints[0]' vertices[j - 1]);                                              double d1 = PlanimetryAlgorithms.Distance(crossPoints[1]' vertices[j - 1]);                                              if (d0 < d1)                                                  currentPath.Add(crossPoints[0]);                                              else                                                  currentPath.Add(crossPoints[1]);                                                  currentPath.Clear();                                                currentPath.Add(crossPoints[d0 < d1 ? 0 : 1]);                                              currentPath.Add(crossPoints[d0 < d1 ? 1 : 0]);                                                // πθρσεμ ξςπεηξκ                                              drawVisiblePolylinePartWithStyleDetection(g' currentPath'                                                                                         viewBox' scaleFactor                                                                                        );                                                                                         // θνθφθΰλθηθπσεμ βνεψνώώ χΰρςό οξλθλθνθθ                                              currentPath.Clear();                                              if (d0 < d1)                                                  currentPath.Add(crossPoints[1]);                                              else                                                  currentPath.Add(crossPoints[0]);                                              currentPath.Add(vertices[j]);                                              isInternalPath = false;                                              continue;                                          }                                      }                                      else // 1-ώ ςξχκσ νσζνξ οπξρςξ δξαΰβθςό β ροθρξκ                                      {                                          currentPath.Add(vertices[j]);                                          continue;                                      }                                  }                              }                          }                            // πθρσεμ χΰρςό οξλθλθνθθ' ερλθ ξνΰ βνσςπενν                          if (isInternalPath)                              drawVisiblePolylinePartWithStyleDetection(g' currentPath'                                                                        viewBox' scaleFactor);                      }
Magic Number,MapAround.Web,JSONMpHelper,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,drawPolylineSimple,The following statement contains a magic number: foreach (LinePath path in feature.Polyline.Paths)              {                  if (path.Vertices.Count < 2)                      continue;                    double[][] points = new double[path.Vertices.Count][];                    for (int j = 0; j < path.Vertices.Count; j++)                  {                      points[j] = new double[2];                      points[j][0] =  ((path.Vertices[j].X - viewBox.MinX)*scaleFactor);                      points[j][1] =  ((viewBox.MaxY - path.Vertices[j].Y)*scaleFactor);                  }                                                                                   // ξρνξβνΰ οξλθλθνθ                      g.Add("points"'JToken.FromObject(points));                                                     }
Magic Number,MapAround.Web,JSONMpHelper,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,drawPolylineSimple,The following statement contains a magic number: foreach (LinePath path in feature.Polyline.Paths)              {                  if (path.Vertices.Count < 2)                      continue;                    double[][] points = new double[path.Vertices.Count][];                    for (int j = 0; j < path.Vertices.Count; j++)                  {                      points[j] = new double[2];                      points[j][0] =  ((path.Vertices[j].X - viewBox.MinX)*scaleFactor);                      points[j][1] =  ((viewBox.MaxY - path.Vertices[j].Y)*scaleFactor);                  }                                                                                   // ξρνξβνΰ οξλθλθνθ                      g.Add("points"'JToken.FromObject(points));                                                     }
Magic Number,MapAround.Web,JSONMpHelper,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,DrawPoint,The following statement contains a magic number: foreach (ICoordinate targetPoint in targetPoints)              {                  _points[i] = new double[2];                  _points[i][0] = (targetPoint.X - viewBox.MinX)*scaleFactor;                  _points[i][1] = (viewBox.MaxY - targetPoint.Y)*scaleFactor;                    i++;                }
Magic Number,MapAround.Web,JSONMpHelper,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,DrawPolyline,The following statement contains a magic number: if (Math.Min(viewBox.Width/(feature.BoundingRectangle.Width)'                               viewBox.Height/(feature.BoundingRectangle.Height)) < 2)                      drawPolylineWithIntersectCalculation(g' feature'  viewBox' scaleFactor);                  else                      drawPolylineSimple(g' feature'  viewBox' scaleFactor);
Magic Number,MapAround.Web,JSONMpHelper,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,DrawPolygon,The following statement contains a magic number: foreach (Contour c in feature.Polygon.Contours)                  {                      // νες ρμϋρλΰ οϋςΰςόρ πθρξβΰςό βϋπξζδεννϋε κξνςσπϋ                      if (c.Vertices.Count <= 2)                          continue;                        double[][] points = new double[c.Vertices.Count][];                        for (int j = 0; j < c.Vertices.Count; j++)                      {                          points[j] = new double[2];                          points[j][0] =  ((c.Vertices[j].X - viewBox.MinX)*scaleFactor);                          points[j][1] =  ((viewBox.MaxY - c.Vertices[j].Y)*scaleFactor);                      }                                            if (points.Length > 2)                      {                                                   con.Add(points);                                                }                  }
Magic Number,MapAround.Web,JSONMpHelper,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,DrawPolygon,The following statement contains a magic number: foreach (Contour c in feature.Polygon.Contours)                  {                      // νες ρμϋρλΰ οϋςΰςόρ πθρξβΰςό βϋπξζδεννϋε κξνςσπϋ                      if (c.Vertices.Count <= 2)                          continue;                        double[][] points = new double[c.Vertices.Count][];                        for (int j = 0; j < c.Vertices.Count; j++)                      {                          points[j] = new double[2];                          points[j][0] =  ((c.Vertices[j].X - viewBox.MinX)*scaleFactor);                          points[j][1] =  ((viewBox.MaxY - c.Vertices[j].Y)*scaleFactor);                      }                                            if (points.Length > 2)                      {                                                   con.Add(points);                                                }                  }
Magic Number,MapAround.Web,JSONMpHelper,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\MapServerBase.cs,DrawPolygon,The following statement contains a magic number: foreach (Contour c in feature.Polygon.Contours)                  {                      // νες ρμϋρλΰ οϋςΰςόρ πθρξβΰςό βϋπξζδεννϋε κξνςσπϋ                      if (c.Vertices.Count <= 2)                          continue;                        double[][] points = new double[c.Vertices.Count][];                        for (int j = 0; j < c.Vertices.Count; j++)                      {                          points[j] = new double[2];                          points[j][0] =  ((c.Vertices[j].X - viewBox.MinX)*scaleFactor);                          points[j][1] =  ((viewBox.MaxY - c.Vertices[j].Y)*scaleFactor);                      }                                            if (points.Length > 2)                      {                                                   con.Add(points);                                                }                  }
Magic Number,MapAround.Web.Wmts,WmtsCapabilities,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,GenerateTileMatrixInfo,The following statement contains a magic number: matrixInfo.AppendChild(createElement("MatrixWidth"' Math.Pow(2' i).ToString()' capabilities' false' wmtsNamespaceURI));
Magic Number,MapAround.Web.Wmts,WmtsCapabilities,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Web\Wmts\WmtsCapabilities.cs,GenerateTileMatrixInfo,The following statement contains a magic number: matrixInfo.AppendChild(createElement("MatrixHeight"' Math.Pow(2' i).ToString()' capabilities' false' wmtsNamespaceURI));
Missing Default,MapAround.Caching,SimpleCacheAccessor,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Caching\FeatureCaching.cs,featureTypeSubKey,The following switch statement is missing a default case: switch (featureType)              {                  case FeatureType.Point:                  case FeatureType.MultiPoint:                      return "points";                  case FeatureType.Polyline:                      return "polylines";                  case FeatureType.Polygon:                      return "polygons";              }
Missing Default,MapAround.CoordinateSystems.Transformations,FeatureTransformer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\CoordinateSystems\Transformations\Transformers.cs,TransformFeatureInPlace,The following switch statement is missing a default case: switch (feature.FeatureType)              {                   case FeatureType.Point:                      feature.Point = GeometryTransformer.TransformPoint(feature.Point' transform);                      break;                  case FeatureType.Polyline:                      feature.Polyline = GeometryTransformer.TransformPolyline(feature.Polyline' transform);                      break;                  case FeatureType.Polygon:                      feature.Polygon = GeometryTransformer.TransformPolygon(feature.Polygon' transform);                      break;                  case FeatureType.MultiPoint:                      feature.MultiPoint = GeometryTransformer.TransformMultiPoint(feature.MultiPoint' transform);                      break;              }
Missing Default,MapAround.DataProviders,ShapeFileSpatialDataProvider,C:\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\ShapeFileDataProvider.cs,geometryFromShapeRecord,The following switch statement is missing a default case: switch (record.ShapeType)              {                  // point                  case 1:                      return new PointD(record.Points[0].X' record.Points[0].Y);                  // polyline                  case 3:                      Polyline polyline = new Polyline();                      for (int i = 0; i < record.Parts.Count; i++)                      {                          LinePath path = new LinePath();                          int j;                          for (j = record.Parts[i]; j < (i == record.Parts.Count - 1 ? record.Points.Count : record.Parts[i + 1]); j++)                              path.Vertices.Add(PlanimetryEnvironment.NewCoordinate(record.Points[j].X' record.Points[j].Y));                            polyline.Paths.Add(path);                      }                      return polyline;                  // ground                  case 5:                      Polygon p = new Polygon();                      for (int i = 0; i < record.Parts.Count; i++)                      {                          Contour contour = new Contour();                          int j;                          for (j = record.Parts[i]; j < (i == record.Parts.Count - 1 ? record.Points.Count : record.Parts[i + 1]); j++)                              contour.Vertices.Add(PlanimetryEnvironment.NewCoordinate(record.Points[j].X' record.Points[j].Y));                            contour.Vertices.RemoveAt(contour.Vertices.Count - 1);                          p.Contours.Add(contour);                      }                      if (p.CoordinateCount > 0)                          return p;                      else                          return null;                  // set of points                  case 8:                      MultiPoint mp = new MultiPoint();                      for (int i = 0; i < record.Points.Count; i++)                          mp.Points.Add(PlanimetryEnvironment.NewCoordinate(record.Points[i].X' record.Points[i].Y));                      return mp;              }
Missing Default,MapAround.DataProviders,ShapeFileSpatialDataProvider,C:\repos\gkrsu_maparound.core\src\MapAround.Core\DataProviders\ShapeFileDataProvider.cs,processFeature,The following switch statement is missing a default case: switch (feature.FeatureType)              {                  case FeatureType.Point: points.Add(feature); break;                  case FeatureType.MultiPoint: multiPoints.Add(feature); break;                  case FeatureType.Polyline: polylines.Add(feature); break;                  case FeatureType.Polygon: polygons.Add(feature); break;              }
Missing Default,MapAround.Geometry,MonotoneChain,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\DataStructures.cs,getSubChainBounds,The following switch statement is missing a default case: switch (_orientation)              {                   case Orientation.RightUp:                      return new BoundingRectangle(s1.V1' s2.V2);                  case Orientation.RightDown:                      return new BoundingRectangle(s1.V1.X' s2.V2.Y' s2.V2.X' s1.V1.Y);                  case Orientation.LeftUp:                      return new BoundingRectangle(s2.V2.X' s1.V1.Y' s1.V1.X' s2.V2.Y);                  case Orientation.LeftDown:                      return new BoundingRectangle(s2.V2' s1.V1);              }
Missing Default,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,checkContoursOrientation,The following switch statement is missing a default case: switch (or)                              {                                  case Contour.Orientation.Undefined:                                      ICoordinate p = Contours[i].GetSelfIntersectionPoint();                                      return new ValidationError(InvalidityCase.SelfIntersection' p' i);                                  case Contour.Orientation.CCW:                                      return new ValidationError(InvalidityCase.WrongOrientation' null' i);                              }
Missing Default,MapAround.Geometry,Polygon,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Geometries.cs,checkContoursOrientation,The following switch statement is missing a default case: switch (or)                      {                          case Contour.Orientation.Undefined:                              ICoordinate p = Contours[0].GetSelfIntersectionPoint();                              return new ValidationError(InvalidityCase.SelfIntersection' p' 0);                          case Contour.Orientation.CW:                              return new ValidationError(InvalidityCase.WrongOrientation' null' 0);                      }
Missing Default,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPointOverlay,The following switch statement is missing a default case: switch (operation)              {                  case OverlayType.Intersection:                      foreach (PlanarGraphNode node in graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              result.Add(new PointD(node.Point));                      break;                  case OverlayType.Union:                      foreach (PlanarGraphNode node in graph.Nodes)                          result.Add(new PointD(node.Point));                      break;                  case OverlayType.Difference:                      foreach (PlanarGraphNode node in graph.Nodes)                          if (node.Label.UsedByObject1 && !node.Label.UsedByObject2)                              result.Add(new PointD(node.Point));                      break;                  case OverlayType.SymmetricDifference:                      foreach (PlanarGraphNode node in graph.Nodes)                          if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                              result.Add(new PointD(node.Point));                      break;              }
Missing Default,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolylinePolylineOverlay,The following switch statement is missing a default case: switch (operation)                          {                              case OverlayType.Intersection:                                  edge.Enabled = edge.Label.UsedByObject1 && edge.Label.UsedByObject2;                                  break;                              case OverlayType.Union:                                  edge.Enabled = edge.Label.UsedByObject1 || edge.Label.UsedByObject2;                                  break;                              case OverlayType.Difference:                                  edge.Enabled = edge.Label.UsedByObject1 && !edge.Label.UsedByObject2;                                  break;                              case OverlayType.SymmetricDifference:                                  edge.Enabled = edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2;                                  break;                          }
Missing Default,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPolylinePolylineOverlay,The following switch statement is missing a default case: switch (operation)                              {                                  case OverlayType.Intersection:                                      node.Enabled = node.Label.UsedByObject1 && node.Label.UsedByObject2;                                      break;                                  case OverlayType.Union:                                      node.Enabled = node.Label.UsedByObject1 || node.Label.UsedByObject2;                                      break;                                  case OverlayType.Difference:                                      node.Enabled = node.Label.UsedByObject1 && !node.Label.UsedByObject2;                                      break;                                  case OverlayType.SymmetricDifference:                                      node.Enabled = node.Label.UsedByObject1 ^ node.Label.UsedByObject2;                                      break;                              }
Missing Default,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolylineOverlay,The following switch statement is missing a default case: switch (operation)                          {                              case OverlayType.Intersection:                                  edge.Enabled = false;                                  break;                              case OverlayType.Union:                                  edge.Enabled = edge.Label.UsedByObject2;                                  break;                              case OverlayType.Difference:                                  edge.Enabled = inverseArgs ? edge.Label.UsedByObject2 : false;                                  break;                              case OverlayType.SymmetricDifference:                                  edge.Enabled = edge.Label.UsedByObject2;                                  break;                          }
Missing Default,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolylineOverlay,The following switch statement is missing a default case: switch (operation)                              {                                  case OverlayType.Intersection:                                      node.Enabled = node.Label.UsedByObject1 && node.Label.UsedByObject2;                                      break;                                  case OverlayType.Union:                                      node.Enabled = node.Label.UsedByObject1;                                      break;                                  case OverlayType.Difference:                                      node.Enabled = inverseArgs ? false : !node.Label.UsedByObject2;                                      break;                                  case OverlayType.SymmetricDifference:                                      node.Enabled = true;                                      break;                              }
Missing Default,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolygonOverlay,The following switch statement is missing a default case: switch (operation)                          {                              case OverlayType.Intersection:                                  edge.Enabled = false;                                  break;                              case OverlayType.Union:                                  edge.Enabled = edge.Label.UsedByObject2;                                  break;                              case OverlayType.Difference:                                  edge.Enabled = inverseArgs ? edge.Label.UsedByObject2 : false;                                  break;                              case OverlayType.SymmetricDifference:                                  edge.Enabled = edge.Label.UsedByObject2;                                  break;                          }
Missing Default,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,getPointPolygonOverlay,The following switch statement is missing a default case: switch (operation)                              {                                  case OverlayType.Intersection:                                      node.Enabled = (pg.ContainsPoint(node.Point) && !node.Label.UsedByObject2) ||                                                     (node.Label.UsedByObject2 && node.Label.UsedByObject1);                                      break;                                  case OverlayType.Union:                                      node.Enabled = !pg.ContainsPoint(node.Point) && !node.Label.UsedByObject2;                                      break;                                  case OverlayType.Difference:                                      node.Enabled = inverseArgs ? false : !pg.ContainsPoint(node.Point) && !node.Label.UsedByObject2;                                      break;                                  case OverlayType.SymmetricDifference:                                      node.Enabled = !pg.ContainsPoint(node.Point) && !node.Label.UsedByObject2;                                      break;                              }
Missing Default,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,isNodeEnabled,The following switch statement is missing a default case: switch (operation)              {                  case OverlayType.Intersection:                      if (!node.Label.UsedByObject1 || !node.Label.UsedByObject2)                          return false;                      break;                  case OverlayType.Union:                      return false;                  case OverlayType.Difference:                      return false;                  case OverlayType.SymmetricDifference:                      return false;              }
Missing Default,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,isLinearEdgeEnabled,The following switch statement is missing a default case: switch (operation)              {                  case OverlayType.Intersection:                      return edge.Label.UsedByObject1 && edge.Label.UsedByObject2;                  case OverlayType.Union:                      return false;                  case OverlayType.Difference:                      return false;                  case OverlayType.SymmetricDifference:                      return false;              }
Missing Default,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,isAreaEdgeEnabled,The following switch statement is missing a default case: switch (operation)              {                  case OverlayType.Intersection:                      if (usebyPolygon1 && usebyPolygon2 && edge.OrientationInObject1 == edge.OrientationInObject2)                          return true;                        if ((usebyPolygon1 ^ usebyPolygon2))                          if (usebyPolygon1)                          {                              if (p2.ContainsPoint(edge.CenterPoint()))                                  return true;                          }                          else                          {                              if (p1.ContainsPoint(edge.CenterPoint()))                                  return true;                          }                      break;                  case OverlayType.Union:                      if (usebyPolygon1 && usebyPolygon2 && edge.OrientationInObject1 == edge.OrientationInObject2)                          return true;                        if ((usebyPolygon1 ^ usebyPolygon2))                          if (usebyPolygon1)                          {                              if (!p2.ContainsPoint(edge.CenterPoint()))                                  return true;                          }                          else                          {                              if (!p1.ContainsPoint(edge.CenterPoint()))                                  return true;                          }                      break;                  case OverlayType.Difference:                      if (usebyPolygon1 && usebyPolygon2 && edge.OrientationInObject1 != edge.OrientationInObject2)                          return true;                        if ((usebyPolygon1 ^ usebyPolygon2))                          if (usebyPolygon1)                          {                              if (!p2.ContainsPoint(edge.CenterPoint()))                                  return true;                          }                          else                          {                              if (p1.ContainsPoint(edge.CenterPoint()))                                  return true;                          }                      break;                  case OverlayType.SymmetricDifference:                      if ((usebyPolygon1 ^ usebyPolygon2))                          return true;                      break;              }
Missing Default,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,isNodeEnabled,The following switch statement is missing a default case: switch (operation)              {                  case OverlayType.Intersection:                      if (!node.Label.UsedByObject1 || !node.Label.UsedByObject2)                          return false;                      break;                  case OverlayType.Union:                      return false;                  case OverlayType.Difference:                  case OverlayType.SymmetricDifference:                      return false;              }
Missing Default,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,isLinearEdgeEnabled,The following switch statement is missing a default case: switch (operation)              {                  case OverlayType.Intersection:                      return edge.Label.UsedByObject1 && (edge.Label.UsedByObject2 || polygon.ContainsPoint(edge.CenterPoint()));                  case OverlayType.Union:                      return edge.Label.UsedByObject1 && !polygon.ContainsPoint(edge.CenterPoint());                  case OverlayType.Difference:                      return inverseArgs ? false :                                            edge.Label.UsedByObject1 &&                                            !polygon.ContainsPoint(edge.CenterPoint()) &&                                           !edge.Label.UsedByObject2;                  case OverlayType.SymmetricDifference:                      return edge.Label.UsedByObject1 &&                             !polygon.ContainsPoint(edge.CenterPoint()) &&                             !edge.Label.UsedByObject2;              }
Missing Default,MapAround.Geometry,OverlayCalculator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Overlays.cs,isAreaEdgeEnabled,The following switch statement is missing a default case: switch (operation)              {                  case OverlayType.Intersection:                      return false;                  case OverlayType.Union:                      if (usebyPolygon) return true;                      break;                  case OverlayType.Difference:                      return inverseArgs;                  case OverlayType.SymmetricDifference:                      if (usebyPolygon) return true;                      break;              }
Missing Default,MapAround.Geometry,GeometrySimplifier,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Simplifier.cs,getVertexWeight,The following switch statement is missing a default case: switch (_vertexWeighting)              {                  case VertexWeightingType.NormalizedLinear:                  case VertexWeightingType.AngleCube:                      // length of the segments                      double s1 = PlanimetryAlgorithms.Distance(p1' p2);                      double s2 = PlanimetryAlgorithms.Distance(p2' p3);                        double s1s2 = s1 * s2;                        //   angle of rotation                      double angle = Math.PI - Math.Abs(Math.Acos(((p1.X - p2.X) * (p3.X - p2.X) + (p1.Y - p2.Y) * (p3.Y - p2.Y)) / s1s2));                        if (_vertexWeighting == VertexWeightingType.SquareDifference)                          return s1s2 * angle / (s1 + s2);                      else                          return s1s2 * angle * angle * angle;                  case VertexWeightingType.SquareDifference:                      return Math.Abs((p2.X - p1.X) * (p3.Y - p1.Y) - (p3.X - p1.X) * (p2.Y - p1.Y));                  case VertexWeightingType.Custom:                      if (SDMinVertexWeightNeeded != null)                      {                          SDMinVertexWeightNeededEventArgs args =                               new SDMinVertexWeightNeededEventArgs(p1' p2' p3' pathIndex' pointIndex);                          SDMinVertexWeightNeeded(this' args);                          return args.Weight;                      }                      break;              }
Missing Default,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,getDimensionPair,The following switch statement is missing a default case: switch (minDim)                  {                      case 0: _sourceDimensions = DimensionPair.ZeroTwo;                          break;                      case 1: _sourceDimensions = DimensionPair.OneTwo;                          break;                      case 2: _sourceDimensions = DimensionPair.TwoTwo;                          break;                  }
Missing Default,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,elementToChar,The following switch statement is missing a default case: switch (_values[x' y])              {                   case ElementValue.Empty: return 'F';                  case ElementValue.Zero: return '0';                  case ElementValue.One: return '1';                  case ElementValue.Two: return '2';              }
Missing Default,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculteInternalInternal,The following switch statement is missing a default case: switch (_sourceDimensions)              {                  // ---------------------------- the intersection of the interior of the two points                  case DimensionPair.ZeroZero:                        this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                              break;                          }                      break;                  // ---------------------------- the intersection of the interior of a point and a polyline                  case DimensionPair.ZeroOne:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2 && node.IncidentEdges.Count % 2 != 1)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                              break;                          }                      break;                  // ---------------------------- crossing point' and the interior of the polygon                  case DimensionPair.ZeroTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        Polygon polygon = _sourceGeometry1 is Polygon ? (Polygon)_sourceGeometry1 : (Polygon)_sourceGeometry2;                        foreach (PlanarGraphNode node in _graph.Nodes)                      {                          if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                              //node is used by one of the objects                              if (isFirstGeometryPoint ^ node.Label.UsedByObject2)                                  //not a polygon. need to check whether it is inside the polygon.                                  if (polygon.ContainsPoint(node.Point))                                  {                                      this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                                      break;                                  }                      }                      break;                  // ---------------------------- the intersection of the interior of polylines                  case DimensionPair.OneOne:                      this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      // lines may intersect at a point' then the graph has a node used by both                       // lines and does not coincide with their boundaries                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              // node was found' make sure that it does not limit:                              // at the boundary points of an odd number of edges used line                              int use1Count = 0;                              int use2Count = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) use1Count++;                                  if (edge.Label.UsedByObject2) use2Count++;                              }                              if (use1Count % 2 != 1 && use2Count % 2 != 1)                              {                                  // polylines intersect at least at                                  this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Zero;                                  break;                              }                          }                        // possible intersection of the one-dimensional'                      // then they should be shared at least one edge of the graph                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.One;                              return;                          }                      break;                  // ---------------------------- the intersection of the interior of the polyline and polygon                  case DimensionPair.OneTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                      polygon = _sourceGeometry1 is Polygon ? (Polygon)_sourceGeometry1 : (Polygon)_sourceGeometry2;                      bool flag = _sourceGeometry1 is Polygon;                        // perhaps one-dimensional intersection' then the edge must lie                       // within the polygon' and used only the line                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (((flag && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1) ||                                (!flag && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2)) && polygon.ContainsPoint(edge.CenterPoint()))                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.One;                              return;                          }                      break;                  // ---------------------------- the intersection of the interior of polygons                  case DimensionPair.TwoTwo:                       this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Empty;                        // possible two-dimensional intersection' in which case at least one edge only                      // have one ground should lie within the other' or at least one edge of the polygon                       // is used both on the same side of the two polygons to mark up orientation                       // of the edges of polygons along the bypass                      markPolygonsOrientation();                        foreach (PlanarGraphEdge edge in _graph.Edges)                      {                          flag = false;                          if (edge.Label.UsedByObject1 && !edge.Label.UsedByObject2)                              if (((Polygon)_sourceGeometry2).ContainsPoint(edge.CenterPoint()))                                  flag = true;                            if (edge.Label.UsedByObject2 && !edge.Label.UsedByObject1)                              if (((Polygon)_sourceGeometry1).ContainsPoint(edge.CenterPoint()))                                  flag = true;                            if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              if (edge.OrientationInObject1 == edge.OrientationInObject2)                                  flag = true;                            if(flag)                          {                              this[ElementPosition.Internal' ElementPosition.Internal] = ElementValue.Two;                              return;                          }                      }                      break;              }
Missing Default,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsBounds,The following switch statement is missing a default case: switch (_sourceDimensions)              {                  // ---------------------------- two border crossing points                  case DimensionPair.ZeroZero:                      // border points - the empty set' and their intersection is also                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ---------------------------- border crossing points and polylines                  case DimensionPair.ZeroOne:                      // border points - the empty set' the intersection of the boundary polyline too                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ----------------------------border crossing point and polygon                  case DimensionPair.ZeroTwo:                      //border points - the empty set' the intersection of the boundary of the landfill' too                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                      break;                  // ---------------------------- border crossing polylines                  case DimensionPair.OneOne:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possible boundary lines coincide' in this case in the graph'                       // there must exist a node incident to the edges of which are used an odd number of times both lines                      foreach (PlanarGraphNode node in _graph.Nodes)                      {                          int use1count = 0;                          int use2count = 0;                          foreach (PlanarGraphEdge edge in node.IncidentEdges)                          {                              if (edge.Label.UsedByObject1) use1count++;                              if (edge.Label.UsedByObject2) use2count++;                          }                          if (use1count % 2 == 1 && use2count % 2 == 1)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                              return;                          }                      }                      break;                  // ---------------------------- border crossing polyline and polygon                  case DimensionPair.OneTwo:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node used polygon and polyline' and the number of edges                       // incident to a node used polyline' must be odd                                         bool flag = _sourceGeometry1 is Polygon;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usedEdgesCount = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (flag && edge.Label.UsedByObject2) usedEdgesCount++;                                  if (!flag && edge.Label.UsedByObject1) usedEdgesCount++;                              }                              if (usedEdgesCount % 2 == 1)                              {                                  this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ----------------------------intersection polygon boundaries                  case DimensionPair.TwoTwo:                      this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Empty;                        // possibly zero-dimensional intersection' in this case in the graph' there must exist a node used by both polygons                      flag = false;                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.Zero;                              flag = true;                              break;                          }                        if (!flag) return;                        // perhaps there is a one-dimensional intersection' in which case the graph must find at least one shared edge                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                          {                              this[ElementPosition.Boundary' ElementPosition.Boundary] = ElementValue.One;                              return;                          }                      break;              }
Missing Default,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalBounds,The following switch statement is missing a default case: switch (_sourceDimensions)              {                  // ----------------------------the interior of the intersection points with the boundary point - always empty                  case DimensionPair.ZeroZero:                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and the interior of the points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                           return;                        // possibly zero-dimensional intersection' in this case' there must exist a node count of incident edges is odd                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                        break;                  // ---------------------------- crossing the border and the interior of the point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      // crossing the border points - empty                      if ((isFirstGeometryPoint && inverseArgs) || (!isFirstGeometryPoint && !inverseArgs))                          return;                        // possibly zero-dimensional intersection' in this case' there must exist a shared graph node                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              this[xPos' yPos] = ElementValue.Zero;                              return;                          }                      break;                  // ---------------------------- crossing the border and the interior of the polyline                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node for which the number of incident edges'                      // used a polyline - odd' the other used a polyline - even                      foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                          {                              int usageCount1 = 0;                              int usageCount2 = 0;                              foreach (PlanarGraphEdge edge in node.IncidentEdges)                              {                                  if (edge.Label.UsedByObject1) usageCount1++;                                  if (edge.Label.UsedByObject2) usageCount2++;                              }                              if ((!inverseArgs && usageCount1 % 2 == 0 && usageCount2 % 2 == 1) ||                                 (inverseArgs && usageCount1 % 2 == 1 && usageCount2 % 2 == 0))                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                          }                        break;                  // ---------------------------- crossing the border and the interior of the polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                      if ((isFirstGeometryPolyline && inverseArgs) ||                          (!isFirstGeometryPolyline && !inverseArgs))                      {                          // boundary polyline must be inside the polygon                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                  (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (inverseArgs && edge.Label.UsedByObject1) count++;                                      if (!inverseArgs && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 1 && polygon.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                              }                      }                      else                      {                          bool flag = false;                          // boundary of the polygon can intersect the interior of the polyline at                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 && node.Label.UsedByObject2)                              {                                  int count = 0;                                  foreach (PlanarGraphEdge edge in node.IncidentEdges)                                  {                                      if (isFirstGeometryPolyline && edge.Label.UsedByObject1) count++;                                      if (!isFirstGeometryPolyline && edge.Label.UsedByObject2) count++;                                  }                                    if (count % 2 == 0)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      flag = true;                                      break;                                  }                              }                            if (!flag) return;                            // perhaps also one-dimensional intersection' in which                           // case the graph must find at least one shared edge                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      break;                  // ---------------------------- crossing the border and the interior of the polygon                  case DimensionPair.TwoTwo:                      Polygon p1 = (Polygon)_sourceGeometry1;                      Polygon p2 = (Polygon)_sourceGeometry2;                      this[xPos' yPos] = ElementValue.Empty;                        // perhaps one-dimensional intersection' in which case the                      // graph must be some edge' used by one of the sites and are inside other                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                              if ((inverseArgs && edge.Label.UsedByObject1 && p2.ContainsPoint(edge.CenterPoint())) ||                                  (!inverseArgs && edge.Label.UsedByObject2 && p1.ContainsPoint(edge.CenterPoint())))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      break;              }
Missing Default,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateInternalExternal,The following switch statement is missing a default case: switch (_sourceDimensions)              {                  // ---------------------------- the interior of the intersection point with the addition of a point                  case DimensionPair.ZeroZero:                      this[xPos' yPos] = ElementValue.Empty;                        //if (!((PointD)_sourceGeometry1).Equals((PointD)_sourceGeometry2))                      //    this[xPos' yPos] = ElementValue.Zero;                        foreach (PlanarGraphNode node in _graph.Nodes)                          if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                              if (node.Label.UsedByObject1 ^ inverseArgs)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                      break;                  // ----------------------------crossing the inner region and add points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                        if ((isFirstGeometryPolyline && !inverseArgs) ||                          (!isFirstGeometryPolyline && inverseArgs))                      {                          // intersection point with the additions interior of the polyline - dimensional (not in the degenerate case)                          if (_graph.Edges.Count > 0)                              this[xPos' yPos] = ElementValue.One;                      }                      else                      {                          // intersection of the complement to the interior of the polyline point' perhaps a zero-dimensional intersection                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                                  if ((isFirstGeometryPoint && node.Label.UsedByObject1) ||                                      (!isFirstGeometryPoint && node.Label.UsedByObject2))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                      }                      break;                  // ---------------------------- crossing the inner region and add a point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      if ((inverseArgs && isFirstGeometryPoint) ||                         (!inverseArgs && !isFirstGeometryPoint))                      {                          // addition point is always two-dimensional intersection with the inner region of the landfill                          if(_graph.Edges.Count > 0)                              this[xPos' yPos] = ElementValue.Two;                      }                      else                      {                          Polygon polygon = isFirstGeometryPoint ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                            // addition' the landfill has a zero-dimensional intersection with the interior of the point'                           // if the point does not lie within the polygon                          foreach (PlanarGraphNode node in _graph.Nodes)                          {                              if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                                  if (isFirstGeometryPoint ^ node.Label.UsedByObject2)                                  {                                      // node is not shared' if it lies outside the range - we have a zero-dimensional intersection                                      if (!polygon.ContainsPoint(node.Point))                                      {                                          this[xPos' yPos] = ElementValue.Zero;                                          return;                                      }                                      return;                                  }                          }                      }                      break;                  // ---------------------------- crossing the inner region and add polylines                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      //perhaps one-dimensional intersection' in which case there must be an edge is used by only one line                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                              if ((!inverseArgs && edge.Label.UsedByObject1) ||                                 (inverseArgs && edge.Label.UsedByObject2))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      break;                  // ---------------------------- crossing the inner region and add polylines and polygons                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                      Polygon p1 = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                      if ((inverseArgs && isFirstGeometryPolyline) ||                          (!inverseArgs && !isFirstGeometryPolyline))                      {                          // intersection of the complement to the interior of the polyline is two-dimensional polygon                          this[xPos' yPos] = ElementValue.Two;                          return;                      }                      else                      {                          //perhaps one-dimensional intersection polygon additions to the interior of the polyline'                          // in this case there must be an edge that belongs only polylines' and does not lie within the polygon                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                                  if ((!inverseArgs && edge.Label.UsedByObject1) ||                                      (inverseArgs && edge.Label.UsedByObject2))                                      if (!p1.ContainsPoint(edge.CenterPoint()))                                      {                                          this[xPos' yPos] = ElementValue.One;                                          return;                                      }                      }                      break;                  // ---------------------------- the intersection of the interior of the polygon and Supplies                  case DimensionPair.TwoTwo:                      this[xPos' yPos] = ElementValue.Empty;                      // possible two-dimensional intersection' if there is at least one edge is used                       // first ground does not lie within the other' or there is an edge is used only                      // in the second polygon lies inside the first' or there is an edge used                      // by both polygons so that they lie on opposite sides of it                      Polygon polygon1 = (Polygon)_sourceGeometry1;                      Polygon polygon2 = (Polygon)_sourceGeometry2;                      bool _orientationMarked = false;                        foreach (PlanarGraphEdge edge in _graph.Edges)                      {                          if (edge.Label.UsedByObject1 ^ edge.Label.UsedByObject2)                          {                              if ((inverseArgs && edge.Label.UsedByObject2 && !polygon1.ContainsPoint(edge.CenterPoint())) ||                                 (!inverseArgs && edge.Label.UsedByObject1 && !polygon2.ContainsPoint(edge.CenterPoint())))                              {                                  this[xPos' yPos] = ElementValue.Two;                                  return;                              }                                if ((inverseArgs && edge.Label.UsedByObject1 && polygon2.ContainsPoint(edge.CenterPoint())) ||                                 (!inverseArgs && edge.Label.UsedByObject2 && polygon1.ContainsPoint(edge.CenterPoint())))                                {                                  this[xPos' yPos] = ElementValue.Two;                                  return;                              }                          }                          else                              if (edge.Label.UsedByObject1 && edge.Label.UsedByObject2)                              {                                  // possible orientations of the layout do not have to' if the intersection is calculated by other edges                                  if (_orientationMarked)                                  {                                      markPolygonsOrientation();                                      _orientationMarked = true;                                  }                                  if (edge.OrientationInObject1 != edge.OrientationInObject2)                                  {                                      this[xPos' yPos] = ElementValue.Two;                                      return;                                  }                              }                      }                      break;              }
Missing Default,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,calculateBoundsExternal,The following switch statement is missing a default case: switch (_sourceDimensions)              {                  // ---------------------------- border crossing point with the addition of a point                  case DimensionPair.ZeroZero:                      // always empty                      this[xPos' yPos] = ElementValue.Empty;                      break;                  // ---------------------------- crossing the border and add points and polylines                  case DimensionPair.ZeroOne:                      this[xPos' yPos] = ElementValue.Empty;                      if ((inverseArgs && !isFirstGeometryPoint) ||                          (!inverseArgs && isFirstGeometryPoint))                          // always empty                          this[xPos' yPos] = ElementValue.Empty;                      else                      {                          foreach (PlanarGraphNode node in _graph.Nodes)                              if (node.Label.UsedByObject1 ^ node.Label.UsedByObject2)                                  if (node.IncidentEdges.Count % 2 == 1)                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                      }                      break;                  // ---------------------------- crossing the border and add a point and polygon                  case DimensionPair.ZeroTwo:                      this[xPos' yPos] = ElementValue.Empty;                      if ((inverseArgs && isFirstGeometryPoint) ||                          (!inverseArgs && !isFirstGeometryPoint))                      {                          // one-dimensional intersection in the nondegenerate case                          if (_graph.Edges.Count > 0)                              this[xPos' yPos] = ElementValue.One;                      }                      // otherwise empty                      break;                  // ---------------------------- crossing the border and add polylines                  case DimensionPair.OneOne:                      this[xPos' yPos] = ElementValue.Empty;                      // possibly zero-dimensional intersection' in this case in the graph'                       // there must exist a node that is used only a polyline with an odd number of edges incident                      foreach (PlanarGraphNode node in _graph.Nodes)                          if ((!inverseArgs && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                              (inverseArgs && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                              if (node.IncidentEdges.Count % 2 == 1)                              {                                  this[xPos' yPos] = ElementValue.Zero;                                  return;                              }                      break;                  // ---------------------------- crossing the border and add polyline and polygon                  case DimensionPair.OneTwo:                      this[xPos' yPos] = ElementValue.Empty;                                            if ((inverseArgs && isFirstGeometryPolyline) ||                          (!inverseArgs && !isFirstGeometryPolyline))                      {                          //perhaps one-dimensional intersection' if there is at least one edge ispolzeumoe only ground                          foreach (PlanarGraphEdge edge in _graph.Edges)                              if ((isFirstGeometryPolyline && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1) ||                                 (!isFirstGeometryPolyline && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2))                              {                                  this[xPos' yPos] = ElementValue.One;                                  return;                              }                      }                      else                      {                          //possibly zero-dimensional intersection' if there is at least one node'                           // use only the line that has an odd number of incident edges and lying within the polygon                          Polygon p1 = isFirstGeometryPolyline ? (Polygon)_sourceGeometry2 : (Polygon)_sourceGeometry1;                          foreach (PlanarGraphNode node in _graph.Nodes)                              if ((isFirstGeometryPolyline && node.Label.UsedByObject1 && !node.Label.UsedByObject2) ||                                 (!isFirstGeometryPolyline && node.Label.UsedByObject2 && !node.Label.UsedByObject1))                                  if(node.IncidentEdges.Count % 2 == 1 && !p1.ContainsPoint(node.Point))                                  {                                      this[xPos' yPos] = ElementValue.Zero;                                      return;                                  }                      }                      break;                  // ---------------------------- crossing the border and add polygons                  case DimensionPair.TwoTwo:                      this[xPos' yPos] = ElementValue.Empty;                        Polygon polygon1 = (Polygon)_sourceGeometry1;                       Polygon polygon2 = (Polygon)_sourceGeometry2;                        // perhaps one-dimensional intersection' if there is at least one edge                       // belongs to only one polygon and not contained within another                      foreach (PlanarGraphEdge edge in _graph.Edges)                          if ((!inverseArgs && edge.Label.UsedByObject1 && !edge.Label.UsedByObject2 && !polygon2.ContainsPoint(edge.CenterPoint())) ||                              (inverseArgs && edge.Label.UsedByObject2 && !edge.Label.UsedByObject1 && !polygon1.ContainsPoint(edge.CenterPoint())))                          {                              this[xPos' yPos] = ElementValue.One;                              return;                          }                      break;              }
Missing Default,MapAround.Geometry,IntersectionMatrix,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\SpatialRelations.cs,Matches,The following switch statement is missing a default case: switch (ch)                  {                       case '*':break;                      case 'F':                          if (_values[j' i] != ElementValue.Empty)                              return false;                          break;                      case 'T':                           if (_values[j' i] == ElementValue.Empty ||                              _values[j' i] == ElementValue.Undefined)                              return false;                          break;                      case '0':                          if (_values[j' i] != ElementValue.Zero)                              return false;                          break;                      case '1':                           if (_values[j' i] != ElementValue.One)                              return false;                          break;                      case '2':                          if (_values[j' i] != ElementValue.Two)                              return false;                          break;                  }
Missing Default,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,translateAngleQuadrant,The following switch statement is missing a default case: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return _twoPi - angle; }              }
Missing Default,MapAround.Geometry,PlanarGraph,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Topology.cs,processContour,The following switch statement is missing a default case: switch ((EdgeUsage)edge.Label.Tag)                          {                              case EdgeUsage.Both: break;                              case EdgeUsage.None:                                  possibleEdges.Add(edge);                                  break;                              case EdgeUsage.Forward:                                  if (edge.Node2 == currentNode)                                      possibleEdges.Add(edge);                                  break;                              case EdgeUsage.Backward:                                  if (edge.Node1 == currentNode)                                      possibleEdges.Add(edge);                                  break;                          }
Missing Default,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,AddFeature,The following switch statement is missing a default case: switch (feature.FeatureType)              {                   case FeatureType.Point:                      AddPoint(feature);                      break;                  case FeatureType.Polyline:                      AddPolyline(feature);                      break;                  case FeatureType.Polygon:                      AddPolygon(feature);                      break;                  case FeatureType.MultiPoint:                      AddMultiPoint(feature);                      break;              }
Missing Default,MapAround.Mapping,FeatureLayer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,RenderFeaturesSample,The following switch statement is missing a default case: switch (sampleCount)                      {                           case 3:                              minX = image.Width / 3;                              maxX = 2 * image.Width / 3;                              break;                          case 2:                              if (drawPoint)                              {                                  minX = image.Width / 2;                                  maxX = image.Width;                              }                              else                                  maxX = image.Width / 2;                              break;                          case 1:                              maxX = image.Width;                              break;                      }
Missing Default,MapAround.Mapping,LayerFeaturesEnumerator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,getCurrentCollection,The following switch statement is missing a default case: switch (_currentFeatureType)                  {                      case FeatureType.Point: return _layer._points;                      case FeatureType.Polyline: return _layer._polylines;                      case FeatureType.Polygon: return _layer._polygons;                      case FeatureType.MultiPoint: return _layer._multiPoints;                  }
Missing Default,MapAround.Mapping,Feature,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,Clone,The following switch statement is missing a default case: switch(result.FeatureType)              {                  case FeatureType.Point:                      result.Point = (PointD)this.Point.Clone();                      break;                  case FeatureType.Polyline:                      result.Polyline = (Polyline)this.Polyline.Clone();                      break;                  case FeatureType.Polygon:                      result.Polygon = (Polygon)this.Polygon.Clone();                      break;                  case FeatureType.MultiPoint:                      result.MultiPoint = (MultiPoint)this.MultiPoint.Clone();                      break;              }
Missing Default,MapAround.Mapping,Feature,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\MapObjects.cs,Feature,The following switch statement is missing a default case: switch (_featureType)              {                   case FeatureType.Point:                      _point = new PointD();                      break;                  case FeatureType.Polyline:                       _polyline = new Polyline();                      break;                  case FeatureType.Polygon:                      _polygon = new Polygon();                      break;                  case FeatureType.MultiPoint:                      _multiPoint = new MultiPoint();                      break;              }
Missing Default,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,addTitleBufferElement,The following switch statement is missing a default case: switch (feature.FeatureType)              {                  case FeatureType.Polyline:                      if (!titleStyle.LeadAlong)                      {                          foreach (LinePath path in feature.Polyline.Paths)                          {                              if (path.Vertices.Count > 2)                                  targetCoordinate = path.Vertices[path.Vertices.Count / 2 - 1];                              else                              {                                  s = new Segment(path.Vertices[0].X' path.Vertices[0].Y'                                                  path.Vertices[1].X' path.Vertices[1].Y);                                    targetCoordinate = s.Center();                              }                              addTitleBufferElement(titleStyle' targetCoordinate' size' scaleFactor' feature);                          }                      }                      else                      {                          int i = 0;                          foreach (LinePath path in feature.Polyline.Paths)                          {                              FollowingTitle followingTitle =                                   getFollowingTitle(g' path' feature.PolylinePartLengths[i]' feature.Title' titleStyle' viewBox' scaleFactor);                              if (followingTitle != null)                                  _titleBuffer.Add(new TitleBufferElement(followingTitle' titleStyle' _titleCount++));                              i++;                          }                      }                      return;                  case FeatureType.Polygon:                      //if (feature.Polygon.Contours.Count > 0)                      //    targetPoint = feature.Polygon.Contours[0].RibsCentroid();                      //else                      //    return;                      //break;                        if (feature.Polygon.Contours.Count > 0)                          try                          {                              targetCoordinate = feature.Polygon.PointOnSurface();                          }                          catch(InvalidOperationException)                          {                              //interior point of the polygon for some reason (usually singular) can not be found                              return;                          }                      else                          return;                      break;                                        case FeatureType.Point:                      targetCoordinate = feature.Point.Coordinate;                      //targetPoint.Y += size.Height / scaleFactor / 2;                      break;                  case FeatureType.MultiPoint:                      if (titleStyle.LeadAlong)                      {                          foreach (ICoordinate p in feature.MultiPoint.Points)                          {                              targetCoordinate = p;                              targetCoordinate.Y += size.Height / scaleFactor / 2;                              addTitleBufferElement(titleStyle' targetCoordinate' size' scaleFactor' feature);                          }                          return;                      }                      else                          targetCoordinate = PlanimetryAlgorithms.GetCentroid(feature.MultiPoint.Points);                      break;              }
Missing Default,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,translateAngleQuadrant,The following switch statement is missing a default case: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return 2 * Math.PI - angle; }              }
Missing Default,MapAround.Mapping,DefaultFeatureRenderer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Mapping\FeatureRendering.cs,getRelativeDashSize,The following switch statement is missing a default case: switch (pen.DashStyle)              {                  case DashStyle.Dot:                      relativeDashSize = 2;                      break;                    case DashStyle.Dash:                      relativeDashSize = 4;                      break;                    case DashStyle.DashDot:                      relativeDashSize = 6;                      break;                    case DashStyle.DashDotDot:                      relativeDashSize = 8;                      break;                    case DashStyle.Custom:                      relativeDashSize = 0;                      foreach (float d in pen.DashPattern)                          relativeDashSize += d;                      break;              }
Missing Default,MapAround.Geometry.Tessellations,VoronoiBuilder,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Geometry\Tessellations\Voronoi.cs,build,The following switch statement is missing a default case: switch (currentEvent.Kind)                  {                       case FortuneEvent.EventKind.Point :                          handlePointEvent((FortunePointEvent)currentEvent);                          break;                        case FortuneEvent.EventKind.Circle:                          handleCircleEvent((FortuneCircleEvent)currentEvent);                          break;                  }
Missing Default,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The following switch statement is missing a default case: switch (capLocation)              {                   case CapLocation.Start:                      angle += Math.PI / 2;                      startPoint.X = x1;                      startPoint.Y = y1;                      break;                  case CapLocation.End:                      angle -= Math.PI / 2;                      startPoint.X = x2;                      startPoint.Y = y2;                      break;              }
Missing Default,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addCap,The following switch statement is missing a default case: switch (cap)              {                   case LineCap.Flat:                      ICoordinate[] points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' 2);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Round:                      int pointsPerCircle = (int)(Math.Round(Width * Math.PI) / 2);                      points = getCirclePoints(startPoint' angle' angle + Math.PI' _width / 2' pointsPerCircle);                      foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineCap.Square:                      double r = _width * _sqrt2 / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle + _squareCapAngle)'                                                startPoint.Y + r * Math.Sin(angle + _squareCapAngle)));                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + r * Math.Cos(angle - _squareCapAngle + Math.PI)'                                                startPoint.Y + r * Math.Sin(angle - _squareCapAngle + Math.PI)));                      break;                  case LineCap.Triangle:                      double halfWidth = _width / 2;                      vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle)'                            startPoint.Y + halfWidth * Math.Sin(angle)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + _halfPI)'                            startPoint.Y + halfWidth * Math.Sin(angle + _halfPI)));                        vertexList.Add(PlanimetryEnvironment.NewCoordinate(startPoint.X + halfWidth * Math.Cos(angle + Math.PI)'                            startPoint.Y + halfWidth * Math.Sin(angle + Math.PI)));                      break;              }
Missing Default,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,translateAngleQuadrant,The following switch statement is missing a default case: switch (quadrantNumber)              {                  case 1: { return angle; }                  case 2: { return Math.PI - angle; }                  case 3: { return Math.PI + angle; }                  case 4: { return _twoPi - angle; }              }
Missing Default,MapAround.Rendering,Polygonizer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Polygonizing.cs,addJoin,The following switch statement is missing a default case: switch (join)              {                   case LineJoin.Bevel:                      vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                      vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                      break;                  case LineJoin.Round:                      ICoordinate[] points =                          getCirclePoints(PlanimetryEnvironment.NewCoordinate(x2' y2)'                          angle1'                          angle1 - Math.PI + angleBetweenSegments'                           halfWidth'                          (int)(Math.Round(_width * Math.PI) / 2));                        foreach (ICoordinate p in points)                          vertexList.Add(p);                      break;                  case LineJoin.Miter:                  case LineJoin.MiterClipped:                        Segment s1 = new Segment(pointOnCircle(x1' y1' halfWidth' angle1)' pointOnCircle(x2' y2' halfWidth' angle1));                      Segment s2 = new Segment(pointOnCircle(x3' y3' halfWidth' angle2)' pointOnCircle(x2' y2' halfWidth' angle2));                        ICoordinate miterPoint = null;                        if (PlanimetryAlgorithms.DirectsIntersection(s1' s2' ref miterPoint) == Dimension.Zero)                      {                          double miterDistance2 = PlanimetryAlgorithms.Distance(miterPoint' PlanimetryEnvironment.NewCoordinate(x2' y2));                          if (miterDistance2 < _miterLimit * _width / 2)                              vertexList.Add(miterPoint);                          else                          {                              if (join == LineJoin.MiterClipped)                              {                                  vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                                  vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                              }                              else                              {                                  double l = _miterLimit * _width * 0.5;                                  double miterDistance1 = PlanimetryAlgorithms.Distance(s1.V2' miterPoint);                                  double clipDistance = ((miterDistance2 - l) * (miterDistance2 - l) + l) / miterDistance1;                                    double f = clipDistance / (miterDistance1 - clipDistance);                                  vertexList.Add(PlanimetryEnvironment.NewCoordinate((f * s1.V2.X + miterPoint.X) / (1 + f)'                                                            (f * s1.V2.Y + miterPoint.Y) / (1 + f)));                                  vertexList.Add(PlanimetryEnvironment.NewCoordinate((f * s2.V2.X + miterPoint.X) / (1 + f)'                                                            (f * s2.V2.Y + miterPoint.Y) / (1 + f)));                              }                          }                      }                      else                      {                          if (join == LineJoin.MiterClipped)                          {                              vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle1));                              vertexList.Add(pointOnCircle(x2' y2' halfWidth' angle2));                          }                          else                          {                              double d = Math.Sqrt(_width * _width / 4 + _miterLimit * _miterLimit);                              double alpha = Math.Atan(1 / _miterLimit);                              vertexList.Add(pointOnCircle(x2' y2' d' angle1 - alpha));                              vertexList.Add(pointOnCircle(x2' y2' d' angle1 + alpha));                          }                      }                      break;              }
Missing Default,MapAround.Rendering,RenderingPipeline,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Flush,The following switch statement is missing a default case: switch (_parallelizationLevel)              {                   case ParallelizationLevel.Single:                      break;                  case ParallelizationLevel.Duo:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;                  case ParallelizationLevel.Quad:                      _thread1 = new Thread(beginRenderObjectPool);                      _thread1.Start(new ThreadStartData() { MinX = 0' MinY = 0' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height / 2 });                        _thread2 = new Thread(beginRenderObjectPool);                      _thread2.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = 0' MaxX = _rasterData.Width' MaxY = _rasterData.Height / 2});                        _thread3 = new Thread(beginRenderObjectPool);                      _thread3.Start(new ThreadStartData() { MinX = 0' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width / 2' MaxY = _rasterData.Height});                        _thread4 = new Thread(beginRenderObjectPool);                      _thread4.Start(new ThreadStartData() { MinX = _rasterData.Width / 2' MinY = _rasterData.Height / 2' MaxX = _rasterData.Width' MaxY = _rasterData.Height });                      break;              }
Missing Default,MapAround.Rendering,RenderingPipeline,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Pipeline.cs,Render,The following switch statement is missing a default case: switch(_parallelizationLevel)              {                  case ParallelizationLevel.Single:                      renderSingleThread(obj' fill);                      break;                  case ParallelizationLevel.Duo:                  case ParallelizationLevel.Quad:                      renderMultipleThreads(obj' fill);                      break;              }
Missing Default,MapAround.Rendering,SpanGenerator,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\Scaning.cs,addSpans,The following switch statement is missing a default case: switch(orientation)                          {                              case Orientation.Horizontal:                                  for (int k = spanStartIndex; k < i; k++)                                  {                                      double coverage = pixelCoverage[k];                                      if (coverage > _subPixelLevel)                                          coverage = _subPixelLevel;                                        double antiAliasingAlpha = _alphaTable[(int)(coverage / _subPixelLevel * 254f)];                                        Int32 color = fill.GetPixelColor((int)min + f + spanStartIndex' scanPosition);                                      byte fillAlpha = (byte)(color >> 24 & 0xFF);                                      if (fillAlpha == 0)                                          pixelValues[f] = (byte)(antiAliasingAlpha * 255f) << 24 | color;                                      else                                          pixelValues[f] = (byte)(antiAliasingAlpha * fillAlpha) << 24 | (color & 0x00FFFFFF);                                        f++;                                  }                                  spans.Add(new PixelSpan(Orientation.Horizontal' (int)min + spanStartIndex' scanPosition' pixelValues));                                  break;                                case Orientation.Vertical:                                  for (int k = spanStartIndex; k < i; k++)                                  {                                      double coverage = pixelCoverage[k];                                      if (coverage > _subPixelLevel)                                          coverage = _subPixelLevel;                                        double antiAliasingAlpha = _alphaTable[(int)(coverage / _subPixelLevel * 254f)];                                        Int32 color = fill.GetPixelColor(scanPosition' (int)min + f + spanStartIndex);                                      byte fillAlpha = (byte)(color >> 24 & 0xFF);                                      if (fillAlpha == 0)                                          pixelValues[f] = (byte)(antiAliasingAlpha * 255f) << 24 | color;                                      else                                          pixelValues[f] = (byte)(antiAliasingAlpha * fillAlpha) << 24 | (color & 0x00FFFFFF);                                        f++;                                  }                                  spans.Add(new PixelSpan(Orientation.Vertical' scanPosition' (int)min + spanStartIndex' pixelValues));                                  break;                          }
Missing Default,MapAround.Rendering,Region,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,InitScaning,The following switch statement is missing a default case: switch (orientation)              {                   case Orientation.Horizontal:                      fillEdgeTableForHorizontalScanning();                      break;                  case Orientation.Vertical:                      fillEdgeTableForVerticalScanning();                      break;              }
Missing Default,MapAround.Rendering,Region,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,ComputeHorizontalIntersections,The following switch statement is missing a default case: switch (_fillingMode)              {                  case InteriorFillMode.Alternate:                      computeHorizontalAlternateIntersections(scanY' out intersections);                      return;                  case InteriorFillMode.Winding:                      computeHorizontalWindingIntersections(scanY' out intersections);                      return;              }
Missing Default,MapAround.Rendering,Region,C:\repos\gkrsu_maparound.core\src\MapAround.Core\RenderingExperiments\ScannableObjects.cs,ComputeVerticalIntersections,The following switch statement is missing a default case: switch (_fillingMode)              {                  case InteriorFillMode.Alternate:                      computeVerticalAlternateIntersections(scanX' out intersections);                      return;                  case InteriorFillMode.Winding:                      computeVerticalWindingIntersections(scanX' out intersections);                      return;              }
Missing Default,MapAround.Serialization,BinaryGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,DeserializeGeometry,The following switch statement is missing a default case: switch (featureType)              {                  case 1: //Point                      return BinaryGeometrySerializer.DeserializePoint(stream);                  case 2: //Polyline                      return BinaryGeometrySerializer.DeserializePolyline(stream);                  case 3: //Polygon                      return BinaryGeometrySerializer.DeserializePolygon(stream);                  case 4: //MultiPoint                      return BinaryGeometrySerializer.DeserializeMultiPoint(stream);              }
Missing Default,MapAround.Serialization,WKTGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,GeometryFromWKT,The following switch statement is missing a default case: switch (tokenizer.GetStringValue().ToUpper())              {                  case "POINT": return readPoint(tokenizer);                  case "LINESTRING": return readLineString(tokenizer);                  case "MULTILINESTRING": return readMultiLineString(tokenizer);                  case "POLYGON": return readPolygon(tokenizer);                  case "MULTIPOLYGON": return readMultiPolygon(tokenizer);                  case "MULTIPOINT": return readMultiPoint(tokenizer);              }
Missing Default,MapAround.Serialization,WKBGeometrySerializer,C:\repos\gkrsu_maparound.core\src\MapAround.Core\Serialization\GeometrySerializers.cs,DeserializeGeometry,The following switch statement is missing a default case: switch ((WKBGeometryType)type)              {                  case WKBGeometryType.Point:                      return readPoint(stream' (WKBByteOrder)byteOrder);                    case WKBGeometryType.LineString:                      return readLineString(stream' (WKBByteOrder)byteOrder);                    case WKBGeometryType.MultiLineString:                      return readMultiLineString(stream' (WKBByteOrder)byteOrder);                    case WKBGeometryType.Polygon:                      return readPolygon(stream' (WKBByteOrder)byteOrder);                    case WKBGeometryType.MultiPolygon:                      return readMultiPolygon(stream' (WKBByteOrder)byteOrder);                    case WKBGeometryType.MultiPoint:                      return readMultiPoint(stream' (WKBByteOrder)byteOrder);              }
