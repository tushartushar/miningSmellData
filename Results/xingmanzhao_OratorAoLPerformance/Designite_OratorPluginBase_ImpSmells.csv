Implementation smell,Namespace,Class,File,Method,Description
Long Method,OratorPluginBase,OratorSeries,C:\repos\xingmanzhao_OratorAoLPerformance\OratorPluginBase\OratorSeries.cs,Trim,The method has 199 lines of code.
Complex Method,OratorPluginBase,OratorSeries,C:\repos\xingmanzhao_OratorAoLPerformance\OratorPluginBase\OratorSeries.cs,Trim,Cyclomatic complexity of the method is 16
Magic Number,OratorPluginBase,OratorSeries,C:\repos\xingmanzhao_OratorAoLPerformance\OratorPluginBase\OratorSeries.cs,OratorSeries,The following statement contains a magic number: PointsMaximum = 50000;  
Magic Number,OratorPluginBase,OratorSeries,C:\repos\xingmanzhao_OratorAoLPerformance\OratorPluginBase\OratorSeries.cs,Add,The following statement contains a magic number: if (point != null) {  	if (point.X > 0 && Points.Count > 0 && EliminateConsecutiveDuplicatePoints == true) {  		OratorDataPoint last = Points [Points.Count - 1];  		if (point.X >= last.X) {  			if (Points.Count > 1) {  				OratorDataPoint previous = Points [Points.Count - 2];  				if ((last.Y1 == previous.Y1 && last.Y1 == point.Y1) || last.X == point.X) {  					Points.RemoveAt (Points.Count - 1);  				}  			}  			Points.Add (point);  		}  	}  	else {  		Points.Add (point);  	}  	if (Points.Count > PointsMaximum * 4) {  		Trim ();  	}  }  
Magic Number,OratorPluginBase,OratorSeries,C:\repos\xingmanzhao_OratorAoLPerformance\OratorPluginBase\OratorSeries.cs,Add,The following statement contains a magic number: if (point != null) {  	if (point.X > 0 && Points.Count > 0 && EliminateConsecutiveDuplicatePoints == true) {  		OratorDataPoint last = Points [Points.Count - 1];  		if (point.X >= last.X) {  			if (Points.Count > 1) {  				OratorDataPoint previous = Points [Points.Count - 2];  				if ((last.Y1 == previous.Y1 && last.Y1 == point.Y1) || last.X == point.X) {  					Points.RemoveAt (Points.Count - 1);  				}  			}  			Points.Add (point);  		}  	}  	else {  		Points.Add (point);  	}  	if (Points.Count > PointsMaximum * 4) {  		Trim ();  	}  }  
Magic Number,OratorPluginBase,OratorSeries,C:\repos\xingmanzhao_OratorAoLPerformance\OratorPluginBase\OratorSeries.cs,Add,The following statement contains a magic number: if (point.X > 0 && Points.Count > 0 && EliminateConsecutiveDuplicatePoints == true) {  	OratorDataPoint last = Points [Points.Count - 1];  	if (point.X >= last.X) {  		if (Points.Count > 1) {  			OratorDataPoint previous = Points [Points.Count - 2];  			if ((last.Y1 == previous.Y1 && last.Y1 == point.Y1) || last.X == point.X) {  				Points.RemoveAt (Points.Count - 1);  			}  		}  		Points.Add (point);  	}  }  else {  	Points.Add (point);  }  
Magic Number,OratorPluginBase,OratorSeries,C:\repos\xingmanzhao_OratorAoLPerformance\OratorPluginBase\OratorSeries.cs,Add,The following statement contains a magic number: if (point.X >= last.X) {  	if (Points.Count > 1) {  		OratorDataPoint previous = Points [Points.Count - 2];  		if ((last.Y1 == previous.Y1 && last.Y1 == point.Y1) || last.X == point.X) {  			Points.RemoveAt (Points.Count - 1);  		}  	}  	Points.Add (point);  }  
Magic Number,OratorPluginBase,OratorSeries,C:\repos\xingmanzhao_OratorAoLPerformance\OratorPluginBase\OratorSeries.cs,Add,The following statement contains a magic number: if (Points.Count > 1) {  	OratorDataPoint previous = Points [Points.Count - 2];  	if ((last.Y1 == previous.Y1 && last.Y1 == point.Y1) || last.X == point.X) {  		Points.RemoveAt (Points.Count - 1);  	}  }  
Magic Number,OratorPluginBase,OratorSeries,C:\repos\xingmanzhao_OratorAoLPerformance\OratorPluginBase\OratorSeries.cs,Add,The following statement contains a magic number: if (Points.Count > PointsMaximum * 4) {  	Trim ();  }  
Magic Number,OratorPluginBase,OratorSeries,C:\repos\xingmanzhao_OratorAoLPerformance\OratorPluginBase\OratorSeries.cs,Trim,The following statement contains a magic number: if (Points.Count > PointsMaximum) {  	List<OratorDataPoint> resultList = new List<OratorDataPoint> ();  	double minTime = 0.0;  	if (BeginningTime != DateTime.MinValue) {  		minTime = BeginningTime.ToOADate ();  	}  	else {  		minTime = Points [0].X;  	}  	double maxTime = 0.0;  	if (EndTime != DateTime.MinValue) {  		maxTime = EndTime.ToOADate ();  	}  	else {  		maxTime = Points [Points.Count - 1].X;  	}  	double timeInterval = (maxTime - minTime) / PointsMaximum;  	double peakValue = 0;  	double peakValueTime = 0;  	double troughValue = Points [0].Y1;  	double troughValueTime = Points [0].X;  	double timePeriod = minTime + timeInterval;  	double runningTotal = 0.0;  	int pointCount = 0;  	DateTime startTime = DateTime.FromOADate (minTime);  	DateTime endTime = DateTime.FromOADate (maxTime);  	//switch (DataPointCombiningMode)  	//{  	//    case CombiningModeOptions.TroughAndPeak:  	//        foreach (OratorDataPoint dataPoint in Points)  	//        {  	//            if (dataPoint.Y1 >= peakValue)  	//            {  	//                peakValue = dataPoint.Y1;  	//                peakValueTime = dataPoint.X;  	//            }  	//            else if (dataPoint.Y1 <= troughValue)  	//            {  	//                troughValue = dataPoint.Y1;  	//                troughValueTime = dataPoint.X;  	//            }  	//            if (dataPoint.X >= timePeriod)  	//            {  	//                if (troughValueTime < peakValueTime)  	//                {  	//                    resultList.Add(new OratorDataPoint(troughValueTime' troughValue));  	//                    resultList.Add(new OratorDataPoint(peakValueTime' peakValue));  	//                }  	//                else  	//                {  	//                    resultList.Add(new OratorDataPoint(peakValueTime' peakValue));  	//                    resultList.Add(new OratorDataPoint(troughValueTime' troughValue));  	//                }  	//                peakValue = 0;  	//                troughValue = dataPoint.Y1;  	//                troughValueTime = dataPoint.X;  	//                timePeriod += timeInterval;  	//            }  	//        }  	//        //Last point  	//        if (troughValueTime < peakValueTime)  	//        {  	//            resultList.Add(new OratorDataPoint(troughValueTime' troughValue));  	//            resultList.Add(new OratorDataPoint(peakValueTime' peakValue));  	//        }  	//        else  	//        {  	//            resultList.Add(new OratorDataPoint(peakValueTime' peakValue));  	//            resultList.Add(new OratorDataPoint(troughValueTime' troughValue));  	//        }  	//        break;  	//    case CombiningModeOptions.Average:  	//        foreach (OratorDataPoint dataPoint in Points)  	//        {  	//            pointCount++;  	//            runningTotal += dataPoint.Y1;  	//            if (dataPoint.X >= timePeriod)  	//            {  	//                double timeStamp = timePeriod - (timeInterval / 2);  	//                resultList.Add(new OratorDataPoint(timeStamp' runningTotal / (double)pointCount));  	//                pointCount = 0;  	//                runningTotal = 0.0;  	//                timePeriod += timeInterval;  	//            }  	//        }  	//        break;  	//}  	//foreach (OratorDataPoint dataPoint in Points)  	//{  	//    switch (DataPointCombiningMode)  	//    {  	//        case CombiningModeOptions.TroughAndPeak:  	//            if (dataPoint.Y1 >= peakValue)  	//            {  	//                peakValue = dataPoint.Y1;  	//                peakValueTime = dataPoint.X;  	//            }  	//            else if (dataPoint.Y1 <= troughValue)  	//            {  	//                troughValue = dataPoint.Y1;  	//                troughValueTime = dataPoint.X;  	//            }  	//            if (dataPoint.X >= timePeriod)  	//            {  	//                if (troughValueTime < peakValueTime)  	//                {  	//                    resultList.Add(new OratorDataPoint(troughValueTime' troughValue));  	//                    resultList.Add(new OratorDataPoint(peakValueTime' peakValue));  	//                }  	//                else  	//                {  	//                    resultList.Add(new OratorDataPoint(peakValueTime' peakValue));  	//                    resultList.Add(new OratorDataPoint(troughValueTime' troughValue));  	//                }  	//                peakValue = 0;  	//                troughValue = dataPoint.Y1;  	//                troughValueTime = dataPoint.X;  	//                timePeriod += timeInterval;  	//            }  	//            break;  	//        case CombiningModeOptions.Average:  	//            pointCount++;  	//            runningTotal += dataPoint.Y1;  	//            if (dataPoint.X >= timePeriod)  	//            {  	//                double timeStamp = timePeriod - (timeInterval / 2);  	//                resultList.Add(new OratorDataPoint(timeStamp' runningTotal / (double)pointCount));  	//                pointCount = 0;  	//                runningTotal = 0.0;  	//                timePeriod += timeInterval;  	//            }  	//            break;  	//    }  	//}  	#region fix the Bug70964 by Zhao xingman  	switch (DataPointCombiningMode) {  	case CombiningModeOptions.TroughAndPeak:  		foreach (OratorDataPoint dataPoint in Points) {  			if (dataPoint.Y1 >= peakValue) {  				peakValue = dataPoint.Y1;  				peakValueTime = dataPoint.X;  			}  			else if (dataPoint.Y1 <= troughValue) {  				troughValue = dataPoint.Y1;  				troughValueTime = dataPoint.X;  			}  			if (dataPoint.X >= timePeriod) {  				if (troughValueTime < peakValueTime) {  					resultList.Add (new OratorDataPoint (troughValueTime' troughValue));  					resultList.Add (new OratorDataPoint (peakValueTime' peakValue));  				}  				else {  					resultList.Add (new OratorDataPoint (peakValueTime' peakValue));  					resultList.Add (new OratorDataPoint (troughValueTime' troughValue));  				}  				peakValue = 0;  				troughValue = dataPoint.Y1;  				troughValueTime = dataPoint.X;  				timePeriod += timeInterval;  			}  		}  		break;  	case CombiningModeOptions.Average:  		int pointIndex = 0;  		int pointNumber = 1;  		while (pointNumber <= PointsMaximum) {  			timePeriod = minTime + timeInterval * pointNumber;  			pointCount = 0;  			runningTotal = 0.0;  			for (int i = pointIndex; i < Points.Count; i++) {  				OratorDataPoint dataPoint = Points [i];  				if (dataPoint.X <= timePeriod) {  					pointCount++;  					runningTotal += dataPoint.Y1;  				}  				else {  					double timeStamp = timePeriod - (timeInterval / 2);  					double y1 = 0;  					if (pointCount > 0) {  						y1 = runningTotal / (double)pointCount;  					}  					resultList.Add (new OratorDataPoint (timeStamp' y1));  					pointIndex = i;  					break;  				}  			}  			if (pointIndex >= Points.Count) {  				double timeStamp = timePeriod - (timeInterval / 2);  				resultList.Add (new OratorDataPoint (timeStamp' 0d));  			}  			pointNumber++;  		}  		break;  	}  	#endregion  	Points = resultList;  }  
Magic Number,OratorPluginBase,OratorSeries,C:\repos\xingmanzhao_OratorAoLPerformance\OratorPluginBase\OratorSeries.cs,Trim,The following statement contains a magic number: if (Points.Count > PointsMaximum) {  	List<OratorDataPoint> resultList = new List<OratorDataPoint> ();  	double minTime = 0.0;  	if (BeginningTime != DateTime.MinValue) {  		minTime = BeginningTime.ToOADate ();  	}  	else {  		minTime = Points [0].X;  	}  	double maxTime = 0.0;  	if (EndTime != DateTime.MinValue) {  		maxTime = EndTime.ToOADate ();  	}  	else {  		maxTime = Points [Points.Count - 1].X;  	}  	double timeInterval = (maxTime - minTime) / PointsMaximum;  	double peakValue = 0;  	double peakValueTime = 0;  	double troughValue = Points [0].Y1;  	double troughValueTime = Points [0].X;  	double timePeriod = minTime + timeInterval;  	double runningTotal = 0.0;  	int pointCount = 0;  	DateTime startTime = DateTime.FromOADate (minTime);  	DateTime endTime = DateTime.FromOADate (maxTime);  	//switch (DataPointCombiningMode)  	//{  	//    case CombiningModeOptions.TroughAndPeak:  	//        foreach (OratorDataPoint dataPoint in Points)  	//        {  	//            if (dataPoint.Y1 >= peakValue)  	//            {  	//                peakValue = dataPoint.Y1;  	//                peakValueTime = dataPoint.X;  	//            }  	//            else if (dataPoint.Y1 <= troughValue)  	//            {  	//                troughValue = dataPoint.Y1;  	//                troughValueTime = dataPoint.X;  	//            }  	//            if (dataPoint.X >= timePeriod)  	//            {  	//                if (troughValueTime < peakValueTime)  	//                {  	//                    resultList.Add(new OratorDataPoint(troughValueTime' troughValue));  	//                    resultList.Add(new OratorDataPoint(peakValueTime' peakValue));  	//                }  	//                else  	//                {  	//                    resultList.Add(new OratorDataPoint(peakValueTime' peakValue));  	//                    resultList.Add(new OratorDataPoint(troughValueTime' troughValue));  	//                }  	//                peakValue = 0;  	//                troughValue = dataPoint.Y1;  	//                troughValueTime = dataPoint.X;  	//                timePeriod += timeInterval;  	//            }  	//        }  	//        //Last point  	//        if (troughValueTime < peakValueTime)  	//        {  	//            resultList.Add(new OratorDataPoint(troughValueTime' troughValue));  	//            resultList.Add(new OratorDataPoint(peakValueTime' peakValue));  	//        }  	//        else  	//        {  	//            resultList.Add(new OratorDataPoint(peakValueTime' peakValue));  	//            resultList.Add(new OratorDataPoint(troughValueTime' troughValue));  	//        }  	//        break;  	//    case CombiningModeOptions.Average:  	//        foreach (OratorDataPoint dataPoint in Points)  	//        {  	//            pointCount++;  	//            runningTotal += dataPoint.Y1;  	//            if (dataPoint.X >= timePeriod)  	//            {  	//                double timeStamp = timePeriod - (timeInterval / 2);  	//                resultList.Add(new OratorDataPoint(timeStamp' runningTotal / (double)pointCount));  	//                pointCount = 0;  	//                runningTotal = 0.0;  	//                timePeriod += timeInterval;  	//            }  	//        }  	//        break;  	//}  	//foreach (OratorDataPoint dataPoint in Points)  	//{  	//    switch (DataPointCombiningMode)  	//    {  	//        case CombiningModeOptions.TroughAndPeak:  	//            if (dataPoint.Y1 >= peakValue)  	//            {  	//                peakValue = dataPoint.Y1;  	//                peakValueTime = dataPoint.X;  	//            }  	//            else if (dataPoint.Y1 <= troughValue)  	//            {  	//                troughValue = dataPoint.Y1;  	//                troughValueTime = dataPoint.X;  	//            }  	//            if (dataPoint.X >= timePeriod)  	//            {  	//                if (troughValueTime < peakValueTime)  	//                {  	//                    resultList.Add(new OratorDataPoint(troughValueTime' troughValue));  	//                    resultList.Add(new OratorDataPoint(peakValueTime' peakValue));  	//                }  	//                else  	//                {  	//                    resultList.Add(new OratorDataPoint(peakValueTime' peakValue));  	//                    resultList.Add(new OratorDataPoint(troughValueTime' troughValue));  	//                }  	//                peakValue = 0;  	//                troughValue = dataPoint.Y1;  	//                troughValueTime = dataPoint.X;  	//                timePeriod += timeInterval;  	//            }  	//            break;  	//        case CombiningModeOptions.Average:  	//            pointCount++;  	//            runningTotal += dataPoint.Y1;  	//            if (dataPoint.X >= timePeriod)  	//            {  	//                double timeStamp = timePeriod - (timeInterval / 2);  	//                resultList.Add(new OratorDataPoint(timeStamp' runningTotal / (double)pointCount));  	//                pointCount = 0;  	//                runningTotal = 0.0;  	//                timePeriod += timeInterval;  	//            }  	//            break;  	//    }  	//}  	#region fix the Bug70964 by Zhao xingman  	switch (DataPointCombiningMode) {  	case CombiningModeOptions.TroughAndPeak:  		foreach (OratorDataPoint dataPoint in Points) {  			if (dataPoint.Y1 >= peakValue) {  				peakValue = dataPoint.Y1;  				peakValueTime = dataPoint.X;  			}  			else if (dataPoint.Y1 <= troughValue) {  				troughValue = dataPoint.Y1;  				troughValueTime = dataPoint.X;  			}  			if (dataPoint.X >= timePeriod) {  				if (troughValueTime < peakValueTime) {  					resultList.Add (new OratorDataPoint (troughValueTime' troughValue));  					resultList.Add (new OratorDataPoint (peakValueTime' peakValue));  				}  				else {  					resultList.Add (new OratorDataPoint (peakValueTime' peakValue));  					resultList.Add (new OratorDataPoint (troughValueTime' troughValue));  				}  				peakValue = 0;  				troughValue = dataPoint.Y1;  				troughValueTime = dataPoint.X;  				timePeriod += timeInterval;  			}  		}  		break;  	case CombiningModeOptions.Average:  		int pointIndex = 0;  		int pointNumber = 1;  		while (pointNumber <= PointsMaximum) {  			timePeriod = minTime + timeInterval * pointNumber;  			pointCount = 0;  			runningTotal = 0.0;  			for (int i = pointIndex; i < Points.Count; i++) {  				OratorDataPoint dataPoint = Points [i];  				if (dataPoint.X <= timePeriod) {  					pointCount++;  					runningTotal += dataPoint.Y1;  				}  				else {  					double timeStamp = timePeriod - (timeInterval / 2);  					double y1 = 0;  					if (pointCount > 0) {  						y1 = runningTotal / (double)pointCount;  					}  					resultList.Add (new OratorDataPoint (timeStamp' y1));  					pointIndex = i;  					break;  				}  			}  			if (pointIndex >= Points.Count) {  				double timeStamp = timePeriod - (timeInterval / 2);  				resultList.Add (new OratorDataPoint (timeStamp' 0d));  			}  			pointNumber++;  		}  		break;  	}  	#endregion  	Points = resultList;  }  
Magic Number,OratorPluginBase,OratorSeries,C:\repos\xingmanzhao_OratorAoLPerformance\OratorPluginBase\OratorSeries.cs,Trim,The following statement contains a magic number: switch (DataPointCombiningMode) {  case CombiningModeOptions.TroughAndPeak:  	foreach (OratorDataPoint dataPoint in Points) {  		if (dataPoint.Y1 >= peakValue) {  			peakValue = dataPoint.Y1;  			peakValueTime = dataPoint.X;  		}  		else if (dataPoint.Y1 <= troughValue) {  			troughValue = dataPoint.Y1;  			troughValueTime = dataPoint.X;  		}  		if (dataPoint.X >= timePeriod) {  			if (troughValueTime < peakValueTime) {  				resultList.Add (new OratorDataPoint (troughValueTime' troughValue));  				resultList.Add (new OratorDataPoint (peakValueTime' peakValue));  			}  			else {  				resultList.Add (new OratorDataPoint (peakValueTime' peakValue));  				resultList.Add (new OratorDataPoint (troughValueTime' troughValue));  			}  			peakValue = 0;  			troughValue = dataPoint.Y1;  			troughValueTime = dataPoint.X;  			timePeriod += timeInterval;  		}  	}  	break;  case CombiningModeOptions.Average:  	int pointIndex = 0;  	int pointNumber = 1;  	while (pointNumber <= PointsMaximum) {  		timePeriod = minTime + timeInterval * pointNumber;  		pointCount = 0;  		runningTotal = 0.0;  		for (int i = pointIndex; i < Points.Count; i++) {  			OratorDataPoint dataPoint = Points [i];  			if (dataPoint.X <= timePeriod) {  				pointCount++;  				runningTotal += dataPoint.Y1;  			}  			else {  				double timeStamp = timePeriod - (timeInterval / 2);  				double y1 = 0;  				if (pointCount > 0) {  					y1 = runningTotal / (double)pointCount;  				}  				resultList.Add (new OratorDataPoint (timeStamp' y1));  				pointIndex = i;  				break;  			}  		}  		if (pointIndex >= Points.Count) {  			double timeStamp = timePeriod - (timeInterval / 2);  			resultList.Add (new OratorDataPoint (timeStamp' 0d));  		}  		pointNumber++;  	}  	break;  }  
Magic Number,OratorPluginBase,OratorSeries,C:\repos\xingmanzhao_OratorAoLPerformance\OratorPluginBase\OratorSeries.cs,Trim,The following statement contains a magic number: switch (DataPointCombiningMode) {  case CombiningModeOptions.TroughAndPeak:  	foreach (OratorDataPoint dataPoint in Points) {  		if (dataPoint.Y1 >= peakValue) {  			peakValue = dataPoint.Y1;  			peakValueTime = dataPoint.X;  		}  		else if (dataPoint.Y1 <= troughValue) {  			troughValue = dataPoint.Y1;  			troughValueTime = dataPoint.X;  		}  		if (dataPoint.X >= timePeriod) {  			if (troughValueTime < peakValueTime) {  				resultList.Add (new OratorDataPoint (troughValueTime' troughValue));  				resultList.Add (new OratorDataPoint (peakValueTime' peakValue));  			}  			else {  				resultList.Add (new OratorDataPoint (peakValueTime' peakValue));  				resultList.Add (new OratorDataPoint (troughValueTime' troughValue));  			}  			peakValue = 0;  			troughValue = dataPoint.Y1;  			troughValueTime = dataPoint.X;  			timePeriod += timeInterval;  		}  	}  	break;  case CombiningModeOptions.Average:  	int pointIndex = 0;  	int pointNumber = 1;  	while (pointNumber <= PointsMaximum) {  		timePeriod = minTime + timeInterval * pointNumber;  		pointCount = 0;  		runningTotal = 0.0;  		for (int i = pointIndex; i < Points.Count; i++) {  			OratorDataPoint dataPoint = Points [i];  			if (dataPoint.X <= timePeriod) {  				pointCount++;  				runningTotal += dataPoint.Y1;  			}  			else {  				double timeStamp = timePeriod - (timeInterval / 2);  				double y1 = 0;  				if (pointCount > 0) {  					y1 = runningTotal / (double)pointCount;  				}  				resultList.Add (new OratorDataPoint (timeStamp' y1));  				pointIndex = i;  				break;  			}  		}  		if (pointIndex >= Points.Count) {  			double timeStamp = timePeriod - (timeInterval / 2);  			resultList.Add (new OratorDataPoint (timeStamp' 0d));  		}  		pointNumber++;  	}  	break;  }  
Magic Number,OratorPluginBase,OratorSeries,C:\repos\xingmanzhao_OratorAoLPerformance\OratorPluginBase\OratorSeries.cs,Trim,The following statement contains a magic number: while (pointNumber <= PointsMaximum) {  	timePeriod = minTime + timeInterval * pointNumber;  	pointCount = 0;  	runningTotal = 0.0;  	for (int i = pointIndex; i < Points.Count; i++) {  		OratorDataPoint dataPoint = Points [i];  		if (dataPoint.X <= timePeriod) {  			pointCount++;  			runningTotal += dataPoint.Y1;  		}  		else {  			double timeStamp = timePeriod - (timeInterval / 2);  			double y1 = 0;  			if (pointCount > 0) {  				y1 = runningTotal / (double)pointCount;  			}  			resultList.Add (new OratorDataPoint (timeStamp' y1));  			pointIndex = i;  			break;  		}  	}  	if (pointIndex >= Points.Count) {  		double timeStamp = timePeriod - (timeInterval / 2);  		resultList.Add (new OratorDataPoint (timeStamp' 0d));  	}  	pointNumber++;  }  
Magic Number,OratorPluginBase,OratorSeries,C:\repos\xingmanzhao_OratorAoLPerformance\OratorPluginBase\OratorSeries.cs,Trim,The following statement contains a magic number: while (pointNumber <= PointsMaximum) {  	timePeriod = minTime + timeInterval * pointNumber;  	pointCount = 0;  	runningTotal = 0.0;  	for (int i = pointIndex; i < Points.Count; i++) {  		OratorDataPoint dataPoint = Points [i];  		if (dataPoint.X <= timePeriod) {  			pointCount++;  			runningTotal += dataPoint.Y1;  		}  		else {  			double timeStamp = timePeriod - (timeInterval / 2);  			double y1 = 0;  			if (pointCount > 0) {  				y1 = runningTotal / (double)pointCount;  			}  			resultList.Add (new OratorDataPoint (timeStamp' y1));  			pointIndex = i;  			break;  		}  	}  	if (pointIndex >= Points.Count) {  		double timeStamp = timePeriod - (timeInterval / 2);  		resultList.Add (new OratorDataPoint (timeStamp' 0d));  	}  	pointNumber++;  }  
Magic Number,OratorPluginBase,OratorSeries,C:\repos\xingmanzhao_OratorAoLPerformance\OratorPluginBase\OratorSeries.cs,Trim,The following statement contains a magic number: for (int i = pointIndex; i < Points.Count; i++) {  	OratorDataPoint dataPoint = Points [i];  	if (dataPoint.X <= timePeriod) {  		pointCount++;  		runningTotal += dataPoint.Y1;  	}  	else {  		double timeStamp = timePeriod - (timeInterval / 2);  		double y1 = 0;  		if (pointCount > 0) {  			y1 = runningTotal / (double)pointCount;  		}  		resultList.Add (new OratorDataPoint (timeStamp' y1));  		pointIndex = i;  		break;  	}  }  
Magic Number,OratorPluginBase,OratorSeries,C:\repos\xingmanzhao_OratorAoLPerformance\OratorPluginBase\OratorSeries.cs,Trim,The following statement contains a magic number: if (dataPoint.X <= timePeriod) {  	pointCount++;  	runningTotal += dataPoint.Y1;  }  else {  	double timeStamp = timePeriod - (timeInterval / 2);  	double y1 = 0;  	if (pointCount > 0) {  		y1 = runningTotal / (double)pointCount;  	}  	resultList.Add (new OratorDataPoint (timeStamp' y1));  	pointIndex = i;  	break;  }  
Magic Number,OratorPluginBase,OratorSeries,C:\repos\xingmanzhao_OratorAoLPerformance\OratorPluginBase\OratorSeries.cs,Trim,The following statement contains a magic number: if (pointIndex >= Points.Count) {  	double timeStamp = timePeriod - (timeInterval / 2);  	resultList.Add (new OratorDataPoint (timeStamp' 0d));  }  
Duplicate Code,OratorPluginBase,OratorSeries,C:\repos\xingmanzhao_OratorAoLPerformance\OratorPluginBase\OratorSeries.cs,Trim,The method contains a code clone-set at the following line numbers (starting from the method definition): ((33' 59)' (94' 120))
Missing Default,OratorPluginBase,OratorSeries,C:\repos\xingmanzhao_OratorAoLPerformance\OratorPluginBase\OratorSeries.cs,Trim,The following switch statement is missing a default case: switch (DataPointCombiningMode) {  case CombiningModeOptions.TroughAndPeak:  	foreach (OratorDataPoint dataPoint in Points) {  		if (dataPoint.Y1 >= peakValue) {  			peakValue = dataPoint.Y1;  			peakValueTime = dataPoint.X;  		}  		else if (dataPoint.Y1 <= troughValue) {  			troughValue = dataPoint.Y1;  			troughValueTime = dataPoint.X;  		}  		if (dataPoint.X >= timePeriod) {  			if (troughValueTime < peakValueTime) {  				resultList.Add (new OratorDataPoint (troughValueTime' troughValue));  				resultList.Add (new OratorDataPoint (peakValueTime' peakValue));  			}  			else {  				resultList.Add (new OratorDataPoint (peakValueTime' peakValue));  				resultList.Add (new OratorDataPoint (troughValueTime' troughValue));  			}  			peakValue = 0;  			troughValue = dataPoint.Y1;  			troughValueTime = dataPoint.X;  			timePeriod += timeInterval;  		}  	}  	break;  case CombiningModeOptions.Average:  	int pointIndex = 0;  	int pointNumber = 1;  	while (pointNumber <= PointsMaximum) {  		timePeriod = minTime + timeInterval * pointNumber;  		pointCount = 0;  		runningTotal = 0.0;  		for (int i = pointIndex; i < Points.Count; i++) {  			OratorDataPoint dataPoint = Points [i];  			if (dataPoint.X <= timePeriod) {  				pointCount++;  				runningTotal += dataPoint.Y1;  			}  			else {  				double timeStamp = timePeriod - (timeInterval / 2);  				double y1 = 0;  				if (pointCount > 0) {  					y1 = runningTotal / (double)pointCount;  				}  				resultList.Add (new OratorDataPoint (timeStamp' y1));  				pointIndex = i;  				break;  			}  		}  		if (pointIndex >= Points.Count) {  			double timeStamp = timePeriod - (timeInterval / 2);  			resultList.Add (new OratorDataPoint (timeStamp' 0d));  		}  		pointNumber++;  	}  	break;  }  
