Implementation smell,Namespace,Class,File,Method,Description
Long Method,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The method has 121 lines of code.
Complex Method,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,Cyclomatic complexity of the method is 11
Complex Method,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,GetRectOfAllMarkers,Cyclomatic complexity of the method is 10
Complex Method,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,Cyclomatic complexity of the method is 9
Complex Method,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnMouseWheel,Cyclomatic complexity of the method is 8
Complex Method,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnMouseMove,Cyclomatic complexity of the method is 8
Complex Method,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnStylusMove,Cyclomatic complexity of the method is 9
Long Identifier,GMap.NET.WindowsPresentation,GMapMarker,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapMarker.cs,,The length of the parameter Shape_PropertyChangedEventArgs is 30.
Long Identifier,GMap.NET.WindowsPresentation,GMapMarker,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapMarker.cs,,The length of the parameter LocalPositionX_PropertyChangedEventArgs is 39.
Long Identifier,GMap.NET.WindowsPresentation,GMapMarker,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapMarker.cs,,The length of the parameter LocalPositionY_PropertyChangedEventArgs is 39.
Long Identifier,GMap.NET.WindowsPresentation,GMapMarker,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapMarker.cs,,The length of the parameter ZIndex_PropertyChangedEventArgs is 31.
Long Statement,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,MapProviderPropertyChanged,The length of the statement  "               map.Copyright = new FormattedText(map.Core.Provider.Copyright' CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' new Typeface("GenericSansSerif")' 9' Brushes.Navy); " is 171.
Long Statement,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The length of the statement  "                           var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6); " is 124.
Long Statement,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The length of the statement  "                              var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6); " is 215.
Long Statement,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The length of the statement  "                        parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix))); " is 152.
Long Statement,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The length of the statement  "                        var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6)); " is 148.
Long Statement,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The length of the statement  "                        var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6); " is 199.
Long Statement,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The length of the statement  "                           g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height)); " is 137.
Long Statement,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The length of the statement  "                           FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red); " is 180.
Long Statement,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The length of the statement  "                           g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2)); " is 192.
Long Statement,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The length of the statement  "                     g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height)); " is 127.
Long Statement,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The length of the statement  "                        FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red); " is 186.
Long Statement,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The length of the statement  "                        g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2)); " is 182.
Long Statement,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The length of the statement  "                        FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red); " is 185.
Long Statement,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The length of the statement  "                        g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2)); " is 182.
Long Statement,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The length of the statement  "               drawingContext.DrawEllipse(SelectedAreaFill' SelectionPen' new System.Windows.Point(x1 + (x2 - x1) / 2' y1 + (y2 - y1) / 2)' (x2 - x1) / 2' (y2 - y1) / 2); " is 155.
Long Statement,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The length of the statement  "            drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point((ActualWidth / 2) - 5' ActualHeight / 2)' new System.Windows.Point((ActualWidth / 2) + 5' ActualHeight / 2)); " is 174.
Long Statement,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The length of the statement  "            drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) - 5)' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) + 5)); " is 174.
Long Statement,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnMouseMove,The length of the statement  "            if(Math.Abs(p.X - Core.mouseDown.X) * 2 >= SystemParameters.MinimumHorizontalDragDistance || Math.Abs(p.Y - Core.mouseDown.Y) * 2 >= SystemParameters.MinimumVerticalDragDistance) " is 178.
Long Statement,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnMouseMove,The length of the statement  "            if(isSelected && !selectionStart.IsEmpty && (Keyboard.Modifiers == ModifierKeys.Shift || Keyboard.Modifiers == ModifierKeys.Alt || DisableAltForSelection)) " is 155.
Long Statement,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnStylusMove,The length of the statement  "               if(Math.Abs(p.X - Core.mouseDown.X) * 2 >= SystemParameters.MinimumHorizontalDragDistance || Math.Abs(p.Y - Core.mouseDown.Y) * 2 >= SystemParameters.MinimumVerticalDragDistance) " is 178.
Long Statement,GMap.NET.WindowsPresentation,TilePrefetcher,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\TilePrefetcher.xaml.cs,worker_ProgressChanged,The length of the statement  "         this.label1.Text = "Fetching tile at zoom (" + zoom + "): " + ((int)e.UserState).ToString() + " of " + all + "' complete: " + e.ProgressPercentage.ToString() + "%"; " is 164.
Long Statement,GMap.NET.WindowsPresentation,TilePrefetcher,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\TilePrefetcher.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/GMap.NET.WindowsPresentation;component/gmap.net.windowspresentation/tileprefetch" + " is 129.
Complex Conditional,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,GetRectOfAllMarkers,The conditional expression  "left != double.MaxValue && right != double.MinValue && top != double.MinValue && bottom != double.MaxValue"  is complex.
Complex Conditional,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnMouseWheel,The conditional expression  "MouseWheelZoomEnabled && (IsMouseDirectlyOver || IgnoreMarkerOnMouseWheel) && !Core.IsDragging"  is complex.
Complex Conditional,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnMouseMove,The conditional expression  "isSelected && !selectionStart.IsEmpty && (Keyboard.Modifiers == ModifierKeys.Shift || Keyboard.Modifiers == ModifierKeys.Alt || DisableAltForSelection)"  is complex.
Virtual Method Call from Constructor,GMap.NET.WindowsPresentation,GMapPolygon,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapPolygon.cs,GMapPolygon,The constructor "GMapPolygon" calls a virtual method "RegenerateShape".
Virtual Method Call from Constructor,GMap.NET.WindowsPresentation,GMapRoute,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapRoute.cs,GMapRoute,The constructor "GMapRoute" calls a virtual method "RegenerateShape".
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,MapProviderPropertyChanged,The following statement contains a magic number: if(map != null && e.NewValue != null)           {              Debug.WriteLine("MapType: " + e.OldValue + " -> " + e.NewValue);                RectLatLng viewarea = map.SelectedArea;              if(viewarea != RectLatLng.Empty)              {                 map.Position = new PointLatLng(viewarea.Lat - viewarea.HeightLat / 2' viewarea.Lng + viewarea.WidthLng / 2);              }              else              {                 viewarea = map.ViewArea;              }                map.Core.Provider = e.NewValue as GMapProvider;                map.Copyright = null;              if(!string.IsNullOrEmpty(map.Core.Provider.Copyright))              {                 map.Copyright = new FormattedText(map.Core.Provider.Copyright' CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' new Typeface("GenericSansSerif")' 9' Brushes.Navy);              }                if(map.Core.IsStarted && map.Core.zoomToArea)              {                 // restore zoomrect as close as possible                 if(viewarea != RectLatLng.Empty && viewarea != map.ViewArea)                 {                    int bestZoom = map.Core.GetMaxZoomToFitRect(viewarea);                    if(bestZoom > 0 && map.Zoom != bestZoom)                    {                       map.Zoom = bestZoom;                    }                 }              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,MapProviderPropertyChanged,The following statement contains a magic number: if(map != null && e.NewValue != null)           {              Debug.WriteLine("MapType: " + e.OldValue + " -> " + e.NewValue);                RectLatLng viewarea = map.SelectedArea;              if(viewarea != RectLatLng.Empty)              {                 map.Position = new PointLatLng(viewarea.Lat - viewarea.HeightLat / 2' viewarea.Lng + viewarea.WidthLng / 2);              }              else              {                 viewarea = map.ViewArea;              }                map.Core.Provider = e.NewValue as GMapProvider;                map.Copyright = null;              if(!string.IsNullOrEmpty(map.Core.Provider.Copyright))              {                 map.Copyright = new FormattedText(map.Core.Provider.Copyright' CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' new Typeface("GenericSansSerif")' 9' Brushes.Navy);              }                if(map.Core.IsStarted && map.Core.zoomToArea)              {                 // restore zoomrect as close as possible                 if(viewarea != RectLatLng.Empty && viewarea != map.ViewArea)                 {                    int bestZoom = map.Core.GetMaxZoomToFitRect(viewarea);                    if(bestZoom > 0 && map.Zoom != bestZoom)                    {                       map.Zoom = bestZoom;                    }                 }              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,MapProviderPropertyChanged,The following statement contains a magic number: if(map != null && e.NewValue != null)           {              Debug.WriteLine("MapType: " + e.OldValue + " -> " + e.NewValue);                RectLatLng viewarea = map.SelectedArea;              if(viewarea != RectLatLng.Empty)              {                 map.Position = new PointLatLng(viewarea.Lat - viewarea.HeightLat / 2' viewarea.Lng + viewarea.WidthLng / 2);              }              else              {                 viewarea = map.ViewArea;              }                map.Core.Provider = e.NewValue as GMapProvider;                map.Copyright = null;              if(!string.IsNullOrEmpty(map.Core.Provider.Copyright))              {                 map.Copyright = new FormattedText(map.Core.Provider.Copyright' CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' new Typeface("GenericSansSerif")' 9' Brushes.Navy);              }                if(map.Core.IsStarted && map.Core.zoomToArea)              {                 // restore zoomrect as close as possible                 if(viewarea != RectLatLng.Empty && viewarea != map.ViewArea)                 {                    int bestZoom = map.Core.GetMaxZoomToFitRect(viewarea);                    if(bestZoom > 0 && map.Zoom != bestZoom)                    {                       map.Zoom = bestZoom;                    }                 }              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,ZoomPropertyChanged,The following statement contains a magic number: if(map != null && map.MapProvider.Projection != null)           {              double value = (double)e.NewValue;                Debug.WriteLine("Zoom: " + e.OldValue + " -> " + value);                double remainder = value % 1;              if(map.ScaleMode != ScaleModes.Integer && remainder != 0 && map.ActualWidth > 0)              {                 bool scaleDown;                   switch(map.ScaleMode)                 {                    case ScaleModes.ScaleDown:                    scaleDown = true;                    break;                      case ScaleModes.Dynamic:                    scaleDown = remainder > 0.25;                    break;                      default:                    scaleDown = false;                    break;                 }                   if(scaleDown)                    remainder--;                   double scaleValue = Math.Pow(2d' remainder);                 {                    if(map.MapScaleTransform == null)                    {                       map.MapScaleTransform = map.lastScaleTransform;                    }                    map.MapScaleTransform.ScaleX = scaleValue;                    map.MapScaleTransform.ScaleY = scaleValue;                      map.Core.scaleX = 1 / scaleValue;                    map.Core.scaleY = 1 / scaleValue;                      map.MapScaleTransform.CenterX = map.ActualWidth / 2;                    map.MapScaleTransform.CenterY = map.ActualHeight / 2;                 }                   map.Core.Zoom = Convert.ToInt32(scaleDown ? Math.Ceiling(value) : value - remainder);              }              else              {                 map.MapScaleTransform = null;                 map.Core.scaleX = 1;                 map.Core.scaleY = 1;                 map.Core.Zoom = (int)Math.Floor(value);              }                if(map.IsLoaded)              {                 map.ForceUpdateOverlays();                 map.InvalidateVisual(true);              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,ZoomPropertyChanged,The following statement contains a magic number: if(map != null && map.MapProvider.Projection != null)           {              double value = (double)e.NewValue;                Debug.WriteLine("Zoom: " + e.OldValue + " -> " + value);                double remainder = value % 1;              if(map.ScaleMode != ScaleModes.Integer && remainder != 0 && map.ActualWidth > 0)              {                 bool scaleDown;                   switch(map.ScaleMode)                 {                    case ScaleModes.ScaleDown:                    scaleDown = true;                    break;                      case ScaleModes.Dynamic:                    scaleDown = remainder > 0.25;                    break;                      default:                    scaleDown = false;                    break;                 }                   if(scaleDown)                    remainder--;                   double scaleValue = Math.Pow(2d' remainder);                 {                    if(map.MapScaleTransform == null)                    {                       map.MapScaleTransform = map.lastScaleTransform;                    }                    map.MapScaleTransform.ScaleX = scaleValue;                    map.MapScaleTransform.ScaleY = scaleValue;                      map.Core.scaleX = 1 / scaleValue;                    map.Core.scaleY = 1 / scaleValue;                      map.MapScaleTransform.CenterX = map.ActualWidth / 2;                    map.MapScaleTransform.CenterY = map.ActualHeight / 2;                 }                   map.Core.Zoom = Convert.ToInt32(scaleDown ? Math.Ceiling(value) : value - remainder);              }              else              {                 map.MapScaleTransform = null;                 map.Core.scaleX = 1;                 map.Core.scaleY = 1;                 map.Core.Zoom = (int)Math.Floor(value);              }                if(map.IsLoaded)              {                 map.ForceUpdateOverlays();                 map.InvalidateVisual(true);              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,ZoomPropertyChanged,The following statement contains a magic number: if(map != null && map.MapProvider.Projection != null)           {              double value = (double)e.NewValue;                Debug.WriteLine("Zoom: " + e.OldValue + " -> " + value);                double remainder = value % 1;              if(map.ScaleMode != ScaleModes.Integer && remainder != 0 && map.ActualWidth > 0)              {                 bool scaleDown;                   switch(map.ScaleMode)                 {                    case ScaleModes.ScaleDown:                    scaleDown = true;                    break;                      case ScaleModes.Dynamic:                    scaleDown = remainder > 0.25;                    break;                      default:                    scaleDown = false;                    break;                 }                   if(scaleDown)                    remainder--;                   double scaleValue = Math.Pow(2d' remainder);                 {                    if(map.MapScaleTransform == null)                    {                       map.MapScaleTransform = map.lastScaleTransform;                    }                    map.MapScaleTransform.ScaleX = scaleValue;                    map.MapScaleTransform.ScaleY = scaleValue;                      map.Core.scaleX = 1 / scaleValue;                    map.Core.scaleY = 1 / scaleValue;                      map.MapScaleTransform.CenterX = map.ActualWidth / 2;                    map.MapScaleTransform.CenterY = map.ActualHeight / 2;                 }                   map.Core.Zoom = Convert.ToInt32(scaleDown ? Math.Ceiling(value) : value - remainder);              }              else              {                 map.MapScaleTransform = null;                 map.Core.scaleX = 1;                 map.Core.scaleY = 1;                 map.Core.Zoom = (int)Math.Floor(value);              }                if(map.IsLoaded)              {                 map.ForceUpdateOverlays();                 map.InvalidateVisual(true);              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,DrawMap,The following statement contains a magic number: try           {              foreach(var tilePoint in Core.tileDrawingList)              {                 Core.tileRect.Location = tilePoint.PosPixel;                 Core.tileRect.OffsetNegative(Core.compensationOffset);                   //if(region.IntersectsWith(Core.tileRect) || IsRotated)                 {                    bool found = false;                      Tile t = Core.Matrix.GetTileWithNoLock(Core.Zoom' tilePoint.PosXY);                    if(t.NotEmpty)                    {                       foreach(GMapImage img in t.Overlays)                       {                          if(img != null && img.Img != null)                          {                             if(!found)                                found = true;                               var imgRect = new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6);                             if(!img.IsParent)                             {                                g.DrawImage(img.Img' imgRect);                             }                             else                             {                                // TODO: move calculations to loader thread                                var geometry = new RectangleGeometry(imgRect);                                var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * img.Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * img.Yoff + 0.6' Core.tileRect.Width * img.Ix + 0.6' Core.tileRect.Height * img.Ix + 0.6);                                  g.PushClip(geometry);                                g.DrawImage(img.Img' parentImgRect);                                g.Pop();                                geometry = null;                             }                          }                       }                    }                    else if(FillEmptyTiles && MapProvider.Projection is MercatorProjection)                    {                       #region -- fill empty tiles --                       int zoomOffset = 1;                       Tile parentTile = Tile.Empty;                       long Ix = 0;                         while(!parentTile.NotEmpty && zoomOffset < Core.Zoom && zoomOffset <= LevelsKeepInMemmory)                       {                          Ix = (long)Math.Pow(2' zoomOffset);                          parentTile = Core.Matrix.GetTileWithNoLock(Core.Zoom - zoomOffset++' new GMap.NET.GPoint((int)(tilePoint.PosXY.X / Ix)' (int)(tilePoint.PosXY.Y / Ix)));                       }                         if(parentTile.NotEmpty)                       {                          long Xoff = Math.Abs(tilePoint.PosXY.X - (parentTile.Pos.X * Ix));                          long Yoff = Math.Abs(tilePoint.PosXY.Y - (parentTile.Pos.Y * Ix));                            var geometry = new RectangleGeometry(new Rect(Core.tileRect.X + 0.6' Core.tileRect.Y + 0.6' Core.tileRect.Width + 0.6' Core.tileRect.Height + 0.6));                          var parentImgRect = new Rect(Core.tileRect.X - Core.tileRect.Width * Xoff + 0.6' Core.tileRect.Y - Core.tileRect.Height * Yoff + 0.6' Core.tileRect.Width * Ix + 0.6' Core.tileRect.Height * Ix + 0.6);                            // render tile                           {                             foreach(GMapImage img in parentTile.Overlays)                             {                                if(img != null && img.Img != null && !img.IsParent)                                {                                   if(!found)                                      found = true;                                     g.PushClip(geometry);                                   g.DrawImage(img.Img' parentImgRect);                                   g.DrawRectangle(SelectedAreaFill' null' geometry.Bounds);                                   g.Pop();                                }                             }                          }                            geometry = null;                       }                       #endregion                    }                      // add text if tile is missing                    if(!found)                    {                       lock(Core.FailedLoads)                       {                          var lt = new LoadTask(tilePoint.PosXY' Core.Zoom);                            if(Core.FailedLoads.ContainsKey(lt))                          {                             g.DrawRectangle(EmptytileBrush' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                               var ex = Core.FailedLoads[lt];                             FormattedText TileText = new FormattedText("Exception: " + ex.Message' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 14' Brushes.Red);                             TileText.MaxTextWidth = Core.tileRect.Width - 11;                               g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + 11' Core.tileRect.Y + 11));                               g.DrawText(EmptyTileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - EmptyTileText.Height / 2));                          }                       }                    }                      if(ShowTileGridLines)                    {                       g.DrawRectangle(null' EmptyTileBorders' new Rect(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height));                         if(tilePoint.PosXY == Core.centerTileXYLocation)                       {                          FormattedText TileText = new FormattedText("CENTER:" + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                       else                       {                          FormattedText TileText = new FormattedText("TILE: " + tilePoint.ToString()' System.Globalization.CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' tileTypeface' 16' Brushes.Red);                          TileText.MaxTextWidth = Core.tileRect.Width;                          g.DrawText(TileText' new System.Windows.Point(Core.tileRect.X + Core.tileRect.Width / 2 - EmptyTileText.Width / 2' Core.tileRect.Y + Core.tileRect.Height / 2 - TileText.Height / 2));                       }                    }                 }              }           }           finally           {              Core.Matrix.LeaveReadLock();              Core.tileDrawingListLock.ReleaseReaderLock();           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,ToImageSource,The following statement contains a magic number: RenderTargetBitmap bmp = new RenderTargetBitmap(           (int)size.Width' (int)size.Height' 96' 96' PixelFormats.Pbgra32);
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,ToImageSource,The following statement contains a magic number: RenderTargetBitmap bmp = new RenderTargetBitmap(           (int)size.Width' (int)size.Height' 96' 96' PixelFormats.Pbgra32);
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,CreateRoutePath,The following statement contains a magic number: {              // Specify the shape of the Path using the StreamGeometry.              myPath.Data = geometry;                if (addBlurEffect)              {                  BlurEffect ef = new BlurEffect();                  {                      ef.KernelType = KernelType.Gaussian;                      ef.Radius = 3.0;                      ef.RenderingBias = RenderingBias.Performance;                  }                    myPath.Effect = ef;              }                myPath.Stroke = Brushes.Navy;              myPath.StrokeThickness = 5;              myPath.StrokeLineJoin = PenLineJoin.Round;              myPath.StrokeStartLineCap = PenLineCap.Triangle;              myPath.StrokeEndLineCap = PenLineCap.Square;                myPath.Opacity = 0.6;              myPath.IsHitTestVisible = false;           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,CreateRoutePath,The following statement contains a magic number: {              // Specify the shape of the Path using the StreamGeometry.              myPath.Data = geometry;                if (addBlurEffect)              {                  BlurEffect ef = new BlurEffect();                  {                      ef.KernelType = KernelType.Gaussian;                      ef.Radius = 3.0;                      ef.RenderingBias = RenderingBias.Performance;                  }                    myPath.Effect = ef;              }                myPath.Stroke = Brushes.Navy;              myPath.StrokeThickness = 5;              myPath.StrokeLineJoin = PenLineJoin.Round;              myPath.StrokeStartLineCap = PenLineCap.Triangle;              myPath.StrokeEndLineCap = PenLineCap.Square;                myPath.Opacity = 0.6;              myPath.IsHitTestVisible = false;           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,CreateRoutePath,The following statement contains a magic number: {              // Specify the shape of the Path using the StreamGeometry.              myPath.Data = geometry;                if (addBlurEffect)              {                  BlurEffect ef = new BlurEffect();                  {                      ef.KernelType = KernelType.Gaussian;                      ef.Radius = 3.0;                      ef.RenderingBias = RenderingBias.Performance;                  }                    myPath.Effect = ef;              }                myPath.Stroke = Brushes.Navy;              myPath.StrokeThickness = 5;              myPath.StrokeLineJoin = PenLineJoin.Round;              myPath.StrokeStartLineCap = PenLineCap.Triangle;              myPath.StrokeEndLineCap = PenLineCap.Square;                myPath.Opacity = 0.6;              myPath.IsHitTestVisible = false;           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,CreatePolygonPath,The following statement contains a magic number: {              // Specify the shape of the Path using the StreamGeometry.              myPath.Data = geometry;                if (addBlurEffect)              {                  BlurEffect ef = new BlurEffect();                  {                      ef.KernelType = KernelType.Gaussian;                      ef.Radius = 3.0;                      ef.RenderingBias = RenderingBias.Performance;                  }                    myPath.Effect = ef;              }                myPath.Stroke = Brushes.MidnightBlue;              myPath.StrokeThickness = 5;              myPath.StrokeLineJoin = PenLineJoin.Round;              myPath.StrokeStartLineCap = PenLineCap.Triangle;              myPath.StrokeEndLineCap = PenLineCap.Square;                myPath.Fill = Brushes.AliceBlue;                myPath.Opacity = 0.6;              myPath.IsHitTestVisible = false;           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,CreatePolygonPath,The following statement contains a magic number: {              // Specify the shape of the Path using the StreamGeometry.              myPath.Data = geometry;                if (addBlurEffect)              {                  BlurEffect ef = new BlurEffect();                  {                      ef.KernelType = KernelType.Gaussian;                      ef.Radius = 3.0;                      ef.RenderingBias = RenderingBias.Performance;                  }                    myPath.Effect = ef;              }                myPath.Stroke = Brushes.MidnightBlue;              myPath.StrokeThickness = 5;              myPath.StrokeLineJoin = PenLineJoin.Round;              myPath.StrokeStartLineCap = PenLineCap.Triangle;              myPath.StrokeEndLineCap = PenLineCap.Square;                myPath.Fill = Brushes.AliceBlue;                myPath.Opacity = 0.6;              myPath.IsHitTestVisible = false;           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,CreatePolygonPath,The following statement contains a magic number: {              // Specify the shape of the Path using the StreamGeometry.              myPath.Data = geometry;                if (addBlurEffect)              {                  BlurEffect ef = new BlurEffect();                  {                      ef.KernelType = KernelType.Gaussian;                      ef.Radius = 3.0;                      ef.RenderingBias = RenderingBias.Performance;                  }                    myPath.Effect = ef;              }                myPath.Stroke = Brushes.MidnightBlue;              myPath.StrokeThickness = 5;              myPath.StrokeLineJoin = PenLineJoin.Round;              myPath.StrokeStartLineCap = PenLineCap.Triangle;              myPath.StrokeEndLineCap = PenLineCap.Square;                myPath.Fill = Brushes.AliceBlue;                myPath.Opacity = 0.6;              myPath.IsHitTestVisible = false;           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,SetZoomToFitRect,The following statement contains a magic number: if(lazyEvents)           {              lazySetZoomToFitRect = rect;           }           else           {              int maxZoom = Core.GetMaxZoomToFitRect(rect);              if(maxZoom > 0)              {                 PointLatLng center = new PointLatLng(rect.Lat - (rect.HeightLat / 2)' rect.Lng + (rect.WidthLng / 2));                 Position = center;                   if(maxZoom > MaxZoom)                 {                    maxZoom = MaxZoom;                 }                   if(Core.Zoom != maxZoom)                 {                    Zoom = maxZoom;                 }                   return true;              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,SetZoomToFitRect,The following statement contains a magic number: if(lazyEvents)           {              lazySetZoomToFitRect = rect;           }           else           {              int maxZoom = Core.GetMaxZoomToFitRect(rect);              if(maxZoom > 0)              {                 PointLatLng center = new PointLatLng(rect.Lat - (rect.HeightLat / 2)' rect.Lng + (rect.WidthLng / 2));                 Position = center;                   if(maxZoom > MaxZoom)                 {                    maxZoom = MaxZoom;                 }                   if(Core.Zoom != maxZoom)                 {                    Zoom = maxZoom;                 }                   return true;              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,UpdateRotationMatrix,The following statement contains a magic number: System.Windows.Point center = new System.Windows.Point(ActualWidth / 2.0' ActualHeight / 2.0);
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,UpdateRotationMatrix,The following statement contains a magic number: System.Windows.Point center = new System.Windows.Point(ActualWidth / 2.0' ActualHeight / 2.0);
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(IsRotated)           {              drawingContext.PushTransform(rotationMatrix);                if(MapScaleTransform != null)              {                 drawingContext.PushTransform(MapScaleTransform);                  drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);                 }                 drawingContext.Pop();                 drawingContext.Pop();              }              else              {                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);                 }                 drawingContext.Pop();              }                drawingContext.Pop();           }           else           {              if(MapScaleTransform != null)              {                 drawingContext.PushTransform(MapScaleTransform);                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);    #if DEBUG                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(-20' 0)' new Point(20' 0));                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(0' -20)' new Point(0' 20));  #endif                 }                 drawingContext.Pop();                 drawingContext.Pop();              }              else              {                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);  #if DEBUG                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(-20' 0)' new Point(20' 0));                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(0' -20)' new Point(0' 20));  #endif                 }                 drawingContext.Pop();              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(IsRotated)           {              drawingContext.PushTransform(rotationMatrix);                if(MapScaleTransform != null)              {                 drawingContext.PushTransform(MapScaleTransform);                  drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);                 }                 drawingContext.Pop();                 drawingContext.Pop();              }              else              {                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);                 }                 drawingContext.Pop();              }                drawingContext.Pop();           }           else           {              if(MapScaleTransform != null)              {                 drawingContext.PushTransform(MapScaleTransform);                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);    #if DEBUG                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(-20' 0)' new Point(20' 0));                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(0' -20)' new Point(0' 20));  #endif                 }                 drawingContext.Pop();                 drawingContext.Pop();              }              else              {                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);  #if DEBUG                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(-20' 0)' new Point(20' 0));                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(0' -20)' new Point(0' 20));  #endif                 }                 drawingContext.Pop();              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(IsRotated)           {              drawingContext.PushTransform(rotationMatrix);                if(MapScaleTransform != null)              {                 drawingContext.PushTransform(MapScaleTransform);                  drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);                 }                 drawingContext.Pop();                 drawingContext.Pop();              }              else              {                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);                 }                 drawingContext.Pop();              }                drawingContext.Pop();           }           else           {              if(MapScaleTransform != null)              {                 drawingContext.PushTransform(MapScaleTransform);                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);    #if DEBUG                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(-20' 0)' new Point(20' 0));                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(0' -20)' new Point(0' 20));  #endif                 }                 drawingContext.Pop();                 drawingContext.Pop();              }              else              {                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);  #if DEBUG                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(-20' 0)' new Point(20' 0));                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(0' -20)' new Point(0' 20));  #endif                 }                 drawingContext.Pop();              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(IsRotated)           {              drawingContext.PushTransform(rotationMatrix);                if(MapScaleTransform != null)              {                 drawingContext.PushTransform(MapScaleTransform);                  drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);                 }                 drawingContext.Pop();                 drawingContext.Pop();              }              else              {                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);                 }                 drawingContext.Pop();              }                drawingContext.Pop();           }           else           {              if(MapScaleTransform != null)              {                 drawingContext.PushTransform(MapScaleTransform);                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);    #if DEBUG                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(-20' 0)' new Point(20' 0));                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(0' -20)' new Point(0' 20));  #endif                 }                 drawingContext.Pop();                 drawingContext.Pop();              }              else              {                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);  #if DEBUG                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(-20' 0)' new Point(20' 0));                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(0' -20)' new Point(0' 20));  #endif                 }                 drawingContext.Pop();              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(IsRotated)           {              drawingContext.PushTransform(rotationMatrix);                if(MapScaleTransform != null)              {                 drawingContext.PushTransform(MapScaleTransform);                  drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);                 }                 drawingContext.Pop();                 drawingContext.Pop();              }              else              {                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);                 }                 drawingContext.Pop();              }                drawingContext.Pop();           }           else           {              if(MapScaleTransform != null)              {                 drawingContext.PushTransform(MapScaleTransform);                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);    #if DEBUG                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(-20' 0)' new Point(20' 0));                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(0' -20)' new Point(0' 20));  #endif                 }                 drawingContext.Pop();                 drawingContext.Pop();              }              else              {                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);  #if DEBUG                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(-20' 0)' new Point(20' 0));                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(0' -20)' new Point(0' 20));  #endif                 }                 drawingContext.Pop();              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(IsRotated)           {              drawingContext.PushTransform(rotationMatrix);                if(MapScaleTransform != null)              {                 drawingContext.PushTransform(MapScaleTransform);                  drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);                 }                 drawingContext.Pop();                 drawingContext.Pop();              }              else              {                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);                 }                 drawingContext.Pop();              }                drawingContext.Pop();           }           else           {              if(MapScaleTransform != null)              {                 drawingContext.PushTransform(MapScaleTransform);                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);    #if DEBUG                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(-20' 0)' new Point(20' 0));                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(0' -20)' new Point(0' 20));  #endif                 }                 drawingContext.Pop();                 drawingContext.Pop();              }              else              {                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);  #if DEBUG                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(-20' 0)' new Point(20' 0));                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(0' -20)' new Point(0' 20));  #endif                 }                 drawingContext.Pop();              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(IsRotated)           {              drawingContext.PushTransform(rotationMatrix);                if(MapScaleTransform != null)              {                 drawingContext.PushTransform(MapScaleTransform);                  drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);                 }                 drawingContext.Pop();                 drawingContext.Pop();              }              else              {                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);                 }                 drawingContext.Pop();              }                drawingContext.Pop();           }           else           {              if(MapScaleTransform != null)              {                 drawingContext.PushTransform(MapScaleTransform);                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);    #if DEBUG                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(-20' 0)' new Point(20' 0));                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(0' -20)' new Point(0' 20));  #endif                 }                 drawingContext.Pop();                 drawingContext.Pop();              }              else              {                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);  #if DEBUG                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(-20' 0)' new Point(20' 0));                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(0' -20)' new Point(0' 20));  #endif                 }                 drawingContext.Pop();              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(IsRotated)           {              drawingContext.PushTransform(rotationMatrix);                if(MapScaleTransform != null)              {                 drawingContext.PushTransform(MapScaleTransform);                  drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);                 }                 drawingContext.Pop();                 drawingContext.Pop();              }              else              {                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);                 }                 drawingContext.Pop();              }                drawingContext.Pop();           }           else           {              if(MapScaleTransform != null)              {                 drawingContext.PushTransform(MapScaleTransform);                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);    #if DEBUG                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(-20' 0)' new Point(20' 0));                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(0' -20)' new Point(0' 20));  #endif                 }                 drawingContext.Pop();                 drawingContext.Pop();              }              else              {                 drawingContext.PushTransform(MapTranslateTransform);                 {                    DrawMap(drawingContext);  #if DEBUG                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(-20' 0)' new Point(20' 0));                    drawingContext.DrawLine(VirtualCenterCrossPen' new Point(0' -20)' new Point(0' 20));  #endif                 }                 drawingContext.Pop();              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(!SelectedArea.IsEmpty)           {              GPoint p1 = FromLatLngToLocal(SelectedArea.LocationTopLeft);              GPoint p2 = FromLatLngToLocal(SelectedArea.LocationRightBottom);                long x1 = p1.X;              long y1 = p1.Y;              long x2 = p2.X;              long y2 = p2.Y;                if(SelectionUseCircle)              {                 drawingContext.DrawEllipse(SelectedAreaFill' SelectionPen' new System.Windows.Point(x1 + (x2 - x1) / 2' y1 + (y2 - y1) / 2)' (x2 - x1) / 2' (y2 - y1) / 2);              }              else              {                 drawingContext.DrawRoundedRectangle(SelectedAreaFill' SelectionPen' new Rect(x1' y1' x2 - x1' y2 - y1)' 5' 5);              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(!SelectedArea.IsEmpty)           {              GPoint p1 = FromLatLngToLocal(SelectedArea.LocationTopLeft);              GPoint p2 = FromLatLngToLocal(SelectedArea.LocationRightBottom);                long x1 = p1.X;              long y1 = p1.Y;              long x2 = p2.X;              long y2 = p2.Y;                if(SelectionUseCircle)              {                 drawingContext.DrawEllipse(SelectedAreaFill' SelectionPen' new System.Windows.Point(x1 + (x2 - x1) / 2' y1 + (y2 - y1) / 2)' (x2 - x1) / 2' (y2 - y1) / 2);              }              else              {                 drawingContext.DrawRoundedRectangle(SelectedAreaFill' SelectionPen' new Rect(x1' y1' x2 - x1' y2 - y1)' 5' 5);              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(!SelectedArea.IsEmpty)           {              GPoint p1 = FromLatLngToLocal(SelectedArea.LocationTopLeft);              GPoint p2 = FromLatLngToLocal(SelectedArea.LocationRightBottom);                long x1 = p1.X;              long y1 = p1.Y;              long x2 = p2.X;              long y2 = p2.Y;                if(SelectionUseCircle)              {                 drawingContext.DrawEllipse(SelectedAreaFill' SelectionPen' new System.Windows.Point(x1 + (x2 - x1) / 2' y1 + (y2 - y1) / 2)' (x2 - x1) / 2' (y2 - y1) / 2);              }              else              {                 drawingContext.DrawRoundedRectangle(SelectedAreaFill' SelectionPen' new Rect(x1' y1' x2 - x1' y2 - y1)' 5' 5);              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(!SelectedArea.IsEmpty)           {              GPoint p1 = FromLatLngToLocal(SelectedArea.LocationTopLeft);              GPoint p2 = FromLatLngToLocal(SelectedArea.LocationRightBottom);                long x1 = p1.X;              long y1 = p1.Y;              long x2 = p2.X;              long y2 = p2.Y;                if(SelectionUseCircle)              {                 drawingContext.DrawEllipse(SelectedAreaFill' SelectionPen' new System.Windows.Point(x1 + (x2 - x1) / 2' y1 + (y2 - y1) / 2)' (x2 - x1) / 2' (y2 - y1) / 2);              }              else              {                 drawingContext.DrawRoundedRectangle(SelectedAreaFill' SelectionPen' new Rect(x1' y1' x2 - x1' y2 - y1)' 5' 5);              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(!SelectedArea.IsEmpty)           {              GPoint p1 = FromLatLngToLocal(SelectedArea.LocationTopLeft);              GPoint p2 = FromLatLngToLocal(SelectedArea.LocationRightBottom);                long x1 = p1.X;              long y1 = p1.Y;              long x2 = p2.X;              long y2 = p2.Y;                if(SelectionUseCircle)              {                 drawingContext.DrawEllipse(SelectedAreaFill' SelectionPen' new System.Windows.Point(x1 + (x2 - x1) / 2' y1 + (y2 - y1) / 2)' (x2 - x1) / 2' (y2 - y1) / 2);              }              else              {                 drawingContext.DrawRoundedRectangle(SelectedAreaFill' SelectionPen' new Rect(x1' y1' x2 - x1' y2 - y1)' 5' 5);              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(!SelectedArea.IsEmpty)           {              GPoint p1 = FromLatLngToLocal(SelectedArea.LocationTopLeft);              GPoint p2 = FromLatLngToLocal(SelectedArea.LocationRightBottom);                long x1 = p1.X;              long y1 = p1.Y;              long x2 = p2.X;              long y2 = p2.Y;                if(SelectionUseCircle)              {                 drawingContext.DrawEllipse(SelectedAreaFill' SelectionPen' new System.Windows.Point(x1 + (x2 - x1) / 2' y1 + (y2 - y1) / 2)' (x2 - x1) / 2' (y2 - y1) / 2);              }              else              {                 drawingContext.DrawRoundedRectangle(SelectedAreaFill' SelectionPen' new Rect(x1' y1' x2 - x1' y2 - y1)' 5' 5);              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(ShowCenter)           {              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point((ActualWidth / 2) - 5' ActualHeight / 2)' new System.Windows.Point((ActualWidth / 2) + 5' ActualHeight / 2));              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) - 5)' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) + 5));           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(ShowCenter)           {              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point((ActualWidth / 2) - 5' ActualHeight / 2)' new System.Windows.Point((ActualWidth / 2) + 5' ActualHeight / 2));              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) - 5)' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) + 5));           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(ShowCenter)           {              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point((ActualWidth / 2) - 5' ActualHeight / 2)' new System.Windows.Point((ActualWidth / 2) + 5' ActualHeight / 2));              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) - 5)' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) + 5));           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(ShowCenter)           {              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point((ActualWidth / 2) - 5' ActualHeight / 2)' new System.Windows.Point((ActualWidth / 2) + 5' ActualHeight / 2));              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) - 5)' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) + 5));           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(ShowCenter)           {              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point((ActualWidth / 2) - 5' ActualHeight / 2)' new System.Windows.Point((ActualWidth / 2) + 5' ActualHeight / 2));              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) - 5)' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) + 5));           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(ShowCenter)           {              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point((ActualWidth / 2) - 5' ActualHeight / 2)' new System.Windows.Point((ActualWidth / 2) + 5' ActualHeight / 2));              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) - 5)' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) + 5));           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(ShowCenter)           {              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point((ActualWidth / 2) - 5' ActualHeight / 2)' new System.Windows.Point((ActualWidth / 2) + 5' ActualHeight / 2));              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) - 5)' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) + 5));           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(ShowCenter)           {              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point((ActualWidth / 2) - 5' ActualHeight / 2)' new System.Windows.Point((ActualWidth / 2) + 5' ActualHeight / 2));              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) - 5)' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) + 5));           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(ShowCenter)           {              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point((ActualWidth / 2) - 5' ActualHeight / 2)' new System.Windows.Point((ActualWidth / 2) + 5' ActualHeight / 2));              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) - 5)' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) + 5));           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(ShowCenter)           {              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point((ActualWidth / 2) - 5' ActualHeight / 2)' new System.Windows.Point((ActualWidth / 2) + 5' ActualHeight / 2));              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) - 5)' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) + 5));           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(ShowCenter)           {              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point((ActualWidth / 2) - 5' ActualHeight / 2)' new System.Windows.Point((ActualWidth / 2) + 5' ActualHeight / 2));              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) - 5)' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) + 5));           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(ShowCenter)           {              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point((ActualWidth / 2) - 5' ActualHeight / 2)' new System.Windows.Point((ActualWidth / 2) + 5' ActualHeight / 2));              drawingContext.DrawLine(CenterCrossPen' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) - 5)' new System.Windows.Point(ActualWidth / 2' (ActualHeight / 2) + 5));           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(Copyright != null)           {              drawingContext.DrawText(Copyright' new System.Windows.Point(5' ActualHeight - Copyright.Height - 5));           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnRender,The following statement contains a magic number: if(Copyright != null)           {              drawingContext.DrawText(Copyright' new System.Windows.Point(5' ActualHeight - Copyright.Height - 5));           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnMouseWheel,The following statement contains a magic number: if(MouseWheelZoomEnabled && (IsMouseDirectlyOver || IgnoreMarkerOnMouseWheel) && !Core.IsDragging)           {              System.Windows.Point p = e.GetPosition(this);                if(MapScaleTransform != null)              {                 p = MapScaleTransform.Inverse.Transform(p);              }                p = ApplyRotationInversion(p.X' p.Y);                if(Core.mouseLastZoom.X != (int)p.X && Core.mouseLastZoom.Y != (int)p.Y)              {                 if(MouseWheelZoomType == MouseWheelZoomType.MousePositionAndCenter)                 {                    Core.position = FromLocalToLatLng((int)p.X' (int)p.Y);                 }                 else if(MouseWheelZoomType == MouseWheelZoomType.ViewCenter)                 {                    Core.position = FromLocalToLatLng((int)ActualWidth / 2' (int)ActualHeight / 2);                 }                 else if(MouseWheelZoomType == MouseWheelZoomType.MousePositionWithoutCenter)                 {                    Core.position = FromLocalToLatLng((int)p.X' (int)p.Y);                 }                   Core.mouseLastZoom.X = (int)p.X;                 Core.mouseLastZoom.Y = (int)p.Y;              }                // set mouse position to map center              if(MouseWheelZoomType != MouseWheelZoomType.MousePositionWithoutCenter)              {                 System.Windows.Point ps = PointToScreen(new System.Windows.Point(ActualWidth / 2' ActualHeight / 2));                 Stuff.SetCursorPos((int)ps.X' (int)ps.Y);              }                Core.MouseWheelZooming = true;                if(e.Delta > 0)              {                 if(!InvertedMouseWheelZooming)                 {                    Zoom = ((int)Zoom) + 1;                 }                 else                 {                    Zoom = ((int)(Zoom + 0.99)) - 1;                 }              }              else              {                 if(InvertedMouseWheelZooming)                 {                    Zoom = ((int)Zoom) + 1;                 }                 else                 {                    Zoom = ((int)(Zoom + 0.99)) - 1;                 }              }                Core.MouseWheelZooming = false;           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnMouseWheel,The following statement contains a magic number: if(MouseWheelZoomEnabled && (IsMouseDirectlyOver || IgnoreMarkerOnMouseWheel) && !Core.IsDragging)           {              System.Windows.Point p = e.GetPosition(this);                if(MapScaleTransform != null)              {                 p = MapScaleTransform.Inverse.Transform(p);              }                p = ApplyRotationInversion(p.X' p.Y);                if(Core.mouseLastZoom.X != (int)p.X && Core.mouseLastZoom.Y != (int)p.Y)              {                 if(MouseWheelZoomType == MouseWheelZoomType.MousePositionAndCenter)                 {                    Core.position = FromLocalToLatLng((int)p.X' (int)p.Y);                 }                 else if(MouseWheelZoomType == MouseWheelZoomType.ViewCenter)                 {                    Core.position = FromLocalToLatLng((int)ActualWidth / 2' (int)ActualHeight / 2);                 }                 else if(MouseWheelZoomType == MouseWheelZoomType.MousePositionWithoutCenter)                 {                    Core.position = FromLocalToLatLng((int)p.X' (int)p.Y);                 }                   Core.mouseLastZoom.X = (int)p.X;                 Core.mouseLastZoom.Y = (int)p.Y;              }                // set mouse position to map center              if(MouseWheelZoomType != MouseWheelZoomType.MousePositionWithoutCenter)              {                 System.Windows.Point ps = PointToScreen(new System.Windows.Point(ActualWidth / 2' ActualHeight / 2));                 Stuff.SetCursorPos((int)ps.X' (int)ps.Y);              }                Core.MouseWheelZooming = true;                if(e.Delta > 0)              {                 if(!InvertedMouseWheelZooming)                 {                    Zoom = ((int)Zoom) + 1;                 }                 else                 {                    Zoom = ((int)(Zoom + 0.99)) - 1;                 }              }              else              {                 if(InvertedMouseWheelZooming)                 {                    Zoom = ((int)Zoom) + 1;                 }                 else                 {                    Zoom = ((int)(Zoom + 0.99)) - 1;                 }              }                Core.MouseWheelZooming = false;           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnMouseWheel,The following statement contains a magic number: if(MouseWheelZoomEnabled && (IsMouseDirectlyOver || IgnoreMarkerOnMouseWheel) && !Core.IsDragging)           {              System.Windows.Point p = e.GetPosition(this);                if(MapScaleTransform != null)              {                 p = MapScaleTransform.Inverse.Transform(p);              }                p = ApplyRotationInversion(p.X' p.Y);                if(Core.mouseLastZoom.X != (int)p.X && Core.mouseLastZoom.Y != (int)p.Y)              {                 if(MouseWheelZoomType == MouseWheelZoomType.MousePositionAndCenter)                 {                    Core.position = FromLocalToLatLng((int)p.X' (int)p.Y);                 }                 else if(MouseWheelZoomType == MouseWheelZoomType.ViewCenter)                 {                    Core.position = FromLocalToLatLng((int)ActualWidth / 2' (int)ActualHeight / 2);                 }                 else if(MouseWheelZoomType == MouseWheelZoomType.MousePositionWithoutCenter)                 {                    Core.position = FromLocalToLatLng((int)p.X' (int)p.Y);                 }                   Core.mouseLastZoom.X = (int)p.X;                 Core.mouseLastZoom.Y = (int)p.Y;              }                // set mouse position to map center              if(MouseWheelZoomType != MouseWheelZoomType.MousePositionWithoutCenter)              {                 System.Windows.Point ps = PointToScreen(new System.Windows.Point(ActualWidth / 2' ActualHeight / 2));                 Stuff.SetCursorPos((int)ps.X' (int)ps.Y);              }                Core.MouseWheelZooming = true;                if(e.Delta > 0)              {                 if(!InvertedMouseWheelZooming)                 {                    Zoom = ((int)Zoom) + 1;                 }                 else                 {                    Zoom = ((int)(Zoom + 0.99)) - 1;                 }              }              else              {                 if(InvertedMouseWheelZooming)                 {                    Zoom = ((int)Zoom) + 1;                 }                 else                 {                    Zoom = ((int)(Zoom + 0.99)) - 1;                 }              }                Core.MouseWheelZooming = false;           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnMouseWheel,The following statement contains a magic number: if(MouseWheelZoomEnabled && (IsMouseDirectlyOver || IgnoreMarkerOnMouseWheel) && !Core.IsDragging)           {              System.Windows.Point p = e.GetPosition(this);                if(MapScaleTransform != null)              {                 p = MapScaleTransform.Inverse.Transform(p);              }                p = ApplyRotationInversion(p.X' p.Y);                if(Core.mouseLastZoom.X != (int)p.X && Core.mouseLastZoom.Y != (int)p.Y)              {                 if(MouseWheelZoomType == MouseWheelZoomType.MousePositionAndCenter)                 {                    Core.position = FromLocalToLatLng((int)p.X' (int)p.Y);                 }                 else if(MouseWheelZoomType == MouseWheelZoomType.ViewCenter)                 {                    Core.position = FromLocalToLatLng((int)ActualWidth / 2' (int)ActualHeight / 2);                 }                 else if(MouseWheelZoomType == MouseWheelZoomType.MousePositionWithoutCenter)                 {                    Core.position = FromLocalToLatLng((int)p.X' (int)p.Y);                 }                   Core.mouseLastZoom.X = (int)p.X;                 Core.mouseLastZoom.Y = (int)p.Y;              }                // set mouse position to map center              if(MouseWheelZoomType != MouseWheelZoomType.MousePositionWithoutCenter)              {                 System.Windows.Point ps = PointToScreen(new System.Windows.Point(ActualWidth / 2' ActualHeight / 2));                 Stuff.SetCursorPos((int)ps.X' (int)ps.Y);              }                Core.MouseWheelZooming = true;                if(e.Delta > 0)              {                 if(!InvertedMouseWheelZooming)                 {                    Zoom = ((int)Zoom) + 1;                 }                 else                 {                    Zoom = ((int)(Zoom + 0.99)) - 1;                 }              }              else              {                 if(InvertedMouseWheelZooming)                 {                    Zoom = ((int)Zoom) + 1;                 }                 else                 {                    Zoom = ((int)(Zoom + 0.99)) - 1;                 }              }                Core.MouseWheelZooming = false;           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnMouseWheel,The following statement contains a magic number: if(MouseWheelZoomEnabled && (IsMouseDirectlyOver || IgnoreMarkerOnMouseWheel) && !Core.IsDragging)           {              System.Windows.Point p = e.GetPosition(this);                if(MapScaleTransform != null)              {                 p = MapScaleTransform.Inverse.Transform(p);              }                p = ApplyRotationInversion(p.X' p.Y);                if(Core.mouseLastZoom.X != (int)p.X && Core.mouseLastZoom.Y != (int)p.Y)              {                 if(MouseWheelZoomType == MouseWheelZoomType.MousePositionAndCenter)                 {                    Core.position = FromLocalToLatLng((int)p.X' (int)p.Y);                 }                 else if(MouseWheelZoomType == MouseWheelZoomType.ViewCenter)                 {                    Core.position = FromLocalToLatLng((int)ActualWidth / 2' (int)ActualHeight / 2);                 }                 else if(MouseWheelZoomType == MouseWheelZoomType.MousePositionWithoutCenter)                 {                    Core.position = FromLocalToLatLng((int)p.X' (int)p.Y);                 }                   Core.mouseLastZoom.X = (int)p.X;                 Core.mouseLastZoom.Y = (int)p.Y;              }                // set mouse position to map center              if(MouseWheelZoomType != MouseWheelZoomType.MousePositionWithoutCenter)              {                 System.Windows.Point ps = PointToScreen(new System.Windows.Point(ActualWidth / 2' ActualHeight / 2));                 Stuff.SetCursorPos((int)ps.X' (int)ps.Y);              }                Core.MouseWheelZooming = true;                if(e.Delta > 0)              {                 if(!InvertedMouseWheelZooming)                 {                    Zoom = ((int)Zoom) + 1;                 }                 else                 {                    Zoom = ((int)(Zoom + 0.99)) - 1;                 }              }              else              {                 if(InvertedMouseWheelZooming)                 {                    Zoom = ((int)Zoom) + 1;                 }                 else                 {                    Zoom = ((int)(Zoom + 0.99)) - 1;                 }              }                Core.MouseWheelZooming = false;           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnMouseWheel,The following statement contains a magic number: if(MouseWheelZoomEnabled && (IsMouseDirectlyOver || IgnoreMarkerOnMouseWheel) && !Core.IsDragging)           {              System.Windows.Point p = e.GetPosition(this);                if(MapScaleTransform != null)              {                 p = MapScaleTransform.Inverse.Transform(p);              }                p = ApplyRotationInversion(p.X' p.Y);                if(Core.mouseLastZoom.X != (int)p.X && Core.mouseLastZoom.Y != (int)p.Y)              {                 if(MouseWheelZoomType == MouseWheelZoomType.MousePositionAndCenter)                 {                    Core.position = FromLocalToLatLng((int)p.X' (int)p.Y);                 }                 else if(MouseWheelZoomType == MouseWheelZoomType.ViewCenter)                 {                    Core.position = FromLocalToLatLng((int)ActualWidth / 2' (int)ActualHeight / 2);                 }                 else if(MouseWheelZoomType == MouseWheelZoomType.MousePositionWithoutCenter)                 {                    Core.position = FromLocalToLatLng((int)p.X' (int)p.Y);                 }                   Core.mouseLastZoom.X = (int)p.X;                 Core.mouseLastZoom.Y = (int)p.Y;              }                // set mouse position to map center              if(MouseWheelZoomType != MouseWheelZoomType.MousePositionWithoutCenter)              {                 System.Windows.Point ps = PointToScreen(new System.Windows.Point(ActualWidth / 2' ActualHeight / 2));                 Stuff.SetCursorPos((int)ps.X' (int)ps.Y);              }                Core.MouseWheelZooming = true;                if(e.Delta > 0)              {                 if(!InvertedMouseWheelZooming)                 {                    Zoom = ((int)Zoom) + 1;                 }                 else                 {                    Zoom = ((int)(Zoom + 0.99)) - 1;                 }              }              else              {                 if(InvertedMouseWheelZooming)                 {                    Zoom = ((int)Zoom) + 1;                 }                 else                 {                    Zoom = ((int)(Zoom + 0.99)) - 1;                 }              }                Core.MouseWheelZooming = false;           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnMouseMove,The following statement contains a magic number: if((e.Timestamp & Int32.MaxValue) - onMouseUpTimestamp < 55)           {              Debug.WriteLine("OnMouseMove skipped: " + ((e.Timestamp & Int32.MaxValue) - onMouseUpTimestamp) + "ms");              return;           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnMouseMove,The following statement contains a magic number: if(!Core.IsDragging && !Core.mouseDown.IsEmpty)           {              Point p = e.GetPosition(this);                if(MapScaleTransform != null)              {                 p = MapScaleTransform.Inverse.Transform(p);              }                p = ApplyRotationInversion(p.X' p.Y);                // cursor has moved beyond drag tolerance              if(Math.Abs(p.X - Core.mouseDown.X) * 2 >= SystemParameters.MinimumHorizontalDragDistance || Math.Abs(p.Y - Core.mouseDown.Y) * 2 >= SystemParameters.MinimumVerticalDragDistance)              {                 Core.BeginDrag(Core.mouseDown);              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnMouseMove,The following statement contains a magic number: if(!Core.IsDragging && !Core.mouseDown.IsEmpty)           {              Point p = e.GetPosition(this);                if(MapScaleTransform != null)              {                 p = MapScaleTransform.Inverse.Transform(p);              }                p = ApplyRotationInversion(p.X' p.Y);                // cursor has moved beyond drag tolerance              if(Math.Abs(p.X - Core.mouseDown.X) * 2 >= SystemParameters.MinimumHorizontalDragDistance || Math.Abs(p.Y - Core.mouseDown.Y) * 2 >= SystemParameters.MinimumVerticalDragDistance)              {                 Core.BeginDrag(Core.mouseDown);              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnStylusMove,The following statement contains a magic number: if(TouchEnabled)           {              // wpf generates to many events if mouse is over some visual              // and OnMouseUp is fired' wtf' anyway...              // http://greatmaps.codeplex.com/workitem/16013              if((e.Timestamp & Int32.MaxValue) - onMouseUpTimestamp < 55)              {                 Debug.WriteLine("OnMouseMove skipped: " + ((e.Timestamp & Int32.MaxValue) - onMouseUpTimestamp) + "ms");                 return;              }                if(!Core.IsDragging && !Core.mouseDown.IsEmpty)              {                 Point p = e.GetPosition(this);                   if(MapScaleTransform != null)                 {                    p = MapScaleTransform.Inverse.Transform(p);                 }                   p = ApplyRotationInversion(p.X' p.Y);                   // cursor has moved beyond drag tolerance                 if(Math.Abs(p.X - Core.mouseDown.X) * 2 >= SystemParameters.MinimumHorizontalDragDistance || Math.Abs(p.Y - Core.mouseDown.Y) * 2 >= SystemParameters.MinimumVerticalDragDistance)                 {                    Core.BeginDrag(Core.mouseDown);                 }              }                if(Core.IsDragging)              {                 if(!isDragging)                 {                    isDragging = true;                    Debug.WriteLine("IsDragging = " + isDragging);                    cursorBefore = Cursor;                    Cursor = Cursors.SizeAll;                    Mouse.Capture(this);                 }                   if(BoundsOfMap.HasValue && !BoundsOfMap.Value.Contains(Position))                 {                    // ...                 }                 else                 {                    Point p = e.GetPosition(this);                      if(MapScaleTransform != null)                    {                       p = MapScaleTransform.Inverse.Transform(p);                    }                      p = ApplyRotationInversion(p.X' p.Y);                      Core.mouseCurrent.X = (int)p.X;                    Core.mouseCurrent.Y = (int)p.Y;                    {                       Core.Drag(Core.mouseCurrent);                    }                      if(IsRotated)                    {                       ForceUpdateOverlays();                    }                    else                    {                       UpdateMarkersOffset();                    }                 }                 InvalidateVisual();              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnStylusMove,The following statement contains a magic number: if(TouchEnabled)           {              // wpf generates to many events if mouse is over some visual              // and OnMouseUp is fired' wtf' anyway...              // http://greatmaps.codeplex.com/workitem/16013              if((e.Timestamp & Int32.MaxValue) - onMouseUpTimestamp < 55)              {                 Debug.WriteLine("OnMouseMove skipped: " + ((e.Timestamp & Int32.MaxValue) - onMouseUpTimestamp) + "ms");                 return;              }                if(!Core.IsDragging && !Core.mouseDown.IsEmpty)              {                 Point p = e.GetPosition(this);                   if(MapScaleTransform != null)                 {                    p = MapScaleTransform.Inverse.Transform(p);                 }                   p = ApplyRotationInversion(p.X' p.Y);                   // cursor has moved beyond drag tolerance                 if(Math.Abs(p.X - Core.mouseDown.X) * 2 >= SystemParameters.MinimumHorizontalDragDistance || Math.Abs(p.Y - Core.mouseDown.Y) * 2 >= SystemParameters.MinimumVerticalDragDistance)                 {                    Core.BeginDrag(Core.mouseDown);                 }              }                if(Core.IsDragging)              {                 if(!isDragging)                 {                    isDragging = true;                    Debug.WriteLine("IsDragging = " + isDragging);                    cursorBefore = Cursor;                    Cursor = Cursors.SizeAll;                    Mouse.Capture(this);                 }                   if(BoundsOfMap.HasValue && !BoundsOfMap.Value.Contains(Position))                 {                    // ...                 }                 else                 {                    Point p = e.GetPosition(this);                      if(MapScaleTransform != null)                    {                       p = MapScaleTransform.Inverse.Transform(p);                    }                      p = ApplyRotationInversion(p.X' p.Y);                      Core.mouseCurrent.X = (int)p.X;                    Core.mouseCurrent.Y = (int)p.Y;                    {                       Core.Drag(Core.mouseCurrent);                    }                      if(IsRotated)                    {                       ForceUpdateOverlays();                    }                    else                    {                       UpdateMarkersOffset();                    }                 }                 InvalidateVisual();              }           }
Magic Number,GMap.NET.WindowsPresentation,GMapControl,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\GMapControl.cs,OnStylusMove,The following statement contains a magic number: if(TouchEnabled)           {              // wpf generates to many events if mouse is over some visual              // and OnMouseUp is fired' wtf' anyway...              // http://greatmaps.codeplex.com/workitem/16013              if((e.Timestamp & Int32.MaxValue) - onMouseUpTimestamp < 55)              {                 Debug.WriteLine("OnMouseMove skipped: " + ((e.Timestamp & Int32.MaxValue) - onMouseUpTimestamp) + "ms");                 return;              }                if(!Core.IsDragging && !Core.mouseDown.IsEmpty)              {                 Point p = e.GetPosition(this);                   if(MapScaleTransform != null)                 {                    p = MapScaleTransform.Inverse.Transform(p);                 }                   p = ApplyRotationInversion(p.X' p.Y);                   // cursor has moved beyond drag tolerance                 if(Math.Abs(p.X - Core.mouseDown.X) * 2 >= SystemParameters.MinimumHorizontalDragDistance || Math.Abs(p.Y - Core.mouseDown.Y) * 2 >= SystemParameters.MinimumVerticalDragDistance)                 {                    Core.BeginDrag(Core.mouseDown);                 }              }                if(Core.IsDragging)              {                 if(!isDragging)                 {                    isDragging = true;                    Debug.WriteLine("IsDragging = " + isDragging);                    cursorBefore = Cursor;                    Cursor = Cursors.SizeAll;                    Mouse.Capture(this);                 }                   if(BoundsOfMap.HasValue && !BoundsOfMap.Value.Contains(Position))                 {                    // ...                 }                 else                 {                    Point p = e.GetPosition(this);                      if(MapScaleTransform != null)                    {                       p = MapScaleTransform.Inverse.Transform(p);                    }                      p = ApplyRotationInversion(p.X' p.Y);                      Core.mouseCurrent.X = (int)p.X;                    Core.mouseCurrent.Y = (int)p.Y;                    {                       Core.Drag(Core.mouseCurrent);                    }                      if(IsRotated)                    {                       ForceUpdateOverlays();                    }                    else                    {                       UpdateMarkersOffset();                    }                 }                 InvalidateVisual();              }           }
Magic Number,GMap.NET.WindowsPresentation,TilePrefetcher,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\TilePrefetcher.xaml.cs,worker_DoWork,The following statement contains a magic number: for(int i = 0; i < all; i++)           {              if(worker.CancellationPending)                 break;                GPoint p = list[i];              {                 if(CacheTiles(zoom' p))                 {                    countOk++;                    retry = 0;                 }                 else                 {                    if(++retry <= 1) // retry only one                    {                       i--;                       System.Threading.Thread.Sleep(1111);                       continue;                    }                    else                    {                       retry = 0;                    }                 }              }                worker.ReportProgress((int)((i + 1) * 100 / all)' i + 1);                System.Threading.Thread.Sleep(sleep);           }
Magic Number,GMap.NET.WindowsPresentation,TilePrefetcher,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\TilePrefetcher.xaml.cs,worker_DoWork,The following statement contains a magic number: for(int i = 0; i < all; i++)           {              if(worker.CancellationPending)                 break;                GPoint p = list[i];              {                 if(CacheTiles(zoom' p))                 {                    countOk++;                    retry = 0;                 }                 else                 {                    if(++retry <= 1) // retry only one                    {                       i--;                       System.Threading.Thread.Sleep(1111);                       continue;                    }                    else                    {                       retry = 0;                    }                 }              }                worker.ReportProgress((int)((i + 1) * 100 / all)' i + 1);                System.Threading.Thread.Sleep(sleep);           }
Magic Number,GMap.NET.WindowsPresentation,TilePrefetcher,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\TilePrefetcher.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.label1 = ((System.Windows.Controls.TextBlock)(target));              return;              case 2:              this.progressBar1 = ((System.Windows.Controls.ProgressBar)(target));              return;              case 3:              this.label2 = ((System.Windows.Controls.TextBlock)(target));              return;              }
Magic Number,GMap.NET.WindowsPresentation,TilePrefetcher,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\TilePrefetcher.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.label1 = ((System.Windows.Controls.TextBlock)(target));              return;              case 2:              this.progressBar1 = ((System.Windows.Controls.ProgressBar)(target));              return;              case 3:              this.label2 = ((System.Windows.Controls.TextBlock)(target));              return;              }
Missing Default,GMap.NET.WindowsPresentation,TilePrefetcher,C:\repos\radioman_greatmaps\GMap.NET.WindowsPresentation\GMap.NET.WindowsPresentation\TilePrefetcher.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.label1 = ((System.Windows.Controls.TextBlock)(target));              return;              case 2:              this.progressBar1 = ((System.Windows.Controls.ProgressBar)(target));              return;              case 3:              this.label2 = ((System.Windows.Controls.TextBlock)(target));              return;              }
