Implementation smell,Namespace,Class,File,Method,Description
Long Method,CalcBinding,Binding,C:\repos\Alex141_CalcBinding\CalcBinding\CalcBinding.cs,ProvideValue,The method has 106 lines of code.
Long Method,CalcBinding.Inversion,Inverter,C:\repos\Alex141_CalcBinding\CalcBinding\Inversion\Inverter.cs,InverseExpressionInternal,The method has 131 lines of code.
Complex Method,CalcBinding,Binding,C:\repos\Alex141_CalcBinding\CalcBinding\CalcBinding.cs,ProvideValue,Cyclomatic complexity of the method is 8
Complex Method,CalcBinding,Binding,C:\repos\Alex141_CalcBinding\CalcBinding\CalcBinding.cs,GetExpressionTemplate,Cyclomatic complexity of the method is 8
Complex Method,CalcBinding,CalcConverter,C:\repos\Alex141_CalcBinding\CalcBinding\CalcConverter.cs,Convert,Cyclomatic complexity of the method is 9
Long Parameter List,CalcBinding.PathAnalysis,EnumToken,C:\repos\Alex141_CalcBinding\CalcBinding\PathAnalysis\Tokens\Realization\EnumToken.cs,EnumToken,The method has 5 parameters. Parameters: start' end' namespace' enum' enumMember
Long Parameter List,CalcBinding.PathAnalysis,StaticPropertyPathToken,C:\repos\Alex141_CalcBinding\CalcBinding\PathAnalysis\Tokens\Realization\StaticPropertyPathToken.cs,StaticPropertyPathToken,The method has 5 parameters. Parameters: start' end' namespace' class' properties
Long Statement,CalcBinding,Binding,C:\repos\Alex141_CalcBinding\CalcBinding\CalcBinding.cs,ProvideValue,The length of the statement  "                    pathValue = string.Format("({0})"' pathValue);  // need to use brackets for Static property recognition in standart binding " is 123.
Long Statement,CalcBinding,Binding,C:\repos\Alex141_CalcBinding\CalcBinding\CalcBinding.cs,ProvideValue,The length of the statement  "                        pathValue = string.Format("({0})"' pathValue);  // need to use brackets for Static property recognition in standart binding " is 123.
Long Statement,CalcBinding,CalcConverter,C:\repos\Alex141_CalcBinding\CalcBinding\CalcConverter.cs,Convert,The length of the statement  "                Trace.WriteLine("Binding error: calc converter can't invoke expression " + compiledExpression.ExpressionText + ": " + e.Message); " is 129.
Long Statement,CalcBinding.Inversion,Inverter,C:\repos\Alex141_CalcBinding\CalcBinding\Inversion\Inverter.cs,InverseExpressionInternal,The length of the statement  "                            throw new InverseException(String.Format("More than one variables are defined in expression: {0} and {1}"' recInfo.FoundedParamName' parameter.Name)); " is 150.
Long Statement,CalcBinding.Inversion,Inverter,C:\repos\Alex141_CalcBinding\CalcBinding\Inversion\Inverter.cs,InverseExpressionInternal,The length of the statement  "                            constantExpression = String.Format(CultureInfo.InvariantCulture' "({0})"' memberExpr.Member.DeclaringType.Name + "." + memberExpr.Member.Name); " is 143.
Long Statement,CalcBinding.PathAnalysis,PropertyPathAnalyzer,C:\repos\Alex141_CalcBinding\CalcBinding\PathAnalysis\PropertyPathAnalyzer.cs,TracePath,The length of the statement  "            Debug.WriteLine(string.Format("PropertyPathAnalyzer: read {0} ({1}) ({2}-{3})"' path.Id.Value' path.Id.PathType' path.Start' path.End)); " is 136.
Magic Number,CalcBinding.Inversion,Inverter,C:\repos\Alex141_CalcBinding\CalcBinding\Inversion\Inverter.cs,InverseExpressionInternal,The following statement contains a magic number: switch (expr.NodeType)              {                  case ExpressionType.Add:                  case ExpressionType.Subtract:                  case ExpressionType.Multiply:                  case ExpressionType.Divide:                      {                          var binExp = expr as BinaryExpression;                            string leftConstant = null' rightConstant = null;                          var leftOperandType = InverseExpressionInternal(binExp.Left' recInfo' ref leftConstant);                          var rightOperandType = InverseExpressionInternal(binExp.Right' recInfo' ref rightConstant);                            var nodeType = (leftOperandType == NodeType.Variable || rightOperandType == NodeType.Variable)                                          ? NodeType.Variable                                          : NodeType.Constant;                            if (nodeType == NodeType.Variable)                          {                              var constantPlace = leftOperandType == NodeType.Constant ? ConstantPlace.Left : ConstantPlace.Right;                              var constant = leftOperandType == NodeType.Constant ? leftConstant :rightConstant;                              recInfo.InvertedExp = String.Format(recInfo.InvertedExp' inversedFuncs[expr.NodeType' constantPlace](constant));                          }                          else                              constantExpression = String.Format("({0}{1}{2})"' leftConstant' NodeTypeToString(binExp.NodeType)' rightConstant);                            return nodeType;                      }                  case ExpressionType.Parameter:                      {                          var parameter = expr as ParameterExpression;                            if (recInfo.FoundedParamName == null)                          {                              recInfo.FoundedParamName = parameter.Name;                              recInfo.InvertedExp = RES;                              return NodeType.Variable;                          }                            if (recInfo.FoundedParamName == parameter.Name)                              throw new InverseException(String.Format("Variable {0} is defined more than one time!"' recInfo.FoundedParamName));                          else                              throw new InverseException(String.Format("More than one variables are defined in expression: {0} and {1}"' recInfo.FoundedParamName' parameter.Name));                      }                    case ExpressionType.Constant:                      {                          var constant = expr as ConstantExpression;                          constantExpression = String.Format(CultureInfo.InvariantCulture' "({0})"' constant.Value);                          return NodeType.Constant;                      }                  case ExpressionType.Convert:                      {                          var convertExpr = expr as UnaryExpression;                          string constant = null;                          var operandType = InverseExpressionInternal(convertExpr.Operand' recInfo' ref constant);                            if (operandType == NodeType.Constant)                              constantExpression = "((" + convertExpr.Type.Name + ")" + constant + ")";                          else                              recInfo.InvertedExp = String.Format(recInfo.InvertedExp' "((" + convertExpr.Operand.Type.Name + ")" + RES + ")");                          return operandType;                      }                  case ExpressionType.Negate:                      {                          var negateExpr = expr as UnaryExpression;                          string constant = null;                          var operandType = InverseExpressionInternal(negateExpr.Operand' recInfo' ref constant);                            if (operandType == NodeType.Constant)                              constantExpression = "(-" + constant + ")";                          else                              recInfo.InvertedExp = String.Format(recInfo.InvertedExp' "(-" + RES + ")");                          return operandType;                      }                  case ExpressionType.Not:                      {                          var convertExpr = expr as UnaryExpression;                            string constant = null;                          var operandType = InverseExpressionInternal(convertExpr.Operand' recInfo' ref constant);                            if (operandType == NodeType.Constant)                              constantExpression = "(" + NodeTypeToString(ExpressionType.Not) + constant + ")";                          else                              recInfo.InvertedExp = String.Format(recInfo.InvertedExp' "(" + NodeTypeToString(ExpressionType.Not) + RES + ")");                          return operandType;                      }                  case ExpressionType.Call:                      {                          var methodExpr = expr as MethodCallExpression;                            var methodName = methodExpr.Method.DeclaringType.Name + "." + methodExpr.Method.Name;                          if (!inversedMathFuncs.ContainsKey(methodName))                          {                              throw new InverseException(String.Format("Unsupported method call expression: {0}"' expr));                          }                            string leftConstant = null' rightConstant = null;                          var leftOperandType = InverseExpressionInternal(methodExpr.Arguments[0]' recInfo' ref leftConstant);                          NodeType? rightOperandType = null;                          Expression leftOperand' rightOperand = null;                            leftOperand = methodExpr.Arguments[0];                            if (methodExpr.Arguments.Count == 2)                          {                              rightOperandType = InverseExpressionInternal(methodExpr.Arguments[1]' recInfo' ref rightConstant);                              rightOperand = methodExpr.Arguments[1];                          }                            string inversedRes = null;                          if (leftOperandType == NodeType.Variable)                              inversedRes = inversedMathFuncs[methodName' ConstantPlace.Right](rightConstant);                          else                              if (rightOperandType.HasValue && rightOperandType.Value == NodeType.Variable)                                  inversedRes = inversedMathFuncs[methodName' ConstantPlace.Left](leftConstant);                              else                              {                                  //constant                                  constantExpression = methodName + "(" + leftConstant;                                  if (rightOperandType != null)                                      constantExpression += "' " + rightConstant;                                  constantExpression += ")";                              }                            if (inversedRes != null)                              recInfo.InvertedExp = String.Format(recInfo.InvertedExp' inversedRes);                            return inversedRes == null ? NodeType.Constant : NodeType.Variable;                      }                  case ExpressionType.MemberAccess:                      {                          var memberExpr = expr as MemberExpression;                            if (memberExpr.Member.DeclaringType.Name == "Math")                          {                              constantExpression = String.Format(CultureInfo.InvariantCulture' "({0})"' memberExpr.Member.DeclaringType.Name + "." + memberExpr.Member.Name);                              return NodeType.Constant;                          }                          else                          {                              throw new InverseException(String.Format("Unsupported method call expression: {0}"' expr));                          }                        }                  default:                      throw new InverseException(String.Format("Unsupported expression: {0}"' expr));              }
Magic Number,CalcBinding.PathAnalysis,PropertyPathAnalyzer,C:\repos\Alex141_CalcBinding\CalcBinding\PathAnalysis\PropertyPathAnalyzer.cs,GetPropPathOrMath,The following statement contains a magic number: if (propChain.Count() == 2 && propChain[0] == "Math")              {                  pathToken = new MathToken(chunk.Start' chunk.End' propChain[1]);              }              else              {                  pathToken = new PropertyPathToken(chunk.Start' chunk.End' propChain);              }
