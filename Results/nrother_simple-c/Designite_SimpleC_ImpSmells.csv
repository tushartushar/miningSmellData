Implementation smell,Namespace,Class,File,Method,Description
Long Method,SimpleC.Excecution,Excecutor,C:\repos\nrother_simple-c\SimpleC\Excecution\Excecutor.cs,exceuteInstruction,The method has 210 lines of code.
Long Method,SimpleC.Parsing,Parser,C:\repos\nrother_simple-c\SimpleC\Parsing\Parser.cs,ParseToAst,The method has 123 lines of code.
Complex Method,SimpleC.Excecution,Excecutor,C:\repos\nrother_simple-c\SimpleC\Excecution\Excecutor.cs,exceuteInstruction,Cyclomatic complexity of the method is 198
Complex Method,SimpleC.Lexing,Tokenizer,C:\repos\nrother_simple-c\SimpleC\Lexing\Tokenizer.cs,Tokenize,Cyclomatic complexity of the method is 32
Complex Method,SimpleC.Lexing,Tokenizer,C:\repos\nrother_simple-c\SimpleC\Lexing\Tokenizer.cs,charTypeOf,Cyclomatic complexity of the method is 24
Complex Method,SimpleC.Parsing,ExpressionParser,C:\repos\nrother_simple-c\SimpleC\Parsing\ExpressionParser.cs,Parse,Cyclomatic complexity of the method is 19
Complex Method,SimpleC.Parsing,Parser,C:\repos\nrother_simple-c\SimpleC\Parsing\Parser.cs,ParseToAst,Cyclomatic complexity of the method is 34
Complex Method,SimpleC.Types.Tokens,CloseBraceToken,C:\repos\nrother_simple-c\SimpleC\Types\Tokens\CloseBraceToken.cs,CloseBraceToken,Cyclomatic complexity of the method is 11
Complex Method,SimpleC.Types.Tokens,OpenBraceToken,C:\repos\nrother_simple-c\SimpleC\Types\Tokens\OpenBraceToken.cs,OpenBraceToken,Cyclomatic complexity of the method is 11
Long Statement,SimpleC.Parsing,ExpressionParser,C:\repos\nrother_simple-c\SimpleC\Parsing\ExpressionParser.cs,Parse,The length of the statement  "			while (operators.Count != 0 && operationPrecedence [operators.Peek ()] > operationPrecedence [op])//stack empty or only low precendence operators on stack " is 154.
Long Statement,SimpleC.Parsing,ExpressionParser,C:\repos\nrother_simple-c\SimpleC\Parsing\ExpressionParser.cs,Parse,The length of the statement  "			if (working.Count > 0 && working.Peek () is VariableReferenceExpressionNode)//we have a "variable" sitting on top of the op stack' this must be the name of a function to be called. Let's fix this. " is 196.
Long Statement,SimpleC.Parsing,Parser,C:\repos\nrother_simple-c\SimpleC\Parsing\Parser.cs,ParseToAst,The length of the statement  "			if (scopes.Count == 1)//we are a top level' the only valid keywords are variable types' starting a variable or function definition " is 130.
Long Statement,SimpleC.Parsing,Parser,C:\repos\nrother_simple-c\SimpleC\Parsing\Parser.cs,ParseToAst,The length of the statement  "					if (lookahead is OperatorToken && (((OperatorToken)lookahead).OperatorType == OperatorType.Assignment) || lookahead is StatementSperatorToken)//variable declaration " is 164.
Long Statement,SimpleC.Parsing,Parser,C:\repos\nrother_simple-c\SimpleC\Parsing\Parser.cs,ParseToAst,The length of the statement  "						scopes.Peek ().AddStatement (new VariableDeclarationNode (varType' name.Content' ExpressionNode.CreateFromTokens (readUntilStatementSeperator ()))); " is 148.
Long Statement,SimpleC.Parsing,Parser,C:\repos\nrother_simple-c\SimpleC\Parsing\Parser.cs,ParseToAst,The length of the statement  "					else if (lookahead is OpenBraceToken && (((OpenBraceToken)lookahead).BraceType == BraceType.Round))//function definition " is 120.
Long Statement,SimpleC.Parsing,Parser,C:\repos\nrother_simple-c\SimpleC\Parsing\Parser.cs,ParseToAst,The length of the statement  "						while (!(peek () is CloseBraceToken && ((CloseBraceToken)peek ()).BraceType == BraceType.Round))//TODO: Refactor using readUntilClosingBrace? " is 141.
Long Statement,SimpleC.Parsing,Parser,C:\repos\nrother_simple-c\SimpleC\Parsing\Parser.cs,ParseToAst,The length of the statement  "					if (lookahead is OperatorToken && (((OperatorToken)lookahead).OperatorType == OperatorType.Assignment) || lookahead is StatementSperatorToken)//variable declaration " is 164.
Long Statement,SimpleC.Parsing,Parser,C:\repos\nrother_simple-c\SimpleC\Parsing\Parser.cs,ParseToAst,The length of the statement  "						scopes.Peek ().AddStatement (new VariableDeclarationNode (varType' name.Content' ExpressionNode.CreateFromTokens (readUntilStatementSeperator ()))); " is 148.
Long Statement,SimpleC.Parsing,Parser,C:\repos\nrother_simple-c\SimpleC\Parsing\Parser.cs,ParseToAst,The length of the statement  "						scopes.Peek ().AddStatement (new ReturnStatementNode (ExpressionNode.CreateFromTokens (readUntilStatementSeperator ()))); " is 121.
Long Statement,SimpleC.Parsing,Parser,C:\repos\nrother_simple-c\SimpleC\Parsing\Parser.cs,ParseToAst,The length of the statement  "				scopes.Peek ().AddStatement (new VariableAssingmentNode (name.Content' ExpressionNode.CreateFromTokens (readUntilStatementSeperator ()))); " is 138.
Magic Number,SimpleC.Excecution,Excecutor,C:\repos\nrother_simple-c\SimpleC\Excecution\Excecutor.cs,exceuteInstruction,The following statement contains a magic number: switch (instr.OpCode) {  case OpCode.LoadC:  	stackPointer++;  	memory [stackPointer] = instr.ShortArg;  	break;  case OpCode.Load:  	for (int i = instr.ByteArg1 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [memory [stackPointer] + i];  	stackPointer += instr.ByteArg1 - 1;  	break;  case OpCode.LoadA:  	stackPointer++;  	for (int i = instr.ByteArg2 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [instr.ByteArg1 + i];  	stackPointer += instr.ByteArg2 - 1;  	break;  case OpCode.Dup:  	memory [stackPointer + 1] = memory [stackPointer];  	stackPointer++;  	break;  case OpCode.LoadRc:  	stackPointer++;  	memory [stackPointer] = framePointer + instr.ShortArg;  	break;  case OpCode.LoadR:  	stackPointer++;  	for (int i = instr.ByteArg2 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [framePointer + instr.ByteArg1 + i];  	stackPointer += instr.ByteArg2 - 1;  	break;  case OpCode.LoadMc:  	stackPointer++;  	memory [stackPointer] = memory [framePointer - 3] + instr.ByteArg1;  	break;  case OpCode.LoadM:  	stackPointer++;  	for (int i = instr.ByteArg2 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [memory [framePointer - 3] + instr.ByteArg1];  	stackPointer += instr.ByteArg2 - 1;  	break;  case OpCode.LoadV:  	memory [stackPointer + 1] = memory [memory [memory [stackPointer - 2]] + instr.ByteArg1];  	stackPointer++;  	break;  case OpCode.LoadSc:  	memory [stackPointer + 1] = stackPointer - instr.ByteArg1;  	stackPointer++;  	break;  case OpCode.LoadS:  	stackPointer++;  	memory [stackPointer] = memory [stackPointer - instr.ByteArg1];  	break;  case OpCode.Pop:  	stackPointer -= instr.ByteArg1;  	break;  case OpCode.Store:  	for (int i = 0; i < instr.ByteArg1; i++)  		memory [memory [stackPointer] + i] = memory [stackPointer - instr.ByteArg1 + i];  	stackPointer--;  	break;  case OpCode.StoreA:  	stackPointer++;  	for (int i = 0; i < instr.ByteArg2; i++)  		memory [instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  	stackPointer--;  	break;  case OpCode.StoreR:  	stackPointer++;  	for (int i = 0; i < instr.ByteArg2; i++)  		memory [framePointer + instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  	stackPointer--;  	break;  case OpCode.StoreM:  	stackPointer++;  	for (int i = 0; i < instr.ByteArg2; i++)  		memory [memory [framePointer - 3] + instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  	stackPointer--;  	break;  case OpCode.Jump:  	programCounter = instr.ShortArg;  	break;  case OpCode.JumpZ:  	if (memory [stackPointer] == 0)  		programCounter = instr.ShortArg;  	stackPointer--;  	break;  case OpCode.JumpI:  	programCounter = instr.ShortArg + memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Add:  	memory [stackPointer - 1] = memory [stackPointer - 1] + memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Sub:  	memory [stackPointer - 1] = memory [stackPointer - 1] - memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Mul:  	memory [stackPointer - 1] = memory [stackPointer - 1] * memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Div:  	memory [stackPointer - 1] = memory [stackPointer - 1] / memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Mod:  	memory [stackPointer - 1] = memory [stackPointer - 1] % memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Neg:  	memory [stackPointer] = -memory [stackPointer];  	break;  case OpCode.Eq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] == memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Neq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] != memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Le:  	memory [stackPointer - 1] = (memory [stackPointer - 1] < memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Leq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] <= memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Gr:  	memory [stackPointer - 1] = (memory [stackPointer - 1] > memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Geq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] >= memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.And:  	memory [stackPointer - 1] = (memory [stackPointer - 1] != 0 && memory [stackPointer] != 0) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Or:  	memory [stackPointer - 1] = (memory [stackPointer - 1] != 0 || memory [stackPointer] != 0) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Not:  	memory [stackPointer] = (memory [stackPointer] == 0) ? 1 : 0;  	break;  case OpCode.Mark:  	memory [stackPointer + 1] = extremePointer;  	memory [stackPointer + 2] = framePointer;  	stackPointer += 2;  	break;  case OpCode.Call:  	framePointer = stackPointer;  	int tmp = programCounter;  	programCounter = memory [stackPointer];  	memory [stackPointer] = tmp;  	break;  case OpCode.Enter:  	extremePointer = stackPointer + instr.ByteArg1;  	if (extremePointer >= heapPointer)  		throw new StackOverflowException ();  	break;  case OpCode.Alloc:  	stackPointer += instr.ByteArg1;  	break;  case OpCode.Slide:  	if (instr.ByteArg1 > 0) {  		if (instr.ByteArg2 == 0)  			stackPointer -= instr.ByteArg1;  		else {  			stackPointer -= instr.ByteArg1 + instr.ByteArg2;  			for (int i = 0; i < instr.ByteArg2; i++) {  				stackPointer++;  				memory [stackPointer] = memory [stackPointer + instr.ByteArg1];  			}  		}  	}  	break;  case OpCode.Return:  	programCounter = memory [framePointer];  	extremePointer = memory [framePointer - 2];  	if (extremePointer >= heapPointer)  		throw new StackOverflowException ();  	stackPointer = framePointer - instr.ByteArg1;  	framePointer = memory [framePointer - 1];  	break;  case OpCode.New:  	if (heapPointer - memory [stackPointer] > extremePointer) {  		heapPointer = heapPointer - memory [stackPointer];  		memory [stackPointer] = heapPointer;  	}  	else  		memory [stackPointer] = 0;  	//out of memory  	break;  case OpCode.Nop:  	//do nothing...  	break;  case OpCode.Halt:  	//do nothing' will be handled by main excecution cycle  	break;  default:  	throw new InvalidOpCodeException ("An unknown opcode was found. OpCode: " + instr.OpCode);  }  
Magic Number,SimpleC.Excecution,Excecutor,C:\repos\nrother_simple-c\SimpleC\Excecution\Excecutor.cs,exceuteInstruction,The following statement contains a magic number: switch (instr.OpCode) {  case OpCode.LoadC:  	stackPointer++;  	memory [stackPointer] = instr.ShortArg;  	break;  case OpCode.Load:  	for (int i = instr.ByteArg1 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [memory [stackPointer] + i];  	stackPointer += instr.ByteArg1 - 1;  	break;  case OpCode.LoadA:  	stackPointer++;  	for (int i = instr.ByteArg2 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [instr.ByteArg1 + i];  	stackPointer += instr.ByteArg2 - 1;  	break;  case OpCode.Dup:  	memory [stackPointer + 1] = memory [stackPointer];  	stackPointer++;  	break;  case OpCode.LoadRc:  	stackPointer++;  	memory [stackPointer] = framePointer + instr.ShortArg;  	break;  case OpCode.LoadR:  	stackPointer++;  	for (int i = instr.ByteArg2 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [framePointer + instr.ByteArg1 + i];  	stackPointer += instr.ByteArg2 - 1;  	break;  case OpCode.LoadMc:  	stackPointer++;  	memory [stackPointer] = memory [framePointer - 3] + instr.ByteArg1;  	break;  case OpCode.LoadM:  	stackPointer++;  	for (int i = instr.ByteArg2 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [memory [framePointer - 3] + instr.ByteArg1];  	stackPointer += instr.ByteArg2 - 1;  	break;  case OpCode.LoadV:  	memory [stackPointer + 1] = memory [memory [memory [stackPointer - 2]] + instr.ByteArg1];  	stackPointer++;  	break;  case OpCode.LoadSc:  	memory [stackPointer + 1] = stackPointer - instr.ByteArg1;  	stackPointer++;  	break;  case OpCode.LoadS:  	stackPointer++;  	memory [stackPointer] = memory [stackPointer - instr.ByteArg1];  	break;  case OpCode.Pop:  	stackPointer -= instr.ByteArg1;  	break;  case OpCode.Store:  	for (int i = 0; i < instr.ByteArg1; i++)  		memory [memory [stackPointer] + i] = memory [stackPointer - instr.ByteArg1 + i];  	stackPointer--;  	break;  case OpCode.StoreA:  	stackPointer++;  	for (int i = 0; i < instr.ByteArg2; i++)  		memory [instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  	stackPointer--;  	break;  case OpCode.StoreR:  	stackPointer++;  	for (int i = 0; i < instr.ByteArg2; i++)  		memory [framePointer + instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  	stackPointer--;  	break;  case OpCode.StoreM:  	stackPointer++;  	for (int i = 0; i < instr.ByteArg2; i++)  		memory [memory [framePointer - 3] + instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  	stackPointer--;  	break;  case OpCode.Jump:  	programCounter = instr.ShortArg;  	break;  case OpCode.JumpZ:  	if (memory [stackPointer] == 0)  		programCounter = instr.ShortArg;  	stackPointer--;  	break;  case OpCode.JumpI:  	programCounter = instr.ShortArg + memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Add:  	memory [stackPointer - 1] = memory [stackPointer - 1] + memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Sub:  	memory [stackPointer - 1] = memory [stackPointer - 1] - memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Mul:  	memory [stackPointer - 1] = memory [stackPointer - 1] * memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Div:  	memory [stackPointer - 1] = memory [stackPointer - 1] / memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Mod:  	memory [stackPointer - 1] = memory [stackPointer - 1] % memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Neg:  	memory [stackPointer] = -memory [stackPointer];  	break;  case OpCode.Eq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] == memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Neq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] != memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Le:  	memory [stackPointer - 1] = (memory [stackPointer - 1] < memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Leq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] <= memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Gr:  	memory [stackPointer - 1] = (memory [stackPointer - 1] > memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Geq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] >= memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.And:  	memory [stackPointer - 1] = (memory [stackPointer - 1] != 0 && memory [stackPointer] != 0) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Or:  	memory [stackPointer - 1] = (memory [stackPointer - 1] != 0 || memory [stackPointer] != 0) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Not:  	memory [stackPointer] = (memory [stackPointer] == 0) ? 1 : 0;  	break;  case OpCode.Mark:  	memory [stackPointer + 1] = extremePointer;  	memory [stackPointer + 2] = framePointer;  	stackPointer += 2;  	break;  case OpCode.Call:  	framePointer = stackPointer;  	int tmp = programCounter;  	programCounter = memory [stackPointer];  	memory [stackPointer] = tmp;  	break;  case OpCode.Enter:  	extremePointer = stackPointer + instr.ByteArg1;  	if (extremePointer >= heapPointer)  		throw new StackOverflowException ();  	break;  case OpCode.Alloc:  	stackPointer += instr.ByteArg1;  	break;  case OpCode.Slide:  	if (instr.ByteArg1 > 0) {  		if (instr.ByteArg2 == 0)  			stackPointer -= instr.ByteArg1;  		else {  			stackPointer -= instr.ByteArg1 + instr.ByteArg2;  			for (int i = 0; i < instr.ByteArg2; i++) {  				stackPointer++;  				memory [stackPointer] = memory [stackPointer + instr.ByteArg1];  			}  		}  	}  	break;  case OpCode.Return:  	programCounter = memory [framePointer];  	extremePointer = memory [framePointer - 2];  	if (extremePointer >= heapPointer)  		throw new StackOverflowException ();  	stackPointer = framePointer - instr.ByteArg1;  	framePointer = memory [framePointer - 1];  	break;  case OpCode.New:  	if (heapPointer - memory [stackPointer] > extremePointer) {  		heapPointer = heapPointer - memory [stackPointer];  		memory [stackPointer] = heapPointer;  	}  	else  		memory [stackPointer] = 0;  	//out of memory  	break;  case OpCode.Nop:  	//do nothing...  	break;  case OpCode.Halt:  	//do nothing' will be handled by main excecution cycle  	break;  default:  	throw new InvalidOpCodeException ("An unknown opcode was found. OpCode: " + instr.OpCode);  }  
Magic Number,SimpleC.Excecution,Excecutor,C:\repos\nrother_simple-c\SimpleC\Excecution\Excecutor.cs,exceuteInstruction,The following statement contains a magic number: switch (instr.OpCode) {  case OpCode.LoadC:  	stackPointer++;  	memory [stackPointer] = instr.ShortArg;  	break;  case OpCode.Load:  	for (int i = instr.ByteArg1 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [memory [stackPointer] + i];  	stackPointer += instr.ByteArg1 - 1;  	break;  case OpCode.LoadA:  	stackPointer++;  	for (int i = instr.ByteArg2 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [instr.ByteArg1 + i];  	stackPointer += instr.ByteArg2 - 1;  	break;  case OpCode.Dup:  	memory [stackPointer + 1] = memory [stackPointer];  	stackPointer++;  	break;  case OpCode.LoadRc:  	stackPointer++;  	memory [stackPointer] = framePointer + instr.ShortArg;  	break;  case OpCode.LoadR:  	stackPointer++;  	for (int i = instr.ByteArg2 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [framePointer + instr.ByteArg1 + i];  	stackPointer += instr.ByteArg2 - 1;  	break;  case OpCode.LoadMc:  	stackPointer++;  	memory [stackPointer] = memory [framePointer - 3] + instr.ByteArg1;  	break;  case OpCode.LoadM:  	stackPointer++;  	for (int i = instr.ByteArg2 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [memory [framePointer - 3] + instr.ByteArg1];  	stackPointer += instr.ByteArg2 - 1;  	break;  case OpCode.LoadV:  	memory [stackPointer + 1] = memory [memory [memory [stackPointer - 2]] + instr.ByteArg1];  	stackPointer++;  	break;  case OpCode.LoadSc:  	memory [stackPointer + 1] = stackPointer - instr.ByteArg1;  	stackPointer++;  	break;  case OpCode.LoadS:  	stackPointer++;  	memory [stackPointer] = memory [stackPointer - instr.ByteArg1];  	break;  case OpCode.Pop:  	stackPointer -= instr.ByteArg1;  	break;  case OpCode.Store:  	for (int i = 0; i < instr.ByteArg1; i++)  		memory [memory [stackPointer] + i] = memory [stackPointer - instr.ByteArg1 + i];  	stackPointer--;  	break;  case OpCode.StoreA:  	stackPointer++;  	for (int i = 0; i < instr.ByteArg2; i++)  		memory [instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  	stackPointer--;  	break;  case OpCode.StoreR:  	stackPointer++;  	for (int i = 0; i < instr.ByteArg2; i++)  		memory [framePointer + instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  	stackPointer--;  	break;  case OpCode.StoreM:  	stackPointer++;  	for (int i = 0; i < instr.ByteArg2; i++)  		memory [memory [framePointer - 3] + instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  	stackPointer--;  	break;  case OpCode.Jump:  	programCounter = instr.ShortArg;  	break;  case OpCode.JumpZ:  	if (memory [stackPointer] == 0)  		programCounter = instr.ShortArg;  	stackPointer--;  	break;  case OpCode.JumpI:  	programCounter = instr.ShortArg + memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Add:  	memory [stackPointer - 1] = memory [stackPointer - 1] + memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Sub:  	memory [stackPointer - 1] = memory [stackPointer - 1] - memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Mul:  	memory [stackPointer - 1] = memory [stackPointer - 1] * memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Div:  	memory [stackPointer - 1] = memory [stackPointer - 1] / memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Mod:  	memory [stackPointer - 1] = memory [stackPointer - 1] % memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Neg:  	memory [stackPointer] = -memory [stackPointer];  	break;  case OpCode.Eq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] == memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Neq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] != memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Le:  	memory [stackPointer - 1] = (memory [stackPointer - 1] < memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Leq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] <= memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Gr:  	memory [stackPointer - 1] = (memory [stackPointer - 1] > memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Geq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] >= memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.And:  	memory [stackPointer - 1] = (memory [stackPointer - 1] != 0 && memory [stackPointer] != 0) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Or:  	memory [stackPointer - 1] = (memory [stackPointer - 1] != 0 || memory [stackPointer] != 0) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Not:  	memory [stackPointer] = (memory [stackPointer] == 0) ? 1 : 0;  	break;  case OpCode.Mark:  	memory [stackPointer + 1] = extremePointer;  	memory [stackPointer + 2] = framePointer;  	stackPointer += 2;  	break;  case OpCode.Call:  	framePointer = stackPointer;  	int tmp = programCounter;  	programCounter = memory [stackPointer];  	memory [stackPointer] = tmp;  	break;  case OpCode.Enter:  	extremePointer = stackPointer + instr.ByteArg1;  	if (extremePointer >= heapPointer)  		throw new StackOverflowException ();  	break;  case OpCode.Alloc:  	stackPointer += instr.ByteArg1;  	break;  case OpCode.Slide:  	if (instr.ByteArg1 > 0) {  		if (instr.ByteArg2 == 0)  			stackPointer -= instr.ByteArg1;  		else {  			stackPointer -= instr.ByteArg1 + instr.ByteArg2;  			for (int i = 0; i < instr.ByteArg2; i++) {  				stackPointer++;  				memory [stackPointer] = memory [stackPointer + instr.ByteArg1];  			}  		}  	}  	break;  case OpCode.Return:  	programCounter = memory [framePointer];  	extremePointer = memory [framePointer - 2];  	if (extremePointer >= heapPointer)  		throw new StackOverflowException ();  	stackPointer = framePointer - instr.ByteArg1;  	framePointer = memory [framePointer - 1];  	break;  case OpCode.New:  	if (heapPointer - memory [stackPointer] > extremePointer) {  		heapPointer = heapPointer - memory [stackPointer];  		memory [stackPointer] = heapPointer;  	}  	else  		memory [stackPointer] = 0;  	//out of memory  	break;  case OpCode.Nop:  	//do nothing...  	break;  case OpCode.Halt:  	//do nothing' will be handled by main excecution cycle  	break;  default:  	throw new InvalidOpCodeException ("An unknown opcode was found. OpCode: " + instr.OpCode);  }  
Magic Number,SimpleC.Excecution,Excecutor,C:\repos\nrother_simple-c\SimpleC\Excecution\Excecutor.cs,exceuteInstruction,The following statement contains a magic number: switch (instr.OpCode) {  case OpCode.LoadC:  	stackPointer++;  	memory [stackPointer] = instr.ShortArg;  	break;  case OpCode.Load:  	for (int i = instr.ByteArg1 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [memory [stackPointer] + i];  	stackPointer += instr.ByteArg1 - 1;  	break;  case OpCode.LoadA:  	stackPointer++;  	for (int i = instr.ByteArg2 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [instr.ByteArg1 + i];  	stackPointer += instr.ByteArg2 - 1;  	break;  case OpCode.Dup:  	memory [stackPointer + 1] = memory [stackPointer];  	stackPointer++;  	break;  case OpCode.LoadRc:  	stackPointer++;  	memory [stackPointer] = framePointer + instr.ShortArg;  	break;  case OpCode.LoadR:  	stackPointer++;  	for (int i = instr.ByteArg2 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [framePointer + instr.ByteArg1 + i];  	stackPointer += instr.ByteArg2 - 1;  	break;  case OpCode.LoadMc:  	stackPointer++;  	memory [stackPointer] = memory [framePointer - 3] + instr.ByteArg1;  	break;  case OpCode.LoadM:  	stackPointer++;  	for (int i = instr.ByteArg2 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [memory [framePointer - 3] + instr.ByteArg1];  	stackPointer += instr.ByteArg2 - 1;  	break;  case OpCode.LoadV:  	memory [stackPointer + 1] = memory [memory [memory [stackPointer - 2]] + instr.ByteArg1];  	stackPointer++;  	break;  case OpCode.LoadSc:  	memory [stackPointer + 1] = stackPointer - instr.ByteArg1;  	stackPointer++;  	break;  case OpCode.LoadS:  	stackPointer++;  	memory [stackPointer] = memory [stackPointer - instr.ByteArg1];  	break;  case OpCode.Pop:  	stackPointer -= instr.ByteArg1;  	break;  case OpCode.Store:  	for (int i = 0; i < instr.ByteArg1; i++)  		memory [memory [stackPointer] + i] = memory [stackPointer - instr.ByteArg1 + i];  	stackPointer--;  	break;  case OpCode.StoreA:  	stackPointer++;  	for (int i = 0; i < instr.ByteArg2; i++)  		memory [instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  	stackPointer--;  	break;  case OpCode.StoreR:  	stackPointer++;  	for (int i = 0; i < instr.ByteArg2; i++)  		memory [framePointer + instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  	stackPointer--;  	break;  case OpCode.StoreM:  	stackPointer++;  	for (int i = 0; i < instr.ByteArg2; i++)  		memory [memory [framePointer - 3] + instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  	stackPointer--;  	break;  case OpCode.Jump:  	programCounter = instr.ShortArg;  	break;  case OpCode.JumpZ:  	if (memory [stackPointer] == 0)  		programCounter = instr.ShortArg;  	stackPointer--;  	break;  case OpCode.JumpI:  	programCounter = instr.ShortArg + memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Add:  	memory [stackPointer - 1] = memory [stackPointer - 1] + memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Sub:  	memory [stackPointer - 1] = memory [stackPointer - 1] - memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Mul:  	memory [stackPointer - 1] = memory [stackPointer - 1] * memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Div:  	memory [stackPointer - 1] = memory [stackPointer - 1] / memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Mod:  	memory [stackPointer - 1] = memory [stackPointer - 1] % memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Neg:  	memory [stackPointer] = -memory [stackPointer];  	break;  case OpCode.Eq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] == memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Neq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] != memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Le:  	memory [stackPointer - 1] = (memory [stackPointer - 1] < memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Leq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] <= memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Gr:  	memory [stackPointer - 1] = (memory [stackPointer - 1] > memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Geq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] >= memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.And:  	memory [stackPointer - 1] = (memory [stackPointer - 1] != 0 && memory [stackPointer] != 0) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Or:  	memory [stackPointer - 1] = (memory [stackPointer - 1] != 0 || memory [stackPointer] != 0) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Not:  	memory [stackPointer] = (memory [stackPointer] == 0) ? 1 : 0;  	break;  case OpCode.Mark:  	memory [stackPointer + 1] = extremePointer;  	memory [stackPointer + 2] = framePointer;  	stackPointer += 2;  	break;  case OpCode.Call:  	framePointer = stackPointer;  	int tmp = programCounter;  	programCounter = memory [stackPointer];  	memory [stackPointer] = tmp;  	break;  case OpCode.Enter:  	extremePointer = stackPointer + instr.ByteArg1;  	if (extremePointer >= heapPointer)  		throw new StackOverflowException ();  	break;  case OpCode.Alloc:  	stackPointer += instr.ByteArg1;  	break;  case OpCode.Slide:  	if (instr.ByteArg1 > 0) {  		if (instr.ByteArg2 == 0)  			stackPointer -= instr.ByteArg1;  		else {  			stackPointer -= instr.ByteArg1 + instr.ByteArg2;  			for (int i = 0; i < instr.ByteArg2; i++) {  				stackPointer++;  				memory [stackPointer] = memory [stackPointer + instr.ByteArg1];  			}  		}  	}  	break;  case OpCode.Return:  	programCounter = memory [framePointer];  	extremePointer = memory [framePointer - 2];  	if (extremePointer >= heapPointer)  		throw new StackOverflowException ();  	stackPointer = framePointer - instr.ByteArg1;  	framePointer = memory [framePointer - 1];  	break;  case OpCode.New:  	if (heapPointer - memory [stackPointer] > extremePointer) {  		heapPointer = heapPointer - memory [stackPointer];  		memory [stackPointer] = heapPointer;  	}  	else  		memory [stackPointer] = 0;  	//out of memory  	break;  case OpCode.Nop:  	//do nothing...  	break;  case OpCode.Halt:  	//do nothing' will be handled by main excecution cycle  	break;  default:  	throw new InvalidOpCodeException ("An unknown opcode was found. OpCode: " + instr.OpCode);  }  
Magic Number,SimpleC.Excecution,Excecutor,C:\repos\nrother_simple-c\SimpleC\Excecution\Excecutor.cs,exceuteInstruction,The following statement contains a magic number: switch (instr.OpCode) {  case OpCode.LoadC:  	stackPointer++;  	memory [stackPointer] = instr.ShortArg;  	break;  case OpCode.Load:  	for (int i = instr.ByteArg1 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [memory [stackPointer] + i];  	stackPointer += instr.ByteArg1 - 1;  	break;  case OpCode.LoadA:  	stackPointer++;  	for (int i = instr.ByteArg2 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [instr.ByteArg1 + i];  	stackPointer += instr.ByteArg2 - 1;  	break;  case OpCode.Dup:  	memory [stackPointer + 1] = memory [stackPointer];  	stackPointer++;  	break;  case OpCode.LoadRc:  	stackPointer++;  	memory [stackPointer] = framePointer + instr.ShortArg;  	break;  case OpCode.LoadR:  	stackPointer++;  	for (int i = instr.ByteArg2 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [framePointer + instr.ByteArg1 + i];  	stackPointer += instr.ByteArg2 - 1;  	break;  case OpCode.LoadMc:  	stackPointer++;  	memory [stackPointer] = memory [framePointer - 3] + instr.ByteArg1;  	break;  case OpCode.LoadM:  	stackPointer++;  	for (int i = instr.ByteArg2 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [memory [framePointer - 3] + instr.ByteArg1];  	stackPointer += instr.ByteArg2 - 1;  	break;  case OpCode.LoadV:  	memory [stackPointer + 1] = memory [memory [memory [stackPointer - 2]] + instr.ByteArg1];  	stackPointer++;  	break;  case OpCode.LoadSc:  	memory [stackPointer + 1] = stackPointer - instr.ByteArg1;  	stackPointer++;  	break;  case OpCode.LoadS:  	stackPointer++;  	memory [stackPointer] = memory [stackPointer - instr.ByteArg1];  	break;  case OpCode.Pop:  	stackPointer -= instr.ByteArg1;  	break;  case OpCode.Store:  	for (int i = 0; i < instr.ByteArg1; i++)  		memory [memory [stackPointer] + i] = memory [stackPointer - instr.ByteArg1 + i];  	stackPointer--;  	break;  case OpCode.StoreA:  	stackPointer++;  	for (int i = 0; i < instr.ByteArg2; i++)  		memory [instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  	stackPointer--;  	break;  case OpCode.StoreR:  	stackPointer++;  	for (int i = 0; i < instr.ByteArg2; i++)  		memory [framePointer + instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  	stackPointer--;  	break;  case OpCode.StoreM:  	stackPointer++;  	for (int i = 0; i < instr.ByteArg2; i++)  		memory [memory [framePointer - 3] + instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  	stackPointer--;  	break;  case OpCode.Jump:  	programCounter = instr.ShortArg;  	break;  case OpCode.JumpZ:  	if (memory [stackPointer] == 0)  		programCounter = instr.ShortArg;  	stackPointer--;  	break;  case OpCode.JumpI:  	programCounter = instr.ShortArg + memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Add:  	memory [stackPointer - 1] = memory [stackPointer - 1] + memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Sub:  	memory [stackPointer - 1] = memory [stackPointer - 1] - memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Mul:  	memory [stackPointer - 1] = memory [stackPointer - 1] * memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Div:  	memory [stackPointer - 1] = memory [stackPointer - 1] / memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Mod:  	memory [stackPointer - 1] = memory [stackPointer - 1] % memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Neg:  	memory [stackPointer] = -memory [stackPointer];  	break;  case OpCode.Eq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] == memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Neq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] != memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Le:  	memory [stackPointer - 1] = (memory [stackPointer - 1] < memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Leq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] <= memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Gr:  	memory [stackPointer - 1] = (memory [stackPointer - 1] > memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Geq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] >= memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.And:  	memory [stackPointer - 1] = (memory [stackPointer - 1] != 0 && memory [stackPointer] != 0) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Or:  	memory [stackPointer - 1] = (memory [stackPointer - 1] != 0 || memory [stackPointer] != 0) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Not:  	memory [stackPointer] = (memory [stackPointer] == 0) ? 1 : 0;  	break;  case OpCode.Mark:  	memory [stackPointer + 1] = extremePointer;  	memory [stackPointer + 2] = framePointer;  	stackPointer += 2;  	break;  case OpCode.Call:  	framePointer = stackPointer;  	int tmp = programCounter;  	programCounter = memory [stackPointer];  	memory [stackPointer] = tmp;  	break;  case OpCode.Enter:  	extremePointer = stackPointer + instr.ByteArg1;  	if (extremePointer >= heapPointer)  		throw new StackOverflowException ();  	break;  case OpCode.Alloc:  	stackPointer += instr.ByteArg1;  	break;  case OpCode.Slide:  	if (instr.ByteArg1 > 0) {  		if (instr.ByteArg2 == 0)  			stackPointer -= instr.ByteArg1;  		else {  			stackPointer -= instr.ByteArg1 + instr.ByteArg2;  			for (int i = 0; i < instr.ByteArg2; i++) {  				stackPointer++;  				memory [stackPointer] = memory [stackPointer + instr.ByteArg1];  			}  		}  	}  	break;  case OpCode.Return:  	programCounter = memory [framePointer];  	extremePointer = memory [framePointer - 2];  	if (extremePointer >= heapPointer)  		throw new StackOverflowException ();  	stackPointer = framePointer - instr.ByteArg1;  	framePointer = memory [framePointer - 1];  	break;  case OpCode.New:  	if (heapPointer - memory [stackPointer] > extremePointer) {  		heapPointer = heapPointer - memory [stackPointer];  		memory [stackPointer] = heapPointer;  	}  	else  		memory [stackPointer] = 0;  	//out of memory  	break;  case OpCode.Nop:  	//do nothing...  	break;  case OpCode.Halt:  	//do nothing' will be handled by main excecution cycle  	break;  default:  	throw new InvalidOpCodeException ("An unknown opcode was found. OpCode: " + instr.OpCode);  }  
Magic Number,SimpleC.Excecution,Excecutor,C:\repos\nrother_simple-c\SimpleC\Excecution\Excecutor.cs,exceuteInstruction,The following statement contains a magic number: switch (instr.OpCode) {  case OpCode.LoadC:  	stackPointer++;  	memory [stackPointer] = instr.ShortArg;  	break;  case OpCode.Load:  	for (int i = instr.ByteArg1 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [memory [stackPointer] + i];  	stackPointer += instr.ByteArg1 - 1;  	break;  case OpCode.LoadA:  	stackPointer++;  	for (int i = instr.ByteArg2 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [instr.ByteArg1 + i];  	stackPointer += instr.ByteArg2 - 1;  	break;  case OpCode.Dup:  	memory [stackPointer + 1] = memory [stackPointer];  	stackPointer++;  	break;  case OpCode.LoadRc:  	stackPointer++;  	memory [stackPointer] = framePointer + instr.ShortArg;  	break;  case OpCode.LoadR:  	stackPointer++;  	for (int i = instr.ByteArg2 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [framePointer + instr.ByteArg1 + i];  	stackPointer += instr.ByteArg2 - 1;  	break;  case OpCode.LoadMc:  	stackPointer++;  	memory [stackPointer] = memory [framePointer - 3] + instr.ByteArg1;  	break;  case OpCode.LoadM:  	stackPointer++;  	for (int i = instr.ByteArg2 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [memory [framePointer - 3] + instr.ByteArg1];  	stackPointer += instr.ByteArg2 - 1;  	break;  case OpCode.LoadV:  	memory [stackPointer + 1] = memory [memory [memory [stackPointer - 2]] + instr.ByteArg1];  	stackPointer++;  	break;  case OpCode.LoadSc:  	memory [stackPointer + 1] = stackPointer - instr.ByteArg1;  	stackPointer++;  	break;  case OpCode.LoadS:  	stackPointer++;  	memory [stackPointer] = memory [stackPointer - instr.ByteArg1];  	break;  case OpCode.Pop:  	stackPointer -= instr.ByteArg1;  	break;  case OpCode.Store:  	for (int i = 0; i < instr.ByteArg1; i++)  		memory [memory [stackPointer] + i] = memory [stackPointer - instr.ByteArg1 + i];  	stackPointer--;  	break;  case OpCode.StoreA:  	stackPointer++;  	for (int i = 0; i < instr.ByteArg2; i++)  		memory [instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  	stackPointer--;  	break;  case OpCode.StoreR:  	stackPointer++;  	for (int i = 0; i < instr.ByteArg2; i++)  		memory [framePointer + instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  	stackPointer--;  	break;  case OpCode.StoreM:  	stackPointer++;  	for (int i = 0; i < instr.ByteArg2; i++)  		memory [memory [framePointer - 3] + instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  	stackPointer--;  	break;  case OpCode.Jump:  	programCounter = instr.ShortArg;  	break;  case OpCode.JumpZ:  	if (memory [stackPointer] == 0)  		programCounter = instr.ShortArg;  	stackPointer--;  	break;  case OpCode.JumpI:  	programCounter = instr.ShortArg + memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Add:  	memory [stackPointer - 1] = memory [stackPointer - 1] + memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Sub:  	memory [stackPointer - 1] = memory [stackPointer - 1] - memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Mul:  	memory [stackPointer - 1] = memory [stackPointer - 1] * memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Div:  	memory [stackPointer - 1] = memory [stackPointer - 1] / memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Mod:  	memory [stackPointer - 1] = memory [stackPointer - 1] % memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Neg:  	memory [stackPointer] = -memory [stackPointer];  	break;  case OpCode.Eq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] == memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Neq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] != memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Le:  	memory [stackPointer - 1] = (memory [stackPointer - 1] < memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Leq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] <= memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Gr:  	memory [stackPointer - 1] = (memory [stackPointer - 1] > memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Geq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] >= memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.And:  	memory [stackPointer - 1] = (memory [stackPointer - 1] != 0 && memory [stackPointer] != 0) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Or:  	memory [stackPointer - 1] = (memory [stackPointer - 1] != 0 || memory [stackPointer] != 0) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Not:  	memory [stackPointer] = (memory [stackPointer] == 0) ? 1 : 0;  	break;  case OpCode.Mark:  	memory [stackPointer + 1] = extremePointer;  	memory [stackPointer + 2] = framePointer;  	stackPointer += 2;  	break;  case OpCode.Call:  	framePointer = stackPointer;  	int tmp = programCounter;  	programCounter = memory [stackPointer];  	memory [stackPointer] = tmp;  	break;  case OpCode.Enter:  	extremePointer = stackPointer + instr.ByteArg1;  	if (extremePointer >= heapPointer)  		throw new StackOverflowException ();  	break;  case OpCode.Alloc:  	stackPointer += instr.ByteArg1;  	break;  case OpCode.Slide:  	if (instr.ByteArg1 > 0) {  		if (instr.ByteArg2 == 0)  			stackPointer -= instr.ByteArg1;  		else {  			stackPointer -= instr.ByteArg1 + instr.ByteArg2;  			for (int i = 0; i < instr.ByteArg2; i++) {  				stackPointer++;  				memory [stackPointer] = memory [stackPointer + instr.ByteArg1];  			}  		}  	}  	break;  case OpCode.Return:  	programCounter = memory [framePointer];  	extremePointer = memory [framePointer - 2];  	if (extremePointer >= heapPointer)  		throw new StackOverflowException ();  	stackPointer = framePointer - instr.ByteArg1;  	framePointer = memory [framePointer - 1];  	break;  case OpCode.New:  	if (heapPointer - memory [stackPointer] > extremePointer) {  		heapPointer = heapPointer - memory [stackPointer];  		memory [stackPointer] = heapPointer;  	}  	else  		memory [stackPointer] = 0;  	//out of memory  	break;  case OpCode.Nop:  	//do nothing...  	break;  case OpCode.Halt:  	//do nothing' will be handled by main excecution cycle  	break;  default:  	throw new InvalidOpCodeException ("An unknown opcode was found. OpCode: " + instr.OpCode);  }  
Magic Number,SimpleC.Excecution,Excecutor,C:\repos\nrother_simple-c\SimpleC\Excecution\Excecutor.cs,exceuteInstruction,The following statement contains a magic number: switch (instr.OpCode) {  case OpCode.LoadC:  	stackPointer++;  	memory [stackPointer] = instr.ShortArg;  	break;  case OpCode.Load:  	for (int i = instr.ByteArg1 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [memory [stackPointer] + i];  	stackPointer += instr.ByteArg1 - 1;  	break;  case OpCode.LoadA:  	stackPointer++;  	for (int i = instr.ByteArg2 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [instr.ByteArg1 + i];  	stackPointer += instr.ByteArg2 - 1;  	break;  case OpCode.Dup:  	memory [stackPointer + 1] = memory [stackPointer];  	stackPointer++;  	break;  case OpCode.LoadRc:  	stackPointer++;  	memory [stackPointer] = framePointer + instr.ShortArg;  	break;  case OpCode.LoadR:  	stackPointer++;  	for (int i = instr.ByteArg2 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [framePointer + instr.ByteArg1 + i];  	stackPointer += instr.ByteArg2 - 1;  	break;  case OpCode.LoadMc:  	stackPointer++;  	memory [stackPointer] = memory [framePointer - 3] + instr.ByteArg1;  	break;  case OpCode.LoadM:  	stackPointer++;  	for (int i = instr.ByteArg2 - 1; i >= 0; i--)  		memory [stackPointer + i] = memory [memory [framePointer - 3] + instr.ByteArg1];  	stackPointer += instr.ByteArg2 - 1;  	break;  case OpCode.LoadV:  	memory [stackPointer + 1] = memory [memory [memory [stackPointer - 2]] + instr.ByteArg1];  	stackPointer++;  	break;  case OpCode.LoadSc:  	memory [stackPointer + 1] = stackPointer - instr.ByteArg1;  	stackPointer++;  	break;  case OpCode.LoadS:  	stackPointer++;  	memory [stackPointer] = memory [stackPointer - instr.ByteArg1];  	break;  case OpCode.Pop:  	stackPointer -= instr.ByteArg1;  	break;  case OpCode.Store:  	for (int i = 0; i < instr.ByteArg1; i++)  		memory [memory [stackPointer] + i] = memory [stackPointer - instr.ByteArg1 + i];  	stackPointer--;  	break;  case OpCode.StoreA:  	stackPointer++;  	for (int i = 0; i < instr.ByteArg2; i++)  		memory [instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  	stackPointer--;  	break;  case OpCode.StoreR:  	stackPointer++;  	for (int i = 0; i < instr.ByteArg2; i++)  		memory [framePointer + instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  	stackPointer--;  	break;  case OpCode.StoreM:  	stackPointer++;  	for (int i = 0; i < instr.ByteArg2; i++)  		memory [memory [framePointer - 3] + instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  	stackPointer--;  	break;  case OpCode.Jump:  	programCounter = instr.ShortArg;  	break;  case OpCode.JumpZ:  	if (memory [stackPointer] == 0)  		programCounter = instr.ShortArg;  	stackPointer--;  	break;  case OpCode.JumpI:  	programCounter = instr.ShortArg + memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Add:  	memory [stackPointer - 1] = memory [stackPointer - 1] + memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Sub:  	memory [stackPointer - 1] = memory [stackPointer - 1] - memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Mul:  	memory [stackPointer - 1] = memory [stackPointer - 1] * memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Div:  	memory [stackPointer - 1] = memory [stackPointer - 1] / memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Mod:  	memory [stackPointer - 1] = memory [stackPointer - 1] % memory [stackPointer];  	stackPointer--;  	break;  case OpCode.Neg:  	memory [stackPointer] = -memory [stackPointer];  	break;  case OpCode.Eq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] == memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Neq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] != memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Le:  	memory [stackPointer - 1] = (memory [stackPointer - 1] < memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Leq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] <= memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Gr:  	memory [stackPointer - 1] = (memory [stackPointer - 1] > memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Geq:  	memory [stackPointer - 1] = (memory [stackPointer - 1] >= memory [stackPointer]) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.And:  	memory [stackPointer - 1] = (memory [stackPointer - 1] != 0 && memory [stackPointer] != 0) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Or:  	memory [stackPointer - 1] = (memory [stackPointer - 1] != 0 || memory [stackPointer] != 0) ? 1 : 0;  	stackPointer--;  	break;  case OpCode.Not:  	memory [stackPointer] = (memory [stackPointer] == 0) ? 1 : 0;  	break;  case OpCode.Mark:  	memory [stackPointer + 1] = extremePointer;  	memory [stackPointer + 2] = framePointer;  	stackPointer += 2;  	break;  case OpCode.Call:  	framePointer = stackPointer;  	int tmp = programCounter;  	programCounter = memory [stackPointer];  	memory [stackPointer] = tmp;  	break;  case OpCode.Enter:  	extremePointer = stackPointer + instr.ByteArg1;  	if (extremePointer >= heapPointer)  		throw new StackOverflowException ();  	break;  case OpCode.Alloc:  	stackPointer += instr.ByteArg1;  	break;  case OpCode.Slide:  	if (instr.ByteArg1 > 0) {  		if (instr.ByteArg2 == 0)  			stackPointer -= instr.ByteArg1;  		else {  			stackPointer -= instr.ByteArg1 + instr.ByteArg2;  			for (int i = 0; i < instr.ByteArg2; i++) {  				stackPointer++;  				memory [stackPointer] = memory [stackPointer + instr.ByteArg1];  			}  		}  	}  	break;  case OpCode.Return:  	programCounter = memory [framePointer];  	extremePointer = memory [framePointer - 2];  	if (extremePointer >= heapPointer)  		throw new StackOverflowException ();  	stackPointer = framePointer - instr.ByteArg1;  	framePointer = memory [framePointer - 1];  	break;  case OpCode.New:  	if (heapPointer - memory [stackPointer] > extremePointer) {  		heapPointer = heapPointer - memory [stackPointer];  		memory [stackPointer] = heapPointer;  	}  	else  		memory [stackPointer] = 0;  	//out of memory  	break;  case OpCode.Nop:  	//do nothing...  	break;  case OpCode.Halt:  	//do nothing' will be handled by main excecution cycle  	break;  default:  	throw new InvalidOpCodeException ("An unknown opcode was found. OpCode: " + instr.OpCode);  }  
Magic Number,SimpleC.Excecution,Excecutor,C:\repos\nrother_simple-c\SimpleC\Excecution\Excecutor.cs,exceuteInstruction,The following statement contains a magic number: memory [stackPointer] = memory [framePointer - 3] + instr.ByteArg1;  
Magic Number,SimpleC.Excecution,Excecutor,C:\repos\nrother_simple-c\SimpleC\Excecution\Excecutor.cs,exceuteInstruction,The following statement contains a magic number: for (int i = instr.ByteArg2 - 1; i >= 0; i--)  	memory [stackPointer + i] = memory [memory [framePointer - 3] + instr.ByteArg1];  
Magic Number,SimpleC.Excecution,Excecutor,C:\repos\nrother_simple-c\SimpleC\Excecution\Excecutor.cs,exceuteInstruction,The following statement contains a magic number: memory [stackPointer + i] = memory [memory [framePointer - 3] + instr.ByteArg1];  
Magic Number,SimpleC.Excecution,Excecutor,C:\repos\nrother_simple-c\SimpleC\Excecution\Excecutor.cs,exceuteInstruction,The following statement contains a magic number: memory [stackPointer + 1] = memory [memory [memory [stackPointer - 2]] + instr.ByteArg1];  
Magic Number,SimpleC.Excecution,Excecutor,C:\repos\nrother_simple-c\SimpleC\Excecution\Excecutor.cs,exceuteInstruction,The following statement contains a magic number: for (int i = 0; i < instr.ByteArg2; i++)  	memory [memory [framePointer - 3] + instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  
Magic Number,SimpleC.Excecution,Excecutor,C:\repos\nrother_simple-c\SimpleC\Excecution\Excecutor.cs,exceuteInstruction,The following statement contains a magic number: memory [memory [framePointer - 3] + instr.ByteArg1 + i] = memory [stackPointer - instr.ByteArg2 + i];  
Magic Number,SimpleC.Excecution,Excecutor,C:\repos\nrother_simple-c\SimpleC\Excecution\Excecutor.cs,exceuteInstruction,The following statement contains a magic number: memory [stackPointer + 2] = framePointer;  
Magic Number,SimpleC.Excecution,Excecutor,C:\repos\nrother_simple-c\SimpleC\Excecution\Excecutor.cs,exceuteInstruction,The following statement contains a magic number: stackPointer += 2;  
Magic Number,SimpleC.Excecution,Excecutor,C:\repos\nrother_simple-c\SimpleC\Excecution\Excecutor.cs,exceuteInstruction,The following statement contains a magic number: extremePointer = memory [framePointer - 2];  
Missing Default,SimpleC.Lexing,Tokenizer,C:\repos\nrother_simple-c\SimpleC\Lexing\Tokenizer.cs,charTypeOf,The following switch statement is missing a default case: switch (c) {  case '+':  case '-':  case '*':  case '/':  case '%':  case '&':  case '|':  case '=':  	return CharType.Operator;  case '(':  case '[':  case '{':  	return CharType.OpenBrace;  case ')':  case ']':  case '}':  	return CharType.CloseBrace;  case ''':  	return CharType.ArgSeperator;  case ';':  	return CharType.StatementSeperator;  case '\r':  //\r and \n have UnicodeCategory.Control' not LineSeperator...  case '\n':  	return CharType.NewLine;  }  
Missing Default,SimpleC.Lexing,Tokenizer,C:\repos\nrother_simple-c\SimpleC\Lexing\Tokenizer.cs,charTypeOf,The following switch statement is missing a default case: switch (char.GetUnicodeCategory (c)) {  case UnicodeCategory.DecimalDigitNumber:  	return CharType.Numeric;  case UnicodeCategory.LineSeparator:  	//just in case... (see above)  	return CharType.NewLine;  case UnicodeCategory.ParagraphSeparator:  case UnicodeCategory.LowercaseLetter:  case UnicodeCategory.OtherLetter:  case UnicodeCategory.UppercaseLetter:  	return CharType.Alpha;  case UnicodeCategory.SpaceSeparator:  	return CharType.LineSpace;  }  
