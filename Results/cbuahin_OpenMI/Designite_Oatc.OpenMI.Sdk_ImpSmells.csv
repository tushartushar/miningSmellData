Implementation smell,Namespace,Class,File,Method,Description
Long Method,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The method has 191 lines of code.
Long Method,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The method has 166 lines of code.
Long Method,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeStamp,The method has 108 lines of code.
Long Method,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The method has 459 lines of code.
Long Method,Oatc.OpenMI.Sdk.Spatial,SpatialAdaptedOutputFactory,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\SpatialAdaptedOutputFactory.cs,SpatialAdaptedOutputFactory,The method has 154 lines of code.
Long Method,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The method has 103 lines of code.
Complex Method,Oatc.OpenMI.Sdk.Backbone,Dimension,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Dimension.cs,Dimension,Cyclomatic complexity of the method is 32
Complex Method,Oatc.OpenMI.Sdk.Backbone,ExchangeItem,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ExchangeItem.cs,ComputeIndex,Cyclomatic complexity of the method is 9
Complex Method,Oatc.OpenMI.Sdk.Backbone,ExchangeItemHelper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ExchangeItemHelper.cs,OutputAndInputTimeSetsFit,Cyclomatic complexity of the method is 12
Complex Method,Oatc.OpenMI.Sdk.Backbone,ExchangeItemHelper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ExchangeItemHelper.cs,ConsumersCompatibleForTimeAndOrElementSet,Cyclomatic complexity of the method is 10
Complex Method,Oatc.OpenMI.Sdk.Backbone,ExchangeItemHelper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ExchangeItemHelper.cs,ProviderConsumerConnectableForTimeAndOrElementSet,Cyclomatic complexity of the method is 8
Complex Method,Oatc.OpenMI.Sdk.Backbone,Unit,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Unit.cs,Unit,Cyclomatic complexity of the method is 27
Complex Method,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,AddValuesToBuffer,Cyclomatic complexity of the method is 8
Complex Method,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,GetValues,Cyclomatic complexity of the method is 8
Complex Method,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,Cyclomatic complexity of the method is 30
Complex Method,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,Cyclomatic complexity of the method is 22
Complex Method,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeStamp,Cyclomatic complexity of the method is 13
Complex Method,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeStamp,Cyclomatic complexity of the method is 17
Complex Method,Oatc.OpenMI.Sdk.Buffer,TimeBufferer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\TimeBufferer.cs,GetValues,Cyclomatic complexity of the method is 9
Complex Method,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,Cyclomatic complexity of the method is 120
Complex Method,Oatc.OpenMI.Sdk.Spatial,ElementSetChecker,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementSetChecker.cs,CheckElementSet,Cyclomatic complexity of the method is 14
Complex Method,Oatc.OpenMI.Sdk.Spatial,Spatial2DGridWrapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\Spatial2DGridWrapper.cs,GetGridIndex,Cyclomatic complexity of the method is 19
Complex Method,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,CalculateSharedLength,Cyclomatic complexity of the method is 8
Complex Method,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,CalculateLengthOfLineInsidePolygon,Cyclomatic complexity of the method is 13
Complex Method,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,Cyclomatic complexity of the method is 12
Complex Method,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,Intersect,Cyclomatic complexity of the method is 12
Complex Method,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,IsPointInPolygon,Cyclomatic complexity of the method is 8
Complex Method,Oatc.OpenMI.Sdk.Spatial,XYPolygon,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYPolygon.cs,Validate,Cyclomatic complexity of the method is 8
Long Parameter List,Oatc.OpenMI.Sdk.Backbone,ExtensionMethods,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ExtensionMethods.cs,FindAdaptor,The method has 5 parameters.
Long Parameter List,Oatc.OpenMI.Sdk.DevelopmentSupport,ComponentConnector,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\DevelopmentSupport\ComponentConnector.cs,Connect,The method has 6 parameters.
Long Parameter List,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,DoLineSegmentsIntersect,The method has 8 parameters.
Long Parameter List,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,Intersect,The method has 6 parameters.
Long Statement,Oatc.OpenMI.Sdk.Backbone,ArgumentDateTime,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Argument.cs,SetValueFromString,The length of the statement  "	Value = DateTime.ParseExact (value' CultureInfo.InvariantCulture.DateTimeFormat.UniversalSortableDateTimePattern' CultureInfo.InvariantCulture); " is 144.
Long Statement,Oatc.OpenMI.Sdk.Backbone,ExchangeItemHelper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ExchangeItemHelper.cs,CheckProviderConsumerConnectable,The length of the statement  "		throw new Exception ("consumer \"" + consumer.Caption + "\" and provider \"" + provider.Caption + "\" are not connectable' put an adapted output in between"); " is 158.
Long Statement,Oatc.OpenMI.Sdk.Backbone,ExchangeItemHelper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ExchangeItemHelper.cs,CheckConsumersCompatible,The length of the statement  "		throw new Exception ("consumer \"" + newConsumer.Caption + "\" can not be added to \"" + outputItem.Caption + "\"' because it is incompatible with existing consumers"); " is 168.
Long Statement,Oatc.OpenMI.Sdk.Backbone,ExchangeItemHelper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ExchangeItemHelper.cs,OutputAndInputTimeSetsFit,The length of the statement  "					throw new Exception ("Error when checking if the times of AdaptedOutput \"" + provider.Id + " fits the times required by inputItem \"" + consumer.Id + "\": no time horizon available in the adaptedOutput"); " is 205.
Long Statement,Oatc.OpenMI.Sdk.Backbone,ExchangeItemHelper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ExchangeItemHelper.cs,OutputAndInputTimeSetsFit,The length of the statement  "						if ((requiredTimes [timeIndex].DurationInDays > 0 && !(sourceTimes [timeIndex].DurationInDays > 0)) || (sourceTimes [timeIndex].DurationInDays > 0 && !(requiredTimes [timeIndex].DurationInDays > 0))) { " is 201.
Long Statement,Oatc.OpenMI.Sdk.Backbone,ExchangeItemHelper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ExchangeItemHelper.cs,OutputAndInputTimeSetsFit,The length of the statement  "							throw new Exception ("Incompatible times (stamp versus span) between outputItem \"" + provider.Id + " and inputItem \"" + consumer.Id + "\""); " is 142.
Long Statement,Oatc.OpenMI.Sdk.Backbone,ExchangeItemHelper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ExchangeItemHelper.cs,CheckValueSizes,The length of the statement  "		throw new Exception ("ExchangeItem \"" + exchangeItem.Caption + "\": Wrong #times in valueSet (" + ValueSet.GetTimesCount (valueSet) + ")' expected #times (" + timesCount + ")"); " is 178.
Long Statement,Oatc.OpenMI.Sdk.Backbone,ExchangeItemHelper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ExchangeItemHelper.cs,CheckValueSizes,The length of the statement  "		throw new Exception ("ExchangeItem \"" + exchangeItem.Caption + "\": Wrong #times in valueSet (" + ValueSet.GetElementCount (valueSet) + ")' expected #times (" + elementCount + ")"); " is 182.
Long Statement,Oatc.OpenMI.Sdk.Backbone,ExchangeItemHelper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ExchangeItemHelper.cs,ConsumersCompatibleForTimeAndOrElementSet,The length of the statement  "			if (consumer.ElementSet () != null && outputItem.Consumers [0].ElementSet () != null && consumer.ElementSet ().ElementCount != outputItem.Consumers [0].ElementSet ().ElementCount) { " is 181.
Long Statement,Oatc.OpenMI.Sdk.Backbone,ExchangeItemHelper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ExchangeItemHelper.cs,ConsumersCompatibleForTimeAndOrElementSet,The length of the statement  "					if (consumerAsTimeSpace.TimeSet != null && existingConsumers [0].TimeSet != null && consumerAsTimeSpace.TimeSet.HasDurations != existingConsumers [0].TimeSet.HasDurations) { " is 173.
Long Statement,Oatc.OpenMI.Sdk.Backbone,ExchangeItemHelper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ExchangeItemHelper.cs,ProviderConsumerConnectableForTimeAndOrElementSet,The length of the statement  "			if (consumer.ElementSet ().ElementType != provider.ElementSet ().ElementType && consumer.ElementSet ().ElementCount != 1) { " is 123.
Long Statement,Oatc.OpenMI.Sdk.Backbone,ExchangeItemHelper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ExchangeItemHelper.cs,ProviderConsumerConnectableForTimeAndOrElementSet,The length of the statement  "			if (consumerAsTimeSpace.TimeSet != null && providerAsTimeSpace.TimeSet != null && consumerAsTimeSpace.TimeSet.HasDurations != providerAsTimeSpace.TimeSet.HasDurations) { " is 169.
Long Statement,Oatc.OpenMI.Sdk.Backbone,ExtensionMethods,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ExtensionMethods.cs,SetSingleTimeSpan,The length of the statement  "	timeSet.SetSingleTimeSpan (startTime.StampAsModifiedJulianDay' endTime.StampAsModifiedJulianDay + endTime.DurationInDays); " is 122.
Long Statement,Oatc.OpenMI.Sdk.Backbone,TimeComponentUpdater,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\IComponentUpdater.cs,Update,The length of the statement  "	if (querySpecifier.TimeSet == null || querySpecifier.TimeSet.Times == null || querySpecifier.TimeSet.Times.Count == 0) { " is 120.
Long Statement,Oatc.OpenMI.Sdk.Backbone,TimeComponentUpdater,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\IComponentUpdater.cs,Update,The length of the statement  "		throw new Exception ("Given the TimeSet of output item \"" + output.Id + "\"' it can not produce one set of values for \"" + querySpecifier.Id + "\""); " is 151.
Long Statement,Oatc.OpenMI.Sdk.Backbone,TimeComponentUpdater,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\IComponentUpdater.cs,Update,The length of the statement  "		throw new Exception ("Invalid time specifier in output item \"" + output.Id + "\" for in updating according to a time specification" + querySpecifier.Id); " is 154.
Long Statement,Oatc.OpenMI.Sdk.Backbone,TimeComponentUpdater,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\IComponentUpdater.cs,Update,The length of the statement  "	while ((component.Status == LinkableComponentStatus.Valid || component.Status == LinkableComponentStatus.Updated) && availableTimeMjd + Time.EpsilonForTimeCompare < queryTimeMjd) { " is 180.
Long Statement,Oatc.OpenMI.Sdk.Backbone,MultiInputAdaptor,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\MultiInputAdaptorFactory.cs,RemoveConsumer,The length of the statement  "		throw new Exception ("consumer \"" + consumer.Caption + "\" can not be removed from \"" + Caption + "\"' because it was not added"); " is 132.
Long Statement,Oatc.OpenMI.Sdk.Backbone,MultiInputAdaptor,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\MultiInputAdaptorFactory.cs,GetValues,The length of the statement  "	TimeSpaceValueSet<double> resultSet = ElementMapper.CreateResultValueSet (timeSpaceQuery.TimeSet.Times.Count' this.ElementSet ().ElementCount); " is 143.
Long Statement,Oatc.OpenMI.Sdk.Backbone,Output,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Output.cs,RemoveConsumer,The length of the statement  "		throw new Exception ("consumer \"" + consumer.Caption + "\" can not be removed from \"" + Caption + "\"' because it was not added"); " is 132.
Long Statement,Oatc.OpenMI.Sdk.Backbone,Output,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Output.cs,GetValues,The length of the statement  "		throw new Exception ("ElementSet of output item \"" + Id + "\" does not fit the ElementSet of requesting item \"" + querySpecifier.Id); " is 135.
Long Statement,Oatc.OpenMI.Sdk.Backbone,Output,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Output.cs,GetValues,The length of the statement  "		throw new Exception ("TimeSet of output item \"" + Id + "\" does not fit the TimeSet of requesting item \"" + querySpecifier.Id); " is 129.
Long Statement,Oatc.OpenMI.Sdk.Backbone,Quantity,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Quantity.cs,DescribesSameAs,The length of the statement  "	if (((valueDefinition1 is IQuality) && (valueDefinition2 is IQuantity)) || ((valueDefinition1 is IQuantity) && (valueDefinition2 is IQuality))) " is 143.
Long Statement,Oatc.OpenMI.Sdk.Backbone,Quantity,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Quantity.cs,DescribesSameAs,The length of the statement  "		return Dimension.DescribesSameAs (((IQuantity)valueDefinition1).Unit.Dimension' ((IQuantity)valueDefinition2).Unit.Dimension); " is 126.
Long Statement,Oatc.OpenMI.Sdk.Backbone,Time,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Time.cs,ToString,The length of the statement  "		return (stampAsModifiedJulianDay.ToString (CultureInfo.InvariantCulture) + " - " + (stampAsModifiedJulianDay + DurationInDays).ToString (CultureInfo.InvariantCulture) + " (" + (ToDateTime ().ToString ("yyyy-MM-dd HH:mm:ss")) + " - " + (ToDateTime (stampAsModifiedJulianDay + DurationInDays).ToString ("yyyy-MM-dd HH:mm:ss")) + ")"); " is 332.
Long Statement,Oatc.OpenMI.Sdk.Backbone,ValueSet,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ValueSet.cs,CheckElementIndex,The length of the statement  "		throw new Exception ("Invalid elementindex (" + elementIndex + ")' only " + GetElementCount (valueSet) + " elements available"); " is 128.
Long Statement,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,AddValuesToBuffer,The length of the statement  "		if (_times.Times.Count > 0 && time.StampAsModifiedJulianDay + Time.EpsilonForTimeCompare < _times [_times.Times.Count - 1].EndStampAsModifiedJulianDay ()) " is 154.
Long Statement,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,AddValuesToBuffer,The length of the statement  "		if (_times.Count > 0 && time.StampAsModifiedJulianDay - Time.EpsilonForTimeCompare < _times [_times.Count - 1].StampAsModifiedJulianDay) " is 136.
Long Statement,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,GetValues,The length of the statement  "		if (requestedTime.End ().StampAsModifiedJulianDay > _times [_times.Count - 1].End ().StampAsModifiedJulianDay + Time.EpsilonForTimeCompare || requestedTime.Start ().StampAsModifiedJulianDay < _times [0].Start ().StampAsModifiedJulianDay - Time.EpsilonForTimeCompare) { " is 268.
Long Statement,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The length of the statement  "						xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1)); " is 128.
Long Statement,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeStamp,The length of the statement  "				if (time.StampAsModifiedJulianDay - Time.EpsilonForTimeCompare > tr || tr > time.EndStampAsModifiedJulianDay () + Time.EpsilonForTimeCompare) " is 141.
Long Statement,Oatc.OpenMI.Sdk.Buffer,TimeBufferer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\TimeBufferer.cs,GetValues,The length of the statement  "	if (querySpecifier.TimeSet == null || querySpecifier.TimeSet.Times == null || querySpecifier.TimeSet.Times.Count == 0) { " is 120.
Long Statement,Oatc.OpenMI.Sdk.Buffer,TimeBufferer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\TimeBufferer.cs,GetValues,The length of the statement  "		throw new Exception ("Invalid query specifier \"" + querySpecifier.Id + "\" for in GetValues() call to time decorater " + Id); " is 126.
Long Statement,Oatc.OpenMI.Sdk.Buffer,TimeBufferer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\TimeBufferer.cs,GetValues,The length of the statement  "	double queryTimeMjd = querySpecifier.TimeSet.Times [querySpecifier.TimeSet.Times.Count - 1].End ().StampAsModifiedJulianDay; " is 124.
Long Statement,Oatc.OpenMI.Sdk.Buffer,TimeBufferer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\TimeBufferer.cs,Refresh,The length of the statement  "	if (Adaptee.Component.Status != LinkableComponentStatus.Preparing && Adaptee.Component.Status != LinkableComponentStatus.Updating) { " is 132.
Long Statement,Oatc.OpenMI.Sdk.Buffer,TimeBufferer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\TimeBufferer.cs,UpdateTimeHorizonFromDecoratedOutputItem,The length of the statement  "			_buffer.TimeSet.TimeHorizon = new Time (decoratedTimeHorizon.StampAsModifiedJulianDay' decoratedTimeHorizon.DurationInDays); " is 124.
Long Statement,Oatc.OpenMI.Sdk.Buffer,TimeBufferer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\TimeBufferer.cs,AddNewValuesToBuffer,The length of the statement  "		throw new Exception ("AdaptedOutput \"" + Id + "\" did not receive values from Decorated OutputItem \"" + Adaptee.Id + "\""); " is 125.
Long Statement,Oatc.OpenMI.Sdk.DevelopmentSupport,ComponentConnector,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\DevelopmentSupport\ComponentConnector.cs,CheckIfDimensionsMatch,The length of the statement  "			error += string.Format (" ({0}'{1}'{2})"' dimBase' dimbaseval1.ToString (System.Globalization.CultureInfo.InvariantCulture)' dimbaseval2.ToString (System.Globalization.CultureInfo.InvariantCulture)); " is 199.
Long Statement,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The length of the statement  "							_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength (); " is 123.
Long Statement,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The length of the statement  "		else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine " is 129.
Long Statement,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The length of the statement  "							_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength (); " is 123.
Long Statement,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The length of the statement  "							_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength (); " is 123.
Long Statement,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The length of the statement  "		else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon " is 127.
Long Statement,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,CreateXYPoint,The length of the statement  "		throw new ArgumentOutOfRangeException ("elementSet"' "Cannot create XYPoint' the element type of the element set is not XYPoint"); " is 130.
Long Statement,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,CreateXYPolyline,The length of the statement  "		xyPolyline.Points.Add (new XYPoint (elementSet.GetVertexXCoordinate (index' i)' elementSet.GetVertexYCoordinate (index' i))); " is 125.
Long Statement,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,CreateXYPolygon,The length of the statement  "		xyPolygon.Points.Add (new XYPoint (elementSet.GetVertexXCoordinate (index' i)' elementSet.GetVertexYCoordinate (index' i))); " is 124.
Long Statement,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,CreateFromXYPolygon,The length of the statement  "		xyPolygon.Points.Add (new XYPoint (elementSet.GetVertexXCoordinate (index' i)' elementSet.GetVertexYCoordinate (index' i))); " is 124.
Long Statement,Oatc.OpenMI.Sdk.Spatial,ElementMapperAdaptedOutput,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapperAdaptedOutput.cs,GetValues,The length of the statement  "	ITimeSpaceValueSet<double> resultValues = ElementMapper.CreateResultValueSet (incomingValues.TimesCount ()' SpatialDefinition.ElementCount); " is 140.
Long Statement,Oatc.OpenMI.Sdk.Spatial,ElementSetChecker,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementSetChecker.cs,CheckElementSet,The length of the statement  "						Coordinate coordinate = new Coordinate (elementSet.GetVertexXCoordinate (i' j)' elementSet.GetVertexYCoordinate (i' j)' elementSet.GetVertexZCoordinate (i' j)); " is 160.
Long Statement,Oatc.OpenMI.Sdk.Spatial,SpatialAdaptedOutputFactory,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\SpatialAdaptedOutputFactory.cs,GetAdaptedOutputArguments,The length of the statement  "	if (!(methodIdentifier.Id.StartsWith (_ElementMapperPrefix) || methodIdentifier.Id.StartsWith (_ElementOperationPrefix))) { " is 123.
Long Statement,Oatc.OpenMI.Sdk.Spatial,SpatialAdaptedOutputFactory,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\SpatialAdaptedOutputFactory.cs,GetAdaptedOutputArguments,The length of the statement  "				arguments.Add (new ArgumentString ("FromElementType"' method.FromElementsShapeType.ToString ()' "Valid From-Element Types")); " is 125.
Long Statement,Oatc.OpenMI.Sdk.Spatial,SpatialAdaptedOutputFactory,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\SpatialAdaptedOutputFactory.cs,GetAdaptedOutputArguments,The length of the statement  "				arguments.Add (new ArgumentString ("FromElementType"' method.FromElementsShapeType.ToString ()' "Valid From-Element Types")); " is 125.
Long Statement,Oatc.OpenMI.Sdk.Spatial,SpatialExtensionAdaptorFactory,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\SpatialExtensionAdaptorFactory.cs,GetAvailableAdaptedOutputIds,The length of the statement  "			new SpatialExtensionElementSetAdaptor (tadaptee' new MultiPointWrapper (tadaptee.SpatialDefinition as IMultiPoint)' "MultiPointWrapper") " is 136.
Long Statement,Oatc.OpenMI.Sdk.Spatial,SpatialExtensionAdaptorFactory,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\SpatialExtensionAdaptorFactory.cs,GetAvailableAdaptedOutputIds,The length of the statement  "			new SpatialExtensionElementSetAdaptor (tadaptee' new LineStringWrapper (tadaptee.SpatialDefinition as ILineString)' "LineStringWrapper") " is 136.
Long Statement,Oatc.OpenMI.Sdk.Spatial,SpatialExtensionAdaptorFactory,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\SpatialExtensionAdaptorFactory.cs,GetAvailableAdaptedOutputIds,The length of the statement  "			new SpatialExtensionElementSetAdaptor (tadaptee' new Spatial2DGridWrapper (tadaptee.SpatialDefinition as ISpatial2DGrid)' "Spatial2DGridWrapper") " is 145.
Long Statement,Oatc.OpenMI.Sdk.Spatial,SpatialExtensionAdaptorFactory,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\SpatialExtensionAdaptorFactory.cs,GetAvailableAdaptedOutputIds,The length of the statement  "			new SpatialExtensionElementSetAdaptor (tadaptee' new SpatialMeshWrapper (tadaptee.SpatialDefinition as ISpatialMesh)' "SpatialMeshWrapper") " is 139.
Long Statement,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,DoLineSegmentsIntersect,The length of the statement  "	return DoLineSegmentsIntersect (line1.P1.X' line1.P1.Y' line1.P2.X' line1.P2.Y' line2.P1.X' line2.P1.Y' line2.P2.X' line2.P2.Y); " is 128.
Long Statement,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,CalculateIntersectionPoint,The length of the statement  "		throw new System.Exception ("Attempt to calculate intersection point between non intersecting lines. CalculateIntersectionPoint failed."); " is 138.
Long Statement,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,CalculateSharedLength,The length of the statement  "	if (Math.Abs (lineA.P2.X - lineA.P1.X) < EPSILON && Math.Abs (lineB.P2.X - lineB.P1.X) < EPSILON && Math.Abs (lineA.P1.X - lineB.P1.X) < EPSILON) { " is 147.
Long Statement,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The length of the statement  "				else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) { " is 122.
Long Statement,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,IsPointInLineOld,The length of the statement  "			if (Math.Abs (y - line.P1.Y - (line.P2.Y - line.P1.Y) / (line.P1.X - line.P2.X) * (line.P1.X - x)) < EPSILON * EPSILON) { " is 121.
Long Statement,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,IsPointInLineInterior,The length of the statement  "			if (Math.Abs (y - line.P1.Y - (line.P2.Y - line.P1.Y) / (line.P1.X - line.P2.X) * (line.P1.X - x)) < EPSILON * EPSILON) { " is 121.
Long Statement,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,CalculateLineToPointDistance,The length of the statement  "	double b = Math.Sqrt ((line.P2.X - line.P1.X) * (line.P2.X - line.P1.X) + (line.P2.Y - line.P1.Y) * (line.P2.Y - line.P1.Y)); " is 125.
Long Statement,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,CalculateLineToPointDistance,The length of the statement  "			dist = Math.Abs ((line.P2.X - line.P1.X) * (line.P1.Y - point.Y) - (line.P1.X - point.X) * (line.P2.Y - line.P1.Y)) / b; " is 120.
Long Statement,Oatc.OpenMI.Sdk.Spatial,XYPoint,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYPoint.cs,ToString,The length of the statement  "	return string.Format ("XYPoint ({0}'{1})"' _x.ToString (System.Globalization.CultureInfo.InvariantCulture)' _y.ToString (System.Globalization.CultureInfo.InvariantCulture)); " is 173.
Long Statement,Oatc.OpenMI.Sdk.Spatial,XYPolygon,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYPolygon.cs,GetLine,The length of the statement  "	return new XYLine (((XYPoint)Points [lineNumber]).X' ((XYPoint)Points [lineNumber]).Y' ((XYPoint)Points [index2]).X' ((XYPoint)Points [index2]).Y); " is 147.
Complex Conditional,Oatc.OpenMI.Sdk.Backbone,ExchangeItemHelper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ExchangeItemHelper.cs,OutputAndInputTimeSetsFit,The conditional expression  "(requiredTimes [timeIndex].DurationInDays > 0 && !(sourceTimes [timeIndex].DurationInDays > 0)) || (sourceTimes [timeIndex].DurationInDays > 0 && !(requiredTimes [timeIndex].DurationInDays > 0))"  is complex.
Complex Conditional,Oatc.OpenMI.Sdk.Backbone,Quantity,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Quantity.cs,DescribesSameAs,The conditional expression  "((valueDefinition1 is IQuality) && (valueDefinition2 is IQuantity)) || ((valueDefinition1 is IQuantity) && (valueDefinition2 is IQuality))"  is complex.
Complex Conditional,Oatc.OpenMI.Sdk.Spatial,XYPolygon,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYPolygon.cs,IsIntersected,The conditional expression  "((((j != im1) && (j != i)) && (j != ip1)) && XYGeometryTools.IsPointInPolygon (x' y' localPolygon))"  is complex.
Virtual Method Call from Constructor,Oatc.OpenMI.Sdk.Backbone,ElementSet,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ElementSet.cs,ElementSet,The constructor "ElementSet" calls a virtual method "AddVertex".
Magic Number,Oatc.OpenMI.Sdk.Backbone,Dimension,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Dimension.cs,Dimension,The following statement contains a magic number: switch (predefinedDimension) {  case PredefinedDimensions.Length:  	SetPower (DimensionBase.Length' 1);  	break;  case PredefinedDimensions.Area:  	SetPower (DimensionBase.Length' 2);  	break;  case PredefinedDimensions.Volume:  	SetPower (DimensionBase.Length' 3);  	break;  case PredefinedDimensions.LengthPerTime:  	SetPower (DimensionBase.Length' 1);  	SetPower (DimensionBase.Time' -1);  	break;  case PredefinedDimensions.VolumePerTime:  	SetPower (DimensionBase.Length' 3);  	SetPower (DimensionBase.Time' -1);  	break;  case PredefinedDimensions.VolumePerTimePerLength:  	SetPower (DimensionBase.Length' 2);  	SetPower (DimensionBase.Time' -1);  	break;  case PredefinedDimensions.VolumePerTimePerArea:  	SetPower (DimensionBase.Length' 1);  	SetPower (DimensionBase.Time' -1);  	break;  case PredefinedDimensions.Mass:  	SetPower (DimensionBase.Mass' 1);  	break;  case PredefinedDimensions.MassPerTime:  	SetPower (DimensionBase.Mass' 1);  	SetPower (DimensionBase.Time' -1);  	break;  }  
Magic Number,Oatc.OpenMI.Sdk.Backbone,Dimension,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Dimension.cs,Dimension,The following statement contains a magic number: switch (predefinedDimension) {  case PredefinedDimensions.Length:  	SetPower (DimensionBase.Length' 1);  	break;  case PredefinedDimensions.Area:  	SetPower (DimensionBase.Length' 2);  	break;  case PredefinedDimensions.Volume:  	SetPower (DimensionBase.Length' 3);  	break;  case PredefinedDimensions.LengthPerTime:  	SetPower (DimensionBase.Length' 1);  	SetPower (DimensionBase.Time' -1);  	break;  case PredefinedDimensions.VolumePerTime:  	SetPower (DimensionBase.Length' 3);  	SetPower (DimensionBase.Time' -1);  	break;  case PredefinedDimensions.VolumePerTimePerLength:  	SetPower (DimensionBase.Length' 2);  	SetPower (DimensionBase.Time' -1);  	break;  case PredefinedDimensions.VolumePerTimePerArea:  	SetPower (DimensionBase.Length' 1);  	SetPower (DimensionBase.Time' -1);  	break;  case PredefinedDimensions.Mass:  	SetPower (DimensionBase.Mass' 1);  	break;  case PredefinedDimensions.MassPerTime:  	SetPower (DimensionBase.Mass' 1);  	SetPower (DimensionBase.Time' -1);  	break;  }  
Magic Number,Oatc.OpenMI.Sdk.Backbone,Dimension,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Dimension.cs,Dimension,The following statement contains a magic number: switch (predefinedDimension) {  case PredefinedDimensions.Length:  	SetPower (DimensionBase.Length' 1);  	break;  case PredefinedDimensions.Area:  	SetPower (DimensionBase.Length' 2);  	break;  case PredefinedDimensions.Volume:  	SetPower (DimensionBase.Length' 3);  	break;  case PredefinedDimensions.LengthPerTime:  	SetPower (DimensionBase.Length' 1);  	SetPower (DimensionBase.Time' -1);  	break;  case PredefinedDimensions.VolumePerTime:  	SetPower (DimensionBase.Length' 3);  	SetPower (DimensionBase.Time' -1);  	break;  case PredefinedDimensions.VolumePerTimePerLength:  	SetPower (DimensionBase.Length' 2);  	SetPower (DimensionBase.Time' -1);  	break;  case PredefinedDimensions.VolumePerTimePerArea:  	SetPower (DimensionBase.Length' 1);  	SetPower (DimensionBase.Time' -1);  	break;  case PredefinedDimensions.Mass:  	SetPower (DimensionBase.Mass' 1);  	break;  case PredefinedDimensions.MassPerTime:  	SetPower (DimensionBase.Mass' 1);  	SetPower (DimensionBase.Time' -1);  	break;  }  
Magic Number,Oatc.OpenMI.Sdk.Backbone,Dimension,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Dimension.cs,Dimension,The following statement contains a magic number: switch (predefinedDimension) {  case PredefinedDimensions.Length:  	SetPower (DimensionBase.Length' 1);  	break;  case PredefinedDimensions.Area:  	SetPower (DimensionBase.Length' 2);  	break;  case PredefinedDimensions.Volume:  	SetPower (DimensionBase.Length' 3);  	break;  case PredefinedDimensions.LengthPerTime:  	SetPower (DimensionBase.Length' 1);  	SetPower (DimensionBase.Time' -1);  	break;  case PredefinedDimensions.VolumePerTime:  	SetPower (DimensionBase.Length' 3);  	SetPower (DimensionBase.Time' -1);  	break;  case PredefinedDimensions.VolumePerTimePerLength:  	SetPower (DimensionBase.Length' 2);  	SetPower (DimensionBase.Time' -1);  	break;  case PredefinedDimensions.VolumePerTimePerArea:  	SetPower (DimensionBase.Length' 1);  	SetPower (DimensionBase.Time' -1);  	break;  case PredefinedDimensions.Mass:  	SetPower (DimensionBase.Mass' 1);  	break;  case PredefinedDimensions.MassPerTime:  	SetPower (DimensionBase.Mass' 1);  	SetPower (DimensionBase.Time' -1);  	break;  }  
Magic Number,Oatc.OpenMI.Sdk.Backbone,Dimension,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Dimension.cs,Dimension,The following statement contains a magic number: SetPower (DimensionBase.Length' 2);  
Magic Number,Oatc.OpenMI.Sdk.Backbone,Dimension,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Dimension.cs,Dimension,The following statement contains a magic number: SetPower (DimensionBase.Length' 3);  
Magic Number,Oatc.OpenMI.Sdk.Backbone,Dimension,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Dimension.cs,Dimension,The following statement contains a magic number: SetPower (DimensionBase.Length' 3);  
Magic Number,Oatc.OpenMI.Sdk.Backbone,Dimension,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Dimension.cs,Dimension,The following statement contains a magic number: SetPower (DimensionBase.Length' 2);  
Magic Number,Oatc.OpenMI.Sdk.Backbone,ExtensionMethods,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ExtensionMethods.cs,AddSeconds,The following statement contains a magic number: return (new Time (time.StampAsModifiedJulianDay + seconds / 24.0 / 3600.0' time.DurationInDays));  
Magic Number,Oatc.OpenMI.Sdk.Backbone,ExtensionMethods,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ExtensionMethods.cs,AddSeconds,The following statement contains a magic number: return (new Time (time.StampAsModifiedJulianDay + seconds / 24.0 / 3600.0' time.DurationInDays));  
Magic Number,Oatc.OpenMI.Sdk.Backbone,Time,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Time.cs,AddSeconds,The following statement contains a magic number: stampAsModifiedJulianDay += seconds / 24.0 / 3600.0;  
Magic Number,Oatc.OpenMI.Sdk.Backbone,Time,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Time.cs,AddSeconds,The following statement contains a magic number: stampAsModifiedJulianDay += seconds / 24.0 / 3600.0;  
Magic Number,Oatc.OpenMI.Sdk.Backbone,Unit,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Unit.cs,Unit,The following statement contains a magic number: switch (predefinedUnit) {  case PredefinedUnits.Meter:  	caption = "m";  	description = "meter";  	dimension = new Dimension (PredefinedDimensions.Length);  	break;  case PredefinedUnits.Liter:  	caption = "L";  	description = "Liter";  	dimension = new Dimension (PredefinedDimensions.Volume);  	ConversionFactorToSI = 0.001;  	break;  case PredefinedUnits.CubicMeterPerSecond:  	caption = "m3/s";  	description = "cubic meter per second";  	dimension = new Dimension (PredefinedDimensions.VolumePerTime);  	break;  case PredefinedUnits.LiterPerSecond:  	caption = "liter/s";  	description = "liter per second";  	dimension = new Dimension (PredefinedDimensions.VolumePerTime);  	break;  case PredefinedUnits.MillimeterPerDay:  	caption = "mm/day";  	description = "millimeters per day";  	conversionFactorToBeUsed = 1.15741E-08;  	dimension = new Dimension (PredefinedDimensions.VolumePerTimePerArea);  	break;  }  
Magic Number,Oatc.OpenMI.Sdk.Backbone,Unit,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Unit.cs,Unit,The following statement contains a magic number: switch (predefinedUnit) {  case PredefinedUnits.Meter:  	caption = "m";  	description = "meter";  	dimension = new Dimension (PredefinedDimensions.Length);  	break;  case PredefinedUnits.Liter:  	caption = "L";  	description = "Liter";  	dimension = new Dimension (PredefinedDimensions.Volume);  	ConversionFactorToSI = 0.001;  	break;  case PredefinedUnits.CubicMeterPerSecond:  	caption = "m3/s";  	description = "cubic meter per second";  	dimension = new Dimension (PredefinedDimensions.VolumePerTime);  	break;  case PredefinedUnits.LiterPerSecond:  	caption = "liter/s";  	description = "liter per second";  	dimension = new Dimension (PredefinedDimensions.VolumePerTime);  	break;  case PredefinedUnits.MillimeterPerDay:  	caption = "mm/day";  	description = "millimeters per day";  	conversionFactorToBeUsed = 1.15741E-08;  	dimension = new Dimension (PredefinedDimensions.VolumePerTimePerArea);  	break;  }  
Magic Number,Oatc.OpenMI.Sdk.Backbone,Unit,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Unit.cs,Unit,The following statement contains a magic number: ConversionFactorToSI = 0.001;  
Magic Number,Oatc.OpenMI.Sdk.Backbone,Unit,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Unit.cs,Unit,The following statement contains a magic number: conversionFactorToBeUsed = 1.15741E-08;  
Magic Number,Oatc.OpenMI.Sdk.Backbone,ValueSet,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ValueSet.cs,GetValue,The following statement contains a magic number: if (indices.Length != 2)  	throw new ArgumentException ("Indices does not have the correct length"' "indices");  
Magic Number,Oatc.OpenMI.Sdk.Backbone,ValueSet,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\ValueSet.cs,SetValue,The following statement contains a magic number: if (indices.Length != 2)  	throw new ArgumentException ("Indices does not have the correct length"' "indices");  
Magic Number,Oatc.OpenMI.Sdk.Backbone.Generic,TimeSpaceValueSetBase,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Generic\TimeSpaceValueSet.cs,GetValue,The following statement contains a magic number: if (indices.Length != 2)  	throw new ArgumentException ("Indices does not have the correct length"' "indices");  
Magic Number,Oatc.OpenMI.Sdk.Backbone.Generic,TimeSpaceValueSetBase,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Generic\TimeSpaceValueSet.cs,SetValue,The following statement contains a magic number: if (indices.Length != 2)  	throw new ArgumentException ("Indices does not have the correct length"' "indices");  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	double trl = tre - trb;  	// length of requested time interval  	if (_times.Count == 0)  		throw new Exception ("No times in buffer");  	double tbb0 = _times [0].StampAsModifiedJulianDay;  	// In the following the current abbreviations are used:  	// B: Buffer time  	// R: Requested time  	// I: Time included by this part of the code  	if (DoExtrapolate) {  		//--------------------------------------------------------------------------  		// B                tbb0|-------tbe0|tbb1------|tbe1  		// R+I  trb|---|tre                 		//--------------------------------------------------------------------------  		if (tre <= tbb0) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] = sbi0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B          tbb0|--------|---------|--------|  		// R     trb|----------------|tre                		// I        |-----|  		//---------------------------------------------------------------------------  		if (trb < tbb0)// && tre > tbb0  		 {  			double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				// Linear interpolation' use tbb0 as "endpoint" of interval  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] += sbi0 * (tbb0 - trb) / trl;  				}  			}  		}  		double tbeN0 = _times [_times.Count - 1].End ().StampAsModifiedJulianDay;  		//--------------------------------------------------------------------------  		// B     tbb0|---?----|-------|tbeN0  		// R+I                                trb|---|tre  		//--------------------------------------------------------------------------  		if (tbeN0 < trb) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] = sbiN0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B     |---?----|-------|tbeN0  		// R               trb|-------|tre  		// I                      |---|  		//--------------------------------------------------------------------------  		if (tbeN0 < tre) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  				}  			}  			else {  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  				}  			}  		}  	}  	int nstart = 0;  	int nend = _times.Count - 1;  	// Narrow down the number of spans to investigate' based on the requested span.  	if (nend > 10) {  		// Assuming 4 spans in the buffer' use end-time in GetIntrval  		// will provide the right indices  		// spans                 |-0-|-1-|-2-|-3-|  		// endStamp intervals      0 | 1 | 2 | 3 | 4  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.EndStampAsModifiedJulianDay ());  		nend = _times.Times.GetInterval (tre' out fraction' time => time.End ().StampAsModifiedJulianDay);  		nend = Math.Min (nend' _times.Count - 1);  	}  	for (int n = nstart; n <= nend; n++) {  		double tbbn = _times [n].StampAsModifiedJulianDay;  		double tben = _times [n].EndStampAsModifiedJulianDay ();  		//---------------------------------------------------------------------------  		// B:       tbbn|--------------------------|tben  		// R:     trb|-------------------------------------|tre  		// I:           |--------------------------|  		//---------------------------------------------------------------------------  		if (trb <= tbbn && tre >= tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - tbbn) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbbn|-----------------------|tben  		// R+I:          trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbbn <= trb && tre <= tben)//cover all  		 {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				xr [i] += BufferHelper.GetVal (_values [n]' i);  			}  		}  		//---------------------------------------------------------------------------  		// B:     tbbn|-----------------|tben  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbbn < trb && trb < tben && tre > tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - trb) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:           tbbn|-----------------|tben  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbbn && tre > tbbn && tre < tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tre - tbbn) / (tre - trb);  			}  		}  	}  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeSpansToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	double trl = tre - trb;  	// length of requested time interval  	if (_times.Count == 0)  		throw new Exception ("No times in buffer");  	double tbb0 = _times [0].StampAsModifiedJulianDay;  	// In the following the current abbreviations are used:  	// B: Buffer time  	// R: Requested time  	// I: Time included by this part of the code  	if (DoExtrapolate) {  		//--------------------------------------------------------------------------  		// B                tbb0|-------tbe0|tbb1------|tbe1  		// R+I  trb|---|tre                 		//--------------------------------------------------------------------------  		if (tre <= tbb0) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] = sbi0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B          tbb0|--------|---------|--------|  		// R     trb|----------------|tre                		// I        |-----|  		//---------------------------------------------------------------------------  		if (trb < tbb0)// && tre > tbb0  		 {  			double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				// Linear interpolation' use tbb0 as "endpoint" of interval  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] += sbi0 * (tbb0 - trb) / trl;  				}  			}  		}  		double tbeN0 = _times [_times.Count - 1].End ().StampAsModifiedJulianDay;  		//--------------------------------------------------------------------------  		// B     tbb0|---?----|-------|tbeN0  		// R+I                                trb|---|tre  		//--------------------------------------------------------------------------  		if (tbeN0 < trb) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] = sbiN0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B     |---?----|-------|tbeN0  		// R               trb|-------|tre  		// I                      |---|  		//--------------------------------------------------------------------------  		if (tbeN0 < tre) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  				}  			}  			else {  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  				}  			}  		}  	}  	int nstart = 0;  	int nend = _times.Count - 1;  	// Narrow down the number of spans to investigate' based on the requested span.  	if (nend > 10) {  		// Assuming 4 spans in the buffer' use end-time in GetIntrval  		// will provide the right indices  		// spans                 |-0-|-1-|-2-|-3-|  		// endStamp intervals      0 | 1 | 2 | 3 | 4  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.EndStampAsModifiedJulianDay ());  		nend = _times.Times.GetInterval (tre' out fraction' time => time.End ().StampAsModifiedJulianDay);  		nend = Math.Min (nend' _times.Count - 1);  	}  	for (int n = nstart; n <= nend; n++) {  		double tbbn = _times [n].StampAsModifiedJulianDay;  		double tben = _times [n].EndStampAsModifiedJulianDay ();  		//---------------------------------------------------------------------------  		// B:       tbbn|--------------------------|tben  		// R:     trb|-------------------------------------|tre  		// I:           |--------------------------|  		//---------------------------------------------------------------------------  		if (trb <= tbbn && tre >= tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - tbbn) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbbn|-----------------------|tben  		// R+I:          trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbbn <= trb && tre <= tben)//cover all  		 {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				xr [i] += BufferHelper.GetVal (_values [n]' i);  			}  		}  		//---------------------------------------------------------------------------  		// B:     tbbn|-----------------|tben  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbbn < trb && trb < tben && tre > tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - trb) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:           tbbn|-----------------|tben  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbbn && tre > tbbn && tre < tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tre - tbbn) / (tre - trb);  			}  		}  	}  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeSpansToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	double trl = tre - trb;  	// length of requested time interval  	if (_times.Count == 0)  		throw new Exception ("No times in buffer");  	double tbb0 = _times [0].StampAsModifiedJulianDay;  	// In the following the current abbreviations are used:  	// B: Buffer time  	// R: Requested time  	// I: Time included by this part of the code  	if (DoExtrapolate) {  		//--------------------------------------------------------------------------  		// B                tbb0|-------tbe0|tbb1------|tbe1  		// R+I  trb|---|tre                 		//--------------------------------------------------------------------------  		if (tre <= tbb0) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] = sbi0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B          tbb0|--------|---------|--------|  		// R     trb|----------------|tre                		// I        |-----|  		//---------------------------------------------------------------------------  		if (trb < tbb0)// && tre > tbb0  		 {  			double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				// Linear interpolation' use tbb0 as "endpoint" of interval  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] += sbi0 * (tbb0 - trb) / trl;  				}  			}  		}  		double tbeN0 = _times [_times.Count - 1].End ().StampAsModifiedJulianDay;  		//--------------------------------------------------------------------------  		// B     tbb0|---?----|-------|tbeN0  		// R+I                                trb|---|tre  		//--------------------------------------------------------------------------  		if (tbeN0 < trb) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] = sbiN0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B     |---?----|-------|tbeN0  		// R               trb|-------|tre  		// I                      |---|  		//--------------------------------------------------------------------------  		if (tbeN0 < tre) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  				}  			}  			else {  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  				}  			}  		}  	}  	int nstart = 0;  	int nend = _times.Count - 1;  	// Narrow down the number of spans to investigate' based on the requested span.  	if (nend > 10) {  		// Assuming 4 spans in the buffer' use end-time in GetIntrval  		// will provide the right indices  		// spans                 |-0-|-1-|-2-|-3-|  		// endStamp intervals      0 | 1 | 2 | 3 | 4  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.EndStampAsModifiedJulianDay ());  		nend = _times.Times.GetInterval (tre' out fraction' time => time.End ().StampAsModifiedJulianDay);  		nend = Math.Min (nend' _times.Count - 1);  	}  	for (int n = nstart; n <= nend; n++) {  		double tbbn = _times [n].StampAsModifiedJulianDay;  		double tben = _times [n].EndStampAsModifiedJulianDay ();  		//---------------------------------------------------------------------------  		// B:       tbbn|--------------------------|tben  		// R:     trb|-------------------------------------|tre  		// I:           |--------------------------|  		//---------------------------------------------------------------------------  		if (trb <= tbbn && tre >= tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - tbbn) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbbn|-----------------------|tben  		// R+I:          trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbbn <= trb && tre <= tben)//cover all  		 {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				xr [i] += BufferHelper.GetVal (_values [n]' i);  			}  		}  		//---------------------------------------------------------------------------  		// B:     tbbn|-----------------|tben  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbbn < trb && trb < tben && tre > tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - trb) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:           tbbn|-----------------|tben  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbbn && tre > tbbn && tre < tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tre - tbbn) / (tre - trb);  			}  		}  	}  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeSpansToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	double trl = tre - trb;  	// length of requested time interval  	if (_times.Count == 0)  		throw new Exception ("No times in buffer");  	double tbb0 = _times [0].StampAsModifiedJulianDay;  	// In the following the current abbreviations are used:  	// B: Buffer time  	// R: Requested time  	// I: Time included by this part of the code  	if (DoExtrapolate) {  		//--------------------------------------------------------------------------  		// B                tbb0|-------tbe0|tbb1------|tbe1  		// R+I  trb|---|tre                 		//--------------------------------------------------------------------------  		if (tre <= tbb0) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] = sbi0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B          tbb0|--------|---------|--------|  		// R     trb|----------------|tre                		// I        |-----|  		//---------------------------------------------------------------------------  		if (trb < tbb0)// && tre > tbb0  		 {  			double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				// Linear interpolation' use tbb0 as "endpoint" of interval  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] += sbi0 * (tbb0 - trb) / trl;  				}  			}  		}  		double tbeN0 = _times [_times.Count - 1].End ().StampAsModifiedJulianDay;  		//--------------------------------------------------------------------------  		// B     tbb0|---?----|-------|tbeN0  		// R+I                                trb|---|tre  		//--------------------------------------------------------------------------  		if (tbeN0 < trb) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] = sbiN0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B     |---?----|-------|tbeN0  		// R               trb|-------|tre  		// I                      |---|  		//--------------------------------------------------------------------------  		if (tbeN0 < tre) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  				}  			}  			else {  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  				}  			}  		}  	}  	int nstart = 0;  	int nend = _times.Count - 1;  	// Narrow down the number of spans to investigate' based on the requested span.  	if (nend > 10) {  		// Assuming 4 spans in the buffer' use end-time in GetIntrval  		// will provide the right indices  		// spans                 |-0-|-1-|-2-|-3-|  		// endStamp intervals      0 | 1 | 2 | 3 | 4  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.EndStampAsModifiedJulianDay ());  		nend = _times.Times.GetInterval (tre' out fraction' time => time.End ().StampAsModifiedJulianDay);  		nend = Math.Min (nend' _times.Count - 1);  	}  	for (int n = nstart; n <= nend; n++) {  		double tbbn = _times [n].StampAsModifiedJulianDay;  		double tben = _times [n].EndStampAsModifiedJulianDay ();  		//---------------------------------------------------------------------------  		// B:       tbbn|--------------------------|tben  		// R:     trb|-------------------------------------|tre  		// I:           |--------------------------|  		//---------------------------------------------------------------------------  		if (trb <= tbbn && tre >= tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - tbbn) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbbn|-----------------------|tben  		// R+I:          trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbbn <= trb && tre <= tben)//cover all  		 {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				xr [i] += BufferHelper.GetVal (_values [n]' i);  			}  		}  		//---------------------------------------------------------------------------  		// B:     tbbn|-----------------|tben  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbbn < trb && trb < tben && tre > tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - trb) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:           tbbn|-----------------|tben  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbbn && tre > tbbn && tre < tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tre - tbbn) / (tre - trb);  			}  		}  	}  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeSpansToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	double trl = tre - trb;  	// length of requested time interval  	if (_times.Count == 0)  		throw new Exception ("No times in buffer");  	double tbb0 = _times [0].StampAsModifiedJulianDay;  	// In the following the current abbreviations are used:  	// B: Buffer time  	// R: Requested time  	// I: Time included by this part of the code  	if (DoExtrapolate) {  		//--------------------------------------------------------------------------  		// B                tbb0|-------tbe0|tbb1------|tbe1  		// R+I  trb|---|tre                 		//--------------------------------------------------------------------------  		if (tre <= tbb0) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] = sbi0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B          tbb0|--------|---------|--------|  		// R     trb|----------------|tre                		// I        |-----|  		//---------------------------------------------------------------------------  		if (trb < tbb0)// && tre > tbb0  		 {  			double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				// Linear interpolation' use tbb0 as "endpoint" of interval  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] += sbi0 * (tbb0 - trb) / trl;  				}  			}  		}  		double tbeN0 = _times [_times.Count - 1].End ().StampAsModifiedJulianDay;  		//--------------------------------------------------------------------------  		// B     tbb0|---?----|-------|tbeN0  		// R+I                                trb|---|tre  		//--------------------------------------------------------------------------  		if (tbeN0 < trb) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] = sbiN0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B     |---?----|-------|tbeN0  		// R               trb|-------|tre  		// I                      |---|  		//--------------------------------------------------------------------------  		if (tbeN0 < tre) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  				}  			}  			else {  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  				}  			}  		}  	}  	int nstart = 0;  	int nend = _times.Count - 1;  	// Narrow down the number of spans to investigate' based on the requested span.  	if (nend > 10) {  		// Assuming 4 spans in the buffer' use end-time in GetIntrval  		// will provide the right indices  		// spans                 |-0-|-1-|-2-|-3-|  		// endStamp intervals      0 | 1 | 2 | 3 | 4  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.EndStampAsModifiedJulianDay ());  		nend = _times.Times.GetInterval (tre' out fraction' time => time.End ().StampAsModifiedJulianDay);  		nend = Math.Min (nend' _times.Count - 1);  	}  	for (int n = nstart; n <= nend; n++) {  		double tbbn = _times [n].StampAsModifiedJulianDay;  		double tben = _times [n].EndStampAsModifiedJulianDay ();  		//---------------------------------------------------------------------------  		// B:       tbbn|--------------------------|tben  		// R:     trb|-------------------------------------|tre  		// I:           |--------------------------|  		//---------------------------------------------------------------------------  		if (trb <= tbbn && tre >= tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - tbbn) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbbn|-----------------------|tben  		// R+I:          trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbbn <= trb && tre <= tben)//cover all  		 {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				xr [i] += BufferHelper.GetVal (_values [n]' i);  			}  		}  		//---------------------------------------------------------------------------  		// B:     tbbn|-----------------|tben  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbbn < trb && trb < tben && tre > tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - trb) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:           tbbn|-----------------|tben  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbbn && tre > tbbn && tre < tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tre - tbbn) / (tre - trb);  			}  		}  	}  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeSpansToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	double trl = tre - trb;  	// length of requested time interval  	if (_times.Count == 0)  		throw new Exception ("No times in buffer");  	double tbb0 = _times [0].StampAsModifiedJulianDay;  	// In the following the current abbreviations are used:  	// B: Buffer time  	// R: Requested time  	// I: Time included by this part of the code  	if (DoExtrapolate) {  		//--------------------------------------------------------------------------  		// B                tbb0|-------tbe0|tbb1------|tbe1  		// R+I  trb|---|tre                 		//--------------------------------------------------------------------------  		if (tre <= tbb0) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] = sbi0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B          tbb0|--------|---------|--------|  		// R     trb|----------------|tre                		// I        |-----|  		//---------------------------------------------------------------------------  		if (trb < tbb0)// && tre > tbb0  		 {  			double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				// Linear interpolation' use tbb0 as "endpoint" of interval  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] += sbi0 * (tbb0 - trb) / trl;  				}  			}  		}  		double tbeN0 = _times [_times.Count - 1].End ().StampAsModifiedJulianDay;  		//--------------------------------------------------------------------------  		// B     tbb0|---?----|-------|tbeN0  		// R+I                                trb|---|tre  		//--------------------------------------------------------------------------  		if (tbeN0 < trb) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] = sbiN0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B     |---?----|-------|tbeN0  		// R               trb|-------|tre  		// I                      |---|  		//--------------------------------------------------------------------------  		if (tbeN0 < tre) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  				}  			}  			else {  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  				}  			}  		}  	}  	int nstart = 0;  	int nend = _times.Count - 1;  	// Narrow down the number of spans to investigate' based on the requested span.  	if (nend > 10) {  		// Assuming 4 spans in the buffer' use end-time in GetIntrval  		// will provide the right indices  		// spans                 |-0-|-1-|-2-|-3-|  		// endStamp intervals      0 | 1 | 2 | 3 | 4  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.EndStampAsModifiedJulianDay ());  		nend = _times.Times.GetInterval (tre' out fraction' time => time.End ().StampAsModifiedJulianDay);  		nend = Math.Min (nend' _times.Count - 1);  	}  	for (int n = nstart; n <= nend; n++) {  		double tbbn = _times [n].StampAsModifiedJulianDay;  		double tben = _times [n].EndStampAsModifiedJulianDay ();  		//---------------------------------------------------------------------------  		// B:       tbbn|--------------------------|tben  		// R:     trb|-------------------------------------|tre  		// I:           |--------------------------|  		//---------------------------------------------------------------------------  		if (trb <= tbbn && tre >= tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - tbbn) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbbn|-----------------------|tben  		// R+I:          trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbbn <= trb && tre <= tben)//cover all  		 {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				xr [i] += BufferHelper.GetVal (_values [n]' i);  			}  		}  		//---------------------------------------------------------------------------  		// B:     tbbn|-----------------|tben  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbbn < trb && trb < tben && tre > tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - trb) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:           tbbn|-----------------|tben  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbbn && tre > tbbn && tre < tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tre - tbbn) / (tre - trb);  			}  		}  	}  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeSpansToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	double trl = tre - trb;  	// length of requested time interval  	if (_times.Count == 0)  		throw new Exception ("No times in buffer");  	double tbb0 = _times [0].StampAsModifiedJulianDay;  	// In the following the current abbreviations are used:  	// B: Buffer time  	// R: Requested time  	// I: Time included by this part of the code  	if (DoExtrapolate) {  		//--------------------------------------------------------------------------  		// B                tbb0|-------tbe0|tbb1------|tbe1  		// R+I  trb|---|tre                 		//--------------------------------------------------------------------------  		if (tre <= tbb0) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] = sbi0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B          tbb0|--------|---------|--------|  		// R     trb|----------------|tre                		// I        |-----|  		//---------------------------------------------------------------------------  		if (trb < tbb0)// && tre > tbb0  		 {  			double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				// Linear interpolation' use tbb0 as "endpoint" of interval  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] += sbi0 * (tbb0 - trb) / trl;  				}  			}  		}  		double tbeN0 = _times [_times.Count - 1].End ().StampAsModifiedJulianDay;  		//--------------------------------------------------------------------------  		// B     tbb0|---?----|-------|tbeN0  		// R+I                                trb|---|tre  		//--------------------------------------------------------------------------  		if (tbeN0 < trb) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] = sbiN0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B     |---?----|-------|tbeN0  		// R               trb|-------|tre  		// I                      |---|  		//--------------------------------------------------------------------------  		if (tbeN0 < tre) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  				}  			}  			else {  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  				}  			}  		}  	}  	int nstart = 0;  	int nend = _times.Count - 1;  	// Narrow down the number of spans to investigate' based on the requested span.  	if (nend > 10) {  		// Assuming 4 spans in the buffer' use end-time in GetIntrval  		// will provide the right indices  		// spans                 |-0-|-1-|-2-|-3-|  		// endStamp intervals      0 | 1 | 2 | 3 | 4  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.EndStampAsModifiedJulianDay ());  		nend = _times.Times.GetInterval (tre' out fraction' time => time.End ().StampAsModifiedJulianDay);  		nend = Math.Min (nend' _times.Count - 1);  	}  	for (int n = nstart; n <= nend; n++) {  		double tbbn = _times [n].StampAsModifiedJulianDay;  		double tben = _times [n].EndStampAsModifiedJulianDay ();  		//---------------------------------------------------------------------------  		// B:       tbbn|--------------------------|tben  		// R:     trb|-------------------------------------|tre  		// I:           |--------------------------|  		//---------------------------------------------------------------------------  		if (trb <= tbbn && tre >= tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - tbbn) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbbn|-----------------------|tben  		// R+I:          trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbbn <= trb && tre <= tben)//cover all  		 {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				xr [i] += BufferHelper.GetVal (_values [n]' i);  			}  		}  		//---------------------------------------------------------------------------  		// B:     tbbn|-----------------|tben  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbbn < trb && trb < tben && tre > tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - trb) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:           tbbn|-----------------|tben  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbbn && tre > tbbn && tre < tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tre - tbbn) / (tre - trb);  			}  		}  	}  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeSpansToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	double trl = tre - trb;  	// length of requested time interval  	if (_times.Count == 0)  		throw new Exception ("No times in buffer");  	double tbb0 = _times [0].StampAsModifiedJulianDay;  	// In the following the current abbreviations are used:  	// B: Buffer time  	// R: Requested time  	// I: Time included by this part of the code  	if (DoExtrapolate) {  		//--------------------------------------------------------------------------  		// B                tbb0|-------tbe0|tbb1------|tbe1  		// R+I  trb|---|tre                 		//--------------------------------------------------------------------------  		if (tre <= tbb0) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] = sbi0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B          tbb0|--------|---------|--------|  		// R     trb|----------------|tre                		// I        |-----|  		//---------------------------------------------------------------------------  		if (trb < tbb0)// && tre > tbb0  		 {  			double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				// Linear interpolation' use tbb0 as "endpoint" of interval  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] += sbi0 * (tbb0 - trb) / trl;  				}  			}  		}  		double tbeN0 = _times [_times.Count - 1].End ().StampAsModifiedJulianDay;  		//--------------------------------------------------------------------------  		// B     tbb0|---?----|-------|tbeN0  		// R+I                                trb|---|tre  		//--------------------------------------------------------------------------  		if (tbeN0 < trb) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] = sbiN0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B     |---?----|-------|tbeN0  		// R               trb|-------|tre  		// I                      |---|  		//--------------------------------------------------------------------------  		if (tbeN0 < tre) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  				}  			}  			else {  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  				}  			}  		}  	}  	int nstart = 0;  	int nend = _times.Count - 1;  	// Narrow down the number of spans to investigate' based on the requested span.  	if (nend > 10) {  		// Assuming 4 spans in the buffer' use end-time in GetIntrval  		// will provide the right indices  		// spans                 |-0-|-1-|-2-|-3-|  		// endStamp intervals      0 | 1 | 2 | 3 | 4  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.EndStampAsModifiedJulianDay ());  		nend = _times.Times.GetInterval (tre' out fraction' time => time.End ().StampAsModifiedJulianDay);  		nend = Math.Min (nend' _times.Count - 1);  	}  	for (int n = nstart; n <= nend; n++) {  		double tbbn = _times [n].StampAsModifiedJulianDay;  		double tben = _times [n].EndStampAsModifiedJulianDay ();  		//---------------------------------------------------------------------------  		// B:       tbbn|--------------------------|tben  		// R:     trb|-------------------------------------|tre  		// I:           |--------------------------|  		//---------------------------------------------------------------------------  		if (trb <= tbbn && tre >= tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - tbbn) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbbn|-----------------------|tben  		// R+I:          trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbbn <= trb && tre <= tben)//cover all  		 {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				xr [i] += BufferHelper.GetVal (_values [n]' i);  			}  		}  		//---------------------------------------------------------------------------  		// B:     tbbn|-----------------|tben  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbbn < trb && trb < tben && tre > tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - trb) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:           tbbn|-----------------|tben  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbbn && tre > tbbn && tre < tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tre - tbbn) / (tre - trb);  			}  		}  	}  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeSpansToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	double trl = tre - trb;  	// length of requested time interval  	if (_times.Count == 0)  		throw new Exception ("No times in buffer");  	double tbb0 = _times [0].StampAsModifiedJulianDay;  	// In the following the current abbreviations are used:  	// B: Buffer time  	// R: Requested time  	// I: Time included by this part of the code  	if (DoExtrapolate) {  		//--------------------------------------------------------------------------  		// B                tbb0|-------tbe0|tbb1------|tbe1  		// R+I  trb|---|tre                 		//--------------------------------------------------------------------------  		if (tre <= tbb0) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] = sbi0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B          tbb0|--------|---------|--------|  		// R     trb|----------------|tre                		// I        |-----|  		//---------------------------------------------------------------------------  		if (trb < tbb0)// && tre > tbb0  		 {  			double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				// Linear interpolation' use tbb0 as "endpoint" of interval  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] += sbi0 * (tbb0 - trb) / trl;  				}  			}  		}  		double tbeN0 = _times [_times.Count - 1].End ().StampAsModifiedJulianDay;  		//--------------------------------------------------------------------------  		// B     tbb0|---?----|-------|tbeN0  		// R+I                                trb|---|tre  		//--------------------------------------------------------------------------  		if (tbeN0 < trb) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] = sbiN0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B     |---?----|-------|tbeN0  		// R               trb|-------|tre  		// I                      |---|  		//--------------------------------------------------------------------------  		if (tbeN0 < tre) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  				}  			}  			else {  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  				}  			}  		}  	}  	int nstart = 0;  	int nend = _times.Count - 1;  	// Narrow down the number of spans to investigate' based on the requested span.  	if (nend > 10) {  		// Assuming 4 spans in the buffer' use end-time in GetIntrval  		// will provide the right indices  		// spans                 |-0-|-1-|-2-|-3-|  		// endStamp intervals      0 | 1 | 2 | 3 | 4  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.EndStampAsModifiedJulianDay ());  		nend = _times.Times.GetInterval (tre' out fraction' time => time.End ().StampAsModifiedJulianDay);  		nend = Math.Min (nend' _times.Count - 1);  	}  	for (int n = nstart; n <= nend; n++) {  		double tbbn = _times [n].StampAsModifiedJulianDay;  		double tben = _times [n].EndStampAsModifiedJulianDay ();  		//---------------------------------------------------------------------------  		// B:       tbbn|--------------------------|tben  		// R:     trb|-------------------------------------|tre  		// I:           |--------------------------|  		//---------------------------------------------------------------------------  		if (trb <= tbbn && tre >= tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - tbbn) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbbn|-----------------------|tben  		// R+I:          trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbbn <= trb && tre <= tben)//cover all  		 {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				xr [i] += BufferHelper.GetVal (_values [n]' i);  			}  		}  		//---------------------------------------------------------------------------  		// B:     tbbn|-----------------|tben  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbbn < trb && trb < tben && tre > tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - trb) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:           tbbn|-----------------|tben  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbbn && tre > tbbn && tre < tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tre - tbbn) / (tre - trb);  			}  		}  	}  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeSpansToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	double trl = tre - trb;  	// length of requested time interval  	if (_times.Count == 0)  		throw new Exception ("No times in buffer");  	double tbb0 = _times [0].StampAsModifiedJulianDay;  	// In the following the current abbreviations are used:  	// B: Buffer time  	// R: Requested time  	// I: Time included by this part of the code  	if (DoExtrapolate) {  		//--------------------------------------------------------------------------  		// B                tbb0|-------tbe0|tbb1------|tbe1  		// R+I  trb|---|tre                 		//--------------------------------------------------------------------------  		if (tre <= tbb0) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] = sbi0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B          tbb0|--------|---------|--------|  		// R     trb|----------------|tre                		// I        |-----|  		//---------------------------------------------------------------------------  		if (trb < tbb0)// && tre > tbb0  		 {  			double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				// Linear interpolation' use tbb0 as "endpoint" of interval  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] += sbi0 * (tbb0 - trb) / trl;  				}  			}  		}  		double tbeN0 = _times [_times.Count - 1].End ().StampAsModifiedJulianDay;  		//--------------------------------------------------------------------------  		// B     tbb0|---?----|-------|tbeN0  		// R+I                                trb|---|tre  		//--------------------------------------------------------------------------  		if (tbeN0 < trb) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] = sbiN0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B     |---?----|-------|tbeN0  		// R               trb|-------|tre  		// I                      |---|  		//--------------------------------------------------------------------------  		if (tbeN0 < tre) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  				}  			}  			else {  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  				}  			}  		}  	}  	int nstart = 0;  	int nend = _times.Count - 1;  	// Narrow down the number of spans to investigate' based on the requested span.  	if (nend > 10) {  		// Assuming 4 spans in the buffer' use end-time in GetIntrval  		// will provide the right indices  		// spans                 |-0-|-1-|-2-|-3-|  		// endStamp intervals      0 | 1 | 2 | 3 | 4  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.EndStampAsModifiedJulianDay ());  		nend = _times.Times.GetInterval (tre' out fraction' time => time.End ().StampAsModifiedJulianDay);  		nend = Math.Min (nend' _times.Count - 1);  	}  	for (int n = nstart; n <= nend; n++) {  		double tbbn = _times [n].StampAsModifiedJulianDay;  		double tben = _times [n].EndStampAsModifiedJulianDay ();  		//---------------------------------------------------------------------------  		// B:       tbbn|--------------------------|tben  		// R:     trb|-------------------------------------|tre  		// I:           |--------------------------|  		//---------------------------------------------------------------------------  		if (trb <= tbbn && tre >= tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - tbbn) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbbn|-----------------------|tben  		// R+I:          trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbbn <= trb && tre <= tben)//cover all  		 {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				xr [i] += BufferHelper.GetVal (_values [n]' i);  			}  		}  		//---------------------------------------------------------------------------  		// B:     tbbn|-----------------|tben  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbbn < trb && trb < tben && tre > tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - trb) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:           tbbn|-----------------|tben  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbbn && tre > tbbn && tre < tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tre - tbbn) / (tre - trb);  			}  		}  	}  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeSpansToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	double trl = tre - trb;  	// length of requested time interval  	if (_times.Count == 0)  		throw new Exception ("No times in buffer");  	double tbb0 = _times [0].StampAsModifiedJulianDay;  	// In the following the current abbreviations are used:  	// B: Buffer time  	// R: Requested time  	// I: Time included by this part of the code  	if (DoExtrapolate) {  		//--------------------------------------------------------------------------  		// B                tbb0|-------tbe0|tbb1------|tbe1  		// R+I  trb|---|tre                 		//--------------------------------------------------------------------------  		if (tre <= tbb0) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] = sbi0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B          tbb0|--------|---------|--------|  		// R     trb|----------------|tre                		// I        |-----|  		//---------------------------------------------------------------------------  		if (trb < tbb0)// && tre > tbb0  		 {  			double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  				// Linear interpolation' use tbb0 as "endpoint" of interval  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					double sbi1 = BufferHelper.GetVal (_values [1]' i);  					xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbi0 = BufferHelper.GetVal (_values [0]' i);  					xr [i] += sbi0 * (tbb0 - trb) / trl;  				}  			}  		}  		double tbeN0 = _times [_times.Count - 1].End ().StampAsModifiedJulianDay;  		//--------------------------------------------------------------------------  		// B     tbb0|---?----|-------|tbeN0  		// R+I                                trb|---|tre  		//--------------------------------------------------------------------------  		if (tbeN0 < trb) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				// Linear interpolation  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  				}  			}  			else {  				// Nearest value interpolation  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] = sbiN0;  				}  			}  			// We are done now' just return xr  			return xr;  		}  		//--------------------------------------------------------------------------  		// B     |---?----|-------|tbeN0  		// R               trb|-------|tre  		// I                      |---|  		//--------------------------------------------------------------------------  		if (tbeN0 < tre) {  			if (_times.Count >= 2 && _relaxationFactor != 1) {  				//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  				double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  				double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  					xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  				}  			}  			else {  				for (int i = 0; i < m; i++) {  					double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  					xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  				}  			}  		}  	}  	int nstart = 0;  	int nend = _times.Count - 1;  	// Narrow down the number of spans to investigate' based on the requested span.  	if (nend > 10) {  		// Assuming 4 spans in the buffer' use end-time in GetIntrval  		// will provide the right indices  		// spans                 |-0-|-1-|-2-|-3-|  		// endStamp intervals      0 | 1 | 2 | 3 | 4  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.EndStampAsModifiedJulianDay ());  		nend = _times.Times.GetInterval (tre' out fraction' time => time.End ().StampAsModifiedJulianDay);  		nend = Math.Min (nend' _times.Count - 1);  	}  	for (int n = nstart; n <= nend; n++) {  		double tbbn = _times [n].StampAsModifiedJulianDay;  		double tben = _times [n].EndStampAsModifiedJulianDay ();  		//---------------------------------------------------------------------------  		// B:       tbbn|--------------------------|tben  		// R:     trb|-------------------------------------|tre  		// I:           |--------------------------|  		//---------------------------------------------------------------------------  		if (trb <= tbbn && tre >= tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - tbbn) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbbn|-----------------------|tben  		// R+I:          trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbbn <= trb && tre <= tben)//cover all  		 {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				xr [i] += BufferHelper.GetVal (_values [n]' i);  			}  		}  		//---------------------------------------------------------------------------  		// B:     tbbn|-----------------|tben  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbbn < trb && trb < tben && tre > tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tben - trb) / (tre - trb);  			}  		}  		//---------------------------------------------------------------------------  		// B:           tbbn|-----------------|tben  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbbn && tre > tbbn && tre < tben) {  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin * (tre - tbbn) / (tre - trb);  			}  		}  	}  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeSpansToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (DoExtrapolate) {  	//--------------------------------------------------------------------------  	// B                tbb0|-------tbe0|tbb1------|tbe1  	// R+I  trb|---|tre                 	//--------------------------------------------------------------------------  	if (tre <= tbb0) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			// Linear interpolation  			double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  			double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  			//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				xr [i] = sbi0;  			}  		}  		// We are done now' just return xr  		return xr;  	}  	//--------------------------------------------------------------------------  	// B          tbb0|--------|---------|--------|  	// R     trb|----------------|tre                	// I        |-----|  	//---------------------------------------------------------------------------  	if (trb < tbb0)// && tre > tbb0  	 {  		double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  			// Linear interpolation' use tbb0 as "endpoint" of interval  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				xr [i] += sbi0 * (tbb0 - trb) / trl;  			}  		}  	}  	double tbeN0 = _times [_times.Count - 1].End ().StampAsModifiedJulianDay;  	//--------------------------------------------------------------------------  	// B     tbb0|---?----|-------|tbeN0  	// R+I                                trb|---|tre  	//--------------------------------------------------------------------------  	if (tbeN0 < trb) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			// Linear interpolation  			double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  			//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] = sbiN0;  			}  		}  		// We are done now' just return xr  		return xr;  	}  	//--------------------------------------------------------------------------  	// B     |---?----|-------|tbeN0  	// R               trb|-------|tre  	// I                      |---|  	//--------------------------------------------------------------------------  	if (tbeN0 < tre) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  			double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  			}  		}  		else {  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  			}  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (DoExtrapolate) {  	//--------------------------------------------------------------------------  	// B                tbb0|-------tbe0|tbb1------|tbe1  	// R+I  trb|---|tre                 	//--------------------------------------------------------------------------  	if (tre <= tbb0) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			// Linear interpolation  			double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  			double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  			//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				xr [i] = sbi0;  			}  		}  		// We are done now' just return xr  		return xr;  	}  	//--------------------------------------------------------------------------  	// B          tbb0|--------|---------|--------|  	// R     trb|----------------|tre                	// I        |-----|  	//---------------------------------------------------------------------------  	if (trb < tbb0)// && tre > tbb0  	 {  		double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  			// Linear interpolation' use tbb0 as "endpoint" of interval  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				xr [i] += sbi0 * (tbb0 - trb) / trl;  			}  		}  	}  	double tbeN0 = _times [_times.Count - 1].End ().StampAsModifiedJulianDay;  	//--------------------------------------------------------------------------  	// B     tbb0|---?----|-------|tbeN0  	// R+I                                trb|---|tre  	//--------------------------------------------------------------------------  	if (tbeN0 < trb) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			// Linear interpolation  			double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  			//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] = sbiN0;  			}  		}  		// We are done now' just return xr  		return xr;  	}  	//--------------------------------------------------------------------------  	// B     |---?----|-------|tbeN0  	// R               trb|-------|tre  	// I                      |---|  	//--------------------------------------------------------------------------  	if (tbeN0 < tre) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  			double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  			}  		}  		else {  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  			}  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (DoExtrapolate) {  	//--------------------------------------------------------------------------  	// B                tbb0|-------tbe0|tbb1------|tbe1  	// R+I  trb|---|tre                 	//--------------------------------------------------------------------------  	if (tre <= tbb0) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			// Linear interpolation  			double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  			double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  			//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				xr [i] = sbi0;  			}  		}  		// We are done now' just return xr  		return xr;  	}  	//--------------------------------------------------------------------------  	// B          tbb0|--------|---------|--------|  	// R     trb|----------------|tre                	// I        |-----|  	//---------------------------------------------------------------------------  	if (trb < tbb0)// && tre > tbb0  	 {  		double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  			// Linear interpolation' use tbb0 as "endpoint" of interval  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				xr [i] += sbi0 * (tbb0 - trb) / trl;  			}  		}  	}  	double tbeN0 = _times [_times.Count - 1].End ().StampAsModifiedJulianDay;  	//--------------------------------------------------------------------------  	// B     tbb0|---?----|-------|tbeN0  	// R+I                                trb|---|tre  	//--------------------------------------------------------------------------  	if (tbeN0 < trb) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			// Linear interpolation  			double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  			//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] = sbiN0;  			}  		}  		// We are done now' just return xr  		return xr;  	}  	//--------------------------------------------------------------------------  	// B     |---?----|-------|tbeN0  	// R               trb|-------|tre  	// I                      |---|  	//--------------------------------------------------------------------------  	if (tbeN0 < tre) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  			double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  			}  		}  		else {  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  			}  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (DoExtrapolate) {  	//--------------------------------------------------------------------------  	// B                tbb0|-------tbe0|tbb1------|tbe1  	// R+I  trb|---|tre                 	//--------------------------------------------------------------------------  	if (tre <= tbb0) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			// Linear interpolation  			double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  			double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  			//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				xr [i] = sbi0;  			}  		}  		// We are done now' just return xr  		return xr;  	}  	//--------------------------------------------------------------------------  	// B          tbb0|--------|---------|--------|  	// R     trb|----------------|tre                	// I        |-----|  	//---------------------------------------------------------------------------  	if (trb < tbb0)// && tre > tbb0  	 {  		double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  			// Linear interpolation' use tbb0 as "endpoint" of interval  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				xr [i] += sbi0 * (tbb0 - trb) / trl;  			}  		}  	}  	double tbeN0 = _times [_times.Count - 1].End ().StampAsModifiedJulianDay;  	//--------------------------------------------------------------------------  	// B     tbb0|---?----|-------|tbeN0  	// R+I                                trb|---|tre  	//--------------------------------------------------------------------------  	if (tbeN0 < trb) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			// Linear interpolation  			double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  			//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] = sbiN0;  			}  		}  		// We are done now' just return xr  		return xr;  	}  	//--------------------------------------------------------------------------  	// B     |---?----|-------|tbeN0  	// R               trb|-------|tre  	// I                      |---|  	//--------------------------------------------------------------------------  	if (tbeN0 < tre) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  			double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  			}  		}  		else {  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  			}  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (DoExtrapolate) {  	//--------------------------------------------------------------------------  	// B                tbb0|-------tbe0|tbb1------|tbe1  	// R+I  trb|---|tre                 	//--------------------------------------------------------------------------  	if (tre <= tbb0) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			// Linear interpolation  			double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  			double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  			//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				xr [i] = sbi0;  			}  		}  		// We are done now' just return xr  		return xr;  	}  	//--------------------------------------------------------------------------  	// B          tbb0|--------|---------|--------|  	// R     trb|----------------|tre                	// I        |-----|  	//---------------------------------------------------------------------------  	if (trb < tbb0)// && tre > tbb0  	 {  		double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  			// Linear interpolation' use tbb0 as "endpoint" of interval  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				xr [i] += sbi0 * (tbb0 - trb) / trl;  			}  		}  	}  	double tbeN0 = _times [_times.Count - 1].End ().StampAsModifiedJulianDay;  	//--------------------------------------------------------------------------  	// B     tbb0|---?----|-------|tbeN0  	// R+I                                trb|---|tre  	//--------------------------------------------------------------------------  	if (tbeN0 < trb) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			// Linear interpolation  			double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  			//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] = sbiN0;  			}  		}  		// We are done now' just return xr  		return xr;  	}  	//--------------------------------------------------------------------------  	// B     |---?----|-------|tbeN0  	// R               trb|-------|tre  	// I                      |---|  	//--------------------------------------------------------------------------  	if (tbeN0 < tre) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  			double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  			}  		}  		else {  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  			}  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (DoExtrapolate) {  	//--------------------------------------------------------------------------  	// B                tbb0|-------tbe0|tbb1------|tbe1  	// R+I  trb|---|tre                 	//--------------------------------------------------------------------------  	if (tre <= tbb0) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			// Linear interpolation  			double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  			double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  			//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				xr [i] = sbi0;  			}  		}  		// We are done now' just return xr  		return xr;  	}  	//--------------------------------------------------------------------------  	// B          tbb0|--------|---------|--------|  	// R     trb|----------------|tre                	// I        |-----|  	//---------------------------------------------------------------------------  	if (trb < tbb0)// && tre > tbb0  	 {  		double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  			// Linear interpolation' use tbb0 as "endpoint" of interval  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				xr [i] += sbi0 * (tbb0 - trb) / trl;  			}  		}  	}  	double tbeN0 = _times [_times.Count - 1].End ().StampAsModifiedJulianDay;  	//--------------------------------------------------------------------------  	// B     tbb0|---?----|-------|tbeN0  	// R+I                                trb|---|tre  	//--------------------------------------------------------------------------  	if (tbeN0 < trb) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			// Linear interpolation  			double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  			//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] = sbiN0;  			}  		}  		// We are done now' just return xr  		return xr;  	}  	//--------------------------------------------------------------------------  	// B     |---?----|-------|tbeN0  	// R               trb|-------|tre  	// I                      |---|  	//--------------------------------------------------------------------------  	if (tbeN0 < tre) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  			double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  			}  		}  		else {  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  			}  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (DoExtrapolate) {  	//--------------------------------------------------------------------------  	// B                tbb0|-------tbe0|tbb1------|tbe1  	// R+I  trb|---|tre                 	//--------------------------------------------------------------------------  	if (tre <= tbb0) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			// Linear interpolation  			double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  			double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  			//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				xr [i] = sbi0;  			}  		}  		// We are done now' just return xr  		return xr;  	}  	//--------------------------------------------------------------------------  	// B          tbb0|--------|---------|--------|  	// R     trb|----------------|tre                	// I        |-----|  	//---------------------------------------------------------------------------  	if (trb < tbb0)// && tre > tbb0  	 {  		double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  			// Linear interpolation' use tbb0 as "endpoint" of interval  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				xr [i] += sbi0 * (tbb0 - trb) / trl;  			}  		}  	}  	double tbeN0 = _times [_times.Count - 1].End ().StampAsModifiedJulianDay;  	//--------------------------------------------------------------------------  	// B     tbb0|---?----|-------|tbeN0  	// R+I                                trb|---|tre  	//--------------------------------------------------------------------------  	if (tbeN0 < trb) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			// Linear interpolation  			double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  			//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] = sbiN0;  			}  		}  		// We are done now' just return xr  		return xr;  	}  	//--------------------------------------------------------------------------  	// B     |---?----|-------|tbeN0  	// R               trb|-------|tre  	// I                      |---|  	//--------------------------------------------------------------------------  	if (tbeN0 < tre) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  			double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  			}  		}  		else {  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  			}  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (DoExtrapolate) {  	//--------------------------------------------------------------------------  	// B                tbb0|-------tbe0|tbb1------|tbe1  	// R+I  trb|---|tre                 	//--------------------------------------------------------------------------  	if (tre <= tbb0) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			// Linear interpolation  			double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  			double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  			//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				xr [i] = sbi0;  			}  		}  		// We are done now' just return xr  		return xr;  	}  	//--------------------------------------------------------------------------  	// B          tbb0|--------|---------|--------|  	// R     trb|----------------|tre                	// I        |-----|  	//---------------------------------------------------------------------------  	if (trb < tbb0)// && tre > tbb0  	 {  		double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  			// Linear interpolation' use tbb0 as "endpoint" of interval  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				xr [i] += sbi0 * (tbb0 - trb) / trl;  			}  		}  	}  	double tbeN0 = _times [_times.Count - 1].End ().StampAsModifiedJulianDay;  	//--------------------------------------------------------------------------  	// B     tbb0|---?----|-------|tbeN0  	// R+I                                trb|---|tre  	//--------------------------------------------------------------------------  	if (tbeN0 < trb) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			// Linear interpolation  			double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  			//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] = sbiN0;  			}  		}  		// We are done now' just return xr  		return xr;  	}  	//--------------------------------------------------------------------------  	// B     |---?----|-------|tbeN0  	// R               trb|-------|tre  	// I                      |---|  	//--------------------------------------------------------------------------  	if (tbeN0 < tre) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  			double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  			}  		}  		else {  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  			}  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (DoExtrapolate) {  	//--------------------------------------------------------------------------  	// B                tbb0|-------tbe0|tbb1------|tbe1  	// R+I  trb|---|tre                 	//--------------------------------------------------------------------------  	if (tre <= tbb0) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			// Linear interpolation  			double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  			double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  			//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				xr [i] = sbi0;  			}  		}  		// We are done now' just return xr  		return xr;  	}  	//--------------------------------------------------------------------------  	// B          tbb0|--------|---------|--------|  	// R     trb|----------------|tre                	// I        |-----|  	//---------------------------------------------------------------------------  	if (trb < tbb0)// && tre > tbb0  	 {  		double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  			// Linear interpolation' use tbb0 as "endpoint" of interval  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				xr [i] += sbi0 * (tbb0 - trb) / trl;  			}  		}  	}  	double tbeN0 = _times [_times.Count - 1].End ().StampAsModifiedJulianDay;  	//--------------------------------------------------------------------------  	// B     tbb0|---?----|-------|tbeN0  	// R+I                                trb|---|tre  	//--------------------------------------------------------------------------  	if (tbeN0 < trb) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			// Linear interpolation  			double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  			//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] = sbiN0;  			}  		}  		// We are done now' just return xr  		return xr;  	}  	//--------------------------------------------------------------------------  	// B     |---?----|-------|tbeN0  	// R               trb|-------|tre  	// I                      |---|  	//--------------------------------------------------------------------------  	if (tbeN0 < tre) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  			double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  			}  		}  		else {  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  			}  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (DoExtrapolate) {  	//--------------------------------------------------------------------------  	// B                tbb0|-------tbe0|tbb1------|tbe1  	// R+I  trb|---|tre                 	//--------------------------------------------------------------------------  	if (tre <= tbb0) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			// Linear interpolation  			double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  			double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  			//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				xr [i] = sbi0;  			}  		}  		// We are done now' just return xr  		return xr;  	}  	//--------------------------------------------------------------------------  	// B          tbb0|--------|---------|--------|  	// R     trb|----------------|tre                	// I        |-----|  	//---------------------------------------------------------------------------  	if (trb < tbb0)// && tre > tbb0  	 {  		double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  			// Linear interpolation' use tbb0 as "endpoint" of interval  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				xr [i] += sbi0 * (tbb0 - trb) / trl;  			}  		}  	}  	double tbeN0 = _times [_times.Count - 1].End ().StampAsModifiedJulianDay;  	//--------------------------------------------------------------------------  	// B     tbb0|---?----|-------|tbeN0  	// R+I                                trb|---|tre  	//--------------------------------------------------------------------------  	if (tbeN0 < trb) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			// Linear interpolation  			double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  			//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  			}  		}  		else {  			// Nearest value interpolation  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] = sbiN0;  			}  		}  		// We are done now' just return xr  		return xr;  	}  	//--------------------------------------------------------------------------  	// B     |---?----|-------|tbeN0  	// R               trb|-------|tre  	// I                      |---|  	//--------------------------------------------------------------------------  	if (tbeN0 < tre) {  		if (_times.Count >= 2 && _relaxationFactor != 1) {  			//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  			double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  			}  		}  		else {  			for (int i = 0; i < m; i++) {  				double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  			}  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (tre <= tbb0) {  	if (_times.Count >= 2 && _relaxationFactor != 1) {  		// Linear interpolation  		double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  		double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  		//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  		}  	}  	else {  		// Nearest value interpolation  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			xr [i] = sbi0;  		}  	}  	// We are done now' just return xr  	return xr;  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (_times.Count >= 2 && _relaxationFactor != 1) {  	// Linear interpolation  	double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  	double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  	//double tbb1 = ((ITimeSpan) times[1]).Start.StampAsModifiedJulianDay;  	for (int i = 0; i < m; i++) {  		double sbi0 = BufferHelper.GetVal (_values [0]' i);  		double sbi1 = BufferHelper.GetVal (_values [1]' i);  		xr [i] = sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 + tbb0 - tre - trb) / (tbe1 - tbb0);  	}  }  else {  	// Nearest value interpolation  	for (int i = 0; i < m; i++) {  		double sbi0 = BufferHelper.GetVal (_values [0]' i);  		xr [i] = sbi0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (trb < tbb0)// && tre > tbb0   {  	double tbe0 = _times [0].EndStampAsModifiedJulianDay ();  	if (_times.Count >= 2 && _relaxationFactor != 1) {  		double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  		// Linear interpolation' use tbb0 as "endpoint" of interval  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  		}  	}  	else {  		// Nearest value interpolation  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			xr [i] += sbi0 * (tbb0 - trb) / trl;  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (_times.Count >= 2 && _relaxationFactor != 1) {  	double tbe1 = _times [1].EndStampAsModifiedJulianDay ();  	// Linear interpolation' use tbb0 as "endpoint" of interval  	for (int i = 0; i < m; i++) {  		double sbi0 = BufferHelper.GetVal (_values [0]' i);  		double sbi1 = BufferHelper.GetVal (_values [1]' i);  		xr [i] += ((tbb0 - trb) / trl) * (sbi0 - (1 - _relaxationFactor) * (sbi1 - sbi0) * (tbe0 - trb) / (tbe1 - tbb0));  	}  }  else {  	// Nearest value interpolation  	for (int i = 0; i < m; i++) {  		double sbi0 = BufferHelper.GetVal (_values [0]' i);  		xr [i] += sbi0 * (tbb0 - trb) / trl;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (tbeN0 < trb) {  	if (_times.Count >= 2 && _relaxationFactor != 1) {  		// Linear interpolation  		double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  		double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  		for (int i = 0; i < m; i++) {  			double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  		}  	}  	else {  		// Nearest value interpolation  		for (int i = 0; i < m; i++) {  			double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			xr [i] = sbiN0;  		}  	}  	// We are done now' just return xr  	return xr;  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (tbeN0 < trb) {  	if (_times.Count >= 2 && _relaxationFactor != 1) {  		// Linear interpolation  		double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  		double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  		for (int i = 0; i < m; i++) {  			double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  		}  	}  	else {  		// Nearest value interpolation  		for (int i = 0; i < m; i++) {  			double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			xr [i] = sbiN0;  		}  	}  	// We are done now' just return xr  	return xr;  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (tbeN0 < trb) {  	if (_times.Count >= 2 && _relaxationFactor != 1) {  		// Linear interpolation  		double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  		double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  		for (int i = 0; i < m; i++) {  			double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  		}  	}  	else {  		// Nearest value interpolation  		for (int i = 0; i < m; i++) {  			double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			xr [i] = sbiN0;  		}  	}  	// We are done now' just return xr  	return xr;  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (tbeN0 < trb) {  	if (_times.Count >= 2 && _relaxationFactor != 1) {  		// Linear interpolation  		double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  		double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  		for (int i = 0; i < m; i++) {  			double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  		}  	}  	else {  		// Nearest value interpolation  		for (int i = 0; i < m; i++) {  			double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			xr [i] = sbiN0;  		}  	}  	// We are done now' just return xr  	return xr;  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (_times.Count >= 2 && _relaxationFactor != 1) {  	// Linear interpolation  	double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  	double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  	//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  	for (int i = 0; i < m; i++) {  		double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  		xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  	}  }  else {  	// Nearest value interpolation  	for (int i = 0; i < m; i++) {  		double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		xr [i] = sbiN0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (_times.Count >= 2 && _relaxationFactor != 1) {  	// Linear interpolation  	double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  	double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  	//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  	for (int i = 0; i < m; i++) {  		double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  		xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  	}  }  else {  	// Nearest value interpolation  	for (int i = 0; i < m; i++) {  		double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		xr [i] = sbiN0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (_times.Count >= 2 && _relaxationFactor != 1) {  	// Linear interpolation  	double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  	double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  	//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  	for (int i = 0; i < m; i++) {  		double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  		xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  	}  }  else {  	// Nearest value interpolation  	for (int i = 0; i < m; i++) {  		double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		xr [i] = sbiN0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (_times.Count >= 2 && _relaxationFactor != 1) {  	// Linear interpolation  	double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  	double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  	//double tbbN_1 = ((ITimeSpan) times[times.Count-1]).Start.StampAsModifiedJulianDay;  	for (int i = 0; i < m; i++) {  		double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  		xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  	}  }  else {  	// Nearest value interpolation  	for (int i = 0; i < m; i++) {  		double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		xr [i] = sbiN0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  	double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  	xr [i] = sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (trb + tre - tbeN0 - tbeN1) / (tbeN0 - tbbN1);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (tbeN0 < tre) {  	if (_times.Count >= 2 && _relaxationFactor != 1) {  		//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  		double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  		double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		for (int i = 0; i < m; i++) {  			double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  		}  	}  	else {  		for (int i = 0; i < m; i++) {  			double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (tbeN0 < tre) {  	if (_times.Count >= 2 && _relaxationFactor != 1) {  		//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  		double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  		double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		for (int i = 0; i < m; i++) {  			double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  		}  	}  	else {  		for (int i = 0; i < m; i++) {  			double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (tbeN0 < tre) {  	if (_times.Count >= 2 && _relaxationFactor != 1) {  		//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  		double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  		double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		for (int i = 0; i < m; i++) {  			double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  		}  	}  	else {  		for (int i = 0; i < m; i++) {  			double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (tbeN0 < tre) {  	if (_times.Count >= 2 && _relaxationFactor != 1) {  		//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  		double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  		double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		for (int i = 0; i < m; i++) {  			double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  		}  	}  	else {  		for (int i = 0; i < m; i++) {  			double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (_times.Count >= 2 && _relaxationFactor != 1) {  	//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  	double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  	double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  	for (int i = 0; i < m; i++) {  		double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  		xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  	}  }  else {  	for (int i = 0; i < m; i++) {  		double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (_times.Count >= 2 && _relaxationFactor != 1) {  	//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  	double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  	double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  	for (int i = 0; i < m; i++) {  		double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  		xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  	}  }  else {  	for (int i = 0; i < m; i++) {  		double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (_times.Count >= 2 && _relaxationFactor != 1) {  	//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  	double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  	double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  	for (int i = 0; i < m; i++) {  		double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  		xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  	}  }  else {  	for (int i = 0; i < m; i++) {  		double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (_times.Count >= 2 && _relaxationFactor != 1) {  	//double tbeN_2 = ((ITimeSpan) times[times.Count-2]).End.StampAsModifiedJulianDay;  	double tbeN1 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  	double tbbN1 = _times [_times.Count - 2].StampAsModifiedJulianDay;  	for (int i = 0; i < m; i++) {  		double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  		xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  	}  }  else {  	for (int i = 0; i < m; i++) {  		double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		xr [i] += sbiN0 * ((tre - tbeN0) / (tre - trb));  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	double sbiN0 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  	double sbiN1 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  	xr [i] += ((tre - tbeN0) / (tre - trb)) * (sbiN0 + (1 - _relaxationFactor) * (sbiN0 - sbiN1) * (tre - tbeN1) / (tbeN0 - tbbN1));  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeSpan,The following statement contains a magic number: if (nend > 10) {  	// Assuming 4 spans in the buffer' use end-time in GetIntrval  	// will provide the right indices  	// spans                 |-0-|-1-|-2-|-3-|  	// endStamp intervals      0 | 1 | 2 | 3 | 4  	double fraction;  	nstart = _times.Times.GetInterval (trb' out fraction' time => time.EndStampAsModifiedJulianDay ());  	nend = _times.Times.GetInterval (tre' out fraction' time => time.End ().StampAsModifiedJulianDay);  	nend = Math.Min (nend' _times.Count - 1);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	//int        N  = times.Count;								   	      // Number of time steps in buffer  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	//---------------------------------------------------------------------------  	// This handles values within the time horizon of the buffer' i.e.  	// there must be at least two values in the buffer.  	int nstart = 1;  	int nend = _times.Count - 1;  	// Narrow down the number of intervals to investigate' based on the requested span.  	if (nend > 4) {  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.StampAsModifiedJulianDay);  		nend = _times.Times.GetInterval (tre' out fraction' time => time.StampAsModifiedJulianDay);  		nstart = Math.Max (nstart' 1);  		nend = Math.Min (nend' _times.Count - 1);  	}  	// n corresponds to the n'th interval between the time stamps.  	for (int n = nstart; n <= nend; n++) {  		double tbn = _times [n - 1].StampAsModifiedJulianDay;  		double tbnp1 = _times [n].StampAsModifiedJulianDay;  		//---------------------------------------------------------------------------  		//    B:        tbn|--------------------------|tbnp1  		//    R:     trb|-------------------------------------|tre  		//    I:           |--------------------------|  		// --------------------------------------------------------------------------  		if (trb <= tbn && tre >= tbnp1) {  			double factor = (tbnp1 - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += 0.5 * (sbin + sbinp1) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:       tbn|-----------------------|tbnp1  		// R+I:         trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbn <= trb && tre <= tbnp1)//cover all  		 {  			double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  			for (int i = 0; i < m; i++)// for all elements  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin + (sbinp1 - sbin) * fraction;  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbn|-----------------|tbnp1  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  			double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  			double factor = (tbnp1 - trb) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:            tbn|-----------------|tbnp1  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbn && tre > tbn && tre < tbnp1) {  			double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  			double factor = (tre - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  			}  		}  	}  	//---------------------------------------------------------------------------  	// This handles values outside the time horizon of the buffer.  	//--------------------------------------------------------------------------  	// In case of only one value in the buffer' regardless of its position relative to R  	//    |     or     |     or   |               B  	//        |----------------|                  R  	//---------------------------------------------------------------------------  	if (_times.Count == 1) {  		// TODO: Test if extrapolation is ok.  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			xr [i] = sbi0;  		}  	}  	else {  		// At least two stamp values in the buffer' so we can do extrapolation  		//--------------------------------------------------------------------------  		//  B:       tb0|-----tb1|---------|--------|  		//  R: trb|----------------|tre  		//  I:    |-----|  		//---------------------------------------------------------------------------  		double tb0 = _times [0].StampAsModifiedJulianDay;  		double tb1 = _times [1].StampAsModifiedJulianDay;  		double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  		double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		if (trb < tb0 && tre > tb0) {  			double fraction = (1 - _relaxationFactor) * 0.5 * (tb0 - trb) / (tb1 - tb0);  			double factor = ((tb0 - trb) / (tre - trb));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += factor * (sbi0 - fraction * (sbi1 - sbi0));  			}  		}  		//-------------------------------------------------------------------------------------  		// B     |--------|---------|tbn_2---|tbn_1  		// R                        trb|----------------|tre  		// I                                 |----------|   		//-------------------------------------------------------------------------------------  		if (tre > tbN_1 && trb < tbN_1) {  			double factor = ((tre - tbN_1) / (tre - trb));  			double fraction = (1 - _relaxationFactor) * 0.5 * (tre - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :   |--------|---------|tbn_2---|tbn_1  		// R+I :                                   trb|----------------|tre  		//-------------------------------------------------------------------------------------  		if (trb >= tbN_1) {  			double fraction = (1 - _relaxationFactor) * (0.5 * (trb + tre) - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :                  tb0|-----tb1|---------|--------| B  		// R+I :   trb|-------|tre  		//-------------------------------------------------------------------------------------  		if (tre <= tb0) {  			double fraction = (1 - _relaxationFactor) / (tb1 - tb0) * (tb0 - 0.5 * (trb + tre));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (sbi1 - sbi0) * fraction;  			}  		}  	}  	//-------------------------------------------------------------------------------------  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeStampsToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	//int        N  = times.Count;								   	      // Number of time steps in buffer  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	//---------------------------------------------------------------------------  	// This handles values within the time horizon of the buffer' i.e.  	// there must be at least two values in the buffer.  	int nstart = 1;  	int nend = _times.Count - 1;  	// Narrow down the number of intervals to investigate' based on the requested span.  	if (nend > 4) {  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.StampAsModifiedJulianDay);  		nend = _times.Times.GetInterval (tre' out fraction' time => time.StampAsModifiedJulianDay);  		nstart = Math.Max (nstart' 1);  		nend = Math.Min (nend' _times.Count - 1);  	}  	// n corresponds to the n'th interval between the time stamps.  	for (int n = nstart; n <= nend; n++) {  		double tbn = _times [n - 1].StampAsModifiedJulianDay;  		double tbnp1 = _times [n].StampAsModifiedJulianDay;  		//---------------------------------------------------------------------------  		//    B:        tbn|--------------------------|tbnp1  		//    R:     trb|-------------------------------------|tre  		//    I:           |--------------------------|  		// --------------------------------------------------------------------------  		if (trb <= tbn && tre >= tbnp1) {  			double factor = (tbnp1 - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += 0.5 * (sbin + sbinp1) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:       tbn|-----------------------|tbnp1  		// R+I:         trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbn <= trb && tre <= tbnp1)//cover all  		 {  			double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  			for (int i = 0; i < m; i++)// for all elements  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin + (sbinp1 - sbin) * fraction;  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbn|-----------------|tbnp1  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  			double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  			double factor = (tbnp1 - trb) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:            tbn|-----------------|tbnp1  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbn && tre > tbn && tre < tbnp1) {  			double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  			double factor = (tre - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  			}  		}  	}  	//---------------------------------------------------------------------------  	// This handles values outside the time horizon of the buffer.  	//--------------------------------------------------------------------------  	// In case of only one value in the buffer' regardless of its position relative to R  	//    |     or     |     or   |               B  	//        |----------------|                  R  	//---------------------------------------------------------------------------  	if (_times.Count == 1) {  		// TODO: Test if extrapolation is ok.  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			xr [i] = sbi0;  		}  	}  	else {  		// At least two stamp values in the buffer' so we can do extrapolation  		//--------------------------------------------------------------------------  		//  B:       tb0|-----tb1|---------|--------|  		//  R: trb|----------------|tre  		//  I:    |-----|  		//---------------------------------------------------------------------------  		double tb0 = _times [0].StampAsModifiedJulianDay;  		double tb1 = _times [1].StampAsModifiedJulianDay;  		double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  		double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		if (trb < tb0 && tre > tb0) {  			double fraction = (1 - _relaxationFactor) * 0.5 * (tb0 - trb) / (tb1 - tb0);  			double factor = ((tb0 - trb) / (tre - trb));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += factor * (sbi0 - fraction * (sbi1 - sbi0));  			}  		}  		//-------------------------------------------------------------------------------------  		// B     |--------|---------|tbn_2---|tbn_1  		// R                        trb|----------------|tre  		// I                                 |----------|   		//-------------------------------------------------------------------------------------  		if (tre > tbN_1 && trb < tbN_1) {  			double factor = ((tre - tbN_1) / (tre - trb));  			double fraction = (1 - _relaxationFactor) * 0.5 * (tre - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :   |--------|---------|tbn_2---|tbn_1  		// R+I :                                   trb|----------------|tre  		//-------------------------------------------------------------------------------------  		if (trb >= tbN_1) {  			double fraction = (1 - _relaxationFactor) * (0.5 * (trb + tre) - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :                  tb0|-----tb1|---------|--------| B  		// R+I :   trb|-------|tre  		//-------------------------------------------------------------------------------------  		if (tre <= tb0) {  			double fraction = (1 - _relaxationFactor) / (tb1 - tb0) * (tb0 - 0.5 * (trb + tre));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (sbi1 - sbi0) * fraction;  			}  		}  	}  	//-------------------------------------------------------------------------------------  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeStampsToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	//int        N  = times.Count;								   	      // Number of time steps in buffer  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	//---------------------------------------------------------------------------  	// This handles values within the time horizon of the buffer' i.e.  	// there must be at least two values in the buffer.  	int nstart = 1;  	int nend = _times.Count - 1;  	// Narrow down the number of intervals to investigate' based on the requested span.  	if (nend > 4) {  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.StampAsModifiedJulianDay);  		nend = _times.Times.GetInterval (tre' out fraction' time => time.StampAsModifiedJulianDay);  		nstart = Math.Max (nstart' 1);  		nend = Math.Min (nend' _times.Count - 1);  	}  	// n corresponds to the n'th interval between the time stamps.  	for (int n = nstart; n <= nend; n++) {  		double tbn = _times [n - 1].StampAsModifiedJulianDay;  		double tbnp1 = _times [n].StampAsModifiedJulianDay;  		//---------------------------------------------------------------------------  		//    B:        tbn|--------------------------|tbnp1  		//    R:     trb|-------------------------------------|tre  		//    I:           |--------------------------|  		// --------------------------------------------------------------------------  		if (trb <= tbn && tre >= tbnp1) {  			double factor = (tbnp1 - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += 0.5 * (sbin + sbinp1) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:       tbn|-----------------------|tbnp1  		// R+I:         trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbn <= trb && tre <= tbnp1)//cover all  		 {  			double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  			for (int i = 0; i < m; i++)// for all elements  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin + (sbinp1 - sbin) * fraction;  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbn|-----------------|tbnp1  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  			double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  			double factor = (tbnp1 - trb) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:            tbn|-----------------|tbnp1  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbn && tre > tbn && tre < tbnp1) {  			double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  			double factor = (tre - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  			}  		}  	}  	//---------------------------------------------------------------------------  	// This handles values outside the time horizon of the buffer.  	//--------------------------------------------------------------------------  	// In case of only one value in the buffer' regardless of its position relative to R  	//    |     or     |     or   |               B  	//        |----------------|                  R  	//---------------------------------------------------------------------------  	if (_times.Count == 1) {  		// TODO: Test if extrapolation is ok.  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			xr [i] = sbi0;  		}  	}  	else {  		// At least two stamp values in the buffer' so we can do extrapolation  		//--------------------------------------------------------------------------  		//  B:       tb0|-----tb1|---------|--------|  		//  R: trb|----------------|tre  		//  I:    |-----|  		//---------------------------------------------------------------------------  		double tb0 = _times [0].StampAsModifiedJulianDay;  		double tb1 = _times [1].StampAsModifiedJulianDay;  		double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  		double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		if (trb < tb0 && tre > tb0) {  			double fraction = (1 - _relaxationFactor) * 0.5 * (tb0 - trb) / (tb1 - tb0);  			double factor = ((tb0 - trb) / (tre - trb));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += factor * (sbi0 - fraction * (sbi1 - sbi0));  			}  		}  		//-------------------------------------------------------------------------------------  		// B     |--------|---------|tbn_2---|tbn_1  		// R                        trb|----------------|tre  		// I                                 |----------|   		//-------------------------------------------------------------------------------------  		if (tre > tbN_1 && trb < tbN_1) {  			double factor = ((tre - tbN_1) / (tre - trb));  			double fraction = (1 - _relaxationFactor) * 0.5 * (tre - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :   |--------|---------|tbn_2---|tbn_1  		// R+I :                                   trb|----------------|tre  		//-------------------------------------------------------------------------------------  		if (trb >= tbN_1) {  			double fraction = (1 - _relaxationFactor) * (0.5 * (trb + tre) - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :                  tb0|-----tb1|---------|--------| B  		// R+I :   trb|-------|tre  		//-------------------------------------------------------------------------------------  		if (tre <= tb0) {  			double fraction = (1 - _relaxationFactor) / (tb1 - tb0) * (tb0 - 0.5 * (trb + tre));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (sbi1 - sbi0) * fraction;  			}  		}  	}  	//-------------------------------------------------------------------------------------  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeStampsToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	//int        N  = times.Count;								   	      // Number of time steps in buffer  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	//---------------------------------------------------------------------------  	// This handles values within the time horizon of the buffer' i.e.  	// there must be at least two values in the buffer.  	int nstart = 1;  	int nend = _times.Count - 1;  	// Narrow down the number of intervals to investigate' based on the requested span.  	if (nend > 4) {  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.StampAsModifiedJulianDay);  		nend = _times.Times.GetInterval (tre' out fraction' time => time.StampAsModifiedJulianDay);  		nstart = Math.Max (nstart' 1);  		nend = Math.Min (nend' _times.Count - 1);  	}  	// n corresponds to the n'th interval between the time stamps.  	for (int n = nstart; n <= nend; n++) {  		double tbn = _times [n - 1].StampAsModifiedJulianDay;  		double tbnp1 = _times [n].StampAsModifiedJulianDay;  		//---------------------------------------------------------------------------  		//    B:        tbn|--------------------------|tbnp1  		//    R:     trb|-------------------------------------|tre  		//    I:           |--------------------------|  		// --------------------------------------------------------------------------  		if (trb <= tbn && tre >= tbnp1) {  			double factor = (tbnp1 - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += 0.5 * (sbin + sbinp1) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:       tbn|-----------------------|tbnp1  		// R+I:         trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbn <= trb && tre <= tbnp1)//cover all  		 {  			double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  			for (int i = 0; i < m; i++)// for all elements  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin + (sbinp1 - sbin) * fraction;  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbn|-----------------|tbnp1  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  			double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  			double factor = (tbnp1 - trb) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:            tbn|-----------------|tbnp1  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbn && tre > tbn && tre < tbnp1) {  			double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  			double factor = (tre - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  			}  		}  	}  	//---------------------------------------------------------------------------  	// This handles values outside the time horizon of the buffer.  	//--------------------------------------------------------------------------  	// In case of only one value in the buffer' regardless of its position relative to R  	//    |     or     |     or   |               B  	//        |----------------|                  R  	//---------------------------------------------------------------------------  	if (_times.Count == 1) {  		// TODO: Test if extrapolation is ok.  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			xr [i] = sbi0;  		}  	}  	else {  		// At least two stamp values in the buffer' so we can do extrapolation  		//--------------------------------------------------------------------------  		//  B:       tb0|-----tb1|---------|--------|  		//  R: trb|----------------|tre  		//  I:    |-----|  		//---------------------------------------------------------------------------  		double tb0 = _times [0].StampAsModifiedJulianDay;  		double tb1 = _times [1].StampAsModifiedJulianDay;  		double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  		double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		if (trb < tb0 && tre > tb0) {  			double fraction = (1 - _relaxationFactor) * 0.5 * (tb0 - trb) / (tb1 - tb0);  			double factor = ((tb0 - trb) / (tre - trb));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += factor * (sbi0 - fraction * (sbi1 - sbi0));  			}  		}  		//-------------------------------------------------------------------------------------  		// B     |--------|---------|tbn_2---|tbn_1  		// R                        trb|----------------|tre  		// I                                 |----------|   		//-------------------------------------------------------------------------------------  		if (tre > tbN_1 && trb < tbN_1) {  			double factor = ((tre - tbN_1) / (tre - trb));  			double fraction = (1 - _relaxationFactor) * 0.5 * (tre - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :   |--------|---------|tbn_2---|tbn_1  		// R+I :                                   trb|----------------|tre  		//-------------------------------------------------------------------------------------  		if (trb >= tbN_1) {  			double fraction = (1 - _relaxationFactor) * (0.5 * (trb + tre) - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :                  tb0|-----tb1|---------|--------| B  		// R+I :   trb|-------|tre  		//-------------------------------------------------------------------------------------  		if (tre <= tb0) {  			double fraction = (1 - _relaxationFactor) / (tb1 - tb0) * (tb0 - 0.5 * (trb + tre));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (sbi1 - sbi0) * fraction;  			}  		}  	}  	//-------------------------------------------------------------------------------------  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeStampsToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	//int        N  = times.Count;								   	      // Number of time steps in buffer  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	//---------------------------------------------------------------------------  	// This handles values within the time horizon of the buffer' i.e.  	// there must be at least two values in the buffer.  	int nstart = 1;  	int nend = _times.Count - 1;  	// Narrow down the number of intervals to investigate' based on the requested span.  	if (nend > 4) {  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.StampAsModifiedJulianDay);  		nend = _times.Times.GetInterval (tre' out fraction' time => time.StampAsModifiedJulianDay);  		nstart = Math.Max (nstart' 1);  		nend = Math.Min (nend' _times.Count - 1);  	}  	// n corresponds to the n'th interval between the time stamps.  	for (int n = nstart; n <= nend; n++) {  		double tbn = _times [n - 1].StampAsModifiedJulianDay;  		double tbnp1 = _times [n].StampAsModifiedJulianDay;  		//---------------------------------------------------------------------------  		//    B:        tbn|--------------------------|tbnp1  		//    R:     trb|-------------------------------------|tre  		//    I:           |--------------------------|  		// --------------------------------------------------------------------------  		if (trb <= tbn && tre >= tbnp1) {  			double factor = (tbnp1 - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += 0.5 * (sbin + sbinp1) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:       tbn|-----------------------|tbnp1  		// R+I:         trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbn <= trb && tre <= tbnp1)//cover all  		 {  			double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  			for (int i = 0; i < m; i++)// for all elements  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin + (sbinp1 - sbin) * fraction;  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbn|-----------------|tbnp1  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  			double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  			double factor = (tbnp1 - trb) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:            tbn|-----------------|tbnp1  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbn && tre > tbn && tre < tbnp1) {  			double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  			double factor = (tre - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  			}  		}  	}  	//---------------------------------------------------------------------------  	// This handles values outside the time horizon of the buffer.  	//--------------------------------------------------------------------------  	// In case of only one value in the buffer' regardless of its position relative to R  	//    |     or     |     or   |               B  	//        |----------------|                  R  	//---------------------------------------------------------------------------  	if (_times.Count == 1) {  		// TODO: Test if extrapolation is ok.  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			xr [i] = sbi0;  		}  	}  	else {  		// At least two stamp values in the buffer' so we can do extrapolation  		//--------------------------------------------------------------------------  		//  B:       tb0|-----tb1|---------|--------|  		//  R: trb|----------------|tre  		//  I:    |-----|  		//---------------------------------------------------------------------------  		double tb0 = _times [0].StampAsModifiedJulianDay;  		double tb1 = _times [1].StampAsModifiedJulianDay;  		double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  		double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		if (trb < tb0 && tre > tb0) {  			double fraction = (1 - _relaxationFactor) * 0.5 * (tb0 - trb) / (tb1 - tb0);  			double factor = ((tb0 - trb) / (tre - trb));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += factor * (sbi0 - fraction * (sbi1 - sbi0));  			}  		}  		//-------------------------------------------------------------------------------------  		// B     |--------|---------|tbn_2---|tbn_1  		// R                        trb|----------------|tre  		// I                                 |----------|   		//-------------------------------------------------------------------------------------  		if (tre > tbN_1 && trb < tbN_1) {  			double factor = ((tre - tbN_1) / (tre - trb));  			double fraction = (1 - _relaxationFactor) * 0.5 * (tre - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :   |--------|---------|tbn_2---|tbn_1  		// R+I :                                   trb|----------------|tre  		//-------------------------------------------------------------------------------------  		if (trb >= tbN_1) {  			double fraction = (1 - _relaxationFactor) * (0.5 * (trb + tre) - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :                  tb0|-----tb1|---------|--------| B  		// R+I :   trb|-------|tre  		//-------------------------------------------------------------------------------------  		if (tre <= tb0) {  			double fraction = (1 - _relaxationFactor) / (tb1 - tb0) * (tb0 - 0.5 * (trb + tre));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (sbi1 - sbi0) * fraction;  			}  		}  	}  	//-------------------------------------------------------------------------------------  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeStampsToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	//int        N  = times.Count;								   	      // Number of time steps in buffer  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	//---------------------------------------------------------------------------  	// This handles values within the time horizon of the buffer' i.e.  	// there must be at least two values in the buffer.  	int nstart = 1;  	int nend = _times.Count - 1;  	// Narrow down the number of intervals to investigate' based on the requested span.  	if (nend > 4) {  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.StampAsModifiedJulianDay);  		nend = _times.Times.GetInterval (tre' out fraction' time => time.StampAsModifiedJulianDay);  		nstart = Math.Max (nstart' 1);  		nend = Math.Min (nend' _times.Count - 1);  	}  	// n corresponds to the n'th interval between the time stamps.  	for (int n = nstart; n <= nend; n++) {  		double tbn = _times [n - 1].StampAsModifiedJulianDay;  		double tbnp1 = _times [n].StampAsModifiedJulianDay;  		//---------------------------------------------------------------------------  		//    B:        tbn|--------------------------|tbnp1  		//    R:     trb|-------------------------------------|tre  		//    I:           |--------------------------|  		// --------------------------------------------------------------------------  		if (trb <= tbn && tre >= tbnp1) {  			double factor = (tbnp1 - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += 0.5 * (sbin + sbinp1) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:       tbn|-----------------------|tbnp1  		// R+I:         trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbn <= trb && tre <= tbnp1)//cover all  		 {  			double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  			for (int i = 0; i < m; i++)// for all elements  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin + (sbinp1 - sbin) * fraction;  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbn|-----------------|tbnp1  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  			double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  			double factor = (tbnp1 - trb) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:            tbn|-----------------|tbnp1  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbn && tre > tbn && tre < tbnp1) {  			double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  			double factor = (tre - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  			}  		}  	}  	//---------------------------------------------------------------------------  	// This handles values outside the time horizon of the buffer.  	//--------------------------------------------------------------------------  	// In case of only one value in the buffer' regardless of its position relative to R  	//    |     or     |     or   |               B  	//        |----------------|                  R  	//---------------------------------------------------------------------------  	if (_times.Count == 1) {  		// TODO: Test if extrapolation is ok.  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			xr [i] = sbi0;  		}  	}  	else {  		// At least two stamp values in the buffer' so we can do extrapolation  		//--------------------------------------------------------------------------  		//  B:       tb0|-----tb1|---------|--------|  		//  R: trb|----------------|tre  		//  I:    |-----|  		//---------------------------------------------------------------------------  		double tb0 = _times [0].StampAsModifiedJulianDay;  		double tb1 = _times [1].StampAsModifiedJulianDay;  		double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  		double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		if (trb < tb0 && tre > tb0) {  			double fraction = (1 - _relaxationFactor) * 0.5 * (tb0 - trb) / (tb1 - tb0);  			double factor = ((tb0 - trb) / (tre - trb));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += factor * (sbi0 - fraction * (sbi1 - sbi0));  			}  		}  		//-------------------------------------------------------------------------------------  		// B     |--------|---------|tbn_2---|tbn_1  		// R                        trb|----------------|tre  		// I                                 |----------|   		//-------------------------------------------------------------------------------------  		if (tre > tbN_1 && trb < tbN_1) {  			double factor = ((tre - tbN_1) / (tre - trb));  			double fraction = (1 - _relaxationFactor) * 0.5 * (tre - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :   |--------|---------|tbn_2---|tbn_1  		// R+I :                                   trb|----------------|tre  		//-------------------------------------------------------------------------------------  		if (trb >= tbN_1) {  			double fraction = (1 - _relaxationFactor) * (0.5 * (trb + tre) - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :                  tb0|-----tb1|---------|--------| B  		// R+I :   trb|-------|tre  		//-------------------------------------------------------------------------------------  		if (tre <= tb0) {  			double fraction = (1 - _relaxationFactor) / (tb1 - tb0) * (tb0 - 0.5 * (trb + tre));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (sbi1 - sbi0) * fraction;  			}  		}  	}  	//-------------------------------------------------------------------------------------  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeStampsToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	//int        N  = times.Count;								   	      // Number of time steps in buffer  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	//---------------------------------------------------------------------------  	// This handles values within the time horizon of the buffer' i.e.  	// there must be at least two values in the buffer.  	int nstart = 1;  	int nend = _times.Count - 1;  	// Narrow down the number of intervals to investigate' based on the requested span.  	if (nend > 4) {  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.StampAsModifiedJulianDay);  		nend = _times.Times.GetInterval (tre' out fraction' time => time.StampAsModifiedJulianDay);  		nstart = Math.Max (nstart' 1);  		nend = Math.Min (nend' _times.Count - 1);  	}  	// n corresponds to the n'th interval between the time stamps.  	for (int n = nstart; n <= nend; n++) {  		double tbn = _times [n - 1].StampAsModifiedJulianDay;  		double tbnp1 = _times [n].StampAsModifiedJulianDay;  		//---------------------------------------------------------------------------  		//    B:        tbn|--------------------------|tbnp1  		//    R:     trb|-------------------------------------|tre  		//    I:           |--------------------------|  		// --------------------------------------------------------------------------  		if (trb <= tbn && tre >= tbnp1) {  			double factor = (tbnp1 - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += 0.5 * (sbin + sbinp1) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:       tbn|-----------------------|tbnp1  		// R+I:         trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbn <= trb && tre <= tbnp1)//cover all  		 {  			double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  			for (int i = 0; i < m; i++)// for all elements  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin + (sbinp1 - sbin) * fraction;  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbn|-----------------|tbnp1  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  			double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  			double factor = (tbnp1 - trb) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:            tbn|-----------------|tbnp1  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbn && tre > tbn && tre < tbnp1) {  			double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  			double factor = (tre - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  			}  		}  	}  	//---------------------------------------------------------------------------  	// This handles values outside the time horizon of the buffer.  	//--------------------------------------------------------------------------  	// In case of only one value in the buffer' regardless of its position relative to R  	//    |     or     |     or   |               B  	//        |----------------|                  R  	//---------------------------------------------------------------------------  	if (_times.Count == 1) {  		// TODO: Test if extrapolation is ok.  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			xr [i] = sbi0;  		}  	}  	else {  		// At least two stamp values in the buffer' so we can do extrapolation  		//--------------------------------------------------------------------------  		//  B:       tb0|-----tb1|---------|--------|  		//  R: trb|----------------|tre  		//  I:    |-----|  		//---------------------------------------------------------------------------  		double tb0 = _times [0].StampAsModifiedJulianDay;  		double tb1 = _times [1].StampAsModifiedJulianDay;  		double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  		double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		if (trb < tb0 && tre > tb0) {  			double fraction = (1 - _relaxationFactor) * 0.5 * (tb0 - trb) / (tb1 - tb0);  			double factor = ((tb0 - trb) / (tre - trb));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += factor * (sbi0 - fraction * (sbi1 - sbi0));  			}  		}  		//-------------------------------------------------------------------------------------  		// B     |--------|---------|tbn_2---|tbn_1  		// R                        trb|----------------|tre  		// I                                 |----------|   		//-------------------------------------------------------------------------------------  		if (tre > tbN_1 && trb < tbN_1) {  			double factor = ((tre - tbN_1) / (tre - trb));  			double fraction = (1 - _relaxationFactor) * 0.5 * (tre - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :   |--------|---------|tbn_2---|tbn_1  		// R+I :                                   trb|----------------|tre  		//-------------------------------------------------------------------------------------  		if (trb >= tbN_1) {  			double fraction = (1 - _relaxationFactor) * (0.5 * (trb + tre) - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :                  tb0|-----tb1|---------|--------| B  		// R+I :   trb|-------|tre  		//-------------------------------------------------------------------------------------  		if (tre <= tb0) {  			double fraction = (1 - _relaxationFactor) / (tb1 - tb0) * (tb0 - 0.5 * (trb + tre));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (sbi1 - sbi0) * fraction;  			}  		}  	}  	//-------------------------------------------------------------------------------------  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeStampsToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	//int        N  = times.Count;								   	      // Number of time steps in buffer  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	//---------------------------------------------------------------------------  	// This handles values within the time horizon of the buffer' i.e.  	// there must be at least two values in the buffer.  	int nstart = 1;  	int nend = _times.Count - 1;  	// Narrow down the number of intervals to investigate' based on the requested span.  	if (nend > 4) {  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.StampAsModifiedJulianDay);  		nend = _times.Times.GetInterval (tre' out fraction' time => time.StampAsModifiedJulianDay);  		nstart = Math.Max (nstart' 1);  		nend = Math.Min (nend' _times.Count - 1);  	}  	// n corresponds to the n'th interval between the time stamps.  	for (int n = nstart; n <= nend; n++) {  		double tbn = _times [n - 1].StampAsModifiedJulianDay;  		double tbnp1 = _times [n].StampAsModifiedJulianDay;  		//---------------------------------------------------------------------------  		//    B:        tbn|--------------------------|tbnp1  		//    R:     trb|-------------------------------------|tre  		//    I:           |--------------------------|  		// --------------------------------------------------------------------------  		if (trb <= tbn && tre >= tbnp1) {  			double factor = (tbnp1 - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += 0.5 * (sbin + sbinp1) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:       tbn|-----------------------|tbnp1  		// R+I:         trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbn <= trb && tre <= tbnp1)//cover all  		 {  			double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  			for (int i = 0; i < m; i++)// for all elements  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin + (sbinp1 - sbin) * fraction;  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbn|-----------------|tbnp1  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  			double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  			double factor = (tbnp1 - trb) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:            tbn|-----------------|tbnp1  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbn && tre > tbn && tre < tbnp1) {  			double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  			double factor = (tre - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  			}  		}  	}  	//---------------------------------------------------------------------------  	// This handles values outside the time horizon of the buffer.  	//--------------------------------------------------------------------------  	// In case of only one value in the buffer' regardless of its position relative to R  	//    |     or     |     or   |               B  	//        |----------------|                  R  	//---------------------------------------------------------------------------  	if (_times.Count == 1) {  		// TODO: Test if extrapolation is ok.  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			xr [i] = sbi0;  		}  	}  	else {  		// At least two stamp values in the buffer' so we can do extrapolation  		//--------------------------------------------------------------------------  		//  B:       tb0|-----tb1|---------|--------|  		//  R: trb|----------------|tre  		//  I:    |-----|  		//---------------------------------------------------------------------------  		double tb0 = _times [0].StampAsModifiedJulianDay;  		double tb1 = _times [1].StampAsModifiedJulianDay;  		double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  		double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		if (trb < tb0 && tre > tb0) {  			double fraction = (1 - _relaxationFactor) * 0.5 * (tb0 - trb) / (tb1 - tb0);  			double factor = ((tb0 - trb) / (tre - trb));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += factor * (sbi0 - fraction * (sbi1 - sbi0));  			}  		}  		//-------------------------------------------------------------------------------------  		// B     |--------|---------|tbn_2---|tbn_1  		// R                        trb|----------------|tre  		// I                                 |----------|   		//-------------------------------------------------------------------------------------  		if (tre > tbN_1 && trb < tbN_1) {  			double factor = ((tre - tbN_1) / (tre - trb));  			double fraction = (1 - _relaxationFactor) * 0.5 * (tre - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :   |--------|---------|tbn_2---|tbn_1  		// R+I :                                   trb|----------------|tre  		//-------------------------------------------------------------------------------------  		if (trb >= tbN_1) {  			double fraction = (1 - _relaxationFactor) * (0.5 * (trb + tre) - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :                  tb0|-----tb1|---------|--------| B  		// R+I :   trb|-------|tre  		//-------------------------------------------------------------------------------------  		if (tre <= tb0) {  			double fraction = (1 - _relaxationFactor) / (tb1 - tb0) * (tb0 - 0.5 * (trb + tre));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (sbi1 - sbi0) * fraction;  			}  		}  	}  	//-------------------------------------------------------------------------------------  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeStampsToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	//int        N  = times.Count;								   	      // Number of time steps in buffer  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	//---------------------------------------------------------------------------  	// This handles values within the time horizon of the buffer' i.e.  	// there must be at least two values in the buffer.  	int nstart = 1;  	int nend = _times.Count - 1;  	// Narrow down the number of intervals to investigate' based on the requested span.  	if (nend > 4) {  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.StampAsModifiedJulianDay);  		nend = _times.Times.GetInterval (tre' out fraction' time => time.StampAsModifiedJulianDay);  		nstart = Math.Max (nstart' 1);  		nend = Math.Min (nend' _times.Count - 1);  	}  	// n corresponds to the n'th interval between the time stamps.  	for (int n = nstart; n <= nend; n++) {  		double tbn = _times [n - 1].StampAsModifiedJulianDay;  		double tbnp1 = _times [n].StampAsModifiedJulianDay;  		//---------------------------------------------------------------------------  		//    B:        tbn|--------------------------|tbnp1  		//    R:     trb|-------------------------------------|tre  		//    I:           |--------------------------|  		// --------------------------------------------------------------------------  		if (trb <= tbn && tre >= tbnp1) {  			double factor = (tbnp1 - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += 0.5 * (sbin + sbinp1) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:       tbn|-----------------------|tbnp1  		// R+I:         trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbn <= trb && tre <= tbnp1)//cover all  		 {  			double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  			for (int i = 0; i < m; i++)// for all elements  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin + (sbinp1 - sbin) * fraction;  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbn|-----------------|tbnp1  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  			double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  			double factor = (tbnp1 - trb) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:            tbn|-----------------|tbnp1  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbn && tre > tbn && tre < tbnp1) {  			double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  			double factor = (tre - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  			}  		}  	}  	//---------------------------------------------------------------------------  	// This handles values outside the time horizon of the buffer.  	//--------------------------------------------------------------------------  	// In case of only one value in the buffer' regardless of its position relative to R  	//    |     or     |     or   |               B  	//        |----------------|                  R  	//---------------------------------------------------------------------------  	if (_times.Count == 1) {  		// TODO: Test if extrapolation is ok.  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			xr [i] = sbi0;  		}  	}  	else {  		// At least two stamp values in the buffer' so we can do extrapolation  		//--------------------------------------------------------------------------  		//  B:       tb0|-----tb1|---------|--------|  		//  R: trb|----------------|tre  		//  I:    |-----|  		//---------------------------------------------------------------------------  		double tb0 = _times [0].StampAsModifiedJulianDay;  		double tb1 = _times [1].StampAsModifiedJulianDay;  		double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  		double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		if (trb < tb0 && tre > tb0) {  			double fraction = (1 - _relaxationFactor) * 0.5 * (tb0 - trb) / (tb1 - tb0);  			double factor = ((tb0 - trb) / (tre - trb));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += factor * (sbi0 - fraction * (sbi1 - sbi0));  			}  		}  		//-------------------------------------------------------------------------------------  		// B     |--------|---------|tbn_2---|tbn_1  		// R                        trb|----------------|tre  		// I                                 |----------|   		//-------------------------------------------------------------------------------------  		if (tre > tbN_1 && trb < tbN_1) {  			double factor = ((tre - tbN_1) / (tre - trb));  			double fraction = (1 - _relaxationFactor) * 0.5 * (tre - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :   |--------|---------|tbn_2---|tbn_1  		// R+I :                                   trb|----------------|tre  		//-------------------------------------------------------------------------------------  		if (trb >= tbN_1) {  			double fraction = (1 - _relaxationFactor) * (0.5 * (trb + tre) - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :                  tb0|-----tb1|---------|--------| B  		// R+I :   trb|-------|tre  		//-------------------------------------------------------------------------------------  		if (tre <= tb0) {  			double fraction = (1 - _relaxationFactor) / (tb1 - tb0) * (tb0 - 0.5 * (trb + tre));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (sbi1 - sbi0) * fraction;  			}  		}  	}  	//-------------------------------------------------------------------------------------  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeStampsToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	//int        N  = times.Count;								   	      // Number of time steps in buffer  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	//---------------------------------------------------------------------------  	// This handles values within the time horizon of the buffer' i.e.  	// there must be at least two values in the buffer.  	int nstart = 1;  	int nend = _times.Count - 1;  	// Narrow down the number of intervals to investigate' based on the requested span.  	if (nend > 4) {  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.StampAsModifiedJulianDay);  		nend = _times.Times.GetInterval (tre' out fraction' time => time.StampAsModifiedJulianDay);  		nstart = Math.Max (nstart' 1);  		nend = Math.Min (nend' _times.Count - 1);  	}  	// n corresponds to the n'th interval between the time stamps.  	for (int n = nstart; n <= nend; n++) {  		double tbn = _times [n - 1].StampAsModifiedJulianDay;  		double tbnp1 = _times [n].StampAsModifiedJulianDay;  		//---------------------------------------------------------------------------  		//    B:        tbn|--------------------------|tbnp1  		//    R:     trb|-------------------------------------|tre  		//    I:           |--------------------------|  		// --------------------------------------------------------------------------  		if (trb <= tbn && tre >= tbnp1) {  			double factor = (tbnp1 - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += 0.5 * (sbin + sbinp1) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:       tbn|-----------------------|tbnp1  		// R+I:         trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbn <= trb && tre <= tbnp1)//cover all  		 {  			double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  			for (int i = 0; i < m; i++)// for all elements  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin + (sbinp1 - sbin) * fraction;  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbn|-----------------|tbnp1  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  			double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  			double factor = (tbnp1 - trb) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:            tbn|-----------------|tbnp1  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbn && tre > tbn && tre < tbnp1) {  			double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  			double factor = (tre - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  			}  		}  	}  	//---------------------------------------------------------------------------  	// This handles values outside the time horizon of the buffer.  	//--------------------------------------------------------------------------  	// In case of only one value in the buffer' regardless of its position relative to R  	//    |     or     |     or   |               B  	//        |----------------|                  R  	//---------------------------------------------------------------------------  	if (_times.Count == 1) {  		// TODO: Test if extrapolation is ok.  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			xr [i] = sbi0;  		}  	}  	else {  		// At least two stamp values in the buffer' so we can do extrapolation  		//--------------------------------------------------------------------------  		//  B:       tb0|-----tb1|---------|--------|  		//  R: trb|----------------|tre  		//  I:    |-----|  		//---------------------------------------------------------------------------  		double tb0 = _times [0].StampAsModifiedJulianDay;  		double tb1 = _times [1].StampAsModifiedJulianDay;  		double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  		double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		if (trb < tb0 && tre > tb0) {  			double fraction = (1 - _relaxationFactor) * 0.5 * (tb0 - trb) / (tb1 - tb0);  			double factor = ((tb0 - trb) / (tre - trb));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += factor * (sbi0 - fraction * (sbi1 - sbi0));  			}  		}  		//-------------------------------------------------------------------------------------  		// B     |--------|---------|tbn_2---|tbn_1  		// R                        trb|----------------|tre  		// I                                 |----------|   		//-------------------------------------------------------------------------------------  		if (tre > tbN_1 && trb < tbN_1) {  			double factor = ((tre - tbN_1) / (tre - trb));  			double fraction = (1 - _relaxationFactor) * 0.5 * (tre - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :   |--------|---------|tbn_2---|tbn_1  		// R+I :                                   trb|----------------|tre  		//-------------------------------------------------------------------------------------  		if (trb >= tbN_1) {  			double fraction = (1 - _relaxationFactor) * (0.5 * (trb + tre) - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :                  tb0|-----tb1|---------|--------| B  		// R+I :   trb|-------|tre  		//-------------------------------------------------------------------------------------  		if (tre <= tb0) {  			double fraction = (1 - _relaxationFactor) / (tb1 - tb0) * (tb0 - 0.5 * (trb + tre));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (sbi1 - sbi0) * fraction;  			}  		}  	}  	//-------------------------------------------------------------------------------------  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeStampsToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	//int        N  = times.Count;								   	      // Number of time steps in buffer  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	//---------------------------------------------------------------------------  	// This handles values within the time horizon of the buffer' i.e.  	// there must be at least two values in the buffer.  	int nstart = 1;  	int nend = _times.Count - 1;  	// Narrow down the number of intervals to investigate' based on the requested span.  	if (nend > 4) {  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.StampAsModifiedJulianDay);  		nend = _times.Times.GetInterval (tre' out fraction' time => time.StampAsModifiedJulianDay);  		nstart = Math.Max (nstart' 1);  		nend = Math.Min (nend' _times.Count - 1);  	}  	// n corresponds to the n'th interval between the time stamps.  	for (int n = nstart; n <= nend; n++) {  		double tbn = _times [n - 1].StampAsModifiedJulianDay;  		double tbnp1 = _times [n].StampAsModifiedJulianDay;  		//---------------------------------------------------------------------------  		//    B:        tbn|--------------------------|tbnp1  		//    R:     trb|-------------------------------------|tre  		//    I:           |--------------------------|  		// --------------------------------------------------------------------------  		if (trb <= tbn && tre >= tbnp1) {  			double factor = (tbnp1 - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += 0.5 * (sbin + sbinp1) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:       tbn|-----------------------|tbnp1  		// R+I:         trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbn <= trb && tre <= tbnp1)//cover all  		 {  			double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  			for (int i = 0; i < m; i++)// for all elements  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin + (sbinp1 - sbin) * fraction;  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbn|-----------------|tbnp1  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  			double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  			double factor = (tbnp1 - trb) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:            tbn|-----------------|tbnp1  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbn && tre > tbn && tre < tbnp1) {  			double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  			double factor = (tre - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  			}  		}  	}  	//---------------------------------------------------------------------------  	// This handles values outside the time horizon of the buffer.  	//--------------------------------------------------------------------------  	// In case of only one value in the buffer' regardless of its position relative to R  	//    |     or     |     or   |               B  	//        |----------------|                  R  	//---------------------------------------------------------------------------  	if (_times.Count == 1) {  		// TODO: Test if extrapolation is ok.  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			xr [i] = sbi0;  		}  	}  	else {  		// At least two stamp values in the buffer' so we can do extrapolation  		//--------------------------------------------------------------------------  		//  B:       tb0|-----tb1|---------|--------|  		//  R: trb|----------------|tre  		//  I:    |-----|  		//---------------------------------------------------------------------------  		double tb0 = _times [0].StampAsModifiedJulianDay;  		double tb1 = _times [1].StampAsModifiedJulianDay;  		double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  		double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		if (trb < tb0 && tre > tb0) {  			double fraction = (1 - _relaxationFactor) * 0.5 * (tb0 - trb) / (tb1 - tb0);  			double factor = ((tb0 - trb) / (tre - trb));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += factor * (sbi0 - fraction * (sbi1 - sbi0));  			}  		}  		//-------------------------------------------------------------------------------------  		// B     |--------|---------|tbn_2---|tbn_1  		// R                        trb|----------------|tre  		// I                                 |----------|   		//-------------------------------------------------------------------------------------  		if (tre > tbN_1 && trb < tbN_1) {  			double factor = ((tre - tbN_1) / (tre - trb));  			double fraction = (1 - _relaxationFactor) * 0.5 * (tre - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :   |--------|---------|tbn_2---|tbn_1  		// R+I :                                   trb|----------------|tre  		//-------------------------------------------------------------------------------------  		if (trb >= tbN_1) {  			double fraction = (1 - _relaxationFactor) * (0.5 * (trb + tre) - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :                  tb0|-----tb1|---------|--------| B  		// R+I :   trb|-------|tre  		//-------------------------------------------------------------------------------------  		if (tre <= tb0) {  			double fraction = (1 - _relaxationFactor) / (tb1 - tb0) * (tb0 - 0.5 * (trb + tre));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (sbi1 - sbi0) * fraction;  			}  		}  	}  	//-------------------------------------------------------------------------------------  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeStampsToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: try {  	int m = _values [0].Length;  	//int        N  = times.Count;								   	      // Number of time steps in buffer  	double[] xr = new double[m];  	// Values to return  	double trb = requestedTime.StampAsModifiedJulianDay;  	// Begin time in requester time interval  	double tre = requestedTime.StampAsModifiedJulianDay + requestedTime.DurationInDays;  	// End time in requester time interval  	//---------------------------------------------------------------------------  	// This handles values within the time horizon of the buffer' i.e.  	// there must be at least two values in the buffer.  	int nstart = 1;  	int nend = _times.Count - 1;  	// Narrow down the number of intervals to investigate' based on the requested span.  	if (nend > 4) {  		double fraction;  		nstart = _times.Times.GetInterval (trb' out fraction' time => time.StampAsModifiedJulianDay);  		nend = _times.Times.GetInterval (tre' out fraction' time => time.StampAsModifiedJulianDay);  		nstart = Math.Max (nstart' 1);  		nend = Math.Min (nend' _times.Count - 1);  	}  	// n corresponds to the n'th interval between the time stamps.  	for (int n = nstart; n <= nend; n++) {  		double tbn = _times [n - 1].StampAsModifiedJulianDay;  		double tbnp1 = _times [n].StampAsModifiedJulianDay;  		//---------------------------------------------------------------------------  		//    B:        tbn|--------------------------|tbnp1  		//    R:     trb|-------------------------------------|tre  		//    I:           |--------------------------|  		// --------------------------------------------------------------------------  		if (trb <= tbn && tre >= tbnp1) {  			double factor = (tbnp1 - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += 0.5 * (sbin + sbinp1) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:       tbn|-----------------------|tbnp1  		// R+I:         trb|--------------|tre  		// --------------------------------------------------------------------------  		else if (tbn <= trb && tre <= tbnp1)//cover all  		 {  			double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  			for (int i = 0; i < m; i++)// for all elements  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += sbin + (sbinp1 - sbin) * fraction;  			}  		}  		//---------------------------------------------------------------------------  		// B:      tbn|-----------------|tbnp1  		// R:                 trb|--------------|tre  		// I:                    |------|  		// --------------------------------------------------------------------------  		else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  			double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  			double factor = (tbnp1 - trb) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  			}  		}  		//---------------------------------------------------------------------------  		// B:            tbn|-----------------|tbnp1  		// R:      trb|--------------|tre  		// I:               |--------|  		// --------------------------------------------------------------------------  		else if (trb < tbn && tre > tbn && tre < tbnp1) {  			double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  			double factor = (tre - tbn) / (tre - trb);  			for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  			 {  				double sbin = BufferHelper.GetVal (_values [n - 1]' i);  				double sbinp1 = BufferHelper.GetVal (_values [n]' i);  				xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  			}  		}  	}  	//---------------------------------------------------------------------------  	// This handles values outside the time horizon of the buffer.  	//--------------------------------------------------------------------------  	// In case of only one value in the buffer' regardless of its position relative to R  	//    |     or     |     or   |               B  	//        |----------------|                  R  	//---------------------------------------------------------------------------  	if (_times.Count == 1) {  		// TODO: Test if extrapolation is ok.  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			xr [i] = sbi0;  		}  	}  	else {  		// At least two stamp values in the buffer' so we can do extrapolation  		//--------------------------------------------------------------------------  		//  B:       tb0|-----tb1|---------|--------|  		//  R: trb|----------------|tre  		//  I:    |-----|  		//---------------------------------------------------------------------------  		double tb0 = _times [0].StampAsModifiedJulianDay;  		double tb1 = _times [1].StampAsModifiedJulianDay;  		double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  		double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		if (trb < tb0 && tre > tb0) {  			double fraction = (1 - _relaxationFactor) * 0.5 * (tb0 - trb) / (tb1 - tb0);  			double factor = ((tb0 - trb) / (tre - trb));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] += factor * (sbi0 - fraction * (sbi1 - sbi0));  			}  		}  		//-------------------------------------------------------------------------------------  		// B     |--------|---------|tbn_2---|tbn_1  		// R                        trb|----------------|tre  		// I                                 |----------|   		//-------------------------------------------------------------------------------------  		if (tre > tbN_1 && trb < tbN_1) {  			double factor = ((tre - tbN_1) / (tre - trb));  			double fraction = (1 - _relaxationFactor) * 0.5 * (tre - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :   |--------|---------|tbn_2---|tbn_1  		// R+I :                                   trb|----------------|tre  		//-------------------------------------------------------------------------------------  		if (trb >= tbN_1) {  			double fraction = (1 - _relaxationFactor) * (0.5 * (trb + tre) - tbN_1) / (tbN_1 - tbN_2);  			for (int i = 0; i < m; i++) {  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  			}  		}  		//-------------------------------------------------------------------------------------  		// B   :                  tb0|-----tb1|---------|--------| B  		// R+I :   trb|-------|tre  		//-------------------------------------------------------------------------------------  		if (tre <= tb0) {  			double fraction = (1 - _relaxationFactor) / (tb1 - tb0) * (tb0 - 0.5 * (trb + tre));  			for (int i = 0; i < m; i++) {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = sbi0 - (sbi1 - sbi0) * fraction;  			}  		}  	}  	//-------------------------------------------------------------------------------------  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeStampsToTimeSpan Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (nend > 4) {  	double fraction;  	nstart = _times.Times.GetInterval (trb' out fraction' time => time.StampAsModifiedJulianDay);  	nend = _times.Times.GetInterval (tre' out fraction' time => time.StampAsModifiedJulianDay);  	nstart = Math.Max (nstart' 1);  	nend = Math.Min (nend' _times.Count - 1);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: for (int n = nstart; n <= nend; n++) {  	double tbn = _times [n - 1].StampAsModifiedJulianDay;  	double tbnp1 = _times [n].StampAsModifiedJulianDay;  	//---------------------------------------------------------------------------  	//    B:        tbn|--------------------------|tbnp1  	//    R:     trb|-------------------------------------|tre  	//    I:           |--------------------------|  	// --------------------------------------------------------------------------  	if (trb <= tbn && tre >= tbnp1) {  		double factor = (tbnp1 - tbn) / (tre - trb);  		for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  		 {  			double sbin = BufferHelper.GetVal (_values [n - 1]' i);  			double sbinp1 = BufferHelper.GetVal (_values [n]' i);  			xr [i] += 0.5 * (sbin + sbinp1) * factor;  		}  	}  	//---------------------------------------------------------------------------  	// B:       tbn|-----------------------|tbnp1  	// R+I:         trb|--------------|tre  	// --------------------------------------------------------------------------  	else if (tbn <= trb && tre <= tbnp1)//cover all  	 {  		double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  		for (int i = 0; i < m; i++)// for all elements  		 {  			double sbin = BufferHelper.GetVal (_values [n - 1]' i);  			double sbinp1 = BufferHelper.GetVal (_values [n]' i);  			xr [i] += sbin + (sbinp1 - sbin) * fraction;  		}  	}  	//---------------------------------------------------------------------------  	// B:      tbn|-----------------|tbnp1  	// R:                 trb|--------------|tre  	// I:                    |------|  	// --------------------------------------------------------------------------  	else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  		double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  		double factor = (tbnp1 - trb) / (tre - trb);  		for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  		 {  			double sbin = BufferHelper.GetVal (_values [n - 1]' i);  			double sbinp1 = BufferHelper.GetVal (_values [n]' i);  			xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  		}  	}  	//---------------------------------------------------------------------------  	// B:            tbn|-----------------|tbnp1  	// R:      trb|--------------|tre  	// I:               |--------|  	// --------------------------------------------------------------------------  	else if (trb < tbn && tre > tbn && tre < tbnp1) {  		double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  		double factor = (tre - tbn) / (tre - trb);  		for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  		 {  			double sbin = BufferHelper.GetVal (_values [n - 1]' i);  			double sbinp1 = BufferHelper.GetVal (_values [n]' i);  			xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: for (int n = nstart; n <= nend; n++) {  	double tbn = _times [n - 1].StampAsModifiedJulianDay;  	double tbnp1 = _times [n].StampAsModifiedJulianDay;  	//---------------------------------------------------------------------------  	//    B:        tbn|--------------------------|tbnp1  	//    R:     trb|-------------------------------------|tre  	//    I:           |--------------------------|  	// --------------------------------------------------------------------------  	if (trb <= tbn && tre >= tbnp1) {  		double factor = (tbnp1 - tbn) / (tre - trb);  		for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  		 {  			double sbin = BufferHelper.GetVal (_values [n - 1]' i);  			double sbinp1 = BufferHelper.GetVal (_values [n]' i);  			xr [i] += 0.5 * (sbin + sbinp1) * factor;  		}  	}  	//---------------------------------------------------------------------------  	// B:       tbn|-----------------------|tbnp1  	// R+I:         trb|--------------|tre  	// --------------------------------------------------------------------------  	else if (tbn <= trb && tre <= tbnp1)//cover all  	 {  		double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  		for (int i = 0; i < m; i++)// for all elements  		 {  			double sbin = BufferHelper.GetVal (_values [n - 1]' i);  			double sbinp1 = BufferHelper.GetVal (_values [n]' i);  			xr [i] += sbin + (sbinp1 - sbin) * fraction;  		}  	}  	//---------------------------------------------------------------------------  	// B:      tbn|-----------------|tbnp1  	// R:                 trb|--------------|tre  	// I:                    |------|  	// --------------------------------------------------------------------------  	else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  		double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  		double factor = (tbnp1 - trb) / (tre - trb);  		for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  		 {  			double sbin = BufferHelper.GetVal (_values [n - 1]' i);  			double sbinp1 = BufferHelper.GetVal (_values [n]' i);  			xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  		}  	}  	//---------------------------------------------------------------------------  	// B:            tbn|-----------------|tbnp1  	// R:      trb|--------------|tre  	// I:               |--------|  	// --------------------------------------------------------------------------  	else if (trb < tbn && tre > tbn && tre < tbnp1) {  		double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  		double factor = (tre - tbn) / (tre - trb);  		for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  		 {  			double sbin = BufferHelper.GetVal (_values [n - 1]' i);  			double sbinp1 = BufferHelper.GetVal (_values [n]' i);  			xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: for (int n = nstart; n <= nend; n++) {  	double tbn = _times [n - 1].StampAsModifiedJulianDay;  	double tbnp1 = _times [n].StampAsModifiedJulianDay;  	//---------------------------------------------------------------------------  	//    B:        tbn|--------------------------|tbnp1  	//    R:     trb|-------------------------------------|tre  	//    I:           |--------------------------|  	// --------------------------------------------------------------------------  	if (trb <= tbn && tre >= tbnp1) {  		double factor = (tbnp1 - tbn) / (tre - trb);  		for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  		 {  			double sbin = BufferHelper.GetVal (_values [n - 1]' i);  			double sbinp1 = BufferHelper.GetVal (_values [n]' i);  			xr [i] += 0.5 * (sbin + sbinp1) * factor;  		}  	}  	//---------------------------------------------------------------------------  	// B:       tbn|-----------------------|tbnp1  	// R+I:         trb|--------------|tre  	// --------------------------------------------------------------------------  	else if (tbn <= trb && tre <= tbnp1)//cover all  	 {  		double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  		for (int i = 0; i < m; i++)// for all elements  		 {  			double sbin = BufferHelper.GetVal (_values [n - 1]' i);  			double sbinp1 = BufferHelper.GetVal (_values [n]' i);  			xr [i] += sbin + (sbinp1 - sbin) * fraction;  		}  	}  	//---------------------------------------------------------------------------  	// B:      tbn|-----------------|tbnp1  	// R:                 trb|--------------|tre  	// I:                    |------|  	// --------------------------------------------------------------------------  	else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  		double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  		double factor = (tbnp1 - trb) / (tre - trb);  		for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  		 {  			double sbin = BufferHelper.GetVal (_values [n - 1]' i);  			double sbinp1 = BufferHelper.GetVal (_values [n]' i);  			xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  		}  	}  	//---------------------------------------------------------------------------  	// B:            tbn|-----------------|tbnp1  	// R:      trb|--------------|tre  	// I:               |--------|  	// --------------------------------------------------------------------------  	else if (trb < tbn && tre > tbn && tre < tbnp1) {  		double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  		double factor = (tre - tbn) / (tre - trb);  		for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  		 {  			double sbin = BufferHelper.GetVal (_values [n - 1]' i);  			double sbinp1 = BufferHelper.GetVal (_values [n]' i);  			xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: for (int n = nstart; n <= nend; n++) {  	double tbn = _times [n - 1].StampAsModifiedJulianDay;  	double tbnp1 = _times [n].StampAsModifiedJulianDay;  	//---------------------------------------------------------------------------  	//    B:        tbn|--------------------------|tbnp1  	//    R:     trb|-------------------------------------|tre  	//    I:           |--------------------------|  	// --------------------------------------------------------------------------  	if (trb <= tbn && tre >= tbnp1) {  		double factor = (tbnp1 - tbn) / (tre - trb);  		for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  		 {  			double sbin = BufferHelper.GetVal (_values [n - 1]' i);  			double sbinp1 = BufferHelper.GetVal (_values [n]' i);  			xr [i] += 0.5 * (sbin + sbinp1) * factor;  		}  	}  	//---------------------------------------------------------------------------  	// B:       tbn|-----------------------|tbnp1  	// R+I:         trb|--------------|tre  	// --------------------------------------------------------------------------  	else if (tbn <= trb && tre <= tbnp1)//cover all  	 {  		double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  		for (int i = 0; i < m; i++)// for all elements  		 {  			double sbin = BufferHelper.GetVal (_values [n - 1]' i);  			double sbinp1 = BufferHelper.GetVal (_values [n]' i);  			xr [i] += sbin + (sbinp1 - sbin) * fraction;  		}  	}  	//---------------------------------------------------------------------------  	// B:      tbn|-----------------|tbnp1  	// R:                 trb|--------------|tre  	// I:                    |------|  	// --------------------------------------------------------------------------  	else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  		double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  		double factor = (tbnp1 - trb) / (tre - trb);  		for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  		 {  			double sbin = BufferHelper.GetVal (_values [n - 1]' i);  			double sbinp1 = BufferHelper.GetVal (_values [n]' i);  			xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  		}  	}  	//---------------------------------------------------------------------------  	// B:            tbn|-----------------|tbnp1  	// R:      trb|--------------|tre  	// I:               |--------|  	// --------------------------------------------------------------------------  	else if (trb < tbn && tre > tbn && tre < tbnp1) {  		double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  		double factor = (tre - tbn) / (tre - trb);  		for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  		 {  			double sbin = BufferHelper.GetVal (_values [n - 1]' i);  			double sbinp1 = BufferHelper.GetVal (_values [n]' i);  			xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (trb <= tbn && tre >= tbnp1) {  	double factor = (tbnp1 - tbn) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += 0.5 * (sbin + sbinp1) * factor;  	}  }  //---------------------------------------------------------------------------  // B:       tbn|-----------------------|tbnp1  // R+I:         trb|--------------|tre  // --------------------------------------------------------------------------  else if (tbn <= trb && tre <= tbnp1)//cover all   {  	double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  	for (int i = 0; i < m; i++)// for all elements  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += sbin + (sbinp1 - sbin) * fraction;  	}  }  //---------------------------------------------------------------------------  // B:      tbn|-----------------|tbnp1  // R:                 trb|--------------|tre  // I:                    |------|  // --------------------------------------------------------------------------  else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  	double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  	double factor = (tbnp1 - trb) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  	}  }  //---------------------------------------------------------------------------  // B:            tbn|-----------------|tbnp1  // R:      trb|--------------|tre  // I:               |--------|  // --------------------------------------------------------------------------  else if (trb < tbn && tre > tbn && tre < tbnp1) {  	double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  	double factor = (tre - tbn) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (trb <= tbn && tre >= tbnp1) {  	double factor = (tbnp1 - tbn) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += 0.5 * (sbin + sbinp1) * factor;  	}  }  //---------------------------------------------------------------------------  // B:       tbn|-----------------------|tbnp1  // R+I:         trb|--------------|tre  // --------------------------------------------------------------------------  else if (tbn <= trb && tre <= tbnp1)//cover all   {  	double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  	for (int i = 0; i < m; i++)// for all elements  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += sbin + (sbinp1 - sbin) * fraction;  	}  }  //---------------------------------------------------------------------------  // B:      tbn|-----------------|tbnp1  // R:                 trb|--------------|tre  // I:                    |------|  // --------------------------------------------------------------------------  else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  	double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  	double factor = (tbnp1 - trb) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  	}  }  //---------------------------------------------------------------------------  // B:            tbn|-----------------|tbnp1  // R:      trb|--------------|tre  // I:               |--------|  // --------------------------------------------------------------------------  else if (trb < tbn && tre > tbn && tre < tbnp1) {  	double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  	double factor = (tre - tbn) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (trb <= tbn && tre >= tbnp1) {  	double factor = (tbnp1 - tbn) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += 0.5 * (sbin + sbinp1) * factor;  	}  }  //---------------------------------------------------------------------------  // B:       tbn|-----------------------|tbnp1  // R+I:         trb|--------------|tre  // --------------------------------------------------------------------------  else if (tbn <= trb && tre <= tbnp1)//cover all   {  	double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  	for (int i = 0; i < m; i++)// for all elements  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += sbin + (sbinp1 - sbin) * fraction;  	}  }  //---------------------------------------------------------------------------  // B:      tbn|-----------------|tbnp1  // R:                 trb|--------------|tre  // I:                    |------|  // --------------------------------------------------------------------------  else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  	double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  	double factor = (tbnp1 - trb) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  	}  }  //---------------------------------------------------------------------------  // B:            tbn|-----------------|tbnp1  // R:      trb|--------------|tre  // I:               |--------|  // --------------------------------------------------------------------------  else if (trb < tbn && tre > tbn && tre < tbnp1) {  	double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  	double factor = (tre - tbn) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (trb <= tbn && tre >= tbnp1) {  	double factor = (tbnp1 - tbn) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += 0.5 * (sbin + sbinp1) * factor;  	}  }  //---------------------------------------------------------------------------  // B:       tbn|-----------------------|tbnp1  // R+I:         trb|--------------|tre  // --------------------------------------------------------------------------  else if (tbn <= trb && tre <= tbnp1)//cover all   {  	double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  	for (int i = 0; i < m; i++)// for all elements  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += sbin + (sbinp1 - sbin) * fraction;  	}  }  //---------------------------------------------------------------------------  // B:      tbn|-----------------|tbnp1  // R:                 trb|--------------|tre  // I:                    |------|  // --------------------------------------------------------------------------  else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  	double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  	double factor = (tbnp1 - trb) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  	}  }  //---------------------------------------------------------------------------  // B:            tbn|-----------------|tbnp1  // R:      trb|--------------|tre  // I:               |--------|  // --------------------------------------------------------------------------  else if (trb < tbn && tre > tbn && tre < tbnp1) {  	double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  	double factor = (tre - tbn) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval   {  	double sbin = BufferHelper.GetVal (_values [n - 1]' i);  	double sbinp1 = BufferHelper.GetVal (_values [n]' i);  	xr [i] += 0.5 * (sbin + sbinp1) * factor;  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: xr [i] += 0.5 * (sbin + sbinp1) * factor;  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (tbn <= trb && tre <= tbnp1)//cover all   {  	double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  	for (int i = 0; i < m; i++)// for all elements  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += sbin + (sbinp1 - sbin) * fraction;  	}  }  //---------------------------------------------------------------------------  // B:      tbn|-----------------|tbnp1  // R:                 trb|--------------|tre  // I:                    |------|  // --------------------------------------------------------------------------  else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  	double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  	double factor = (tbnp1 - trb) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  	}  }  //---------------------------------------------------------------------------  // B:            tbn|-----------------|tbnp1  // R:      trb|--------------|tre  // I:               |--------|  // --------------------------------------------------------------------------  else if (trb < tbn && tre > tbn && tre < tbnp1) {  	double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  	double factor = (tre - tbn) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (tbn <= trb && tre <= tbnp1)//cover all   {  	double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  	for (int i = 0; i < m; i++)// for all elements  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += sbin + (sbinp1 - sbin) * fraction;  	}  }  //---------------------------------------------------------------------------  // B:      tbn|-----------------|tbnp1  // R:                 trb|--------------|tre  // I:                    |------|  // --------------------------------------------------------------------------  else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  	double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  	double factor = (tbnp1 - trb) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  	}  }  //---------------------------------------------------------------------------  // B:            tbn|-----------------|tbnp1  // R:      trb|--------------|tre  // I:               |--------|  // --------------------------------------------------------------------------  else if (trb < tbn && tre > tbn && tre < tbnp1) {  	double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  	double factor = (tre - tbn) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (tbn <= trb && tre <= tbnp1)//cover all   {  	double fraction = ((tre + trb) / 2 - tbn) / (tbnp1 - tbn);  	for (int i = 0; i < m; i++)// for all elements  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += sbin + (sbinp1 - sbin) * fraction;  	}  }  //---------------------------------------------------------------------------  // B:      tbn|-----------------|tbnp1  // R:                 trb|--------------|tre  // I:                    |------|  // --------------------------------------------------------------------------  else if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  	double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  	double factor = (tbnp1 - trb) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  	}  }  //---------------------------------------------------------------------------  // B:            tbn|-----------------|tbnp1  // R:      trb|--------------|tre  // I:               |--------|  // --------------------------------------------------------------------------  else if (trb < tbn && tre > tbn && tre < tbnp1) {  	double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  	double factor = (tre - tbn) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  	double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  	double factor = (tbnp1 - trb) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  	}  }  //---------------------------------------------------------------------------  // B:            tbn|-----------------|tbnp1  // R:      trb|--------------|tre  // I:               |--------|  // --------------------------------------------------------------------------  else if (trb < tbn && tre > tbn && tre < tbnp1) {  	double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  	double factor = (tre - tbn) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (tbn < trb && trb < tbnp1 && tre > tbnp1) {  	double fraction = ((tbnp1 - trb) / 2) / (tbnp1 - tbn);  	double factor = (tbnp1 - trb) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += (sbinp1 - (sbinp1 - sbin) * fraction) * factor;  	}  }  //---------------------------------------------------------------------------  // B:            tbn|-----------------|tbnp1  // R:      trb|--------------|tre  // I:               |--------|  // --------------------------------------------------------------------------  else if (trb < tbn && tre > tbn && tre < tbnp1) {  	double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  	double factor = (tre - tbn) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (trb < tbn && tre > tbn && tre < tbnp1) {  	double fraction = ((tre - tbn) / 2) / (tbnp1 - tbn);  	double factor = (tre - tbn) / (tre - trb);  	for (int i = 0; i < m; i++)// for all values coorsponding to the same time interval  	 {  		double sbin = BufferHelper.GetVal (_values [n - 1]' i);  		double sbinp1 = BufferHelper.GetVal (_values [n]' i);  		xr [i] += (sbin + (sbinp1 - sbin) * fraction) * factor;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (_times.Count == 1) {  	// TODO: Test if extrapolation is ok.  	for (int i = 0; i < m; i++) {  		double sbi0 = BufferHelper.GetVal (_values [0]' i);  		xr [i] = sbi0;  	}  }  else {  	// At least two stamp values in the buffer' so we can do extrapolation  	//--------------------------------------------------------------------------  	//  B:       tb0|-----tb1|---------|--------|  	//  R: trb|----------------|tre  	//  I:    |-----|  	//---------------------------------------------------------------------------  	double tb0 = _times [0].StampAsModifiedJulianDay;  	double tb1 = _times [1].StampAsModifiedJulianDay;  	double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  	double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  	if (trb < tb0 && tre > tb0) {  		double fraction = (1 - _relaxationFactor) * 0.5 * (tb0 - trb) / (tb1 - tb0);  		double factor = ((tb0 - trb) / (tre - trb));  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] += factor * (sbi0 - fraction * (sbi1 - sbi0));  		}  	}  	//-------------------------------------------------------------------------------------  	// B     |--------|---------|tbn_2---|tbn_1  	// R                        trb|----------------|tre  	// I                                 |----------|   	//-------------------------------------------------------------------------------------  	if (tre > tbN_1 && trb < tbN_1) {  		double factor = ((tre - tbN_1) / (tre - trb));  		double fraction = (1 - _relaxationFactor) * 0.5 * (tre - tbN_1) / (tbN_1 - tbN_2);  		for (int i = 0; i < m; i++) {  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  		}  	}  	//-------------------------------------------------------------------------------------  	// B   :   |--------|---------|tbn_2---|tbn_1  	// R+I :                                   trb|----------------|tre  	//-------------------------------------------------------------------------------------  	if (trb >= tbN_1) {  		double fraction = (1 - _relaxationFactor) * (0.5 * (trb + tre) - tbN_1) / (tbN_1 - tbN_2);  		for (int i = 0; i < m; i++) {  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  		}  	}  	//-------------------------------------------------------------------------------------  	// B   :                  tb0|-----tb1|---------|--------| B  	// R+I :   trb|-------|tre  	//-------------------------------------------------------------------------------------  	if (tre <= tb0) {  		double fraction = (1 - _relaxationFactor) / (tb1 - tb0) * (tb0 - 0.5 * (trb + tre));  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] = sbi0 - (sbi1 - sbi0) * fraction;  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (_times.Count == 1) {  	// TODO: Test if extrapolation is ok.  	for (int i = 0; i < m; i++) {  		double sbi0 = BufferHelper.GetVal (_values [0]' i);  		xr [i] = sbi0;  	}  }  else {  	// At least two stamp values in the buffer' so we can do extrapolation  	//--------------------------------------------------------------------------  	//  B:       tb0|-----tb1|---------|--------|  	//  R: trb|----------------|tre  	//  I:    |-----|  	//---------------------------------------------------------------------------  	double tb0 = _times [0].StampAsModifiedJulianDay;  	double tb1 = _times [1].StampAsModifiedJulianDay;  	double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  	double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  	if (trb < tb0 && tre > tb0) {  		double fraction = (1 - _relaxationFactor) * 0.5 * (tb0 - trb) / (tb1 - tb0);  		double factor = ((tb0 - trb) / (tre - trb));  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] += factor * (sbi0 - fraction * (sbi1 - sbi0));  		}  	}  	//-------------------------------------------------------------------------------------  	// B     |--------|---------|tbn_2---|tbn_1  	// R                        trb|----------------|tre  	// I                                 |----------|   	//-------------------------------------------------------------------------------------  	if (tre > tbN_1 && trb < tbN_1) {  		double factor = ((tre - tbN_1) / (tre - trb));  		double fraction = (1 - _relaxationFactor) * 0.5 * (tre - tbN_1) / (tbN_1 - tbN_2);  		for (int i = 0; i < m; i++) {  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  		}  	}  	//-------------------------------------------------------------------------------------  	// B   :   |--------|---------|tbn_2---|tbn_1  	// R+I :                                   trb|----------------|tre  	//-------------------------------------------------------------------------------------  	if (trb >= tbN_1) {  		double fraction = (1 - _relaxationFactor) * (0.5 * (trb + tre) - tbN_1) / (tbN_1 - tbN_2);  		for (int i = 0; i < m; i++) {  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  		}  	}  	//-------------------------------------------------------------------------------------  	// B   :                  tb0|-----tb1|---------|--------| B  	// R+I :   trb|-------|tre  	//-------------------------------------------------------------------------------------  	if (tre <= tb0) {  		double fraction = (1 - _relaxationFactor) / (tb1 - tb0) * (tb0 - 0.5 * (trb + tre));  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] = sbi0 - (sbi1 - sbi0) * fraction;  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (_times.Count == 1) {  	// TODO: Test if extrapolation is ok.  	for (int i = 0; i < m; i++) {  		double sbi0 = BufferHelper.GetVal (_values [0]' i);  		xr [i] = sbi0;  	}  }  else {  	// At least two stamp values in the buffer' so we can do extrapolation  	//--------------------------------------------------------------------------  	//  B:       tb0|-----tb1|---------|--------|  	//  R: trb|----------------|tre  	//  I:    |-----|  	//---------------------------------------------------------------------------  	double tb0 = _times [0].StampAsModifiedJulianDay;  	double tb1 = _times [1].StampAsModifiedJulianDay;  	double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  	double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  	if (trb < tb0 && tre > tb0) {  		double fraction = (1 - _relaxationFactor) * 0.5 * (tb0 - trb) / (tb1 - tb0);  		double factor = ((tb0 - trb) / (tre - trb));  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] += factor * (sbi0 - fraction * (sbi1 - sbi0));  		}  	}  	//-------------------------------------------------------------------------------------  	// B     |--------|---------|tbn_2---|tbn_1  	// R                        trb|----------------|tre  	// I                                 |----------|   	//-------------------------------------------------------------------------------------  	if (tre > tbN_1 && trb < tbN_1) {  		double factor = ((tre - tbN_1) / (tre - trb));  		double fraction = (1 - _relaxationFactor) * 0.5 * (tre - tbN_1) / (tbN_1 - tbN_2);  		for (int i = 0; i < m; i++) {  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  		}  	}  	//-------------------------------------------------------------------------------------  	// B   :   |--------|---------|tbn_2---|tbn_1  	// R+I :                                   trb|----------------|tre  	//-------------------------------------------------------------------------------------  	if (trb >= tbN_1) {  		double fraction = (1 - _relaxationFactor) * (0.5 * (trb + tre) - tbN_1) / (tbN_1 - tbN_2);  		for (int i = 0; i < m; i++) {  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  		}  	}  	//-------------------------------------------------------------------------------------  	// B   :                  tb0|-----tb1|---------|--------| B  	// R+I :   trb|-------|tre  	//-------------------------------------------------------------------------------------  	if (tre <= tb0) {  		double fraction = (1 - _relaxationFactor) / (tb1 - tb0) * (tb0 - 0.5 * (trb + tre));  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] = sbi0 - (sbi1 - sbi0) * fraction;  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (_times.Count == 1) {  	// TODO: Test if extrapolation is ok.  	for (int i = 0; i < m; i++) {  		double sbi0 = BufferHelper.GetVal (_values [0]' i);  		xr [i] = sbi0;  	}  }  else {  	// At least two stamp values in the buffer' so we can do extrapolation  	//--------------------------------------------------------------------------  	//  B:       tb0|-----tb1|---------|--------|  	//  R: trb|----------------|tre  	//  I:    |-----|  	//---------------------------------------------------------------------------  	double tb0 = _times [0].StampAsModifiedJulianDay;  	double tb1 = _times [1].StampAsModifiedJulianDay;  	double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  	double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  	if (trb < tb0 && tre > tb0) {  		double fraction = (1 - _relaxationFactor) * 0.5 * (tb0 - trb) / (tb1 - tb0);  		double factor = ((tb0 - trb) / (tre - trb));  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] += factor * (sbi0 - fraction * (sbi1 - sbi0));  		}  	}  	//-------------------------------------------------------------------------------------  	// B     |--------|---------|tbn_2---|tbn_1  	// R                        trb|----------------|tre  	// I                                 |----------|   	//-------------------------------------------------------------------------------------  	if (tre > tbN_1 && trb < tbN_1) {  		double factor = ((tre - tbN_1) / (tre - trb));  		double fraction = (1 - _relaxationFactor) * 0.5 * (tre - tbN_1) / (tbN_1 - tbN_2);  		for (int i = 0; i < m; i++) {  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  		}  	}  	//-------------------------------------------------------------------------------------  	// B   :   |--------|---------|tbn_2---|tbn_1  	// R+I :                                   trb|----------------|tre  	//-------------------------------------------------------------------------------------  	if (trb >= tbN_1) {  		double fraction = (1 - _relaxationFactor) * (0.5 * (trb + tre) - tbN_1) / (tbN_1 - tbN_2);  		for (int i = 0; i < m; i++) {  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  		}  	}  	//-------------------------------------------------------------------------------------  	// B   :                  tb0|-----tb1|---------|--------| B  	// R+I :   trb|-------|tre  	//-------------------------------------------------------------------------------------  	if (tre <= tb0) {  		double fraction = (1 - _relaxationFactor) / (tb1 - tb0) * (tb0 - 0.5 * (trb + tre));  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] = sbi0 - (sbi1 - sbi0) * fraction;  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (_times.Count == 1) {  	// TODO: Test if extrapolation is ok.  	for (int i = 0; i < m; i++) {  		double sbi0 = BufferHelper.GetVal (_values [0]' i);  		xr [i] = sbi0;  	}  }  else {  	// At least two stamp values in the buffer' so we can do extrapolation  	//--------------------------------------------------------------------------  	//  B:       tb0|-----tb1|---------|--------|  	//  R: trb|----------------|tre  	//  I:    |-----|  	//---------------------------------------------------------------------------  	double tb0 = _times [0].StampAsModifiedJulianDay;  	double tb1 = _times [1].StampAsModifiedJulianDay;  	double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  	double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  	if (trb < tb0 && tre > tb0) {  		double fraction = (1 - _relaxationFactor) * 0.5 * (tb0 - trb) / (tb1 - tb0);  		double factor = ((tb0 - trb) / (tre - trb));  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] += factor * (sbi0 - fraction * (sbi1 - sbi0));  		}  	}  	//-------------------------------------------------------------------------------------  	// B     |--------|---------|tbn_2---|tbn_1  	// R                        trb|----------------|tre  	// I                                 |----------|   	//-------------------------------------------------------------------------------------  	if (tre > tbN_1 && trb < tbN_1) {  		double factor = ((tre - tbN_1) / (tre - trb));  		double fraction = (1 - _relaxationFactor) * 0.5 * (tre - tbN_1) / (tbN_1 - tbN_2);  		for (int i = 0; i < m; i++) {  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  		}  	}  	//-------------------------------------------------------------------------------------  	// B   :   |--------|---------|tbn_2---|tbn_1  	// R+I :                                   trb|----------------|tre  	//-------------------------------------------------------------------------------------  	if (trb >= tbN_1) {  		double fraction = (1 - _relaxationFactor) * (0.5 * (trb + tre) - tbN_1) / (tbN_1 - tbN_2);  		for (int i = 0; i < m; i++) {  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  		}  	}  	//-------------------------------------------------------------------------------------  	// B   :                  tb0|-----tb1|---------|--------| B  	// R+I :   trb|-------|tre  	//-------------------------------------------------------------------------------------  	if (tre <= tb0) {  		double fraction = (1 - _relaxationFactor) / (tb1 - tb0) * (tb0 - 0.5 * (trb + tre));  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] = sbi0 - (sbi1 - sbi0) * fraction;  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (_times.Count == 1) {  	// TODO: Test if extrapolation is ok.  	for (int i = 0; i < m; i++) {  		double sbi0 = BufferHelper.GetVal (_values [0]' i);  		xr [i] = sbi0;  	}  }  else {  	// At least two stamp values in the buffer' so we can do extrapolation  	//--------------------------------------------------------------------------  	//  B:       tb0|-----tb1|---------|--------|  	//  R: trb|----------------|tre  	//  I:    |-----|  	//---------------------------------------------------------------------------  	double tb0 = _times [0].StampAsModifiedJulianDay;  	double tb1 = _times [1].StampAsModifiedJulianDay;  	double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  	double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  	if (trb < tb0 && tre > tb0) {  		double fraction = (1 - _relaxationFactor) * 0.5 * (tb0 - trb) / (tb1 - tb0);  		double factor = ((tb0 - trb) / (tre - trb));  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] += factor * (sbi0 - fraction * (sbi1 - sbi0));  		}  	}  	//-------------------------------------------------------------------------------------  	// B     |--------|---------|tbn_2---|tbn_1  	// R                        trb|----------------|tre  	// I                                 |----------|   	//-------------------------------------------------------------------------------------  	if (tre > tbN_1 && trb < tbN_1) {  		double factor = ((tre - tbN_1) / (tre - trb));  		double fraction = (1 - _relaxationFactor) * 0.5 * (tre - tbN_1) / (tbN_1 - tbN_2);  		for (int i = 0; i < m; i++) {  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  		}  	}  	//-------------------------------------------------------------------------------------  	// B   :   |--------|---------|tbn_2---|tbn_1  	// R+I :                                   trb|----------------|tre  	//-------------------------------------------------------------------------------------  	if (trb >= tbN_1) {  		double fraction = (1 - _relaxationFactor) * (0.5 * (trb + tre) - tbN_1) / (tbN_1 - tbN_2);  		for (int i = 0; i < m; i++) {  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  		}  	}  	//-------------------------------------------------------------------------------------  	// B   :                  tb0|-----tb1|---------|--------| B  	// R+I :   trb|-------|tre  	//-------------------------------------------------------------------------------------  	if (tre <= tb0) {  		double fraction = (1 - _relaxationFactor) / (tb1 - tb0) * (tb0 - 0.5 * (trb + tre));  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] = sbi0 - (sbi1 - sbi0) * fraction;  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (_times.Count == 1) {  	// TODO: Test if extrapolation is ok.  	for (int i = 0; i < m; i++) {  		double sbi0 = BufferHelper.GetVal (_values [0]' i);  		xr [i] = sbi0;  	}  }  else {  	// At least two stamp values in the buffer' so we can do extrapolation  	//--------------------------------------------------------------------------  	//  B:       tb0|-----tb1|---------|--------|  	//  R: trb|----------------|tre  	//  I:    |-----|  	//---------------------------------------------------------------------------  	double tb0 = _times [0].StampAsModifiedJulianDay;  	double tb1 = _times [1].StampAsModifiedJulianDay;  	double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  	double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  	if (trb < tb0 && tre > tb0) {  		double fraction = (1 - _relaxationFactor) * 0.5 * (tb0 - trb) / (tb1 - tb0);  		double factor = ((tb0 - trb) / (tre - trb));  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] += factor * (sbi0 - fraction * (sbi1 - sbi0));  		}  	}  	//-------------------------------------------------------------------------------------  	// B     |--------|---------|tbn_2---|tbn_1  	// R                        trb|----------------|tre  	// I                                 |----------|   	//-------------------------------------------------------------------------------------  	if (tre > tbN_1 && trb < tbN_1) {  		double factor = ((tre - tbN_1) / (tre - trb));  		double fraction = (1 - _relaxationFactor) * 0.5 * (tre - tbN_1) / (tbN_1 - tbN_2);  		for (int i = 0; i < m; i++) {  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  		}  	}  	//-------------------------------------------------------------------------------------  	// B   :   |--------|---------|tbn_2---|tbn_1  	// R+I :                                   trb|----------------|tre  	//-------------------------------------------------------------------------------------  	if (trb >= tbN_1) {  		double fraction = (1 - _relaxationFactor) * (0.5 * (trb + tre) - tbN_1) / (tbN_1 - tbN_2);  		for (int i = 0; i < m; i++) {  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  		}  	}  	//-------------------------------------------------------------------------------------  	// B   :                  tb0|-----tb1|---------|--------| B  	// R+I :   trb|-------|tre  	//-------------------------------------------------------------------------------------  	if (tre <= tb0) {  		double fraction = (1 - _relaxationFactor) / (tb1 - tb0) * (tb0 - 0.5 * (trb + tre));  		for (int i = 0; i < m; i++) {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] = sbi0 - (sbi1 - sbi0) * fraction;  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (trb < tb0 && tre > tb0) {  	double fraction = (1 - _relaxationFactor) * 0.5 * (tb0 - trb) / (tb1 - tb0);  	double factor = ((tb0 - trb) / (tre - trb));  	for (int i = 0; i < m; i++) {  		double sbi0 = BufferHelper.GetVal (_values [0]' i);  		double sbi1 = BufferHelper.GetVal (_values [1]' i);  		xr [i] += factor * (sbi0 - fraction * (sbi1 - sbi0));  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (tre > tbN_1 && trb < tbN_1) {  	double factor = ((tre - tbN_1) / (tre - trb));  	double fraction = (1 - _relaxationFactor) * 0.5 * (tre - tbN_1) / (tbN_1 - tbN_2);  	for (int i = 0; i < m; i++) {  		double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  		xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (tre > tbN_1 && trb < tbN_1) {  	double factor = ((tre - tbN_1) / (tre - trb));  	double fraction = (1 - _relaxationFactor) * 0.5 * (tre - tbN_1) / (tbN_1 - tbN_2);  	for (int i = 0; i < m; i++) {  		double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  		xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  	double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  	xr [i] += factor * (sbiN_1 + fraction * (sbiN_1 - sbiN_2));  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (trb >= tbN_1) {  	double fraction = (1 - _relaxationFactor) * (0.5 * (trb + tre) - tbN_1) / (tbN_1 - tbN_2);  	for (int i = 0; i < m; i++) {  		double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  		xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (trb >= tbN_1) {  	double fraction = (1 - _relaxationFactor) * (0.5 * (trb + tre) - tbN_1) / (tbN_1 - tbN_2);  	for (int i = 0; i < m; i++) {  		double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  		xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  	double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  	xr [i] = sbiN_1 + (sbiN_1 - sbiN_2) * fraction;  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeSpan,The following statement contains a magic number: if (tre <= tb0) {  	double fraction = (1 - _relaxationFactor) / (tb1 - tb0) * (tb0 - 0.5 * (trb + tre));  	for (int i = 0; i < m; i++) {  		double sbi0 = BufferHelper.GetVal (_values [0]' i);  		double sbi1 = BufferHelper.GetVal (_values [1]' i);  		xr [i] = sbi0 - (sbi1 - sbi0) * fraction;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeStamp,The following statement contains a magic number: try {  	int m = (_values [0]).Length;  	double[] xr = new double[m];  	// Values to return  	double tr = requestedTimeStamp.StampAsModifiedJulianDay;  	// Requested TimeStamp  	if (_times.Count == 1) {  		//---------------------------------------------------------------------------  		//    Buffered TimesStamps: |          >tb0<    		//    Requested TimeStamp:  |    >tr<  		// or Requested TimeStamp:  |          >tr<  		// or Requested TimeStamp:  |                >tr<  		//                           -----------------------------------------> t  		// --------------------------------------------------------------------------  		if (tr > (_times [0].StampAsModifiedJulianDay + Time.EpsilonForTimeCompare) && !DoExtrapolate) {  			throw new Exception ("Extrapolation not allowed");  		}  		{  			for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [0]  			 {  				xr [i] = BufferHelper.GetVal (_values [0]' i);  			}  		}  	}  	else if (tr <= _times [0].StampAsModifiedJulianDay) {  		//---------------------------------------------------------------------------  		//  Buffered TimesStamps: |          >tb0<   >tb1<   >tb2<  >tbN<  		//  Requested TimeStamp:  |    >tr<  		//                         -----------------------------------------> t  		// --------------------------------------------------------------------------  		double tb0 = _times [0].StampAsModifiedJulianDay;  		double tb1 = _times [1].StampAsModifiedJulianDay;  		{  			for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [0]  			 {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = ((sbi0 - sbi1) / (tb0 - tb1)) * (tr - tb0) * (1 - _relaxationFactor) + sbi0;  			}  		}  	}  	else if (tr > _times [_times.Count - 1].StampAsModifiedJulianDay) {  		//---------------------------------------------------------------------------  		//  Buffered TimesStamps: |    >tb0<   >tb1<   >tb2<  >tbN_2<  >tbN_1<  		//  Requested TimeStamp:  |                                             >tr<  		//                         ---------------------------------------------------> t  		// --------------------------------------------------------------------------  		double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  		{  			for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [N-1]  			 {  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] = ((sbiN_1 - sbiN_2) / (tbN_1 - tbN_2)) * (tr - tbN_1) * (1 - _relaxationFactor) + sbiN_1;  			}  		}  	}  	else {  		//---------------------------------------------------------------------------  		//  Available TimesStamps: |    >tb0<   >tb1<  >tbna<       >tnb<   >tbN_1<  >tbN_2<  		//  Requested TimeStamp:   |                          >tr<  		//                         -------------------------------------------------> t  		// --------------------------------------------------------------------------  		double fraction;  		int interval = _times.Times.GetInterval (tr' out fraction' time => time.StampAsModifiedJulianDay);  		double[] valueSetA = _values [interval - 1];  		double[] valueSetB = _values [interval];  		for (int i = 0; i < m; i++)// For each element value  		 {  			double sbinA = BufferHelper.GetVal (valueSetA' i);  			double sbinB = BufferHelper.GetVal (valueSetB' i);  			xr [i] = sbinA + fraction * (sbinB - sbinA);  		}  	}  	//----------------------------------------------------------------------------------------------  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeStampsToTimeStamp Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeStamp,The following statement contains a magic number: try {  	int m = (_values [0]).Length;  	double[] xr = new double[m];  	// Values to return  	double tr = requestedTimeStamp.StampAsModifiedJulianDay;  	// Requested TimeStamp  	if (_times.Count == 1) {  		//---------------------------------------------------------------------------  		//    Buffered TimesStamps: |          >tb0<    		//    Requested TimeStamp:  |    >tr<  		// or Requested TimeStamp:  |          >tr<  		// or Requested TimeStamp:  |                >tr<  		//                           -----------------------------------------> t  		// --------------------------------------------------------------------------  		if (tr > (_times [0].StampAsModifiedJulianDay + Time.EpsilonForTimeCompare) && !DoExtrapolate) {  			throw new Exception ("Extrapolation not allowed");  		}  		{  			for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [0]  			 {  				xr [i] = BufferHelper.GetVal (_values [0]' i);  			}  		}  	}  	else if (tr <= _times [0].StampAsModifiedJulianDay) {  		//---------------------------------------------------------------------------  		//  Buffered TimesStamps: |          >tb0<   >tb1<   >tb2<  >tbN<  		//  Requested TimeStamp:  |    >tr<  		//                         -----------------------------------------> t  		// --------------------------------------------------------------------------  		double tb0 = _times [0].StampAsModifiedJulianDay;  		double tb1 = _times [1].StampAsModifiedJulianDay;  		{  			for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [0]  			 {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = ((sbi0 - sbi1) / (tb0 - tb1)) * (tr - tb0) * (1 - _relaxationFactor) + sbi0;  			}  		}  	}  	else if (tr > _times [_times.Count - 1].StampAsModifiedJulianDay) {  		//---------------------------------------------------------------------------  		//  Buffered TimesStamps: |    >tb0<   >tb1<   >tb2<  >tbN_2<  >tbN_1<  		//  Requested TimeStamp:  |                                             >tr<  		//                         ---------------------------------------------------> t  		// --------------------------------------------------------------------------  		double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  		double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  		{  			for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [N-1]  			 {  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] = ((sbiN_1 - sbiN_2) / (tbN_1 - tbN_2)) * (tr - tbN_1) * (1 - _relaxationFactor) + sbiN_1;  			}  		}  	}  	else {  		//---------------------------------------------------------------------------  		//  Available TimesStamps: |    >tb0<   >tb1<  >tbna<       >tnb<   >tbN_1<  >tbN_2<  		//  Requested TimeStamp:   |                          >tr<  		//                         -------------------------------------------------> t  		// --------------------------------------------------------------------------  		double fraction;  		int interval = _times.Times.GetInterval (tr' out fraction' time => time.StampAsModifiedJulianDay);  		double[] valueSetA = _values [interval - 1];  		double[] valueSetB = _values [interval];  		for (int i = 0; i < m; i++)// For each element value  		 {  			double sbinA = BufferHelper.GetVal (valueSetA' i);  			double sbinB = BufferHelper.GetVal (valueSetB' i);  			xr [i] = sbinA + fraction * (sbinB - sbinA);  		}  	}  	//----------------------------------------------------------------------------------------------  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeStampsToTimeStamp Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeStamp,The following statement contains a magic number: if (_times.Count == 1) {  	//---------------------------------------------------------------------------  	//    Buffered TimesStamps: |          >tb0<    	//    Requested TimeStamp:  |    >tr<  	// or Requested TimeStamp:  |          >tr<  	// or Requested TimeStamp:  |                >tr<  	//                           -----------------------------------------> t  	// --------------------------------------------------------------------------  	if (tr > (_times [0].StampAsModifiedJulianDay + Time.EpsilonForTimeCompare) && !DoExtrapolate) {  		throw new Exception ("Extrapolation not allowed");  	}  	{  		for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [0]  		 {  			xr [i] = BufferHelper.GetVal (_values [0]' i);  		}  	}  }  else if (tr <= _times [0].StampAsModifiedJulianDay) {  	//---------------------------------------------------------------------------  	//  Buffered TimesStamps: |          >tb0<   >tb1<   >tb2<  >tbN<  	//  Requested TimeStamp:  |    >tr<  	//                         -----------------------------------------> t  	// --------------------------------------------------------------------------  	double tb0 = _times [0].StampAsModifiedJulianDay;  	double tb1 = _times [1].StampAsModifiedJulianDay;  	{  		for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [0]  		 {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] = ((sbi0 - sbi1) / (tb0 - tb1)) * (tr - tb0) * (1 - _relaxationFactor) + sbi0;  		}  	}  }  else if (tr > _times [_times.Count - 1].StampAsModifiedJulianDay) {  	//---------------------------------------------------------------------------  	//  Buffered TimesStamps: |    >tb0<   >tb1<   >tb2<  >tbN_2<  >tbN_1<  	//  Requested TimeStamp:  |                                             >tr<  	//                         ---------------------------------------------------> t  	// --------------------------------------------------------------------------  	double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  	double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  	{  		for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [N-1]  		 {  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			xr [i] = ((sbiN_1 - sbiN_2) / (tbN_1 - tbN_2)) * (tr - tbN_1) * (1 - _relaxationFactor) + sbiN_1;  		}  	}  }  else {  	//---------------------------------------------------------------------------  	//  Available TimesStamps: |    >tb0<   >tb1<  >tbna<       >tnb<   >tbN_1<  >tbN_2<  	//  Requested TimeStamp:   |                          >tr<  	//                         -------------------------------------------------> t  	// --------------------------------------------------------------------------  	double fraction;  	int interval = _times.Times.GetInterval (tr' out fraction' time => time.StampAsModifiedJulianDay);  	double[] valueSetA = _values [interval - 1];  	double[] valueSetB = _values [interval];  	for (int i = 0; i < m; i++)// For each element value  	 {  		double sbinA = BufferHelper.GetVal (valueSetA' i);  		double sbinB = BufferHelper.GetVal (valueSetB' i);  		xr [i] = sbinA + fraction * (sbinB - sbinA);  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeStamp,The following statement contains a magic number: if (_times.Count == 1) {  	//---------------------------------------------------------------------------  	//    Buffered TimesStamps: |          >tb0<    	//    Requested TimeStamp:  |    >tr<  	// or Requested TimeStamp:  |          >tr<  	// or Requested TimeStamp:  |                >tr<  	//                           -----------------------------------------> t  	// --------------------------------------------------------------------------  	if (tr > (_times [0].StampAsModifiedJulianDay + Time.EpsilonForTimeCompare) && !DoExtrapolate) {  		throw new Exception ("Extrapolation not allowed");  	}  	{  		for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [0]  		 {  			xr [i] = BufferHelper.GetVal (_values [0]' i);  		}  	}  }  else if (tr <= _times [0].StampAsModifiedJulianDay) {  	//---------------------------------------------------------------------------  	//  Buffered TimesStamps: |          >tb0<   >tb1<   >tb2<  >tbN<  	//  Requested TimeStamp:  |    >tr<  	//                         -----------------------------------------> t  	// --------------------------------------------------------------------------  	double tb0 = _times [0].StampAsModifiedJulianDay;  	double tb1 = _times [1].StampAsModifiedJulianDay;  	{  		for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [0]  		 {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] = ((sbi0 - sbi1) / (tb0 - tb1)) * (tr - tb0) * (1 - _relaxationFactor) + sbi0;  		}  	}  }  else if (tr > _times [_times.Count - 1].StampAsModifiedJulianDay) {  	//---------------------------------------------------------------------------  	//  Buffered TimesStamps: |    >tb0<   >tb1<   >tb2<  >tbN_2<  >tbN_1<  	//  Requested TimeStamp:  |                                             >tr<  	//                         ---------------------------------------------------> t  	// --------------------------------------------------------------------------  	double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  	double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  	{  		for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [N-1]  		 {  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			xr [i] = ((sbiN_1 - sbiN_2) / (tbN_1 - tbN_2)) * (tr - tbN_1) * (1 - _relaxationFactor) + sbiN_1;  		}  	}  }  else {  	//---------------------------------------------------------------------------  	//  Available TimesStamps: |    >tb0<   >tb1<  >tbna<       >tnb<   >tbN_1<  >tbN_2<  	//  Requested TimeStamp:   |                          >tr<  	//                         -------------------------------------------------> t  	// --------------------------------------------------------------------------  	double fraction;  	int interval = _times.Times.GetInterval (tr' out fraction' time => time.StampAsModifiedJulianDay);  	double[] valueSetA = _values [interval - 1];  	double[] valueSetB = _values [interval];  	for (int i = 0; i < m; i++)// For each element value  	 {  		double sbinA = BufferHelper.GetVal (valueSetA' i);  		double sbinB = BufferHelper.GetVal (valueSetB' i);  		xr [i] = sbinA + fraction * (sbinB - sbinA);  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeStamp,The following statement contains a magic number: if (tr <= _times [0].StampAsModifiedJulianDay) {  	//---------------------------------------------------------------------------  	//  Buffered TimesStamps: |          >tb0<   >tb1<   >tb2<  >tbN<  	//  Requested TimeStamp:  |    >tr<  	//                         -----------------------------------------> t  	// --------------------------------------------------------------------------  	double tb0 = _times [0].StampAsModifiedJulianDay;  	double tb1 = _times [1].StampAsModifiedJulianDay;  	{  		for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [0]  		 {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] = ((sbi0 - sbi1) / (tb0 - tb1)) * (tr - tb0) * (1 - _relaxationFactor) + sbi0;  		}  	}  }  else if (tr > _times [_times.Count - 1].StampAsModifiedJulianDay) {  	//---------------------------------------------------------------------------  	//  Buffered TimesStamps: |    >tb0<   >tb1<   >tb2<  >tbN_2<  >tbN_1<  	//  Requested TimeStamp:  |                                             >tr<  	//                         ---------------------------------------------------> t  	// --------------------------------------------------------------------------  	double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  	double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  	{  		for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [N-1]  		 {  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			xr [i] = ((sbiN_1 - sbiN_2) / (tbN_1 - tbN_2)) * (tr - tbN_1) * (1 - _relaxationFactor) + sbiN_1;  		}  	}  }  else {  	//---------------------------------------------------------------------------  	//  Available TimesStamps: |    >tb0<   >tb1<  >tbna<       >tnb<   >tbN_1<  >tbN_2<  	//  Requested TimeStamp:   |                          >tr<  	//                         -------------------------------------------------> t  	// --------------------------------------------------------------------------  	double fraction;  	int interval = _times.Times.GetInterval (tr' out fraction' time => time.StampAsModifiedJulianDay);  	double[] valueSetA = _values [interval - 1];  	double[] valueSetB = _values [interval];  	for (int i = 0; i < m; i++)// For each element value  	 {  		double sbinA = BufferHelper.GetVal (valueSetA' i);  		double sbinB = BufferHelper.GetVal (valueSetB' i);  		xr [i] = sbinA + fraction * (sbinB - sbinA);  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeStamp,The following statement contains a magic number: if (tr <= _times [0].StampAsModifiedJulianDay) {  	//---------------------------------------------------------------------------  	//  Buffered TimesStamps: |          >tb0<   >tb1<   >tb2<  >tbN<  	//  Requested TimeStamp:  |    >tr<  	//                         -----------------------------------------> t  	// --------------------------------------------------------------------------  	double tb0 = _times [0].StampAsModifiedJulianDay;  	double tb1 = _times [1].StampAsModifiedJulianDay;  	{  		for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [0]  		 {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] = ((sbi0 - sbi1) / (tb0 - tb1)) * (tr - tb0) * (1 - _relaxationFactor) + sbi0;  		}  	}  }  else if (tr > _times [_times.Count - 1].StampAsModifiedJulianDay) {  	//---------------------------------------------------------------------------  	//  Buffered TimesStamps: |    >tb0<   >tb1<   >tb2<  >tbN_2<  >tbN_1<  	//  Requested TimeStamp:  |                                             >tr<  	//                         ---------------------------------------------------> t  	// --------------------------------------------------------------------------  	double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  	double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  	{  		for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [N-1]  		 {  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			xr [i] = ((sbiN_1 - sbiN_2) / (tbN_1 - tbN_2)) * (tr - tbN_1) * (1 - _relaxationFactor) + sbiN_1;  		}  	}  }  else {  	//---------------------------------------------------------------------------  	//  Available TimesStamps: |    >tb0<   >tb1<  >tbna<       >tnb<   >tbN_1<  >tbN_2<  	//  Requested TimeStamp:   |                          >tr<  	//                         -------------------------------------------------> t  	// --------------------------------------------------------------------------  	double fraction;  	int interval = _times.Times.GetInterval (tr' out fraction' time => time.StampAsModifiedJulianDay);  	double[] valueSetA = _values [interval - 1];  	double[] valueSetB = _values [interval];  	for (int i = 0; i < m; i++)// For each element value  	 {  		double sbinA = BufferHelper.GetVal (valueSetA' i);  		double sbinB = BufferHelper.GetVal (valueSetB' i);  		xr [i] = sbinA + fraction * (sbinB - sbinA);  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeStamp,The following statement contains a magic number: if (tr > _times [_times.Count - 1].StampAsModifiedJulianDay) {  	//---------------------------------------------------------------------------  	//  Buffered TimesStamps: |    >tb0<   >tb1<   >tb2<  >tbN_2<  >tbN_1<  	//  Requested TimeStamp:  |                                             >tr<  	//                         ---------------------------------------------------> t  	// --------------------------------------------------------------------------  	double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  	double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  	{  		for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [N-1]  		 {  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			xr [i] = ((sbiN_1 - sbiN_2) / (tbN_1 - tbN_2)) * (tr - tbN_1) * (1 - _relaxationFactor) + sbiN_1;  		}  	}  }  else {  	//---------------------------------------------------------------------------  	//  Available TimesStamps: |    >tb0<   >tb1<  >tbna<       >tnb<   >tbN_1<  >tbN_2<  	//  Requested TimeStamp:   |                          >tr<  	//                         -------------------------------------------------> t  	// --------------------------------------------------------------------------  	double fraction;  	int interval = _times.Times.GetInterval (tr' out fraction' time => time.StampAsModifiedJulianDay);  	double[] valueSetA = _values [interval - 1];  	double[] valueSetB = _values [interval];  	for (int i = 0; i < m; i++)// For each element value  	 {  		double sbinA = BufferHelper.GetVal (valueSetA' i);  		double sbinB = BufferHelper.GetVal (valueSetB' i);  		xr [i] = sbinA + fraction * (sbinB - sbinA);  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeStamp,The following statement contains a magic number: if (tr > _times [_times.Count - 1].StampAsModifiedJulianDay) {  	//---------------------------------------------------------------------------  	//  Buffered TimesStamps: |    >tb0<   >tb1<   >tb2<  >tbN_2<  >tbN_1<  	//  Requested TimeStamp:  |                                             >tr<  	//                         ---------------------------------------------------> t  	// --------------------------------------------------------------------------  	double tbN_2 = _times [_times.Count - 2].StampAsModifiedJulianDay;  	double tbN_1 = _times [_times.Count - 1].StampAsModifiedJulianDay;  	{  		for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [N-1]  		 {  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			xr [i] = ((sbiN_1 - sbiN_2) / (tbN_1 - tbN_2)) * (tr - tbN_1) * (1 - _relaxationFactor) + sbiN_1;  		}  	}  }  else {  	//---------------------------------------------------------------------------  	//  Available TimesStamps: |    >tb0<   >tb1<  >tbna<       >tnb<   >tbN_1<  >tbN_2<  	//  Requested TimeStamp:   |                          >tr<  	//                         -------------------------------------------------> t  	// --------------------------------------------------------------------------  	double fraction;  	int interval = _times.Times.GetInterval (tr' out fraction' time => time.StampAsModifiedJulianDay);  	double[] valueSetA = _values [interval - 1];  	double[] valueSetB = _values [interval];  	for (int i = 0; i < m; i++)// For each element value  	 {  		double sbinA = BufferHelper.GetVal (valueSetA' i);  		double sbinB = BufferHelper.GetVal (valueSetB' i);  		xr [i] = sbinA + fraction * (sbinB - sbinA);  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeStampsToTimeStamp,The following statement contains a magic number: for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [N-1]   {  	double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  	double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  	xr [i] = ((sbiN_1 - sbiN_2) / (tbN_1 - tbN_2)) * (tr - tbN_1) * (1 - _relaxationFactor) + sbiN_1;  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeStamp,The following statement contains a magic number: try {  	int m = _values [0].Length;  	double[] xr = new double[m];  	// Values to return  	double tr = requestedTimeStamp.StampAsModifiedJulianDay;  	// Requested TimeStamp  	if (_times.Count == 1) {  		//---------------------------------------------------------------------------  		//    Buffered TimesSpans:  |         |------|    		//    Requested TimeStamp:  |  >tr<  		// or Requested TimeStamp:  |           >tr<  		// or Requested TimeStamp:  |                   >tr<  		//                           -----------------------------------------> t  		// --------------------------------------------------------------------------  		// Check if tr is inside span  		if (!DoExtrapolate) {  			ITime time = _times.Times [0];  			if (time.StampAsModifiedJulianDay - Time.EpsilonForTimeCompare > tr || tr > time.EndStampAsModifiedJulianDay () + Time.EpsilonForTimeCompare)  				throw new Exception ("Extrapolation not allowed");  		}  		for (int i = 0; i < m; i++)// For each element  		 {  			xr [i] = BufferHelper.GetVal (_values [0]' i);  		}  	}  	//---------------------------------------------------------------------------  	//  Buffered TimesSpans:  |          >tbb0<  ..........  >tbbN<  	//  Requested TimeStamp:  |    >tr<  	//                         -----------------------------------------> t  	// --------------------------------------------------------------------------  	else if (tr <= _times [0].StampAsModifiedJulianDay) {  		// Check if we are allowed to extrapolate  		if (!DoExtrapolate) {  			if (tr < _times [0].StampAsModifiedJulianDay - Time.EpsilonForTimeCompare)  				throw new Exception ("Extrapolation not allowed");  			// Very close to the first point' just provide that value  			for (int i = 0; i < m; i++)// For each element  			 {  				xr [i] = BufferHelper.GetVal (_values [0]' i);  			}  		}  		else {  			// Extrapolate from the first two values  			double tbb0 = _times [0].StampAsModifiedJulianDay;  			double tbb1 = _times [1].StampAsModifiedJulianDay;  			double fraction = (tr - tbb0) / (tbb0 - tbb1) * (1 - _relaxationFactor);  			for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [0]  			 {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = (sbi0 - sbi1) * fraction + sbi0;  			}  		}  	}  	//---------------------------------------------------------------------------  	//  Buffered TimesSpans:  |    >tbb0<   .................  >tbbN_1<  	//  Requested TimeStamp:  |                                             >tr<  	//                         ---------------------------------------------------> t  	// --------------------------------------------------------------------------  	else if (tr >= _times [_times.Count - 1].EndStampAsModifiedJulianDay ()) {  		// Check if we are allowed to extrapolate  		if (!DoExtrapolate) {  			if (tr > _times [0].StampAsModifiedJulianDay + Time.EpsilonForTimeCompare)  				throw new Exception ("Extrapolation not allowed");  			// Very close to the last point' just provide that value  			for (int i = 0; i < m; i++)// For each element  			 {  				xr [i] = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			}  		}  		else {  			// Extrapolate from the last two values  			double tbeN_2 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbeN_1 = _times [_times.Count - 1].EndStampAsModifiedJulianDay ();  			double fraction = (tr - tbeN_1) / (tbeN_1 - tbeN_2) * (1 - _relaxationFactor);  			for (int i = 0; i < m; i++)// For each element  			 {  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] = (sbiN_1 - sbiN_2) * fraction + sbiN_1;  			}  		}  	}  	//---------------------------------------------------------------------------  	//  Availeble TimesSpans:  |    >tbb0<   ......................  >tbbN_1<  	//  Requested TimeStamp:   |                          >tr<  	//                         -------------------------------------------------> t  	// --------------------------------------------------------------------------  	else {  		// Using end-time in GetIntrval will provide the right indices  		// Example: assuming 4 spans in the buffer'   		// spans                 |-0-|-1-|-2-|-3-|  		// endStamp intervals      0 | 1 | 2 | 3 | 4  		double fraction;  		int interval = _times.Times.GetInterval (tr' out fraction' time => time.EndStampAsModifiedJulianDay ());  		for (int i = 0; i < m; i++)// For each element  		 {  			xr [i] = BufferHelper.GetVal (_values [interval]' i);  		}  	}  	//----------------------------------------------------------------------------------------------  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeSpansToTimeStamp Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeStamp,The following statement contains a magic number: try {  	int m = _values [0].Length;  	double[] xr = new double[m];  	// Values to return  	double tr = requestedTimeStamp.StampAsModifiedJulianDay;  	// Requested TimeStamp  	if (_times.Count == 1) {  		//---------------------------------------------------------------------------  		//    Buffered TimesSpans:  |         |------|    		//    Requested TimeStamp:  |  >tr<  		// or Requested TimeStamp:  |           >tr<  		// or Requested TimeStamp:  |                   >tr<  		//                           -----------------------------------------> t  		// --------------------------------------------------------------------------  		// Check if tr is inside span  		if (!DoExtrapolate) {  			ITime time = _times.Times [0];  			if (time.StampAsModifiedJulianDay - Time.EpsilonForTimeCompare > tr || tr > time.EndStampAsModifiedJulianDay () + Time.EpsilonForTimeCompare)  				throw new Exception ("Extrapolation not allowed");  		}  		for (int i = 0; i < m; i++)// For each element  		 {  			xr [i] = BufferHelper.GetVal (_values [0]' i);  		}  	}  	//---------------------------------------------------------------------------  	//  Buffered TimesSpans:  |          >tbb0<  ..........  >tbbN<  	//  Requested TimeStamp:  |    >tr<  	//                         -----------------------------------------> t  	// --------------------------------------------------------------------------  	else if (tr <= _times [0].StampAsModifiedJulianDay) {  		// Check if we are allowed to extrapolate  		if (!DoExtrapolate) {  			if (tr < _times [0].StampAsModifiedJulianDay - Time.EpsilonForTimeCompare)  				throw new Exception ("Extrapolation not allowed");  			// Very close to the first point' just provide that value  			for (int i = 0; i < m; i++)// For each element  			 {  				xr [i] = BufferHelper.GetVal (_values [0]' i);  			}  		}  		else {  			// Extrapolate from the first two values  			double tbb0 = _times [0].StampAsModifiedJulianDay;  			double tbb1 = _times [1].StampAsModifiedJulianDay;  			double fraction = (tr - tbb0) / (tbb0 - tbb1) * (1 - _relaxationFactor);  			for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [0]  			 {  				double sbi0 = BufferHelper.GetVal (_values [0]' i);  				double sbi1 = BufferHelper.GetVal (_values [1]' i);  				xr [i] = (sbi0 - sbi1) * fraction + sbi0;  			}  		}  	}  	//---------------------------------------------------------------------------  	//  Buffered TimesSpans:  |    >tbb0<   .................  >tbbN_1<  	//  Requested TimeStamp:  |                                             >tr<  	//                         ---------------------------------------------------> t  	// --------------------------------------------------------------------------  	else if (tr >= _times [_times.Count - 1].EndStampAsModifiedJulianDay ()) {  		// Check if we are allowed to extrapolate  		if (!DoExtrapolate) {  			if (tr > _times [0].StampAsModifiedJulianDay + Time.EpsilonForTimeCompare)  				throw new Exception ("Extrapolation not allowed");  			// Very close to the last point' just provide that value  			for (int i = 0; i < m; i++)// For each element  			 {  				xr [i] = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			}  		}  		else {  			// Extrapolate from the last two values  			double tbeN_2 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  			double tbeN_1 = _times [_times.Count - 1].EndStampAsModifiedJulianDay ();  			double fraction = (tr - tbeN_1) / (tbeN_1 - tbeN_2) * (1 - _relaxationFactor);  			for (int i = 0; i < m; i++)// For each element  			 {  				double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  				double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  				xr [i] = (sbiN_1 - sbiN_2) * fraction + sbiN_1;  			}  		}  	}  	//---------------------------------------------------------------------------  	//  Availeble TimesSpans:  |    >tbb0<   ......................  >tbbN_1<  	//  Requested TimeStamp:   |                          >tr<  	//                         -------------------------------------------------> t  	// --------------------------------------------------------------------------  	else {  		// Using end-time in GetIntrval will provide the right indices  		// Example: assuming 4 spans in the buffer'   		// spans                 |-0-|-1-|-2-|-3-|  		// endStamp intervals      0 | 1 | 2 | 3 | 4  		double fraction;  		int interval = _times.Times.GetInterval (tr' out fraction' time => time.EndStampAsModifiedJulianDay ());  		for (int i = 0; i < m; i++)// For each element  		 {  			xr [i] = BufferHelper.GetVal (_values [interval]' i);  		}  	}  	//----------------------------------------------------------------------------------------------  	return xr;  }  catch (Exception e) {  	throw new Exception ("MapFromTimeSpansToTimeStamp Failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeStamp,The following statement contains a magic number: if (_times.Count == 1) {  	//---------------------------------------------------------------------------  	//    Buffered TimesSpans:  |         |------|    	//    Requested TimeStamp:  |  >tr<  	// or Requested TimeStamp:  |           >tr<  	// or Requested TimeStamp:  |                   >tr<  	//                           -----------------------------------------> t  	// --------------------------------------------------------------------------  	// Check if tr is inside span  	if (!DoExtrapolate) {  		ITime time = _times.Times [0];  		if (time.StampAsModifiedJulianDay - Time.EpsilonForTimeCompare > tr || tr > time.EndStampAsModifiedJulianDay () + Time.EpsilonForTimeCompare)  			throw new Exception ("Extrapolation not allowed");  	}  	for (int i = 0; i < m; i++)// For each element  	 {  		xr [i] = BufferHelper.GetVal (_values [0]' i);  	}  }  //---------------------------------------------------------------------------  //  Buffered TimesSpans:  |          >tbb0<  ..........  >tbbN<  //  Requested TimeStamp:  |    >tr<  //                         -----------------------------------------> t  // --------------------------------------------------------------------------  else if (tr <= _times [0].StampAsModifiedJulianDay) {  	// Check if we are allowed to extrapolate  	if (!DoExtrapolate) {  		if (tr < _times [0].StampAsModifiedJulianDay - Time.EpsilonForTimeCompare)  			throw new Exception ("Extrapolation not allowed");  		// Very close to the first point' just provide that value  		for (int i = 0; i < m; i++)// For each element  		 {  			xr [i] = BufferHelper.GetVal (_values [0]' i);  		}  	}  	else {  		// Extrapolate from the first two values  		double tbb0 = _times [0].StampAsModifiedJulianDay;  		double tbb1 = _times [1].StampAsModifiedJulianDay;  		double fraction = (tr - tbb0) / (tbb0 - tbb1) * (1 - _relaxationFactor);  		for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [0]  		 {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] = (sbi0 - sbi1) * fraction + sbi0;  		}  	}  }  //---------------------------------------------------------------------------  //  Buffered TimesSpans:  |    >tbb0<   .................  >tbbN_1<  //  Requested TimeStamp:  |                                             >tr<  //                         ---------------------------------------------------> t  // --------------------------------------------------------------------------  else if (tr >= _times [_times.Count - 1].EndStampAsModifiedJulianDay ()) {  	// Check if we are allowed to extrapolate  	if (!DoExtrapolate) {  		if (tr > _times [0].StampAsModifiedJulianDay + Time.EpsilonForTimeCompare)  			throw new Exception ("Extrapolation not allowed");  		// Very close to the last point' just provide that value  		for (int i = 0; i < m; i++)// For each element  		 {  			xr [i] = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		}  	}  	else {  		// Extrapolate from the last two values  		double tbeN_2 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  		double tbeN_1 = _times [_times.Count - 1].EndStampAsModifiedJulianDay ();  		double fraction = (tr - tbeN_1) / (tbeN_1 - tbeN_2) * (1 - _relaxationFactor);  		for (int i = 0; i < m; i++)// For each element  		 {  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			xr [i] = (sbiN_1 - sbiN_2) * fraction + sbiN_1;  		}  	}  }  //---------------------------------------------------------------------------  //  Availeble TimesSpans:  |    >tbb0<   ......................  >tbbN_1<  //  Requested TimeStamp:   |                          >tr<  //                         -------------------------------------------------> t  // --------------------------------------------------------------------------  else {  	// Using end-time in GetIntrval will provide the right indices  	// Example: assuming 4 spans in the buffer'   	// spans                 |-0-|-1-|-2-|-3-|  	// endStamp intervals      0 | 1 | 2 | 3 | 4  	double fraction;  	int interval = _times.Times.GetInterval (tr' out fraction' time => time.EndStampAsModifiedJulianDay ());  	for (int i = 0; i < m; i++)// For each element  	 {  		xr [i] = BufferHelper.GetVal (_values [interval]' i);  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeStamp,The following statement contains a magic number: if (_times.Count == 1) {  	//---------------------------------------------------------------------------  	//    Buffered TimesSpans:  |         |------|    	//    Requested TimeStamp:  |  >tr<  	// or Requested TimeStamp:  |           >tr<  	// or Requested TimeStamp:  |                   >tr<  	//                           -----------------------------------------> t  	// --------------------------------------------------------------------------  	// Check if tr is inside span  	if (!DoExtrapolate) {  		ITime time = _times.Times [0];  		if (time.StampAsModifiedJulianDay - Time.EpsilonForTimeCompare > tr || tr > time.EndStampAsModifiedJulianDay () + Time.EpsilonForTimeCompare)  			throw new Exception ("Extrapolation not allowed");  	}  	for (int i = 0; i < m; i++)// For each element  	 {  		xr [i] = BufferHelper.GetVal (_values [0]' i);  	}  }  //---------------------------------------------------------------------------  //  Buffered TimesSpans:  |          >tbb0<  ..........  >tbbN<  //  Requested TimeStamp:  |    >tr<  //                         -----------------------------------------> t  // --------------------------------------------------------------------------  else if (tr <= _times [0].StampAsModifiedJulianDay) {  	// Check if we are allowed to extrapolate  	if (!DoExtrapolate) {  		if (tr < _times [0].StampAsModifiedJulianDay - Time.EpsilonForTimeCompare)  			throw new Exception ("Extrapolation not allowed");  		// Very close to the first point' just provide that value  		for (int i = 0; i < m; i++)// For each element  		 {  			xr [i] = BufferHelper.GetVal (_values [0]' i);  		}  	}  	else {  		// Extrapolate from the first two values  		double tbb0 = _times [0].StampAsModifiedJulianDay;  		double tbb1 = _times [1].StampAsModifiedJulianDay;  		double fraction = (tr - tbb0) / (tbb0 - tbb1) * (1 - _relaxationFactor);  		for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [0]  		 {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] = (sbi0 - sbi1) * fraction + sbi0;  		}  	}  }  //---------------------------------------------------------------------------  //  Buffered TimesSpans:  |    >tbb0<   .................  >tbbN_1<  //  Requested TimeStamp:  |                                             >tr<  //                         ---------------------------------------------------> t  // --------------------------------------------------------------------------  else if (tr >= _times [_times.Count - 1].EndStampAsModifiedJulianDay ()) {  	// Check if we are allowed to extrapolate  	if (!DoExtrapolate) {  		if (tr > _times [0].StampAsModifiedJulianDay + Time.EpsilonForTimeCompare)  			throw new Exception ("Extrapolation not allowed");  		// Very close to the last point' just provide that value  		for (int i = 0; i < m; i++)// For each element  		 {  			xr [i] = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		}  	}  	else {  		// Extrapolate from the last two values  		double tbeN_2 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  		double tbeN_1 = _times [_times.Count - 1].EndStampAsModifiedJulianDay ();  		double fraction = (tr - tbeN_1) / (tbeN_1 - tbeN_2) * (1 - _relaxationFactor);  		for (int i = 0; i < m; i++)// For each element  		 {  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			xr [i] = (sbiN_1 - sbiN_2) * fraction + sbiN_1;  		}  	}  }  //---------------------------------------------------------------------------  //  Availeble TimesSpans:  |    >tbb0<   ......................  >tbbN_1<  //  Requested TimeStamp:   |                          >tr<  //                         -------------------------------------------------> t  // --------------------------------------------------------------------------  else {  	// Using end-time in GetIntrval will provide the right indices  	// Example: assuming 4 spans in the buffer'   	// spans                 |-0-|-1-|-2-|-3-|  	// endStamp intervals      0 | 1 | 2 | 3 | 4  	double fraction;  	int interval = _times.Times.GetInterval (tr' out fraction' time => time.EndStampAsModifiedJulianDay ());  	for (int i = 0; i < m; i++)// For each element  	 {  		xr [i] = BufferHelper.GetVal (_values [interval]' i);  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeStamp,The following statement contains a magic number: if (tr <= _times [0].StampAsModifiedJulianDay) {  	// Check if we are allowed to extrapolate  	if (!DoExtrapolate) {  		if (tr < _times [0].StampAsModifiedJulianDay - Time.EpsilonForTimeCompare)  			throw new Exception ("Extrapolation not allowed");  		// Very close to the first point' just provide that value  		for (int i = 0; i < m; i++)// For each element  		 {  			xr [i] = BufferHelper.GetVal (_values [0]' i);  		}  	}  	else {  		// Extrapolate from the first two values  		double tbb0 = _times [0].StampAsModifiedJulianDay;  		double tbb1 = _times [1].StampAsModifiedJulianDay;  		double fraction = (tr - tbb0) / (tbb0 - tbb1) * (1 - _relaxationFactor);  		for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [0]  		 {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] = (sbi0 - sbi1) * fraction + sbi0;  		}  	}  }  //---------------------------------------------------------------------------  //  Buffered TimesSpans:  |    >tbb0<   .................  >tbbN_1<  //  Requested TimeStamp:  |                                             >tr<  //                         ---------------------------------------------------> t  // --------------------------------------------------------------------------  else if (tr >= _times [_times.Count - 1].EndStampAsModifiedJulianDay ()) {  	// Check if we are allowed to extrapolate  	if (!DoExtrapolate) {  		if (tr > _times [0].StampAsModifiedJulianDay + Time.EpsilonForTimeCompare)  			throw new Exception ("Extrapolation not allowed");  		// Very close to the last point' just provide that value  		for (int i = 0; i < m; i++)// For each element  		 {  			xr [i] = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		}  	}  	else {  		// Extrapolate from the last two values  		double tbeN_2 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  		double tbeN_1 = _times [_times.Count - 1].EndStampAsModifiedJulianDay ();  		double fraction = (tr - tbeN_1) / (tbeN_1 - tbeN_2) * (1 - _relaxationFactor);  		for (int i = 0; i < m; i++)// For each element  		 {  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			xr [i] = (sbiN_1 - sbiN_2) * fraction + sbiN_1;  		}  	}  }  //---------------------------------------------------------------------------  //  Availeble TimesSpans:  |    >tbb0<   ......................  >tbbN_1<  //  Requested TimeStamp:   |                          >tr<  //                         -------------------------------------------------> t  // --------------------------------------------------------------------------  else {  	// Using end-time in GetIntrval will provide the right indices  	// Example: assuming 4 spans in the buffer'   	// spans                 |-0-|-1-|-2-|-3-|  	// endStamp intervals      0 | 1 | 2 | 3 | 4  	double fraction;  	int interval = _times.Times.GetInterval (tr' out fraction' time => time.EndStampAsModifiedJulianDay ());  	for (int i = 0; i < m; i++)// For each element  	 {  		xr [i] = BufferHelper.GetVal (_values [interval]' i);  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeStamp,The following statement contains a magic number: if (tr <= _times [0].StampAsModifiedJulianDay) {  	// Check if we are allowed to extrapolate  	if (!DoExtrapolate) {  		if (tr < _times [0].StampAsModifiedJulianDay - Time.EpsilonForTimeCompare)  			throw new Exception ("Extrapolation not allowed");  		// Very close to the first point' just provide that value  		for (int i = 0; i < m; i++)// For each element  		 {  			xr [i] = BufferHelper.GetVal (_values [0]' i);  		}  	}  	else {  		// Extrapolate from the first two values  		double tbb0 = _times [0].StampAsModifiedJulianDay;  		double tbb1 = _times [1].StampAsModifiedJulianDay;  		double fraction = (tr - tbb0) / (tbb0 - tbb1) * (1 - _relaxationFactor);  		for (int i = 0; i < m; i++)//For each Vector in buffered VectorSet [0]  		 {  			double sbi0 = BufferHelper.GetVal (_values [0]' i);  			double sbi1 = BufferHelper.GetVal (_values [1]' i);  			xr [i] = (sbi0 - sbi1) * fraction + sbi0;  		}  	}  }  //---------------------------------------------------------------------------  //  Buffered TimesSpans:  |    >tbb0<   .................  >tbbN_1<  //  Requested TimeStamp:  |                                             >tr<  //                         ---------------------------------------------------> t  // --------------------------------------------------------------------------  else if (tr >= _times [_times.Count - 1].EndStampAsModifiedJulianDay ()) {  	// Check if we are allowed to extrapolate  	if (!DoExtrapolate) {  		if (tr > _times [0].StampAsModifiedJulianDay + Time.EpsilonForTimeCompare)  			throw new Exception ("Extrapolation not allowed");  		// Very close to the last point' just provide that value  		for (int i = 0; i < m; i++)// For each element  		 {  			xr [i] = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		}  	}  	else {  		// Extrapolate from the last two values  		double tbeN_2 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  		double tbeN_1 = _times [_times.Count - 1].EndStampAsModifiedJulianDay ();  		double fraction = (tr - tbeN_1) / (tbeN_1 - tbeN_2) * (1 - _relaxationFactor);  		for (int i = 0; i < m; i++)// For each element  		 {  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			xr [i] = (sbiN_1 - sbiN_2) * fraction + sbiN_1;  		}  	}  }  //---------------------------------------------------------------------------  //  Availeble TimesSpans:  |    >tbb0<   ......................  >tbbN_1<  //  Requested TimeStamp:   |                          >tr<  //                         -------------------------------------------------> t  // --------------------------------------------------------------------------  else {  	// Using end-time in GetIntrval will provide the right indices  	// Example: assuming 4 spans in the buffer'   	// spans                 |-0-|-1-|-2-|-3-|  	// endStamp intervals      0 | 1 | 2 | 3 | 4  	double fraction;  	int interval = _times.Times.GetInterval (tr' out fraction' time => time.EndStampAsModifiedJulianDay ());  	for (int i = 0; i < m; i++)// For each element  	 {  		xr [i] = BufferHelper.GetVal (_values [interval]' i);  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeStamp,The following statement contains a magic number: if (tr >= _times [_times.Count - 1].EndStampAsModifiedJulianDay ()) {  	// Check if we are allowed to extrapolate  	if (!DoExtrapolate) {  		if (tr > _times [0].StampAsModifiedJulianDay + Time.EpsilonForTimeCompare)  			throw new Exception ("Extrapolation not allowed");  		// Very close to the last point' just provide that value  		for (int i = 0; i < m; i++)// For each element  		 {  			xr [i] = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		}  	}  	else {  		// Extrapolate from the last two values  		double tbeN_2 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  		double tbeN_1 = _times [_times.Count - 1].EndStampAsModifiedJulianDay ();  		double fraction = (tr - tbeN_1) / (tbeN_1 - tbeN_2) * (1 - _relaxationFactor);  		for (int i = 0; i < m; i++)// For each element  		 {  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			xr [i] = (sbiN_1 - sbiN_2) * fraction + sbiN_1;  		}  	}  }  //---------------------------------------------------------------------------  //  Availeble TimesSpans:  |    >tbb0<   ......................  >tbbN_1<  //  Requested TimeStamp:   |                          >tr<  //                         -------------------------------------------------> t  // --------------------------------------------------------------------------  else {  	// Using end-time in GetIntrval will provide the right indices  	// Example: assuming 4 spans in the buffer'   	// spans                 |-0-|-1-|-2-|-3-|  	// endStamp intervals      0 | 1 | 2 | 3 | 4  	double fraction;  	int interval = _times.Times.GetInterval (tr' out fraction' time => time.EndStampAsModifiedJulianDay ());  	for (int i = 0; i < m; i++)// For each element  	 {  		xr [i] = BufferHelper.GetVal (_values [interval]' i);  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeStamp,The following statement contains a magic number: if (tr >= _times [_times.Count - 1].EndStampAsModifiedJulianDay ()) {  	// Check if we are allowed to extrapolate  	if (!DoExtrapolate) {  		if (tr > _times [0].StampAsModifiedJulianDay + Time.EpsilonForTimeCompare)  			throw new Exception ("Extrapolation not allowed");  		// Very close to the last point' just provide that value  		for (int i = 0; i < m; i++)// For each element  		 {  			xr [i] = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		}  	}  	else {  		// Extrapolate from the last two values  		double tbeN_2 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  		double tbeN_1 = _times [_times.Count - 1].EndStampAsModifiedJulianDay ();  		double fraction = (tr - tbeN_1) / (tbeN_1 - tbeN_2) * (1 - _relaxationFactor);  		for (int i = 0; i < m; i++)// For each element  		 {  			double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  			double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  			xr [i] = (sbiN_1 - sbiN_2) * fraction + sbiN_1;  		}  	}  }  //---------------------------------------------------------------------------  //  Availeble TimesSpans:  |    >tbb0<   ......................  >tbbN_1<  //  Requested TimeStamp:   |                          >tr<  //                         -------------------------------------------------> t  // --------------------------------------------------------------------------  else {  	// Using end-time in GetIntrval will provide the right indices  	// Example: assuming 4 spans in the buffer'   	// spans                 |-0-|-1-|-2-|-3-|  	// endStamp intervals      0 | 1 | 2 | 3 | 4  	double fraction;  	int interval = _times.Times.GetInterval (tr' out fraction' time => time.EndStampAsModifiedJulianDay ());  	for (int i = 0; i < m; i++)// For each element  	 {  		xr [i] = BufferHelper.GetVal (_values [interval]' i);  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeStamp,The following statement contains a magic number: if (!DoExtrapolate) {  	if (tr > _times [0].StampAsModifiedJulianDay + Time.EpsilonForTimeCompare)  		throw new Exception ("Extrapolation not allowed");  	// Very close to the last point' just provide that value  	for (int i = 0; i < m; i++)// For each element  	 {  		xr [i] = BufferHelper.GetVal (_values [_times.Count - 1]' i);  	}  }  else {  	// Extrapolate from the last two values  	double tbeN_2 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  	double tbeN_1 = _times [_times.Count - 1].EndStampAsModifiedJulianDay ();  	double fraction = (tr - tbeN_1) / (tbeN_1 - tbeN_2) * (1 - _relaxationFactor);  	for (int i = 0; i < m; i++)// For each element  	 {  		double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  		double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		xr [i] = (sbiN_1 - sbiN_2) * fraction + sbiN_1;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeStamp,The following statement contains a magic number: if (!DoExtrapolate) {  	if (tr > _times [0].StampAsModifiedJulianDay + Time.EpsilonForTimeCompare)  		throw new Exception ("Extrapolation not allowed");  	// Very close to the last point' just provide that value  	for (int i = 0; i < m; i++)// For each element  	 {  		xr [i] = BufferHelper.GetVal (_values [_times.Count - 1]' i);  	}  }  else {  	// Extrapolate from the last two values  	double tbeN_2 = _times [_times.Count - 2].EndStampAsModifiedJulianDay ();  	double tbeN_1 = _times [_times.Count - 1].EndStampAsModifiedJulianDay ();  	double fraction = (tr - tbeN_1) / (tbeN_1 - tbeN_2) * (1 - _relaxationFactor);  	for (int i = 0; i < m; i++)// For each element  	 {  		double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  		double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  		xr [i] = (sbiN_1 - sbiN_2) * fraction + sbiN_1;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Buffer,SmartBuffer,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Buffer\SmartBuffer.cs,MapFromTimeSpansToTimeStamp,The following statement contains a magic number: for (int i = 0; i < m; i++)// For each element   {  	double sbiN_2 = BufferHelper.GetVal (_values [_times.Count - 2]' i);  	double sbiN_1 = BufferHelper.GetVal (_values [_times.Count - 1]' i);  	xr [i] = (sbiN_1 - sbiN_2) * fraction + sbiN_1;  }  
Magic Number,Oatc.OpenMI.Sdk.DevelopmentSupport,Utils,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\DevelopmentSupport\Utils.cs,GetInterval,The following statement contains a magic number: while ((iHigh - iLow) > 1) {  	int mid = iLow + (iHigh - iLow) / 2;  	if (arg <= vector [mid])  		iHigh = mid;  	else  		iLow = mid;  }  
Magic Number,Oatc.OpenMI.Sdk.DevelopmentSupport,Utils,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\DevelopmentSupport\Utils.cs,GetInterval,The following statement contains a magic number: while ((iHigh - iLow) > 1) {  	int mid = iLow + (iHigh - iLow) / 2;  	if (arg <= vector [mid])  		iHigh = mid;  	else  		iLow = mid;  }  
Magic Number,Oatc.OpenMI.Sdk.DevelopmentSupport,Utils,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\DevelopmentSupport\Utils.cs,GetInterval,The following statement contains a magic number: while ((iHigh - iLow) > 1) {  	int mid = iLow + (iHigh - iLow) / 2;  	double kMid = keySelector (vector [mid]);  	if (arg <= kMid) {  		iHigh = mid;  		kHigh = kMid;  	}  	else {  		iLow = mid;  		kLow = kMid;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.DevelopmentSupport,Utils,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\DevelopmentSupport\Utils.cs,BinarySearch,The following statement contains a magic number: while (iLow <= iHigh) {  	int mid = iLow + (iHigh - iLow) / 2;  	int compare = comparer.Compare (keySelector (list [mid])' key);  	if (compare < 0)  		// when list[mid] < key  		iLow = mid + 1;  	else if (compare > 0)  		iHigh = mid - 1;  	else  		return (mid);  }  
Magic Number,Oatc.OpenMI.Sdk.DevelopmentSupport,Utils,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\DevelopmentSupport\Utils.cs,BinarySearch,The following statement contains a magic number: while (iLow <= iHigh) {  	int mid = iLow + (iHigh - iLow) / 2;  	int compare = comparer (list [mid]);  	if (compare < 0)  		// when list[mid] < key  		iLow = mid + 1;  	else if (compare > 0)  		iHigh = mid - 1;  	else  		return (mid);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementAreaOperationAdaptor,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementAreaOperationAdaptor.cs,UpdateQuantity,The following statement contains a magic number: dimension.SetPower (DimensionBase.Length' dimension.GetPower (DimensionBase.Length) + 2 * _areaExponent);  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: try {  	ElementSetChecker.CheckElementSet (fromElements);  	ElementSetChecker.CheckElementSet (toElements);  	_method = SpatialAdaptedOutputFactory.GetMethod (methodIdentifier);  	_numberOfToRows = toElements.ElementCount;  	_numberOfFromColumns = fromElements.ElementCount;  	_mappingMatrix = new DoubleSparseMatrix (_numberOfToRows' _numberOfFromColumns);  	if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Point) {  		#region  		try {  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPoint toPoint = CreateXYPoint (toElements' i);  				for (int j = 0; j < _numberOfFromColumns; j++) {  					XYPoint fromPoint = CreateXYPoint (fromElements' j);  					_mappingMatrix [i' j] = XYGeometryTools.CalculatePointToPointDistance (toPoint' fromPoint);  				}  			}  			if (_method == ElementMapperMethod.Nearest) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.Inverse) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					if (minDist == 0) {  						int denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							if (_mappingMatrix [i' j] == minDist) {  								_mappingMatrix [i' j] = 1;  								denominator++;  							}  							else {  								_mappingMatrix [i' j] = 0;  							}  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  					else {  						double denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  							denominator = denominator + _mappingMatrix [i' j];  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  				}  			}  			else {  				throw new Exception ("methodDescription unknown for point point mapping");  			}  		}  		catch (Exception e) {  			throw new Exception ("Point to point mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.PolyLine) {  		#region  		try {  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPolyline toPolyLine = CreateXYPolyline (toElements' i);  				for (int j = 0; j < _numberOfFromColumns; j++) {  					XYPoint fromPoint = CreateXYPoint (fromElements' j);  					_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (toPolyLine' fromPoint);  				}  			}  			if (_method == ElementMapperMethod.Nearest) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.Inverse) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					if (minDist == 0) {  						int denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							if (_mappingMatrix [i' j] == minDist) {  								_mappingMatrix [i' j] = 1;  								denominator++;  							}  							else {  								_mappingMatrix [i' j] = 0;  							}  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  					else {  						double denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  							denominator = denominator + _mappingMatrix [i' j];  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  				}  			}  			else {  				throw new Exception ("methodDescription unknown for point to polyline mapping");  			}  		}  		catch (Exception e) {  			throw new Exception ("Point to polyline mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Polygon) {  		#region  		try {  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPolygon polygon = CreateXYPolygon (toElements' i);  				int count = 0;  				XYPoint point;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					point = CreateXYPoint (fromElements' n);  					if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  						if (_method == ElementMapperMethod.Mean) {  							count = count + 1;  						}  						else if (_method == ElementMapperMethod.Sum) {  							count = 1;  						}  						else {  							throw new Exception ("methodDescription unknown for point to polygon mapping");  						}  					}  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					point = CreateXYPoint (fromElements' n);  					if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  						_mappingMatrix [i' n] = 1.0 / count;  					}  				}  			}  		}  		catch (Exception e) {  			throw new Exception ("Point to polygon mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Point) {  		#region  		try {  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPoint toPoint = CreateXYPoint (toElements' i);  				for (int j = 0; j < _numberOfFromColumns; j++) {  					XYPolyline fromPolyLine = CreateXYPolyline (fromElements' j);  					_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (fromPolyLine' toPoint);  				}  			}  			if (_method == ElementMapperMethod.Nearest) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.Inverse) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					if (minDist == 0) {  						int denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							if (_mappingMatrix [i' j] == minDist) {  								_mappingMatrix [i' j] = 1;  								denominator++;  							}  							else {  								_mappingMatrix [i' j] = 0;  							}  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  					else {  						double denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  							denominator = denominator + _mappingMatrix [i' j];  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to point mapping");  			}  		}  		catch (Exception e)// Catch for all of the Point to Polyline part   		 {  			throw new Exception ("Polyline to point mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  		#region  		try {  			// For each polygon in target  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPolygon polygon = CreateXYPolygon (toElements' i);  				if (_method == ElementMapperMethod.WeightedMean) {  					double totalLineLengthInPolygon = 0;  					for (int n = 0; n < _numberOfFromColumns; n++) {  						XYPolyline polyline = CreateXYPolyline (fromElements' n);  						_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  						totalLineLengthInPolygon += _mappingMatrix [i' n];  					}  					if (totalLineLengthInPolygon > 0) {  						for (int n = 0; n < _numberOfFromColumns; n++) {  							_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  						}  					}  				}  				else if (_method == ElementMapperMethod.WeightedSum) {  					// For each line segment in PolyLine  					for (int n = 0; n < _numberOfFromColumns; n++) {  						XYPolyline polyline = CreateXYPolyline (fromElements' n);  						_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  					}  				}  				else {  					throw new Exception ("methodDescription unknown for polyline to polygon mapping");  				}  			}  		}  		catch (Exception e) {  			throw new Exception ("Polyline to polygon mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  		#region  		try {  			if (_method != ElementMapperMethod.Value)  				throw new Exception ("methodDescription unknown for polygon to point mapping");  			// Only create search tree if number of cols/rows is larger than say 10/10.  			bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  			XYElementSearchTree<int> fromSearchTree = null;  			ICollection<int> fromCandidateElmts = null;  			if (useSearchTree)  				fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  			else  				fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  			for (int n = 0; n < _numberOfToRows; n++) {  				XYPoint point = CreateXYPoint (toElements' n);  				if (useSearchTree) {  					XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  					fromCandidateElmts = fromSearchTree.FindElements (toExtent);  				}  				int count = 0;  				// Check first for strict inclusion  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  				if (count == 0) {  					// Not strictly inside any polygon' check also edges  					foreach (int i in fromCandidateElmts) {  						XYPolygon polygon = CreateXYPolygon (fromElements' i);  						if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  							_mappingMatrix [n' i] = 1.0;  							count++;  						}  					}  				}  				if (count > 1) {  					// In case of more than one hit' use average  					foreach (int i in fromCandidateElmts) {  						if (_mappingMatrix [n' i] != 0.0)  							_mappingMatrix [n' i] = 1.0 / count;  					}  				}  			}  		}  		catch (Exception e) {  			throw new Exception ("Polygon to point mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine  	 {  		#region  		try {  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPolyline polyline = CreateXYPolyline (toElements' i);  				if (_method == ElementMapperMethod.WeightedMean) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						XYPolygon polygon = CreateXYPolygon (fromElements' n);  						_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  					}  					double sum = 0;  					for (int n = 0; n < _numberOfFromColumns; n++) {  						sum += _mappingMatrix [i' n];  					}  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  					}  				}  				else if (_method == ElementMapperMethod.WeightedSum) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						XYPolygon polygon = CreateXYPolygon (fromElements' n);  						_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  					}  				}  				else {  					throw new Exception ("methodDescription unknown for polygon to polyline mapping");  				}  			}  		}  		catch (Exception e)// catch for all of Polygon to PolyLine  		 {  			throw new Exception ("Polygon to polyline mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon  	 {  		#region  		try {  			// Only create search tree if number of cols/rows is larger than say 100/10.  			bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  			XYElementSearchTree<int> fromSearchTree = null;  			ICollection<int> fromCandidateElmts = null;  			if (useSearchTree)  				fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  			else  				fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPolygon toPolygon = CreateXYPolygon (toElements' i);  				if (useSearchTree) {  					XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  					fromCandidateElmts = fromSearchTree.FindElements (toExtent);  				}  				foreach (int j in fromCandidateElmts) {  					XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  					_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  					if (_method == ElementMapperMethod.Distribute) {  						_mappingMatrix [i' j] /= fromPolygon.GetArea ();  					}  				}  				if (_method == ElementMapperMethod.WeightedMean) {  					double denominator = 0;  					foreach (int j in fromCandidateElmts) {  						denominator = denominator + _mappingMatrix [i' j];  					}  					foreach (int j in fromCandidateElmts) {  						if (denominator != 0) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  				}  				else if (_method == ElementMapperMethod.WeightedSum) {  					foreach (int j in fromCandidateElmts) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  					}  				}  				else if (_method != ElementMapperMethod.Distribute) {  					throw new Exception ("methodDescription unknown for polygon to polygon mapping");  				}  			}  		}  		catch (Exception e)// catch for all of Polygon to Polygon  		 {  			throw new Exception ("Polygon to polygon mapping failed"' e);  		}  		#endregion  	}  	else// if the fromElementType' toElementType combination is no implemented  	 {  		throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  	}  }  catch (Exception e) {  	throw new Exception ("UpdateMappingMatrix failed to update mapping matrix"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: try {  	ElementSetChecker.CheckElementSet (fromElements);  	ElementSetChecker.CheckElementSet (toElements);  	_method = SpatialAdaptedOutputFactory.GetMethod (methodIdentifier);  	_numberOfToRows = toElements.ElementCount;  	_numberOfFromColumns = fromElements.ElementCount;  	_mappingMatrix = new DoubleSparseMatrix (_numberOfToRows' _numberOfFromColumns);  	if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Point) {  		#region  		try {  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPoint toPoint = CreateXYPoint (toElements' i);  				for (int j = 0; j < _numberOfFromColumns; j++) {  					XYPoint fromPoint = CreateXYPoint (fromElements' j);  					_mappingMatrix [i' j] = XYGeometryTools.CalculatePointToPointDistance (toPoint' fromPoint);  				}  			}  			if (_method == ElementMapperMethod.Nearest) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.Inverse) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					if (minDist == 0) {  						int denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							if (_mappingMatrix [i' j] == minDist) {  								_mappingMatrix [i' j] = 1;  								denominator++;  							}  							else {  								_mappingMatrix [i' j] = 0;  							}  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  					else {  						double denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  							denominator = denominator + _mappingMatrix [i' j];  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  				}  			}  			else {  				throw new Exception ("methodDescription unknown for point point mapping");  			}  		}  		catch (Exception e) {  			throw new Exception ("Point to point mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.PolyLine) {  		#region  		try {  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPolyline toPolyLine = CreateXYPolyline (toElements' i);  				for (int j = 0; j < _numberOfFromColumns; j++) {  					XYPoint fromPoint = CreateXYPoint (fromElements' j);  					_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (toPolyLine' fromPoint);  				}  			}  			if (_method == ElementMapperMethod.Nearest) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.Inverse) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					if (minDist == 0) {  						int denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							if (_mappingMatrix [i' j] == minDist) {  								_mappingMatrix [i' j] = 1;  								denominator++;  							}  							else {  								_mappingMatrix [i' j] = 0;  							}  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  					else {  						double denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  							denominator = denominator + _mappingMatrix [i' j];  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  				}  			}  			else {  				throw new Exception ("methodDescription unknown for point to polyline mapping");  			}  		}  		catch (Exception e) {  			throw new Exception ("Point to polyline mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Polygon) {  		#region  		try {  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPolygon polygon = CreateXYPolygon (toElements' i);  				int count = 0;  				XYPoint point;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					point = CreateXYPoint (fromElements' n);  					if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  						if (_method == ElementMapperMethod.Mean) {  							count = count + 1;  						}  						else if (_method == ElementMapperMethod.Sum) {  							count = 1;  						}  						else {  							throw new Exception ("methodDescription unknown for point to polygon mapping");  						}  					}  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					point = CreateXYPoint (fromElements' n);  					if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  						_mappingMatrix [i' n] = 1.0 / count;  					}  				}  			}  		}  		catch (Exception e) {  			throw new Exception ("Point to polygon mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Point) {  		#region  		try {  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPoint toPoint = CreateXYPoint (toElements' i);  				for (int j = 0; j < _numberOfFromColumns; j++) {  					XYPolyline fromPolyLine = CreateXYPolyline (fromElements' j);  					_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (fromPolyLine' toPoint);  				}  			}  			if (_method == ElementMapperMethod.Nearest) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.Inverse) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					if (minDist == 0) {  						int denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							if (_mappingMatrix [i' j] == minDist) {  								_mappingMatrix [i' j] = 1;  								denominator++;  							}  							else {  								_mappingMatrix [i' j] = 0;  							}  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  					else {  						double denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  							denominator = denominator + _mappingMatrix [i' j];  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to point mapping");  			}  		}  		catch (Exception e)// Catch for all of the Point to Polyline part   		 {  			throw new Exception ("Polyline to point mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  		#region  		try {  			// For each polygon in target  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPolygon polygon = CreateXYPolygon (toElements' i);  				if (_method == ElementMapperMethod.WeightedMean) {  					double totalLineLengthInPolygon = 0;  					for (int n = 0; n < _numberOfFromColumns; n++) {  						XYPolyline polyline = CreateXYPolyline (fromElements' n);  						_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  						totalLineLengthInPolygon += _mappingMatrix [i' n];  					}  					if (totalLineLengthInPolygon > 0) {  						for (int n = 0; n < _numberOfFromColumns; n++) {  							_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  						}  					}  				}  				else if (_method == ElementMapperMethod.WeightedSum) {  					// For each line segment in PolyLine  					for (int n = 0; n < _numberOfFromColumns; n++) {  						XYPolyline polyline = CreateXYPolyline (fromElements' n);  						_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  					}  				}  				else {  					throw new Exception ("methodDescription unknown for polyline to polygon mapping");  				}  			}  		}  		catch (Exception e) {  			throw new Exception ("Polyline to polygon mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  		#region  		try {  			if (_method != ElementMapperMethod.Value)  				throw new Exception ("methodDescription unknown for polygon to point mapping");  			// Only create search tree if number of cols/rows is larger than say 10/10.  			bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  			XYElementSearchTree<int> fromSearchTree = null;  			ICollection<int> fromCandidateElmts = null;  			if (useSearchTree)  				fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  			else  				fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  			for (int n = 0; n < _numberOfToRows; n++) {  				XYPoint point = CreateXYPoint (toElements' n);  				if (useSearchTree) {  					XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  					fromCandidateElmts = fromSearchTree.FindElements (toExtent);  				}  				int count = 0;  				// Check first for strict inclusion  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  				if (count == 0) {  					// Not strictly inside any polygon' check also edges  					foreach (int i in fromCandidateElmts) {  						XYPolygon polygon = CreateXYPolygon (fromElements' i);  						if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  							_mappingMatrix [n' i] = 1.0;  							count++;  						}  					}  				}  				if (count > 1) {  					// In case of more than one hit' use average  					foreach (int i in fromCandidateElmts) {  						if (_mappingMatrix [n' i] != 0.0)  							_mappingMatrix [n' i] = 1.0 / count;  					}  				}  			}  		}  		catch (Exception e) {  			throw new Exception ("Polygon to point mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine  	 {  		#region  		try {  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPolyline polyline = CreateXYPolyline (toElements' i);  				if (_method == ElementMapperMethod.WeightedMean) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						XYPolygon polygon = CreateXYPolygon (fromElements' n);  						_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  					}  					double sum = 0;  					for (int n = 0; n < _numberOfFromColumns; n++) {  						sum += _mappingMatrix [i' n];  					}  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  					}  				}  				else if (_method == ElementMapperMethod.WeightedSum) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						XYPolygon polygon = CreateXYPolygon (fromElements' n);  						_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  					}  				}  				else {  					throw new Exception ("methodDescription unknown for polygon to polyline mapping");  				}  			}  		}  		catch (Exception e)// catch for all of Polygon to PolyLine  		 {  			throw new Exception ("Polygon to polyline mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon  	 {  		#region  		try {  			// Only create search tree if number of cols/rows is larger than say 100/10.  			bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  			XYElementSearchTree<int> fromSearchTree = null;  			ICollection<int> fromCandidateElmts = null;  			if (useSearchTree)  				fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  			else  				fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPolygon toPolygon = CreateXYPolygon (toElements' i);  				if (useSearchTree) {  					XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  					fromCandidateElmts = fromSearchTree.FindElements (toExtent);  				}  				foreach (int j in fromCandidateElmts) {  					XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  					_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  					if (_method == ElementMapperMethod.Distribute) {  						_mappingMatrix [i' j] /= fromPolygon.GetArea ();  					}  				}  				if (_method == ElementMapperMethod.WeightedMean) {  					double denominator = 0;  					foreach (int j in fromCandidateElmts) {  						denominator = denominator + _mappingMatrix [i' j];  					}  					foreach (int j in fromCandidateElmts) {  						if (denominator != 0) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  				}  				else if (_method == ElementMapperMethod.WeightedSum) {  					foreach (int j in fromCandidateElmts) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  					}  				}  				else if (_method != ElementMapperMethod.Distribute) {  					throw new Exception ("methodDescription unknown for polygon to polygon mapping");  				}  			}  		}  		catch (Exception e)// catch for all of Polygon to Polygon  		 {  			throw new Exception ("Polygon to polygon mapping failed"' e);  		}  		#endregion  	}  	else// if the fromElementType' toElementType combination is no implemented  	 {  		throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  	}  }  catch (Exception e) {  	throw new Exception ("UpdateMappingMatrix failed to update mapping matrix"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: try {  	ElementSetChecker.CheckElementSet (fromElements);  	ElementSetChecker.CheckElementSet (toElements);  	_method = SpatialAdaptedOutputFactory.GetMethod (methodIdentifier);  	_numberOfToRows = toElements.ElementCount;  	_numberOfFromColumns = fromElements.ElementCount;  	_mappingMatrix = new DoubleSparseMatrix (_numberOfToRows' _numberOfFromColumns);  	if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Point) {  		#region  		try {  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPoint toPoint = CreateXYPoint (toElements' i);  				for (int j = 0; j < _numberOfFromColumns; j++) {  					XYPoint fromPoint = CreateXYPoint (fromElements' j);  					_mappingMatrix [i' j] = XYGeometryTools.CalculatePointToPointDistance (toPoint' fromPoint);  				}  			}  			if (_method == ElementMapperMethod.Nearest) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.Inverse) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					if (minDist == 0) {  						int denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							if (_mappingMatrix [i' j] == minDist) {  								_mappingMatrix [i' j] = 1;  								denominator++;  							}  							else {  								_mappingMatrix [i' j] = 0;  							}  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  					else {  						double denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  							denominator = denominator + _mappingMatrix [i' j];  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  				}  			}  			else {  				throw new Exception ("methodDescription unknown for point point mapping");  			}  		}  		catch (Exception e) {  			throw new Exception ("Point to point mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.PolyLine) {  		#region  		try {  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPolyline toPolyLine = CreateXYPolyline (toElements' i);  				for (int j = 0; j < _numberOfFromColumns; j++) {  					XYPoint fromPoint = CreateXYPoint (fromElements' j);  					_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (toPolyLine' fromPoint);  				}  			}  			if (_method == ElementMapperMethod.Nearest) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.Inverse) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					if (minDist == 0) {  						int denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							if (_mappingMatrix [i' j] == minDist) {  								_mappingMatrix [i' j] = 1;  								denominator++;  							}  							else {  								_mappingMatrix [i' j] = 0;  							}  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  					else {  						double denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  							denominator = denominator + _mappingMatrix [i' j];  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  				}  			}  			else {  				throw new Exception ("methodDescription unknown for point to polyline mapping");  			}  		}  		catch (Exception e) {  			throw new Exception ("Point to polyline mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Polygon) {  		#region  		try {  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPolygon polygon = CreateXYPolygon (toElements' i);  				int count = 0;  				XYPoint point;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					point = CreateXYPoint (fromElements' n);  					if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  						if (_method == ElementMapperMethod.Mean) {  							count = count + 1;  						}  						else if (_method == ElementMapperMethod.Sum) {  							count = 1;  						}  						else {  							throw new Exception ("methodDescription unknown for point to polygon mapping");  						}  					}  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					point = CreateXYPoint (fromElements' n);  					if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  						_mappingMatrix [i' n] = 1.0 / count;  					}  				}  			}  		}  		catch (Exception e) {  			throw new Exception ("Point to polygon mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Point) {  		#region  		try {  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPoint toPoint = CreateXYPoint (toElements' i);  				for (int j = 0; j < _numberOfFromColumns; j++) {  					XYPolyline fromPolyLine = CreateXYPolyline (fromElements' j);  					_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (fromPolyLine' toPoint);  				}  			}  			if (_method == ElementMapperMethod.Nearest) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.Inverse) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					if (minDist == 0) {  						int denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							if (_mappingMatrix [i' j] == minDist) {  								_mappingMatrix [i' j] = 1;  								denominator++;  							}  							else {  								_mappingMatrix [i' j] = 0;  							}  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  					else {  						double denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  							denominator = denominator + _mappingMatrix [i' j];  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to point mapping");  			}  		}  		catch (Exception e)// Catch for all of the Point to Polyline part   		 {  			throw new Exception ("Polyline to point mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  		#region  		try {  			// For each polygon in target  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPolygon polygon = CreateXYPolygon (toElements' i);  				if (_method == ElementMapperMethod.WeightedMean) {  					double totalLineLengthInPolygon = 0;  					for (int n = 0; n < _numberOfFromColumns; n++) {  						XYPolyline polyline = CreateXYPolyline (fromElements' n);  						_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  						totalLineLengthInPolygon += _mappingMatrix [i' n];  					}  					if (totalLineLengthInPolygon > 0) {  						for (int n = 0; n < _numberOfFromColumns; n++) {  							_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  						}  					}  				}  				else if (_method == ElementMapperMethod.WeightedSum) {  					// For each line segment in PolyLine  					for (int n = 0; n < _numberOfFromColumns; n++) {  						XYPolyline polyline = CreateXYPolyline (fromElements' n);  						_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  					}  				}  				else {  					throw new Exception ("methodDescription unknown for polyline to polygon mapping");  				}  			}  		}  		catch (Exception e) {  			throw new Exception ("Polyline to polygon mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  		#region  		try {  			if (_method != ElementMapperMethod.Value)  				throw new Exception ("methodDescription unknown for polygon to point mapping");  			// Only create search tree if number of cols/rows is larger than say 10/10.  			bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  			XYElementSearchTree<int> fromSearchTree = null;  			ICollection<int> fromCandidateElmts = null;  			if (useSearchTree)  				fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  			else  				fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  			for (int n = 0; n < _numberOfToRows; n++) {  				XYPoint point = CreateXYPoint (toElements' n);  				if (useSearchTree) {  					XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  					fromCandidateElmts = fromSearchTree.FindElements (toExtent);  				}  				int count = 0;  				// Check first for strict inclusion  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  				if (count == 0) {  					// Not strictly inside any polygon' check also edges  					foreach (int i in fromCandidateElmts) {  						XYPolygon polygon = CreateXYPolygon (fromElements' i);  						if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  							_mappingMatrix [n' i] = 1.0;  							count++;  						}  					}  				}  				if (count > 1) {  					// In case of more than one hit' use average  					foreach (int i in fromCandidateElmts) {  						if (_mappingMatrix [n' i] != 0.0)  							_mappingMatrix [n' i] = 1.0 / count;  					}  				}  			}  		}  		catch (Exception e) {  			throw new Exception ("Polygon to point mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine  	 {  		#region  		try {  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPolyline polyline = CreateXYPolyline (toElements' i);  				if (_method == ElementMapperMethod.WeightedMean) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						XYPolygon polygon = CreateXYPolygon (fromElements' n);  						_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  					}  					double sum = 0;  					for (int n = 0; n < _numberOfFromColumns; n++) {  						sum += _mappingMatrix [i' n];  					}  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  					}  				}  				else if (_method == ElementMapperMethod.WeightedSum) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						XYPolygon polygon = CreateXYPolygon (fromElements' n);  						_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  					}  				}  				else {  					throw new Exception ("methodDescription unknown for polygon to polyline mapping");  				}  			}  		}  		catch (Exception e)// catch for all of Polygon to PolyLine  		 {  			throw new Exception ("Polygon to polyline mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon  	 {  		#region  		try {  			// Only create search tree if number of cols/rows is larger than say 100/10.  			bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  			XYElementSearchTree<int> fromSearchTree = null;  			ICollection<int> fromCandidateElmts = null;  			if (useSearchTree)  				fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  			else  				fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPolygon toPolygon = CreateXYPolygon (toElements' i);  				if (useSearchTree) {  					XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  					fromCandidateElmts = fromSearchTree.FindElements (toExtent);  				}  				foreach (int j in fromCandidateElmts) {  					XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  					_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  					if (_method == ElementMapperMethod.Distribute) {  						_mappingMatrix [i' j] /= fromPolygon.GetArea ();  					}  				}  				if (_method == ElementMapperMethod.WeightedMean) {  					double denominator = 0;  					foreach (int j in fromCandidateElmts) {  						denominator = denominator + _mappingMatrix [i' j];  					}  					foreach (int j in fromCandidateElmts) {  						if (denominator != 0) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  				}  				else if (_method == ElementMapperMethod.WeightedSum) {  					foreach (int j in fromCandidateElmts) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  					}  				}  				else if (_method != ElementMapperMethod.Distribute) {  					throw new Exception ("methodDescription unknown for polygon to polygon mapping");  				}  			}  		}  		catch (Exception e)// catch for all of Polygon to Polygon  		 {  			throw new Exception ("Polygon to polygon mapping failed"' e);  		}  		#endregion  	}  	else// if the fromElementType' toElementType combination is no implemented  	 {  		throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  	}  }  catch (Exception e) {  	throw new Exception ("UpdateMappingMatrix failed to update mapping matrix"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: try {  	ElementSetChecker.CheckElementSet (fromElements);  	ElementSetChecker.CheckElementSet (toElements);  	_method = SpatialAdaptedOutputFactory.GetMethod (methodIdentifier);  	_numberOfToRows = toElements.ElementCount;  	_numberOfFromColumns = fromElements.ElementCount;  	_mappingMatrix = new DoubleSparseMatrix (_numberOfToRows' _numberOfFromColumns);  	if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Point) {  		#region  		try {  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPoint toPoint = CreateXYPoint (toElements' i);  				for (int j = 0; j < _numberOfFromColumns; j++) {  					XYPoint fromPoint = CreateXYPoint (fromElements' j);  					_mappingMatrix [i' j] = XYGeometryTools.CalculatePointToPointDistance (toPoint' fromPoint);  				}  			}  			if (_method == ElementMapperMethod.Nearest) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.Inverse) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					if (minDist == 0) {  						int denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							if (_mappingMatrix [i' j] == minDist) {  								_mappingMatrix [i' j] = 1;  								denominator++;  							}  							else {  								_mappingMatrix [i' j] = 0;  							}  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  					else {  						double denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  							denominator = denominator + _mappingMatrix [i' j];  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  				}  			}  			else {  				throw new Exception ("methodDescription unknown for point point mapping");  			}  		}  		catch (Exception e) {  			throw new Exception ("Point to point mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.PolyLine) {  		#region  		try {  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPolyline toPolyLine = CreateXYPolyline (toElements' i);  				for (int j = 0; j < _numberOfFromColumns; j++) {  					XYPoint fromPoint = CreateXYPoint (fromElements' j);  					_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (toPolyLine' fromPoint);  				}  			}  			if (_method == ElementMapperMethod.Nearest) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.Inverse) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					if (minDist == 0) {  						int denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							if (_mappingMatrix [i' j] == minDist) {  								_mappingMatrix [i' j] = 1;  								denominator++;  							}  							else {  								_mappingMatrix [i' j] = 0;  							}  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  					else {  						double denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  							denominator = denominator + _mappingMatrix [i' j];  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  				}  			}  			else {  				throw new Exception ("methodDescription unknown for point to polyline mapping");  			}  		}  		catch (Exception e) {  			throw new Exception ("Point to polyline mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Polygon) {  		#region  		try {  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPolygon polygon = CreateXYPolygon (toElements' i);  				int count = 0;  				XYPoint point;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					point = CreateXYPoint (fromElements' n);  					if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  						if (_method == ElementMapperMethod.Mean) {  							count = count + 1;  						}  						else if (_method == ElementMapperMethod.Sum) {  							count = 1;  						}  						else {  							throw new Exception ("methodDescription unknown for point to polygon mapping");  						}  					}  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					point = CreateXYPoint (fromElements' n);  					if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  						_mappingMatrix [i' n] = 1.0 / count;  					}  				}  			}  		}  		catch (Exception e) {  			throw new Exception ("Point to polygon mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Point) {  		#region  		try {  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPoint toPoint = CreateXYPoint (toElements' i);  				for (int j = 0; j < _numberOfFromColumns; j++) {  					XYPolyline fromPolyLine = CreateXYPolyline (fromElements' j);  					_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (fromPolyLine' toPoint);  				}  			}  			if (_method == ElementMapperMethod.Nearest) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.Inverse) {  				for (int i = 0; i < _numberOfToRows; i++) {  					double minDist = _mappingMatrix [i' 0];  					for (int j = 1; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] < minDist) {  							minDist = _mappingMatrix [i' j];  						}  					}  					if (minDist == 0) {  						int denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							if (_mappingMatrix [i' j] == minDist) {  								_mappingMatrix [i' j] = 1;  								denominator++;  							}  							else {  								_mappingMatrix [i' j] = 0;  							}  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  					else {  						double denominator = 0;  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  							denominator = denominator + _mappingMatrix [i' j];  						}  						for (int j = 0; j < _numberOfFromColumns; j++) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to point mapping");  			}  		}  		catch (Exception e)// Catch for all of the Point to Polyline part   		 {  			throw new Exception ("Polyline to point mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  		#region  		try {  			// For each polygon in target  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPolygon polygon = CreateXYPolygon (toElements' i);  				if (_method == ElementMapperMethod.WeightedMean) {  					double totalLineLengthInPolygon = 0;  					for (int n = 0; n < _numberOfFromColumns; n++) {  						XYPolyline polyline = CreateXYPolyline (fromElements' n);  						_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  						totalLineLengthInPolygon += _mappingMatrix [i' n];  					}  					if (totalLineLengthInPolygon > 0) {  						for (int n = 0; n < _numberOfFromColumns; n++) {  							_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  						}  					}  				}  				else if (_method == ElementMapperMethod.WeightedSum) {  					// For each line segment in PolyLine  					for (int n = 0; n < _numberOfFromColumns; n++) {  						XYPolyline polyline = CreateXYPolyline (fromElements' n);  						_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  					}  				}  				else {  					throw new Exception ("methodDescription unknown for polyline to polygon mapping");  				}  			}  		}  		catch (Exception e) {  			throw new Exception ("Polyline to polygon mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  		#region  		try {  			if (_method != ElementMapperMethod.Value)  				throw new Exception ("methodDescription unknown for polygon to point mapping");  			// Only create search tree if number of cols/rows is larger than say 10/10.  			bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  			XYElementSearchTree<int> fromSearchTree = null;  			ICollection<int> fromCandidateElmts = null;  			if (useSearchTree)  				fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  			else  				fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  			for (int n = 0; n < _numberOfToRows; n++) {  				XYPoint point = CreateXYPoint (toElements' n);  				if (useSearchTree) {  					XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  					fromCandidateElmts = fromSearchTree.FindElements (toExtent);  				}  				int count = 0;  				// Check first for strict inclusion  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  				if (count == 0) {  					// Not strictly inside any polygon' check also edges  					foreach (int i in fromCandidateElmts) {  						XYPolygon polygon = CreateXYPolygon (fromElements' i);  						if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  							_mappingMatrix [n' i] = 1.0;  							count++;  						}  					}  				}  				if (count > 1) {  					// In case of more than one hit' use average  					foreach (int i in fromCandidateElmts) {  						if (_mappingMatrix [n' i] != 0.0)  							_mappingMatrix [n' i] = 1.0 / count;  					}  				}  			}  		}  		catch (Exception e) {  			throw new Exception ("Polygon to point mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine  	 {  		#region  		try {  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPolyline polyline = CreateXYPolyline (toElements' i);  				if (_method == ElementMapperMethod.WeightedMean) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						XYPolygon polygon = CreateXYPolygon (fromElements' n);  						_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  					}  					double sum = 0;  					for (int n = 0; n < _numberOfFromColumns; n++) {  						sum += _mappingMatrix [i' n];  					}  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  					}  				}  				else if (_method == ElementMapperMethod.WeightedSum) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						XYPolygon polygon = CreateXYPolygon (fromElements' n);  						_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  					}  				}  				else {  					throw new Exception ("methodDescription unknown for polygon to polyline mapping");  				}  			}  		}  		catch (Exception e)// catch for all of Polygon to PolyLine  		 {  			throw new Exception ("Polygon to polyline mapping failed"' e);  		}  		#endregion  	}  	else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon  	 {  		#region  		try {  			// Only create search tree if number of cols/rows is larger than say 100/10.  			bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  			XYElementSearchTree<int> fromSearchTree = null;  			ICollection<int> fromCandidateElmts = null;  			if (useSearchTree)  				fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  			else  				fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  			for (int i = 0; i < _numberOfToRows; i++) {  				XYPolygon toPolygon = CreateXYPolygon (toElements' i);  				if (useSearchTree) {  					XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  					fromCandidateElmts = fromSearchTree.FindElements (toExtent);  				}  				foreach (int j in fromCandidateElmts) {  					XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  					_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  					if (_method == ElementMapperMethod.Distribute) {  						_mappingMatrix [i' j] /= fromPolygon.GetArea ();  					}  				}  				if (_method == ElementMapperMethod.WeightedMean) {  					double denominator = 0;  					foreach (int j in fromCandidateElmts) {  						denominator = denominator + _mappingMatrix [i' j];  					}  					foreach (int j in fromCandidateElmts) {  						if (denominator != 0) {  							_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  						}  					}  				}  				else if (_method == ElementMapperMethod.WeightedSum) {  					foreach (int j in fromCandidateElmts) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  					}  				}  				else if (_method != ElementMapperMethod.Distribute) {  					throw new Exception ("methodDescription unknown for polygon to polygon mapping");  				}  			}  		}  		catch (Exception e)// catch for all of Polygon to Polygon  		 {  			throw new Exception ("Polygon to polygon mapping failed"' e);  		}  		#endregion  	}  	else// if the fromElementType' toElementType combination is no implemented  	 {  		throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  	}  }  catch (Exception e) {  	throw new Exception ("UpdateMappingMatrix failed to update mapping matrix"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Point) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPoint toPoint = CreateXYPoint (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPoint fromPoint = CreateXYPoint (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePointToPointDistance (toPoint' fromPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for point point mapping");  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.PolyLine) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline toPolyLine = CreateXYPolyline (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPoint fromPoint = CreateXYPoint (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (toPolyLine' fromPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for point to polyline mapping");  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			int count = 0;  			XYPoint point;  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					if (_method == ElementMapperMethod.Mean) {  						count = count + 1;  					}  					else if (_method == ElementMapperMethod.Sum) {  						count = 1;  					}  					else {  						throw new Exception ("methodDescription unknown for point to polygon mapping");  					}  				}  			}  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [i' n] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Point) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPoint toPoint = CreateXYPoint (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPolyline fromPolyLine = CreateXYPolyline (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (fromPolyLine' toPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for polyline to point mapping");  		}  	}  	catch (Exception e)// Catch for all of the Point to Polyline part   	 {  		throw new Exception ("Polyline to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		// For each polygon in target  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				double totalLineLengthInPolygon = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  					totalLineLengthInPolygon += _mappingMatrix [i' n];  				}  				if (totalLineLengthInPolygon > 0) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				// For each line segment in PolyLine  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to polygon mapping");  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polyline to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Point) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPoint toPoint = CreateXYPoint (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPoint fromPoint = CreateXYPoint (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePointToPointDistance (toPoint' fromPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for point point mapping");  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.PolyLine) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline toPolyLine = CreateXYPolyline (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPoint fromPoint = CreateXYPoint (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (toPolyLine' fromPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for point to polyline mapping");  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			int count = 0;  			XYPoint point;  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					if (_method == ElementMapperMethod.Mean) {  						count = count + 1;  					}  					else if (_method == ElementMapperMethod.Sum) {  						count = 1;  					}  					else {  						throw new Exception ("methodDescription unknown for point to polygon mapping");  					}  				}  			}  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [i' n] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Point) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPoint toPoint = CreateXYPoint (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPolyline fromPolyLine = CreateXYPolyline (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (fromPolyLine' toPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for polyline to point mapping");  		}  	}  	catch (Exception e)// Catch for all of the Point to Polyline part   	 {  		throw new Exception ("Polyline to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		// For each polygon in target  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				double totalLineLengthInPolygon = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  					totalLineLengthInPolygon += _mappingMatrix [i' n];  				}  				if (totalLineLengthInPolygon > 0) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				// For each line segment in PolyLine  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to polygon mapping");  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polyline to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Point) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPoint toPoint = CreateXYPoint (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPoint fromPoint = CreateXYPoint (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePointToPointDistance (toPoint' fromPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for point point mapping");  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.PolyLine) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline toPolyLine = CreateXYPolyline (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPoint fromPoint = CreateXYPoint (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (toPolyLine' fromPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for point to polyline mapping");  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			int count = 0;  			XYPoint point;  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					if (_method == ElementMapperMethod.Mean) {  						count = count + 1;  					}  					else if (_method == ElementMapperMethod.Sum) {  						count = 1;  					}  					else {  						throw new Exception ("methodDescription unknown for point to polygon mapping");  					}  				}  			}  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [i' n] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Point) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPoint toPoint = CreateXYPoint (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPolyline fromPolyLine = CreateXYPolyline (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (fromPolyLine' toPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for polyline to point mapping");  		}  	}  	catch (Exception e)// Catch for all of the Point to Polyline part   	 {  		throw new Exception ("Polyline to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		// For each polygon in target  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				double totalLineLengthInPolygon = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  					totalLineLengthInPolygon += _mappingMatrix [i' n];  				}  				if (totalLineLengthInPolygon > 0) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				// For each line segment in PolyLine  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to polygon mapping");  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polyline to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Point) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPoint toPoint = CreateXYPoint (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPoint fromPoint = CreateXYPoint (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePointToPointDistance (toPoint' fromPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for point point mapping");  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.PolyLine) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline toPolyLine = CreateXYPolyline (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPoint fromPoint = CreateXYPoint (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (toPolyLine' fromPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for point to polyline mapping");  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			int count = 0;  			XYPoint point;  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					if (_method == ElementMapperMethod.Mean) {  						count = count + 1;  					}  					else if (_method == ElementMapperMethod.Sum) {  						count = 1;  					}  					else {  						throw new Exception ("methodDescription unknown for point to polygon mapping");  					}  				}  			}  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [i' n] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Point) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPoint toPoint = CreateXYPoint (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPolyline fromPolyLine = CreateXYPolyline (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (fromPolyLine' toPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for polyline to point mapping");  		}  	}  	catch (Exception e)// Catch for all of the Point to Polyline part   	 {  		throw new Exception ("Polyline to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		// For each polygon in target  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				double totalLineLengthInPolygon = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  					totalLineLengthInPolygon += _mappingMatrix [i' n];  				}  				if (totalLineLengthInPolygon > 0) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				// For each line segment in PolyLine  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to polygon mapping");  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polyline to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.PolyLine) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline toPolyLine = CreateXYPolyline (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPoint fromPoint = CreateXYPoint (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (toPolyLine' fromPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for point to polyline mapping");  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			int count = 0;  			XYPoint point;  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					if (_method == ElementMapperMethod.Mean) {  						count = count + 1;  					}  					else if (_method == ElementMapperMethod.Sum) {  						count = 1;  					}  					else {  						throw new Exception ("methodDescription unknown for point to polygon mapping");  					}  				}  			}  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [i' n] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Point) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPoint toPoint = CreateXYPoint (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPolyline fromPolyLine = CreateXYPolyline (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (fromPolyLine' toPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for polyline to point mapping");  		}  	}  	catch (Exception e)// Catch for all of the Point to Polyline part   	 {  		throw new Exception ("Polyline to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		// For each polygon in target  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				double totalLineLengthInPolygon = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  					totalLineLengthInPolygon += _mappingMatrix [i' n];  				}  				if (totalLineLengthInPolygon > 0) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				// For each line segment in PolyLine  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to polygon mapping");  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polyline to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.PolyLine) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline toPolyLine = CreateXYPolyline (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPoint fromPoint = CreateXYPoint (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (toPolyLine' fromPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for point to polyline mapping");  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			int count = 0;  			XYPoint point;  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					if (_method == ElementMapperMethod.Mean) {  						count = count + 1;  					}  					else if (_method == ElementMapperMethod.Sum) {  						count = 1;  					}  					else {  						throw new Exception ("methodDescription unknown for point to polygon mapping");  					}  				}  			}  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [i' n] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Point) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPoint toPoint = CreateXYPoint (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPolyline fromPolyLine = CreateXYPolyline (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (fromPolyLine' toPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for polyline to point mapping");  		}  	}  	catch (Exception e)// Catch for all of the Point to Polyline part   	 {  		throw new Exception ("Polyline to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		// For each polygon in target  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				double totalLineLengthInPolygon = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  					totalLineLengthInPolygon += _mappingMatrix [i' n];  				}  				if (totalLineLengthInPolygon > 0) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				// For each line segment in PolyLine  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to polygon mapping");  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polyline to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.PolyLine) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline toPolyLine = CreateXYPolyline (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPoint fromPoint = CreateXYPoint (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (toPolyLine' fromPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for point to polyline mapping");  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			int count = 0;  			XYPoint point;  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					if (_method == ElementMapperMethod.Mean) {  						count = count + 1;  					}  					else if (_method == ElementMapperMethod.Sum) {  						count = 1;  					}  					else {  						throw new Exception ("methodDescription unknown for point to polygon mapping");  					}  				}  			}  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [i' n] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Point) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPoint toPoint = CreateXYPoint (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPolyline fromPolyLine = CreateXYPolyline (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (fromPolyLine' toPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for polyline to point mapping");  		}  	}  	catch (Exception e)// Catch for all of the Point to Polyline part   	 {  		throw new Exception ("Polyline to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		// For each polygon in target  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				double totalLineLengthInPolygon = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  					totalLineLengthInPolygon += _mappingMatrix [i' n];  				}  				if (totalLineLengthInPolygon > 0) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				// For each line segment in PolyLine  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to polygon mapping");  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polyline to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.PolyLine) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline toPolyLine = CreateXYPolyline (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPoint fromPoint = CreateXYPoint (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (toPolyLine' fromPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for point to polyline mapping");  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			int count = 0;  			XYPoint point;  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					if (_method == ElementMapperMethod.Mean) {  						count = count + 1;  					}  					else if (_method == ElementMapperMethod.Sum) {  						count = 1;  					}  					else {  						throw new Exception ("methodDescription unknown for point to polygon mapping");  					}  				}  			}  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [i' n] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Point) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPoint toPoint = CreateXYPoint (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPolyline fromPolyLine = CreateXYPolyline (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (fromPolyLine' toPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for polyline to point mapping");  		}  	}  	catch (Exception e)// Catch for all of the Point to Polyline part   	 {  		throw new Exception ("Polyline to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		// For each polygon in target  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				double totalLineLengthInPolygon = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  					totalLineLengthInPolygon += _mappingMatrix [i' n];  				}  				if (totalLineLengthInPolygon > 0) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				// For each line segment in PolyLine  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to polygon mapping");  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polyline to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			int count = 0;  			XYPoint point;  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					if (_method == ElementMapperMethod.Mean) {  						count = count + 1;  					}  					else if (_method == ElementMapperMethod.Sum) {  						count = 1;  					}  					else {  						throw new Exception ("methodDescription unknown for point to polygon mapping");  					}  				}  			}  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [i' n] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Point) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPoint toPoint = CreateXYPoint (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPolyline fromPolyLine = CreateXYPolyline (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (fromPolyLine' toPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for polyline to point mapping");  		}  	}  	catch (Exception e)// Catch for all of the Point to Polyline part   	 {  		throw new Exception ("Polyline to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		// For each polygon in target  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				double totalLineLengthInPolygon = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  					totalLineLengthInPolygon += _mappingMatrix [i' n];  				}  				if (totalLineLengthInPolygon > 0) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				// For each line segment in PolyLine  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to polygon mapping");  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polyline to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			int count = 0;  			XYPoint point;  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					if (_method == ElementMapperMethod.Mean) {  						count = count + 1;  					}  					else if (_method == ElementMapperMethod.Sum) {  						count = 1;  					}  					else {  						throw new Exception ("methodDescription unknown for point to polygon mapping");  					}  				}  			}  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [i' n] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Point) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPoint toPoint = CreateXYPoint (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPolyline fromPolyLine = CreateXYPolyline (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (fromPolyLine' toPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for polyline to point mapping");  		}  	}  	catch (Exception e)// Catch for all of the Point to Polyline part   	 {  		throw new Exception ("Polyline to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		// For each polygon in target  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				double totalLineLengthInPolygon = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  					totalLineLengthInPolygon += _mappingMatrix [i' n];  				}  				if (totalLineLengthInPolygon > 0) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				// For each line segment in PolyLine  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to polygon mapping");  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polyline to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			int count = 0;  			XYPoint point;  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					if (_method == ElementMapperMethod.Mean) {  						count = count + 1;  					}  					else if (_method == ElementMapperMethod.Sum) {  						count = 1;  					}  					else {  						throw new Exception ("methodDescription unknown for point to polygon mapping");  					}  				}  			}  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [i' n] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Point) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPoint toPoint = CreateXYPoint (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPolyline fromPolyLine = CreateXYPolyline (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (fromPolyLine' toPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for polyline to point mapping");  		}  	}  	catch (Exception e)// Catch for all of the Point to Polyline part   	 {  		throw new Exception ("Polyline to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		// For each polygon in target  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				double totalLineLengthInPolygon = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  					totalLineLengthInPolygon += _mappingMatrix [i' n];  				}  				if (totalLineLengthInPolygon > 0) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				// For each line segment in PolyLine  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to polygon mapping");  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polyline to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			int count = 0;  			XYPoint point;  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					if (_method == ElementMapperMethod.Mean) {  						count = count + 1;  					}  					else if (_method == ElementMapperMethod.Sum) {  						count = 1;  					}  					else {  						throw new Exception ("methodDescription unknown for point to polygon mapping");  					}  				}  			}  			for (int n = 0; n < _numberOfFromColumns; n++) {  				point = CreateXYPoint (fromElements' n);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [i' n] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Point to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Point) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPoint toPoint = CreateXYPoint (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPolyline fromPolyLine = CreateXYPolyline (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (fromPolyLine' toPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for polyline to point mapping");  		}  	}  	catch (Exception e)// Catch for all of the Point to Polyline part   	 {  		throw new Exception ("Polyline to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		// For each polygon in target  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				double totalLineLengthInPolygon = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  					totalLineLengthInPolygon += _mappingMatrix [i' n];  				}  				if (totalLineLengthInPolygon > 0) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				// For each line segment in PolyLine  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to polygon mapping");  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polyline to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Point) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPoint toPoint = CreateXYPoint (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPolyline fromPolyLine = CreateXYPolyline (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (fromPolyLine' toPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for polyline to point mapping");  		}  	}  	catch (Exception e)// Catch for all of the Point to Polyline part   	 {  		throw new Exception ("Polyline to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		// For each polygon in target  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				double totalLineLengthInPolygon = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  					totalLineLengthInPolygon += _mappingMatrix [i' n];  				}  				if (totalLineLengthInPolygon > 0) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				// For each line segment in PolyLine  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to polygon mapping");  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polyline to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Point) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPoint toPoint = CreateXYPoint (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPolyline fromPolyLine = CreateXYPolyline (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (fromPolyLine' toPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for polyline to point mapping");  		}  	}  	catch (Exception e)// Catch for all of the Point to Polyline part   	 {  		throw new Exception ("Polyline to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		// For each polygon in target  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				double totalLineLengthInPolygon = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  					totalLineLengthInPolygon += _mappingMatrix [i' n];  				}  				if (totalLineLengthInPolygon > 0) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				// For each line segment in PolyLine  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to polygon mapping");  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polyline to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Point) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPoint toPoint = CreateXYPoint (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPolyline fromPolyLine = CreateXYPolyline (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (fromPolyLine' toPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for polyline to point mapping");  		}  	}  	catch (Exception e)// Catch for all of the Point to Polyline part   	 {  		throw new Exception ("Polyline to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		// For each polygon in target  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				double totalLineLengthInPolygon = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  					totalLineLengthInPolygon += _mappingMatrix [i' n];  				}  				if (totalLineLengthInPolygon > 0) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				// For each line segment in PolyLine  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to polygon mapping");  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polyline to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Point) {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPoint toPoint = CreateXYPoint (toElements' i);  			for (int j = 0; j < _numberOfFromColumns; j++) {  				XYPolyline fromPolyLine = CreateXYPolyline (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculatePolylineToPointDistance (fromPolyLine' toPoint);  			}  		}  		if (_method == ElementMapperMethod.Nearest) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				int denominator = 0;  				for (int j = 0; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] == minDist) {  						_mappingMatrix [i' j] = 1;  						denominator++;  					}  					else {  						_mappingMatrix [i' j] = 0;  					}  				}  				for (int j = 0; j < _numberOfFromColumns; j++) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.Inverse) {  			for (int i = 0; i < _numberOfToRows; i++) {  				double minDist = _mappingMatrix [i' 0];  				for (int j = 1; j < _numberOfFromColumns; j++) {  					if (_mappingMatrix [i' j] < minDist) {  						minDist = _mappingMatrix [i' j];  					}  				}  				if (minDist == 0) {  					int denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						if (_mappingMatrix [i' j] == minDist) {  							_mappingMatrix [i' j] = 1;  							denominator++;  						}  						else {  							_mappingMatrix [i' j] = 0;  						}  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  				else {  					double denominator = 0;  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = 1 / _mappingMatrix [i' j];  						denominator = denominator + _mappingMatrix [i' j];  					}  					for (int j = 0; j < _numberOfFromColumns; j++) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  		}  		else {  			throw new Exception ("methodDescription unknown for polyline to point mapping");  		}  	}  	catch (Exception e)// Catch for all of the Point to Polyline part   	 {  		throw new Exception ("Polyline to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		// For each polygon in target  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				double totalLineLengthInPolygon = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  					totalLineLengthInPolygon += _mappingMatrix [i' n];  				}  				if (totalLineLengthInPolygon > 0) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				// For each line segment in PolyLine  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to polygon mapping");  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polyline to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		// For each polygon in target  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				double totalLineLengthInPolygon = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  					totalLineLengthInPolygon += _mappingMatrix [i' n];  				}  				if (totalLineLengthInPolygon > 0) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				// For each line segment in PolyLine  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to polygon mapping");  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polyline to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		// For each polygon in target  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				double totalLineLengthInPolygon = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  					totalLineLengthInPolygon += _mappingMatrix [i' n];  				}  				if (totalLineLengthInPolygon > 0) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				// For each line segment in PolyLine  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to polygon mapping");  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polyline to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		// For each polygon in target  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				double totalLineLengthInPolygon = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  					totalLineLengthInPolygon += _mappingMatrix [i' n];  				}  				if (totalLineLengthInPolygon > 0) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				// For each line segment in PolyLine  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to polygon mapping");  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polyline to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon) {  	#region  	try {  		// For each polygon in target  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon polygon = CreateXYPolygon (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				double totalLineLengthInPolygon = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon);  					totalLineLengthInPolygon += _mappingMatrix [i' n];  				}  				if (totalLineLengthInPolygon > 0) {  					for (int n = 0; n < _numberOfFromColumns; n++) {  						_mappingMatrix [i' n] = _mappingMatrix [i' n] / totalLineLengthInPolygon;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				// For each line segment in PolyLine  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolyline polyline = CreateXYPolyline (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polyline to polygon mapping");  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polyline to polygon mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point) {  	#region  	try {  		if (_method != ElementMapperMethod.Value)  			throw new Exception ("methodDescription unknown for polygon to point mapping");  		// Only create search tree if number of cols/rows is larger than say 10/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int n = 0; n < _numberOfToRows; n++) {  			XYPoint point = CreateXYPoint (toElements' n);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			int count = 0;  			// Check first for strict inclusion  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  			if (count == 0) {  				// Not strictly inside any polygon' check also edges  				foreach (int i in fromCandidateElmts) {  					XYPolygon polygon = CreateXYPolygon (fromElements' i);  					if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  						_mappingMatrix [n' i] = 1.0;  						count++;  					}  				}  			}  			if (count > 1) {  				// In case of more than one hit' use average  				foreach (int i in fromCandidateElmts) {  					if (_mappingMatrix [n' i] != 0.0)  						_mappingMatrix [n' i] = 1.0 / count;  				}  			}  		}  	}  	catch (Exception e) {  		throw new Exception ("Polygon to point mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: try {  	if (_method != ElementMapperMethod.Value)  		throw new Exception ("methodDescription unknown for polygon to point mapping");  	// Only create search tree if number of cols/rows is larger than say 10/10.  	bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  	XYElementSearchTree<int> fromSearchTree = null;  	ICollection<int> fromCandidateElmts = null;  	if (useSearchTree)  		fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  	else  		fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  	for (int n = 0; n < _numberOfToRows; n++) {  		XYPoint point = CreateXYPoint (toElements' n);  		if (useSearchTree) {  			XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  			fromCandidateElmts = fromSearchTree.FindElements (toExtent);  		}  		int count = 0;  		// Check first for strict inclusion  		foreach (int i in fromCandidateElmts) {  			XYPolygon polygon = CreateXYPolygon (fromElements' i);  			if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  				_mappingMatrix [n' i] = 1.0;  				count++;  			}  		}  		if (count == 0) {  			// Not strictly inside any polygon' check also edges  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  		}  		if (count > 1) {  			// In case of more than one hit' use average  			foreach (int i in fromCandidateElmts) {  				if (_mappingMatrix [n' i] != 0.0)  					_mappingMatrix [n' i] = 1.0 / count;  			}  		}  	}  }  catch (Exception e) {  	throw new Exception ("Polygon to point mapping failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: try {  	if (_method != ElementMapperMethod.Value)  		throw new Exception ("methodDescription unknown for polygon to point mapping");  	// Only create search tree if number of cols/rows is larger than say 10/10.  	bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  	XYElementSearchTree<int> fromSearchTree = null;  	ICollection<int> fromCandidateElmts = null;  	if (useSearchTree)  		fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  	else  		fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  	for (int n = 0; n < _numberOfToRows; n++) {  		XYPoint point = CreateXYPoint (toElements' n);  		if (useSearchTree) {  			XYExtent toExtent = XYExtentUtil.GetExtent (point' XYGeometryTools.EPSILON);  			fromCandidateElmts = fromSearchTree.FindElements (toExtent);  		}  		int count = 0;  		// Check first for strict inclusion  		foreach (int i in fromCandidateElmts) {  			XYPolygon polygon = CreateXYPolygon (fromElements' i);  			if (XYGeometryTools.IsPointInPolygon (point' polygon)) {  				_mappingMatrix [n' i] = 1.0;  				count++;  			}  		}  		if (count == 0) {  			// Not strictly inside any polygon' check also edges  			foreach (int i in fromCandidateElmts) {  				XYPolygon polygon = CreateXYPolygon (fromElements' i);  				if (XYGeometryTools.IsPointInPolygonOrOnEdge (point' polygon)) {  					_mappingMatrix [n' i] = 1.0;  					count++;  				}  			}  		}  		if (count > 1) {  			// In case of more than one hit' use average  			foreach (int i in fromCandidateElmts) {  				if (_mappingMatrix [n' i] != 0.0)  					_mappingMatrix [n' i] = 1.0 / count;  			}  		}  	}  }  catch (Exception e) {  	throw new Exception ("Polygon to point mapping failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine   {  	#region  	try {  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolyline polyline = CreateXYPolyline (toElements' i);  			if (_method == ElementMapperMethod.WeightedMean) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  				double sum = 0;  				for (int n = 0; n < _numberOfFromColumns; n++) {  					sum += _mappingMatrix [i' n];  				}  				for (int n = 0; n < _numberOfFromColumns; n++) {  					_mappingMatrix [i' n] = _mappingMatrix [i' n] / sum;  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				for (int n = 0; n < _numberOfFromColumns; n++) {  					XYPolygon polygon = CreateXYPolygon (fromElements' n);  					_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength ();  				}  			}  			else {  				throw new Exception ("methodDescription unknown for polygon to polyline mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to PolyLine  	 {  		throw new Exception ("Polygon to polyline mapping failed"' e);  	}  	#endregion  }  else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon   {  	#region  	try {  		// Only create search tree if number of cols/rows is larger than say 100/10.  		bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  		XYElementSearchTree<int> fromSearchTree = null;  		ICollection<int> fromCandidateElmts = null;  		if (useSearchTree)  			fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  		else  			fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  		for (int i = 0; i < _numberOfToRows; i++) {  			XYPolygon toPolygon = CreateXYPolygon (toElements' i);  			if (useSearchTree) {  				XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  				fromCandidateElmts = fromSearchTree.FindElements (toExtent);  			}  			foreach (int j in fromCandidateElmts) {  				XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  				_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  				if (_method == ElementMapperMethod.Distribute) {  					_mappingMatrix [i' j] /= fromPolygon.GetArea ();  				}  			}  			if (_method == ElementMapperMethod.WeightedMean) {  				double denominator = 0;  				foreach (int j in fromCandidateElmts) {  					denominator = denominator + _mappingMatrix [i' j];  				}  				foreach (int j in fromCandidateElmts) {  					if (denominator != 0) {  						_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  					}  				}  			}  			else if (_method == ElementMapperMethod.WeightedSum) {  				foreach (int j in fromCandidateElmts) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  				}  			}  			else if (_method != ElementMapperMethod.Distribute) {  				throw new Exception ("methodDescription unknown for polygon to polygon mapping");  			}  		}  	}  	catch (Exception e)// catch for all of Polygon to Polygon  	 {  		throw new Exception ("Polygon to polygon mapping failed"' e);  	}  	#endregion  }  else// if the fromElementType' toElementType combination is no implemented   {  	throw new Exception ("Mapping of specified ElementTypes not included in ElementMapper");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: try {  	// Only create search tree if number of cols/rows is larger than say 100/10.  	bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  	XYElementSearchTree<int> fromSearchTree = null;  	ICollection<int> fromCandidateElmts = null;  	if (useSearchTree)  		fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  	else  		fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  	for (int i = 0; i < _numberOfToRows; i++) {  		XYPolygon toPolygon = CreateXYPolygon (toElements' i);  		if (useSearchTree) {  			XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  			fromCandidateElmts = fromSearchTree.FindElements (toExtent);  		}  		foreach (int j in fromCandidateElmts) {  			XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  			_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  			if (_method == ElementMapperMethod.Distribute) {  				_mappingMatrix [i' j] /= fromPolygon.GetArea ();  			}  		}  		if (_method == ElementMapperMethod.WeightedMean) {  			double denominator = 0;  			foreach (int j in fromCandidateElmts) {  				denominator = denominator + _mappingMatrix [i' j];  			}  			foreach (int j in fromCandidateElmts) {  				if (denominator != 0) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.WeightedSum) {  			foreach (int j in fromCandidateElmts) {  				_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  			}  		}  		else if (_method != ElementMapperMethod.Distribute) {  			throw new Exception ("methodDescription unknown for polygon to polygon mapping");  		}  	}  }  catch (Exception e)// catch for all of Polygon to Polygon   {  	throw new Exception ("Polygon to polygon mapping failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The following statement contains a magic number: try {  	// Only create search tree if number of cols/rows is larger than say 100/10.  	bool useSearchTree = _numberOfFromColumns > 10 && _numberOfToRows > 10;  	XYElementSearchTree<int> fromSearchTree = null;  	ICollection<int> fromCandidateElmts = null;  	if (useSearchTree)  		fromSearchTree = XYElementSearchTree<int>.BuildSearchTree (fromElements);  	else  		fromCandidateElmts = new IntSequence (0' _numberOfFromColumns - 1);  	for (int i = 0; i < _numberOfToRows; i++) {  		XYPolygon toPolygon = CreateXYPolygon (toElements' i);  		if (useSearchTree) {  			XYExtent toExtent = XYExtentUtil.GetExtent (toPolygon);  			fromCandidateElmts = fromSearchTree.FindElements (toExtent);  		}  		foreach (int j in fromCandidateElmts) {  			XYPolygon fromPolygon = CreateXYPolygon (fromElements' j);  			_mappingMatrix [i' j] = XYGeometryTools.CalculateSharedArea (toPolygon' fromPolygon);  			if (_method == ElementMapperMethod.Distribute) {  				_mappingMatrix [i' j] /= fromPolygon.GetArea ();  			}  		}  		if (_method == ElementMapperMethod.WeightedMean) {  			double denominator = 0;  			foreach (int j in fromCandidateElmts) {  				denominator = denominator + _mappingMatrix [i' j];  			}  			foreach (int j in fromCandidateElmts) {  				if (denominator != 0) {  					_mappingMatrix [i' j] = _mappingMatrix [i' j] / denominator;  				}  			}  		}  		else if (_method == ElementMapperMethod.WeightedSum) {  			foreach (int j in fromCandidateElmts) {  				_mappingMatrix [i' j] = _mappingMatrix [i' j] / toPolygon.GetArea ();  			}  		}  		else if (_method != ElementMapperMethod.Distribute) {  			throw new Exception ("methodDescription unknown for polygon to polygon mapping");  		}  	}  }  catch (Exception e)// catch for all of Polygon to Polygon   {  	throw new Exception ("Polygon to polygon mapping failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,LineStringWrapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\LineString.cs,GetVertexCount,The following statement contains a magic number: return ((_lineString.IsNodeBased) ? 1 : 2);  
Magic Number,Oatc.OpenMI.Sdk.Spatial,Spatial2DGridWrapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\Spatial2DGridWrapper.cs,GetVertexCount,The following statement contains a magic number: return (4);  
Magic Number,Oatc.OpenMI.Sdk.Spatial,Spatial2DGridWrapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\Spatial2DGridWrapper.cs,GetGridIndex,The following statement contains a magic number: if (_grid.IsNodeBased) {  	jv = j;  	kv = k;  }  else {  	switch (vertexIndex) {  	case 0:  		// lower left  		jv = j;  		kv = k;  		break;  	case 1:  		// lower right  		jv = j + 1;  		kv = k;  		break;  	case 2:  		// upper left  		jv = j + 1;  		kv = k + 1;  		break;  	case 3:  		// upper right  		jv = j;  		kv = k + 1;  		break;  	default:  		throw new ArgumentOutOfRangeException ("vertexIndex");  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,Spatial2DGridWrapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\Spatial2DGridWrapper.cs,GetGridIndex,The following statement contains a magic number: if (_grid.IsNodeBased) {  	jv = j;  	kv = k;  }  else {  	switch (vertexIndex) {  	case 0:  		// lower left  		jv = j;  		kv = k;  		break;  	case 1:  		// lower right  		jv = j + 1;  		kv = k;  		break;  	case 2:  		// upper left  		jv = j + 1;  		kv = k + 1;  		break;  	case 3:  		// upper right  		jv = j;  		kv = k + 1;  		break;  	default:  		throw new ArgumentOutOfRangeException ("vertexIndex");  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,Spatial2DGridWrapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\Spatial2DGridWrapper.cs,GetGridIndex,The following statement contains a magic number: switch (vertexIndex) {  case 0:  	// lower left  	jv = j;  	kv = k;  	break;  case 1:  	// lower right  	jv = j + 1;  	kv = k;  	break;  case 2:  	// upper left  	jv = j + 1;  	kv = k + 1;  	break;  case 3:  	// upper right  	jv = j;  	kv = k + 1;  	break;  default:  	throw new ArgumentOutOfRangeException ("vertexIndex");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,Spatial2DGridWrapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\Spatial2DGridWrapper.cs,GetGridIndex,The following statement contains a magic number: switch (vertexIndex) {  case 0:  	// lower left  	jv = j;  	kv = k;  	break;  case 1:  	// lower right  	jv = j + 1;  	kv = k;  	break;  case 2:  	// upper left  	jv = j + 1;  	kv = k + 1;  	break;  case 3:  	// upper right  	jv = j;  	kv = k + 1;  	break;  default:  	throw new ArgumentOutOfRangeException ("vertexIndex");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,CalculateLengthOfLineInsidePolygon,The following statement contains a magic number: for (int i = 0; i < polygon.Points.Count; i++)// For all lines in the polygon   {  	for (int n = 0; n < lineList.Count; n++) {  		if (lineList.Count > 1000) {  			throw new Exception ("Problems in ElementMapper' line has been cut in more than 1000 pieces !!!");  		}  		if (DoLineSegmentsIntersect ((XYLine)lineList [n]' polygon.GetLine (i))) {  			// Split the intersecting line into two lines  			XYPoint IntersectionPoint = new XYPoint (CalculateIntersectionPoint ((XYLine)lineList [n]' polygon.GetLine (i)));  			lineList.Add (new XYLine (IntersectionPoint' lineList [n].P2));  			lineList [n].P2.X = IntersectionPoint.X;  			lineList [n].P2.Y = IntersectionPoint.Y;  			break;  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,CalculateLengthOfLineInsidePolygon,The following statement contains a magic number: for (int n = 0; n < lineList.Count; n++) {  	if (lineList.Count > 1000) {  		throw new Exception ("Problems in ElementMapper' line has been cut in more than 1000 pieces !!!");  	}  	if (DoLineSegmentsIntersect ((XYLine)lineList [n]' polygon.GetLine (i))) {  		// Split the intersecting line into two lines  		XYPoint IntersectionPoint = new XYPoint (CalculateIntersectionPoint ((XYLine)lineList [n]' polygon.GetLine (i)));  		lineList.Add (new XYLine (IntersectionPoint' lineList [n].P2));  		lineList [n].P2.X = IntersectionPoint.X;  		lineList [n].P2.Y = IntersectionPoint.Y;  		break;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,CalculateLengthOfLineInsidePolygon,The following statement contains a magic number: if (lineList.Count > 1000) {  	throw new Exception ("Problems in ElementMapper' line has been cut in more than 1000 pieces !!!");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,CalculateLengthOfLineInsidePolygon,The following statement contains a magic number: for (int i = 0; i < lineList.Count; i++) {  	if (lineList.Count > 1000) {  		throw new Exception ("Problems in ElementMapper' line has been cuttes in more than 100 pieces !!!");  	}  	for (int j = 0; j < polygon.Points.Count; j++) {  		if (IsPointInLineInterior (polygon.GetLine (j).P1' ((XYLine)lineList [i]))) {  			lineList.Add (new XYLine (polygon.GetLine (j).P1' ((XYLine)lineList [i]).P2));  			lineList [i].P2.X = polygon.GetLine (j).P1.X;  			lineList [i].P2.Y = polygon.GetLine (j).P1.Y;  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,CalculateLengthOfLineInsidePolygon,The following statement contains a magic number: if (lineList.Count > 1000) {  	throw new Exception ("Problems in ElementMapper' line has been cuttes in more than 100 pieces !!!");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,CalculateLengthOfLineInsidePolygon,The following statement contains a magic number: for (int i = 0; i < lineList.Count; i++) {  	double sharedLength = 0;  	for (int j = 0; j < polygon.Points.Count; j++) {  		sharedLength += CalculateSharedLength (((XYLine)lineList [i])' polygon.GetLine (j));  	}  	if (sharedLength > EPSILON) {  		lengthInside += sharedLength / 2;  	}  	else if (IsPointInPolygon (((XYLine)lineList [i]).GetMidpoint ()' polygon)) {  		lengthInside += ((XYLine)lineList [i]).GetLength ();  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,CalculateLengthOfLineInsidePolygon,The following statement contains a magic number: if (sharedLength > EPSILON) {  	lengthInside += sharedLength / 2;  }  else if (IsPointInPolygon (((XYLine)lineList [i]).GetMidpoint ()' polygon)) {  	lengthInside += ((XYLine)lineList [i]).GetLength ();  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,CalculateLengthOfLineInsidePolygon,The following statement contains a magic number: lengthInside += sharedLength / 2;  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new System.Exception ("Argument must be a polygon with 3 points");  	}  	// TODO: implement an epsilon depending on the two triangles at hand.  	//XYExtent extentA = XYExtentUtil.GetExtent(triangleA);  	//XYExtent extentB = XYExtentUtil.GetExtent(triangleB);  	//double scalingLength  	//  = Math.Max(extentA.XMax - extentA.XMin'  	//    Math.Max(extentA.YMax - extentA.YMin'  	//    Math.Max(extentB.XMax - extentB.XMin' extentB.YMax - extentB.YMin)));  	//double epsilon = EPSILON * scalingLength;  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area = 0;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst = new XYPoint ();  	// First intersection point between triangles  	XYPoint pIntersect = new XYPoint ();  	// Latest intersection node found  	pIntersect.X = triangleA.Points [0].X;  	pIntersect.Y = triangleA.Points [0].Y;  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	pFirst = pIntersect;  	if (j != -1) {  		int jStop = IncrementModula (j' 3);  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = triangleA.Points [i].X - pIntersect.X;  			double vay = triangleA.Points [i].Y - pIntersect.Y;  			double vbx = triangleB.Points [j].X - pIntersect.X;  			double vby = triangleB.Points [j].Y - pIntersect.Y;  			// The sideOf tells if the vb vector or the va vector is the one pointing "left"  			// If sideOf is positive' vb is pointing left' otherwise va is pointing left  			// The "left" vector is the one that is inside the polygon.  			double sideOf = vax * vby - vay * vbx;  			// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  			if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleB  			// TODO: Replace with IsPointOnEdge of triangleB  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleA  			// Should never happen' since above test basically does the same  			// TODO: Replace with IsPointOnEdge of triangleA  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new System.Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (System.Exception e) {  	throw new System.Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new System.Exception ("Argument must be a polygon with 3 points");  	}  	// TODO: implement an epsilon depending on the two triangles at hand.  	//XYExtent extentA = XYExtentUtil.GetExtent(triangleA);  	//XYExtent extentB = XYExtentUtil.GetExtent(triangleB);  	//double scalingLength  	//  = Math.Max(extentA.XMax - extentA.XMin'  	//    Math.Max(extentA.YMax - extentA.YMin'  	//    Math.Max(extentB.XMax - extentB.XMin' extentB.YMax - extentB.YMin)));  	//double epsilon = EPSILON * scalingLength;  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area = 0;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst = new XYPoint ();  	// First intersection point between triangles  	XYPoint pIntersect = new XYPoint ();  	// Latest intersection node found  	pIntersect.X = triangleA.Points [0].X;  	pIntersect.Y = triangleA.Points [0].Y;  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	pFirst = pIntersect;  	if (j != -1) {  		int jStop = IncrementModula (j' 3);  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = triangleA.Points [i].X - pIntersect.X;  			double vay = triangleA.Points [i].Y - pIntersect.Y;  			double vbx = triangleB.Points [j].X - pIntersect.X;  			double vby = triangleB.Points [j].Y - pIntersect.Y;  			// The sideOf tells if the vb vector or the va vector is the one pointing "left"  			// If sideOf is positive' vb is pointing left' otherwise va is pointing left  			// The "left" vector is the one that is inside the polygon.  			double sideOf = vax * vby - vay * vbx;  			// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  			if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleB  			// TODO: Replace with IsPointOnEdge of triangleB  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleA  			// Should never happen' since above test basically does the same  			// TODO: Replace with IsPointOnEdge of triangleA  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new System.Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (System.Exception e) {  	throw new System.Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new System.Exception ("Argument must be a polygon with 3 points");  	}  	// TODO: implement an epsilon depending on the two triangles at hand.  	//XYExtent extentA = XYExtentUtil.GetExtent(triangleA);  	//XYExtent extentB = XYExtentUtil.GetExtent(triangleB);  	//double scalingLength  	//  = Math.Max(extentA.XMax - extentA.XMin'  	//    Math.Max(extentA.YMax - extentA.YMin'  	//    Math.Max(extentB.XMax - extentB.XMin' extentB.YMax - extentB.YMin)));  	//double epsilon = EPSILON * scalingLength;  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area = 0;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst = new XYPoint ();  	// First intersection point between triangles  	XYPoint pIntersect = new XYPoint ();  	// Latest intersection node found  	pIntersect.X = triangleA.Points [0].X;  	pIntersect.Y = triangleA.Points [0].Y;  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	pFirst = pIntersect;  	if (j != -1) {  		int jStop = IncrementModula (j' 3);  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = triangleA.Points [i].X - pIntersect.X;  			double vay = triangleA.Points [i].Y - pIntersect.Y;  			double vbx = triangleB.Points [j].X - pIntersect.X;  			double vby = triangleB.Points [j].Y - pIntersect.Y;  			// The sideOf tells if the vb vector or the va vector is the one pointing "left"  			// If sideOf is positive' vb is pointing left' otherwise va is pointing left  			// The "left" vector is the one that is inside the polygon.  			double sideOf = vax * vby - vay * vbx;  			// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  			if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleB  			// TODO: Replace with IsPointOnEdge of triangleB  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleA  			// Should never happen' since above test basically does the same  			// TODO: Replace with IsPointOnEdge of triangleA  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new System.Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (System.Exception e) {  	throw new System.Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new System.Exception ("Argument must be a polygon with 3 points");  	}  	// TODO: implement an epsilon depending on the two triangles at hand.  	//XYExtent extentA = XYExtentUtil.GetExtent(triangleA);  	//XYExtent extentB = XYExtentUtil.GetExtent(triangleB);  	//double scalingLength  	//  = Math.Max(extentA.XMax - extentA.XMin'  	//    Math.Max(extentA.YMax - extentA.YMin'  	//    Math.Max(extentB.XMax - extentB.XMin' extentB.YMax - extentB.YMin)));  	//double epsilon = EPSILON * scalingLength;  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area = 0;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst = new XYPoint ();  	// First intersection point between triangles  	XYPoint pIntersect = new XYPoint ();  	// Latest intersection node found  	pIntersect.X = triangleA.Points [0].X;  	pIntersect.Y = triangleA.Points [0].Y;  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	pFirst = pIntersect;  	if (j != -1) {  		int jStop = IncrementModula (j' 3);  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = triangleA.Points [i].X - pIntersect.X;  			double vay = triangleA.Points [i].Y - pIntersect.Y;  			double vbx = triangleB.Points [j].X - pIntersect.X;  			double vby = triangleB.Points [j].Y - pIntersect.Y;  			// The sideOf tells if the vb vector or the va vector is the one pointing "left"  			// If sideOf is positive' vb is pointing left' otherwise va is pointing left  			// The "left" vector is the one that is inside the polygon.  			double sideOf = vax * vby - vay * vbx;  			// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  			if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleB  			// TODO: Replace with IsPointOnEdge of triangleB  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleA  			// Should never happen' since above test basically does the same  			// TODO: Replace with IsPointOnEdge of triangleA  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new System.Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (System.Exception e) {  	throw new System.Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new System.Exception ("Argument must be a polygon with 3 points");  	}  	// TODO: implement an epsilon depending on the two triangles at hand.  	//XYExtent extentA = XYExtentUtil.GetExtent(triangleA);  	//XYExtent extentB = XYExtentUtil.GetExtent(triangleB);  	//double scalingLength  	//  = Math.Max(extentA.XMax - extentA.XMin'  	//    Math.Max(extentA.YMax - extentA.YMin'  	//    Math.Max(extentB.XMax - extentB.XMin' extentB.YMax - extentB.YMin)));  	//double epsilon = EPSILON * scalingLength;  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area = 0;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst = new XYPoint ();  	// First intersection point between triangles  	XYPoint pIntersect = new XYPoint ();  	// Latest intersection node found  	pIntersect.X = triangleA.Points [0].X;  	pIntersect.Y = triangleA.Points [0].Y;  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	pFirst = pIntersect;  	if (j != -1) {  		int jStop = IncrementModula (j' 3);  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = triangleA.Points [i].X - pIntersect.X;  			double vay = triangleA.Points [i].Y - pIntersect.Y;  			double vbx = triangleB.Points [j].X - pIntersect.X;  			double vby = triangleB.Points [j].Y - pIntersect.Y;  			// The sideOf tells if the vb vector or the va vector is the one pointing "left"  			// If sideOf is positive' vb is pointing left' otherwise va is pointing left  			// The "left" vector is the one that is inside the polygon.  			double sideOf = vax * vby - vay * vbx;  			// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  			if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleB  			// TODO: Replace with IsPointOnEdge of triangleB  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleA  			// Should never happen' since above test basically does the same  			// TODO: Replace with IsPointOnEdge of triangleA  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new System.Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (System.Exception e) {  	throw new System.Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new System.Exception ("Argument must be a polygon with 3 points");  	}  	// TODO: implement an epsilon depending on the two triangles at hand.  	//XYExtent extentA = XYExtentUtil.GetExtent(triangleA);  	//XYExtent extentB = XYExtentUtil.GetExtent(triangleB);  	//double scalingLength  	//  = Math.Max(extentA.XMax - extentA.XMin'  	//    Math.Max(extentA.YMax - extentA.YMin'  	//    Math.Max(extentB.XMax - extentB.XMin' extentB.YMax - extentB.YMin)));  	//double epsilon = EPSILON * scalingLength;  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area = 0;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst = new XYPoint ();  	// First intersection point between triangles  	XYPoint pIntersect = new XYPoint ();  	// Latest intersection node found  	pIntersect.X = triangleA.Points [0].X;  	pIntersect.Y = triangleA.Points [0].Y;  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	pFirst = pIntersect;  	if (j != -1) {  		int jStop = IncrementModula (j' 3);  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = triangleA.Points [i].X - pIntersect.X;  			double vay = triangleA.Points [i].Y - pIntersect.Y;  			double vbx = triangleB.Points [j].X - pIntersect.X;  			double vby = triangleB.Points [j].Y - pIntersect.Y;  			// The sideOf tells if the vb vector or the va vector is the one pointing "left"  			// If sideOf is positive' vb is pointing left' otherwise va is pointing left  			// The "left" vector is the one that is inside the polygon.  			double sideOf = vax * vby - vay * vbx;  			// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  			if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleB  			// TODO: Replace with IsPointOnEdge of triangleB  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleA  			// Should never happen' since above test basically does the same  			// TODO: Replace with IsPointOnEdge of triangleA  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new System.Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (System.Exception e) {  	throw new System.Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new System.Exception ("Argument must be a polygon with 3 points");  	}  	// TODO: implement an epsilon depending on the two triangles at hand.  	//XYExtent extentA = XYExtentUtil.GetExtent(triangleA);  	//XYExtent extentB = XYExtentUtil.GetExtent(triangleB);  	//double scalingLength  	//  = Math.Max(extentA.XMax - extentA.XMin'  	//    Math.Max(extentA.YMax - extentA.YMin'  	//    Math.Max(extentB.XMax - extentB.XMin' extentB.YMax - extentB.YMin)));  	//double epsilon = EPSILON * scalingLength;  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area = 0;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst = new XYPoint ();  	// First intersection point between triangles  	XYPoint pIntersect = new XYPoint ();  	// Latest intersection node found  	pIntersect.X = triangleA.Points [0].X;  	pIntersect.Y = triangleA.Points [0].Y;  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	pFirst = pIntersect;  	if (j != -1) {  		int jStop = IncrementModula (j' 3);  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = triangleA.Points [i].X - pIntersect.X;  			double vay = triangleA.Points [i].Y - pIntersect.Y;  			double vbx = triangleB.Points [j].X - pIntersect.X;  			double vby = triangleB.Points [j].Y - pIntersect.Y;  			// The sideOf tells if the vb vector or the va vector is the one pointing "left"  			// If sideOf is positive' vb is pointing left' otherwise va is pointing left  			// The "left" vector is the one that is inside the polygon.  			double sideOf = vax * vby - vay * vbx;  			// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  			if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleB  			// TODO: Replace with IsPointOnEdge of triangleB  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleA  			// Should never happen' since above test basically does the same  			// TODO: Replace with IsPointOnEdge of triangleA  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new System.Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (System.Exception e) {  	throw new System.Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new System.Exception ("Argument must be a polygon with 3 points");  	}  	// TODO: implement an epsilon depending on the two triangles at hand.  	//XYExtent extentA = XYExtentUtil.GetExtent(triangleA);  	//XYExtent extentB = XYExtentUtil.GetExtent(triangleB);  	//double scalingLength  	//  = Math.Max(extentA.XMax - extentA.XMin'  	//    Math.Max(extentA.YMax - extentA.YMin'  	//    Math.Max(extentB.XMax - extentB.XMin' extentB.YMax - extentB.YMin)));  	//double epsilon = EPSILON * scalingLength;  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area = 0;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst = new XYPoint ();  	// First intersection point between triangles  	XYPoint pIntersect = new XYPoint ();  	// Latest intersection node found  	pIntersect.X = triangleA.Points [0].X;  	pIntersect.Y = triangleA.Points [0].Y;  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	pFirst = pIntersect;  	if (j != -1) {  		int jStop = IncrementModula (j' 3);  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = triangleA.Points [i].X - pIntersect.X;  			double vay = triangleA.Points [i].Y - pIntersect.Y;  			double vbx = triangleB.Points [j].X - pIntersect.X;  			double vby = triangleB.Points [j].Y - pIntersect.Y;  			// The sideOf tells if the vb vector or the va vector is the one pointing "left"  			// If sideOf is positive' vb is pointing left' otherwise va is pointing left  			// The "left" vector is the one that is inside the polygon.  			double sideOf = vax * vby - vay * vbx;  			// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  			if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleB  			// TODO: Replace with IsPointOnEdge of triangleB  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleA  			// Should never happen' since above test basically does the same  			// TODO: Replace with IsPointOnEdge of triangleA  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new System.Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (System.Exception e) {  	throw new System.Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new System.Exception ("Argument must be a polygon with 3 points");  	}  	// TODO: implement an epsilon depending on the two triangles at hand.  	//XYExtent extentA = XYExtentUtil.GetExtent(triangleA);  	//XYExtent extentB = XYExtentUtil.GetExtent(triangleB);  	//double scalingLength  	//  = Math.Max(extentA.XMax - extentA.XMin'  	//    Math.Max(extentA.YMax - extentA.YMin'  	//    Math.Max(extentB.XMax - extentB.XMin' extentB.YMax - extentB.YMin)));  	//double epsilon = EPSILON * scalingLength;  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area = 0;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst = new XYPoint ();  	// First intersection point between triangles  	XYPoint pIntersect = new XYPoint ();  	// Latest intersection node found  	pIntersect.X = triangleA.Points [0].X;  	pIntersect.Y = triangleA.Points [0].Y;  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	pFirst = pIntersect;  	if (j != -1) {  		int jStop = IncrementModula (j' 3);  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = triangleA.Points [i].X - pIntersect.X;  			double vay = triangleA.Points [i].Y - pIntersect.Y;  			double vbx = triangleB.Points [j].X - pIntersect.X;  			double vby = triangleB.Points [j].Y - pIntersect.Y;  			// The sideOf tells if the vb vector or the va vector is the one pointing "left"  			// If sideOf is positive' vb is pointing left' otherwise va is pointing left  			// The "left" vector is the one that is inside the polygon.  			double sideOf = vax * vby - vay * vbx;  			// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  			if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleB  			// TODO: Replace with IsPointOnEdge of triangleB  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleA  			// Should never happen' since above test basically does the same  			// TODO: Replace with IsPointOnEdge of triangleA  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new System.Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (System.Exception e) {  	throw new System.Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new System.Exception ("Argument must be a polygon with 3 points");  	}  	// TODO: implement an epsilon depending on the two triangles at hand.  	//XYExtent extentA = XYExtentUtil.GetExtent(triangleA);  	//XYExtent extentB = XYExtentUtil.GetExtent(triangleB);  	//double scalingLength  	//  = Math.Max(extentA.XMax - extentA.XMin'  	//    Math.Max(extentA.YMax - extentA.YMin'  	//    Math.Max(extentB.XMax - extentB.XMin' extentB.YMax - extentB.YMin)));  	//double epsilon = EPSILON * scalingLength;  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area = 0;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst = new XYPoint ();  	// First intersection point between triangles  	XYPoint pIntersect = new XYPoint ();  	// Latest intersection node found  	pIntersect.X = triangleA.Points [0].X;  	pIntersect.Y = triangleA.Points [0].Y;  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	pFirst = pIntersect;  	if (j != -1) {  		int jStop = IncrementModula (j' 3);  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = triangleA.Points [i].X - pIntersect.X;  			double vay = triangleA.Points [i].Y - pIntersect.Y;  			double vbx = triangleB.Points [j].X - pIntersect.X;  			double vby = triangleB.Points [j].Y - pIntersect.Y;  			// The sideOf tells if the vb vector or the va vector is the one pointing "left"  			// If sideOf is positive' vb is pointing left' otherwise va is pointing left  			// The "left" vector is the one that is inside the polygon.  			double sideOf = vax * vby - vay * vbx;  			// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  			if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleB  			// TODO: Replace with IsPointOnEdge of triangleB  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleA  			// Should never happen' since above test basically does the same  			// TODO: Replace with IsPointOnEdge of triangleA  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new System.Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (System.Exception e) {  	throw new System.Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new System.Exception ("Argument must be a polygon with 3 points");  	}  	// TODO: implement an epsilon depending on the two triangles at hand.  	//XYExtent extentA = XYExtentUtil.GetExtent(triangleA);  	//XYExtent extentB = XYExtentUtil.GetExtent(triangleB);  	//double scalingLength  	//  = Math.Max(extentA.XMax - extentA.XMin'  	//    Math.Max(extentA.YMax - extentA.YMin'  	//    Math.Max(extentB.XMax - extentB.XMin' extentB.YMax - extentB.YMin)));  	//double epsilon = EPSILON * scalingLength;  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area = 0;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst = new XYPoint ();  	// First intersection point between triangles  	XYPoint pIntersect = new XYPoint ();  	// Latest intersection node found  	pIntersect.X = triangleA.Points [0].X;  	pIntersect.Y = triangleA.Points [0].Y;  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	pFirst = pIntersect;  	if (j != -1) {  		int jStop = IncrementModula (j' 3);  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = triangleA.Points [i].X - pIntersect.X;  			double vay = triangleA.Points [i].Y - pIntersect.Y;  			double vbx = triangleB.Points [j].X - pIntersect.X;  			double vby = triangleB.Points [j].Y - pIntersect.Y;  			// The sideOf tells if the vb vector or the va vector is the one pointing "left"  			// If sideOf is positive' vb is pointing left' otherwise va is pointing left  			// The "left" vector is the one that is inside the polygon.  			double sideOf = vax * vby - vay * vbx;  			// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  			if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleB  			// TODO: Replace with IsPointOnEdge of triangleB  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleA  			// Should never happen' since above test basically does the same  			// TODO: Replace with IsPointOnEdge of triangleA  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new System.Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (System.Exception e) {  	throw new System.Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new System.Exception ("Argument must be a polygon with 3 points");  	}  	// TODO: implement an epsilon depending on the two triangles at hand.  	//XYExtent extentA = XYExtentUtil.GetExtent(triangleA);  	//XYExtent extentB = XYExtentUtil.GetExtent(triangleB);  	//double scalingLength  	//  = Math.Max(extentA.XMax - extentA.XMin'  	//    Math.Max(extentA.YMax - extentA.YMin'  	//    Math.Max(extentB.XMax - extentB.XMin' extentB.YMax - extentB.YMin)));  	//double epsilon = EPSILON * scalingLength;  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area = 0;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst = new XYPoint ();  	// First intersection point between triangles  	XYPoint pIntersect = new XYPoint ();  	// Latest intersection node found  	pIntersect.X = triangleA.Points [0].X;  	pIntersect.Y = triangleA.Points [0].Y;  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	pFirst = pIntersect;  	if (j != -1) {  		int jStop = IncrementModula (j' 3);  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = triangleA.Points [i].X - pIntersect.X;  			double vay = triangleA.Points [i].Y - pIntersect.Y;  			double vbx = triangleB.Points [j].X - pIntersect.X;  			double vby = triangleB.Points [j].Y - pIntersect.Y;  			// The sideOf tells if the vb vector or the va vector is the one pointing "left"  			// If sideOf is positive' vb is pointing left' otherwise va is pointing left  			// The "left" vector is the one that is inside the polygon.  			double sideOf = vax * vby - vay * vbx;  			// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  			if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleB  			// TODO: Replace with IsPointOnEdge of triangleB  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleA  			// Should never happen' since above test basically does the same  			// TODO: Replace with IsPointOnEdge of triangleA  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new System.Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (System.Exception e) {  	throw new System.Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new System.Exception ("Argument must be a polygon with 3 points");  	}  	// TODO: implement an epsilon depending on the two triangles at hand.  	//XYExtent extentA = XYExtentUtil.GetExtent(triangleA);  	//XYExtent extentB = XYExtentUtil.GetExtent(triangleB);  	//double scalingLength  	//  = Math.Max(extentA.XMax - extentA.XMin'  	//    Math.Max(extentA.YMax - extentA.YMin'  	//    Math.Max(extentB.XMax - extentB.XMin' extentB.YMax - extentB.YMin)));  	//double epsilon = EPSILON * scalingLength;  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area = 0;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst = new XYPoint ();  	// First intersection point between triangles  	XYPoint pIntersect = new XYPoint ();  	// Latest intersection node found  	pIntersect.X = triangleA.Points [0].X;  	pIntersect.Y = triangleA.Points [0].Y;  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	pFirst = pIntersect;  	if (j != -1) {  		int jStop = IncrementModula (j' 3);  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = triangleA.Points [i].X - pIntersect.X;  			double vay = triangleA.Points [i].Y - pIntersect.Y;  			double vbx = triangleB.Points [j].X - pIntersect.X;  			double vby = triangleB.Points [j].Y - pIntersect.Y;  			// The sideOf tells if the vb vector or the va vector is the one pointing "left"  			// If sideOf is positive' vb is pointing left' otherwise va is pointing left  			// The "left" vector is the one that is inside the polygon.  			double sideOf = vax * vby - vay * vbx;  			// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  			if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleB  			// TODO: Replace with IsPointOnEdge of triangleB  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleA  			// Should never happen' since above test basically does the same  			// TODO: Replace with IsPointOnEdge of triangleA  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new System.Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (System.Exception e) {  	throw new System.Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new System.Exception ("Argument must be a polygon with 3 points");  	}  	// TODO: implement an epsilon depending on the two triangles at hand.  	//XYExtent extentA = XYExtentUtil.GetExtent(triangleA);  	//XYExtent extentB = XYExtentUtil.GetExtent(triangleB);  	//double scalingLength  	//  = Math.Max(extentA.XMax - extentA.XMin'  	//    Math.Max(extentA.YMax - extentA.YMin'  	//    Math.Max(extentB.XMax - extentB.XMin' extentB.YMax - extentB.YMin)));  	//double epsilon = EPSILON * scalingLength;  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area = 0;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst = new XYPoint ();  	// First intersection point between triangles  	XYPoint pIntersect = new XYPoint ();  	// Latest intersection node found  	pIntersect.X = triangleA.Points [0].X;  	pIntersect.Y = triangleA.Points [0].Y;  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	pFirst = pIntersect;  	if (j != -1) {  		int jStop = IncrementModula (j' 3);  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = triangleA.Points [i].X - pIntersect.X;  			double vay = triangleA.Points [i].Y - pIntersect.Y;  			double vbx = triangleB.Points [j].X - pIntersect.X;  			double vby = triangleB.Points [j].Y - pIntersect.Y;  			// The sideOf tells if the vb vector or the va vector is the one pointing "left"  			// If sideOf is positive' vb is pointing left' otherwise va is pointing left  			// The "left" vector is the one that is inside the polygon.  			double sideOf = vax * vby - vay * vbx;  			// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  			if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleB  			// TODO: Replace with IsPointOnEdge of triangleB  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleA  			// Should never happen' since above test basically does the same  			// TODO: Replace with IsPointOnEdge of triangleA  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new System.Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (System.Exception e) {  	throw new System.Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new System.Exception ("Argument must be a polygon with 3 points");  	}  	// TODO: implement an epsilon depending on the two triangles at hand.  	//XYExtent extentA = XYExtentUtil.GetExtent(triangleA);  	//XYExtent extentB = XYExtentUtil.GetExtent(triangleB);  	//double scalingLength  	//  = Math.Max(extentA.XMax - extentA.XMin'  	//    Math.Max(extentA.YMax - extentA.YMin'  	//    Math.Max(extentB.XMax - extentB.XMin' extentB.YMax - extentB.YMin)));  	//double epsilon = EPSILON * scalingLength;  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area = 0;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst = new XYPoint ();  	// First intersection point between triangles  	XYPoint pIntersect = new XYPoint ();  	// Latest intersection node found  	pIntersect.X = triangleA.Points [0].X;  	pIntersect.Y = triangleA.Points [0].Y;  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	pFirst = pIntersect;  	if (j != -1) {  		int jStop = IncrementModula (j' 3);  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = triangleA.Points [i].X - pIntersect.X;  			double vay = triangleA.Points [i].Y - pIntersect.Y;  			double vbx = triangleB.Points [j].X - pIntersect.X;  			double vby = triangleB.Points [j].Y - pIntersect.Y;  			// The sideOf tells if the vb vector or the va vector is the one pointing "left"  			// If sideOf is positive' vb is pointing left' otherwise va is pointing left  			// The "left" vector is the one that is inside the polygon.  			double sideOf = vax * vby - vay * vbx;  			// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  			if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleB  			// TODO: Replace with IsPointOnEdge of triangleB  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleA  			// Should never happen' since above test basically does the same  			// TODO: Replace with IsPointOnEdge of triangleA  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new System.Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (System.Exception e) {  	throw new System.Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new System.Exception ("Argument must be a polygon with 3 points");  	}  	// TODO: implement an epsilon depending on the two triangles at hand.  	//XYExtent extentA = XYExtentUtil.GetExtent(triangleA);  	//XYExtent extentB = XYExtentUtil.GetExtent(triangleB);  	//double scalingLength  	//  = Math.Max(extentA.XMax - extentA.XMin'  	//    Math.Max(extentA.YMax - extentA.YMin'  	//    Math.Max(extentB.XMax - extentB.XMin' extentB.YMax - extentB.YMin)));  	//double epsilon = EPSILON * scalingLength;  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area = 0;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst = new XYPoint ();  	// First intersection point between triangles  	XYPoint pIntersect = new XYPoint ();  	// Latest intersection node found  	pIntersect.X = triangleA.Points [0].X;  	pIntersect.Y = triangleA.Points [0].Y;  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	pFirst = pIntersect;  	if (j != -1) {  		int jStop = IncrementModula (j' 3);  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = triangleA.Points [i].X - pIntersect.X;  			double vay = triangleA.Points [i].Y - pIntersect.Y;  			double vbx = triangleB.Points [j].X - pIntersect.X;  			double vby = triangleB.Points [j].Y - pIntersect.Y;  			// The sideOf tells if the vb vector or the va vector is the one pointing "left"  			// If sideOf is positive' vb is pointing left' otherwise va is pointing left  			// The "left" vector is the one that is inside the polygon.  			double sideOf = vax * vby - vay * vbx;  			// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  			if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleB  			// TODO: Replace with IsPointOnEdge of triangleB  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleA  			// Should never happen' since above test basically does the same  			// TODO: Replace with IsPointOnEdge of triangleA  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new System.Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (System.Exception e) {  	throw new System.Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new System.Exception ("Argument must be a polygon with 3 points");  	}  	// TODO: implement an epsilon depending on the two triangles at hand.  	//XYExtent extentA = XYExtentUtil.GetExtent(triangleA);  	//XYExtent extentB = XYExtentUtil.GetExtent(triangleB);  	//double scalingLength  	//  = Math.Max(extentA.XMax - extentA.XMin'  	//    Math.Max(extentA.YMax - extentA.YMin'  	//    Math.Max(extentB.XMax - extentB.XMin' extentB.YMax - extentB.YMin)));  	//double epsilon = EPSILON * scalingLength;  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area = 0;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst = new XYPoint ();  	// First intersection point between triangles  	XYPoint pIntersect = new XYPoint ();  	// Latest intersection node found  	pIntersect.X = triangleA.Points [0].X;  	pIntersect.Y = triangleA.Points [0].Y;  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	pFirst = pIntersect;  	if (j != -1) {  		int jStop = IncrementModula (j' 3);  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = triangleA.Points [i].X - pIntersect.X;  			double vay = triangleA.Points [i].Y - pIntersect.Y;  			double vbx = triangleB.Points [j].X - pIntersect.X;  			double vby = triangleB.Points [j].Y - pIntersect.Y;  			// The sideOf tells if the vb vector or the va vector is the one pointing "left"  			// If sideOf is positive' vb is pointing left' otherwise va is pointing left  			// The "left" vector is the one that is inside the polygon.  			double sideOf = vax * vby - vay * vbx;  			// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  			if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleB  			// TODO: Replace with IsPointOnEdge of triangleB  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleA  			// Should never happen' since above test basically does the same  			// TODO: Replace with IsPointOnEdge of triangleA  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new System.Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (System.Exception e) {  	throw new System.Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new System.Exception ("Argument must be a polygon with 3 points");  	}  	// TODO: implement an epsilon depending on the two triangles at hand.  	//XYExtent extentA = XYExtentUtil.GetExtent(triangleA);  	//XYExtent extentB = XYExtentUtil.GetExtent(triangleB);  	//double scalingLength  	//  = Math.Max(extentA.XMax - extentA.XMin'  	//    Math.Max(extentA.YMax - extentA.YMin'  	//    Math.Max(extentB.XMax - extentB.XMin' extentB.YMax - extentB.YMin)));  	//double epsilon = EPSILON * scalingLength;  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area = 0;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst = new XYPoint ();  	// First intersection point between triangles  	XYPoint pIntersect = new XYPoint ();  	// Latest intersection node found  	pIntersect.X = triangleA.Points [0].X;  	pIntersect.Y = triangleA.Points [0].Y;  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	pFirst = pIntersect;  	if (j != -1) {  		int jStop = IncrementModula (j' 3);  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = triangleA.Points [i].X - pIntersect.X;  			double vay = triangleA.Points [i].Y - pIntersect.Y;  			double vbx = triangleB.Points [j].X - pIntersect.X;  			double vby = triangleB.Points [j].Y - pIntersect.Y;  			// The sideOf tells if the vb vector or the va vector is the one pointing "left"  			// If sideOf is positive' vb is pointing left' otherwise va is pointing left  			// The "left" vector is the one that is inside the polygon.  			double sideOf = vax * vby - vay * vbx;  			// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  			if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleB  			// TODO: Replace with IsPointOnEdge of triangleB  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleA  			// Should never happen' since above test basically does the same  			// TODO: Replace with IsPointOnEdge of triangleA  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new System.Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (System.Exception e) {  	throw new System.Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new System.Exception ("Argument must be a polygon with 3 points");  	}  	// TODO: implement an epsilon depending on the two triangles at hand.  	//XYExtent extentA = XYExtentUtil.GetExtent(triangleA);  	//XYExtent extentB = XYExtentUtil.GetExtent(triangleB);  	//double scalingLength  	//  = Math.Max(extentA.XMax - extentA.XMin'  	//    Math.Max(extentA.YMax - extentA.YMin'  	//    Math.Max(extentB.XMax - extentB.XMin' extentB.YMax - extentB.YMin)));  	//double epsilon = EPSILON * scalingLength;  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area = 0;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst = new XYPoint ();  	// First intersection point between triangles  	XYPoint pIntersect = new XYPoint ();  	// Latest intersection node found  	pIntersect.X = triangleA.Points [0].X;  	pIntersect.Y = triangleA.Points [0].Y;  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	pFirst = pIntersect;  	if (j != -1) {  		int jStop = IncrementModula (j' 3);  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = triangleA.Points [i].X - pIntersect.X;  			double vay = triangleA.Points [i].Y - pIntersect.Y;  			double vbx = triangleB.Points [j].X - pIntersect.X;  			double vby = triangleB.Points [j].Y - pIntersect.Y;  			// The sideOf tells if the vb vector or the va vector is the one pointing "left"  			// If sideOf is positive' vb is pointing left' otherwise va is pointing left  			// The "left" vector is the one that is inside the polygon.  			double sideOf = vax * vby - vay * vbx;  			// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  			if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleB  			// TODO: Replace with IsPointOnEdge of triangleB  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleA  			// Should never happen' since above test basically does the same  			// TODO: Replace with IsPointOnEdge of triangleA  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new System.Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (System.Exception e) {  	throw new System.Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new System.Exception ("Argument must be a polygon with 3 points");  	}  	// TODO: implement an epsilon depending on the two triangles at hand.  	//XYExtent extentA = XYExtentUtil.GetExtent(triangleA);  	//XYExtent extentB = XYExtentUtil.GetExtent(triangleB);  	//double scalingLength  	//  = Math.Max(extentA.XMax - extentA.XMin'  	//    Math.Max(extentA.YMax - extentA.YMin'  	//    Math.Max(extentB.XMax - extentB.XMin' extentB.YMax - extentB.YMin)));  	//double epsilon = EPSILON * scalingLength;  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area = 0;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst = new XYPoint ();  	// First intersection point between triangles  	XYPoint pIntersect = new XYPoint ();  	// Latest intersection node found  	pIntersect.X = triangleA.Points [0].X;  	pIntersect.Y = triangleA.Points [0].Y;  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	pFirst = pIntersect;  	if (j != -1) {  		int jStop = IncrementModula (j' 3);  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = triangleA.Points [i].X - pIntersect.X;  			double vay = triangleA.Points [i].Y - pIntersect.Y;  			double vbx = triangleB.Points [j].X - pIntersect.X;  			double vby = triangleB.Points [j].Y - pIntersect.Y;  			// The sideOf tells if the vb vector or the va vector is the one pointing "left"  			// If sideOf is positive' vb is pointing left' otherwise va is pointing left  			// The "left" vector is the one that is inside the polygon.  			double sideOf = vax * vby - vay * vbx;  			// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  			if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleB  			// TODO: Replace with IsPointOnEdge of triangleB  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  			}  			// can be true if the point is on the edge of the triangleA  			// Should never happen' since above test basically does the same  			// TODO: Replace with IsPointOnEdge of triangleA  			else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new System.Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (System.Exception e) {  	throw new System.Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  	throw new System.Exception ("Argument must be a polygon with 3 points");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  	throw new System.Exception ("Argument must be a polygon with 3 points");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	int jStop = IncrementModula (j' 3);  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = triangleA.Points [i].X - pIntersect.X;  		double vay = triangleA.Points [i].Y - pIntersect.Y;  		double vbx = triangleB.Points [j].X - pIntersect.X;  		double vby = triangleB.Points [j].Y - pIntersect.Y;  		// The sideOf tells if the vb vector or the va vector is the one pointing "left"  		// If sideOf is positive' vb is pointing left' otherwise va is pointing left  		// The "left" vector is the one that is inside the polygon.  		double sideOf = vax * vby - vay * vbx;  		// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  		if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleB  		// TODO: Replace with IsPointOnEdge of triangleB  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleA  		// Should never happen' since above test basically does the same  		// TODO: Replace with IsPointOnEdge of triangleA  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new System.Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	int jStop = IncrementModula (j' 3);  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = triangleA.Points [i].X - pIntersect.X;  		double vay = triangleA.Points [i].Y - pIntersect.Y;  		double vbx = triangleB.Points [j].X - pIntersect.X;  		double vby = triangleB.Points [j].Y - pIntersect.Y;  		// The sideOf tells if the vb vector or the va vector is the one pointing "left"  		// If sideOf is positive' vb is pointing left' otherwise va is pointing left  		// The "left" vector is the one that is inside the polygon.  		double sideOf = vax * vby - vay * vbx;  		// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  		if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleB  		// TODO: Replace with IsPointOnEdge of triangleB  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleA  		// Should never happen' since above test basically does the same  		// TODO: Replace with IsPointOnEdge of triangleA  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new System.Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	int jStop = IncrementModula (j' 3);  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = triangleA.Points [i].X - pIntersect.X;  		double vay = triangleA.Points [i].Y - pIntersect.Y;  		double vbx = triangleB.Points [j].X - pIntersect.X;  		double vby = triangleB.Points [j].Y - pIntersect.Y;  		// The sideOf tells if the vb vector or the va vector is the one pointing "left"  		// If sideOf is positive' vb is pointing left' otherwise va is pointing left  		// The "left" vector is the one that is inside the polygon.  		double sideOf = vax * vby - vay * vbx;  		// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  		if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleB  		// TODO: Replace with IsPointOnEdge of triangleB  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleA  		// Should never happen' since above test basically does the same  		// TODO: Replace with IsPointOnEdge of triangleA  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new System.Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	int jStop = IncrementModula (j' 3);  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = triangleA.Points [i].X - pIntersect.X;  		double vay = triangleA.Points [i].Y - pIntersect.Y;  		double vbx = triangleB.Points [j].X - pIntersect.X;  		double vby = triangleB.Points [j].Y - pIntersect.Y;  		// The sideOf tells if the vb vector or the va vector is the one pointing "left"  		// If sideOf is positive' vb is pointing left' otherwise va is pointing left  		// The "left" vector is the one that is inside the polygon.  		double sideOf = vax * vby - vay * vbx;  		// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  		if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleB  		// TODO: Replace with IsPointOnEdge of triangleB  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleA  		// Should never happen' since above test basically does the same  		// TODO: Replace with IsPointOnEdge of triangleA  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new System.Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	int jStop = IncrementModula (j' 3);  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = triangleA.Points [i].X - pIntersect.X;  		double vay = triangleA.Points [i].Y - pIntersect.Y;  		double vbx = triangleB.Points [j].X - pIntersect.X;  		double vby = triangleB.Points [j].Y - pIntersect.Y;  		// The sideOf tells if the vb vector or the va vector is the one pointing "left"  		// If sideOf is positive' vb is pointing left' otherwise va is pointing left  		// The "left" vector is the one that is inside the polygon.  		double sideOf = vax * vby - vay * vbx;  		// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  		if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleB  		// TODO: Replace with IsPointOnEdge of triangleB  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleA  		// Should never happen' since above test basically does the same  		// TODO: Replace with IsPointOnEdge of triangleA  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new System.Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	int jStop = IncrementModula (j' 3);  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = triangleA.Points [i].X - pIntersect.X;  		double vay = triangleA.Points [i].Y - pIntersect.Y;  		double vbx = triangleB.Points [j].X - pIntersect.X;  		double vby = triangleB.Points [j].Y - pIntersect.Y;  		// The sideOf tells if the vb vector or the va vector is the one pointing "left"  		// If sideOf is positive' vb is pointing left' otherwise va is pointing left  		// The "left" vector is the one that is inside the polygon.  		double sideOf = vax * vby - vay * vbx;  		// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  		if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleB  		// TODO: Replace with IsPointOnEdge of triangleB  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleA  		// Should never happen' since above test basically does the same  		// TODO: Replace with IsPointOnEdge of triangleA  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new System.Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	int jStop = IncrementModula (j' 3);  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = triangleA.Points [i].X - pIntersect.X;  		double vay = triangleA.Points [i].Y - pIntersect.Y;  		double vbx = triangleB.Points [j].X - pIntersect.X;  		double vby = triangleB.Points [j].Y - pIntersect.Y;  		// The sideOf tells if the vb vector or the va vector is the one pointing "left"  		// If sideOf is positive' vb is pointing left' otherwise va is pointing left  		// The "left" vector is the one that is inside the polygon.  		double sideOf = vax * vby - vay * vbx;  		// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  		if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleB  		// TODO: Replace with IsPointOnEdge of triangleB  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleA  		// Should never happen' since above test basically does the same  		// TODO: Replace with IsPointOnEdge of triangleA  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new System.Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	int jStop = IncrementModula (j' 3);  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = triangleA.Points [i].X - pIntersect.X;  		double vay = triangleA.Points [i].Y - pIntersect.Y;  		double vbx = triangleB.Points [j].X - pIntersect.X;  		double vby = triangleB.Points [j].Y - pIntersect.Y;  		// The sideOf tells if the vb vector or the va vector is the one pointing "left"  		// If sideOf is positive' vb is pointing left' otherwise va is pointing left  		// The "left" vector is the one that is inside the polygon.  		double sideOf = vax * vby - vay * vbx;  		// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  		if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleB  		// TODO: Replace with IsPointOnEdge of triangleB  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleA  		// Should never happen' since above test basically does the same  		// TODO: Replace with IsPointOnEdge of triangleA  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new System.Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	int jStop = IncrementModula (j' 3);  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = triangleA.Points [i].X - pIntersect.X;  		double vay = triangleA.Points [i].Y - pIntersect.Y;  		double vbx = triangleB.Points [j].X - pIntersect.X;  		double vby = triangleB.Points [j].Y - pIntersect.Y;  		// The sideOf tells if the vb vector or the va vector is the one pointing "left"  		// If sideOf is positive' vb is pointing left' otherwise va is pointing left  		// The "left" vector is the one that is inside the polygon.  		double sideOf = vax * vby - vay * vbx;  		// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  		if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleB  		// TODO: Replace with IsPointOnEdge of triangleB  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleA  		// Should never happen' since above test basically does the same  		// TODO: Replace with IsPointOnEdge of triangleA  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new System.Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	int jStop = IncrementModula (j' 3);  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = triangleA.Points [i].X - pIntersect.X;  		double vay = triangleA.Points [i].Y - pIntersect.Y;  		double vbx = triangleB.Points [j].X - pIntersect.X;  		double vby = triangleB.Points [j].Y - pIntersect.Y;  		// The sideOf tells if the vb vector or the va vector is the one pointing "left"  		// If sideOf is positive' vb is pointing left' otherwise va is pointing left  		// The "left" vector is the one that is inside the polygon.  		double sideOf = vax * vby - vay * vbx;  		// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  		if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleB  		// TODO: Replace with IsPointOnEdge of triangleB  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleA  		// Should never happen' since above test basically does the same  		// TODO: Replace with IsPointOnEdge of triangleA  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new System.Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	int jStop = IncrementModula (j' 3);  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = triangleA.Points [i].X - pIntersect.X;  		double vay = triangleA.Points [i].Y - pIntersect.Y;  		double vbx = triangleB.Points [j].X - pIntersect.X;  		double vby = triangleB.Points [j].Y - pIntersect.Y;  		// The sideOf tells if the vb vector or the va vector is the one pointing "left"  		// If sideOf is positive' vb is pointing left' otherwise va is pointing left  		// The "left" vector is the one that is inside the polygon.  		double sideOf = vax * vby - vay * vbx;  		// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  		if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleB  		// TODO: Replace with IsPointOnEdge of triangleB  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleA  		// Should never happen' since above test basically does the same  		// TODO: Replace with IsPointOnEdge of triangleA  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new System.Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	int jStop = IncrementModula (j' 3);  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = triangleA.Points [i].X - pIntersect.X;  		double vay = triangleA.Points [i].Y - pIntersect.Y;  		double vbx = triangleB.Points [j].X - pIntersect.X;  		double vby = triangleB.Points [j].Y - pIntersect.Y;  		// The sideOf tells if the vb vector or the va vector is the one pointing "left"  		// If sideOf is positive' vb is pointing left' otherwise va is pointing left  		// The "left" vector is the one that is inside the polygon.  		double sideOf = vax * vby - vay * vbx;  		// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  		if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleB  		// TODO: Replace with IsPointOnEdge of triangleB  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleA  		// Should never happen' since above test basically does the same  		// TODO: Replace with IsPointOnEdge of triangleA  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new System.Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	int jStop = IncrementModula (j' 3);  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = triangleA.Points [i].X - pIntersect.X;  		double vay = triangleA.Points [i].Y - pIntersect.Y;  		double vbx = triangleB.Points [j].X - pIntersect.X;  		double vby = triangleB.Points [j].Y - pIntersect.Y;  		// The sideOf tells if the vb vector or the va vector is the one pointing "left"  		// If sideOf is positive' vb is pointing left' otherwise va is pointing left  		// The "left" vector is the one that is inside the polygon.  		double sideOf = vax * vby - vay * vbx;  		// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  		if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleB  		// TODO: Replace with IsPointOnEdge of triangleB  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleA  		// Should never happen' since above test basically does the same  		// TODO: Replace with IsPointOnEdge of triangleA  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new System.Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	int jStop = IncrementModula (j' 3);  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = triangleA.Points [i].X - pIntersect.X;  		double vay = triangleA.Points [i].Y - pIntersect.Y;  		double vbx = triangleB.Points [j].X - pIntersect.X;  		double vby = triangleB.Points [j].Y - pIntersect.Y;  		// The sideOf tells if the vb vector or the va vector is the one pointing "left"  		// If sideOf is positive' vb is pointing left' otherwise va is pointing left  		// The "left" vector is the one that is inside the polygon.  		double sideOf = vax * vby - vay * vbx;  		// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  		if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleB  		// TODO: Replace with IsPointOnEdge of triangleB  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleA  		// Should never happen' since above test basically does the same  		// TODO: Replace with IsPointOnEdge of triangleA  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new System.Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	int jStop = IncrementModula (j' 3);  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = triangleA.Points [i].X - pIntersect.X;  		double vay = triangleA.Points [i].Y - pIntersect.Y;  		double vbx = triangleB.Points [j].X - pIntersect.X;  		double vby = triangleB.Points [j].Y - pIntersect.Y;  		// The sideOf tells if the vb vector or the va vector is the one pointing "left"  		// If sideOf is positive' vb is pointing left' otherwise va is pointing left  		// The "left" vector is the one that is inside the polygon.  		double sideOf = vax * vby - vay * vbx;  		// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  		if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleB  		// TODO: Replace with IsPointOnEdge of triangleB  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleA  		// Should never happen' since above test basically does the same  		// TODO: Replace with IsPointOnEdge of triangleA  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new System.Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	int jStop = IncrementModula (j' 3);  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = triangleA.Points [i].X - pIntersect.X;  		double vay = triangleA.Points [i].Y - pIntersect.Y;  		double vbx = triangleB.Points [j].X - pIntersect.X;  		double vby = triangleB.Points [j].Y - pIntersect.Y;  		// The sideOf tells if the vb vector or the va vector is the one pointing "left"  		// If sideOf is positive' vb is pointing left' otherwise va is pointing left  		// The "left" vector is the one that is inside the polygon.  		double sideOf = vax * vby - vay * vbx;  		// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  		if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleB  		// TODO: Replace with IsPointOnEdge of triangleB  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleA  		// Should never happen' since above test basically does the same  		// TODO: Replace with IsPointOnEdge of triangleA  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new System.Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	int jStop = IncrementModula (j' 3);  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = triangleA.Points [i].X - pIntersect.X;  		double vay = triangleA.Points [i].Y - pIntersect.Y;  		double vbx = triangleB.Points [j].X - pIntersect.X;  		double vby = triangleB.Points [j].Y - pIntersect.Y;  		// The sideOf tells if the vb vector or the va vector is the one pointing "left"  		// If sideOf is positive' vb is pointing left' otherwise va is pointing left  		// The "left" vector is the one that is inside the polygon.  		double sideOf = vax * vby - vay * vbx;  		// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  		if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleB  		// TODO: Replace with IsPointOnEdge of triangleB  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleA  		// Should never happen' since above test basically does the same  		// TODO: Replace with IsPointOnEdge of triangleA  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new System.Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	int jStop = IncrementModula (j' 3);  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = triangleA.Points [i].X - pIntersect.X;  		double vay = triangleA.Points [i].Y - pIntersect.Y;  		double vbx = triangleB.Points [j].X - pIntersect.X;  		double vby = triangleB.Points [j].Y - pIntersect.Y;  		// The sideOf tells if the vb vector or the va vector is the one pointing "left"  		// If sideOf is positive' vb is pointing left' otherwise va is pointing left  		// The "left" vector is the one that is inside the polygon.  		double sideOf = vax * vby - vay * vbx;  		// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  		if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleB  		// TODO: Replace with IsPointOnEdge of triangleB  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  		}  		// can be true if the point is on the edge of the triangleA  		// Should never happen' since above test basically does the same  		// TODO: Replace with IsPointOnEdge of triangleA  		else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new System.Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: while (!complete) {  	// coordinates for vectors pointing to next triangleA and triangleB point respectively  	double vax = triangleA.Points [i].X - pIntersect.X;  	double vay = triangleA.Points [i].Y - pIntersect.Y;  	double vbx = triangleB.Points [j].X - pIntersect.X;  	double vby = triangleB.Points [j].Y - pIntersect.Y;  	// The sideOf tells if the vb vector or the va vector is the one pointing "left"  	// If sideOf is positive' vb is pointing left' otherwise va is pointing left  	// The "left" vector is the one that is inside the polygon.  	double sideOf = vax * vby - vay * vbx;  	// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  	if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  		Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	}  	else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  		Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  	}  	// can be true if the point is on the edge of the triangleB  	// TODO: Replace with IsPointOnEdge of triangleB  	else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  		Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	}  	// can be true if the point is on the edge of the triangleA  	// Should never happen' since above test basically does the same  	// TODO: Replace with IsPointOnEdge of triangleA  	else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  		Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  	}  	else// triangleA and triangleB only touches one another but do not intersect  	 {  		area = 0;  		return area;  	}  	if (intersectionPolygon.Points.Count > 1) {  		complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  	}  	count++;  	if (count > 20) {  		throw new System.Exception ("Failed to find intersection polygon");  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: while (!complete) {  	// coordinates for vectors pointing to next triangleA and triangleB point respectively  	double vax = triangleA.Points [i].X - pIntersect.X;  	double vay = triangleA.Points [i].Y - pIntersect.Y;  	double vbx = triangleB.Points [j].X - pIntersect.X;  	double vby = triangleB.Points [j].Y - pIntersect.Y;  	// The sideOf tells if the vb vector or the va vector is the one pointing "left"  	// If sideOf is positive' vb is pointing left' otherwise va is pointing left  	// The "left" vector is the one that is inside the polygon.  	double sideOf = vax * vby - vay * vbx;  	// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  	if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  		Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	}  	else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  		Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  	}  	// can be true if the point is on the edge of the triangleB  	// TODO: Replace with IsPointOnEdge of triangleB  	else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  		Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	}  	// can be true if the point is on the edge of the triangleA  	// Should never happen' since above test basically does the same  	// TODO: Replace with IsPointOnEdge of triangleA  	else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  		Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  	}  	else// triangleA and triangleB only touches one another but do not intersect  	 {  		area = 0;  		return area;  	}  	if (intersectionPolygon.Points.Count > 1) {  		complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  	}  	count++;  	if (count > 20) {  		throw new System.Exception ("Failed to find intersection polygon");  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: while (!complete) {  	// coordinates for vectors pointing to next triangleA and triangleB point respectively  	double vax = triangleA.Points [i].X - pIntersect.X;  	double vay = triangleA.Points [i].Y - pIntersect.Y;  	double vbx = triangleB.Points [j].X - pIntersect.X;  	double vby = triangleB.Points [j].Y - pIntersect.Y;  	// The sideOf tells if the vb vector or the va vector is the one pointing "left"  	// If sideOf is positive' vb is pointing left' otherwise va is pointing left  	// The "left" vector is the one that is inside the polygon.  	double sideOf = vax * vby - vay * vbx;  	// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  	if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  		Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	}  	else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  		Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  	}  	// can be true if the point is on the edge of the triangleB  	// TODO: Replace with IsPointOnEdge of triangleB  	else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  		Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	}  	// can be true if the point is on the edge of the triangleA  	// Should never happen' since above test basically does the same  	// TODO: Replace with IsPointOnEdge of triangleA  	else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  		Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  	}  	else// triangleA and triangleB only touches one another but do not intersect  	 {  		area = 0;  		return area;  	}  	if (intersectionPolygon.Points.Count > 1) {  		complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  	}  	count++;  	if (count > 20) {  		throw new System.Exception ("Failed to find intersection polygon");  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: while (!complete) {  	// coordinates for vectors pointing to next triangleA and triangleB point respectively  	double vax = triangleA.Points [i].X - pIntersect.X;  	double vay = triangleA.Points [i].Y - pIntersect.Y;  	double vbx = triangleB.Points [j].X - pIntersect.X;  	double vby = triangleB.Points [j].Y - pIntersect.Y;  	// The sideOf tells if the vb vector or the va vector is the one pointing "left"  	// If sideOf is positive' vb is pointing left' otherwise va is pointing left  	// The "left" vector is the one that is inside the polygon.  	double sideOf = vax * vby - vay * vbx;  	// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  	if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  		Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	}  	else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  		Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  	}  	// can be true if the point is on the edge of the triangleB  	// TODO: Replace with IsPointOnEdge of triangleB  	else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  		Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	}  	// can be true if the point is on the edge of the triangleA  	// Should never happen' since above test basically does the same  	// TODO: Replace with IsPointOnEdge of triangleA  	else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  		Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  	}  	else// triangleA and triangleB only touches one another but do not intersect  	 {  		area = 0;  		return area;  	}  	if (intersectionPolygon.Points.Count > 1) {  		complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  	}  	count++;  	if (count > 20) {  		throw new System.Exception ("Failed to find intersection polygon");  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: while (!complete) {  	// coordinates for vectors pointing to next triangleA and triangleB point respectively  	double vax = triangleA.Points [i].X - pIntersect.X;  	double vay = triangleA.Points [i].Y - pIntersect.Y;  	double vbx = triangleB.Points [j].X - pIntersect.X;  	double vby = triangleB.Points [j].Y - pIntersect.Y;  	// The sideOf tells if the vb vector or the va vector is the one pointing "left"  	// If sideOf is positive' vb is pointing left' otherwise va is pointing left  	// The "left" vector is the one that is inside the polygon.  	double sideOf = vax * vby - vay * vbx;  	// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  	if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  		Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	}  	else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  		Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  	}  	// can be true if the point is on the edge of the triangleB  	// TODO: Replace with IsPointOnEdge of triangleB  	else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  		Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	}  	// can be true if the point is on the edge of the triangleA  	// Should never happen' since above test basically does the same  	// TODO: Replace with IsPointOnEdge of triangleA  	else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  		Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  	}  	else// triangleA and triangleB only touches one another but do not intersect  	 {  		area = 0;  		return area;  	}  	if (intersectionPolygon.Points.Count > 1) {  		complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  	}  	count++;  	if (count > 20) {  		throw new System.Exception ("Failed to find intersection polygon");  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: while (!complete) {  	// coordinates for vectors pointing to next triangleA and triangleB point respectively  	double vax = triangleA.Points [i].X - pIntersect.X;  	double vay = triangleA.Points [i].Y - pIntersect.Y;  	double vbx = triangleB.Points [j].X - pIntersect.X;  	double vby = triangleB.Points [j].Y - pIntersect.Y;  	// The sideOf tells if the vb vector or the va vector is the one pointing "left"  	// If sideOf is positive' vb is pointing left' otherwise va is pointing left  	// The "left" vector is the one that is inside the polygon.  	double sideOf = vax * vby - vay * vbx;  	// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  	if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  		Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	}  	else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  		Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  	}  	// can be true if the point is on the edge of the triangleB  	// TODO: Replace with IsPointOnEdge of triangleB  	else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  		Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	}  	// can be true if the point is on the edge of the triangleA  	// Should never happen' since above test basically does the same  	// TODO: Replace with IsPointOnEdge of triangleA  	else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  		Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  	}  	else// triangleA and triangleB only touches one another but do not intersect  	 {  		area = 0;  		return area;  	}  	if (intersectionPolygon.Points.Count > 1) {  		complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  	}  	count++;  	if (count > 20) {  		throw new System.Exception ("Failed to find intersection polygon");  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: while (!complete) {  	// coordinates for vectors pointing to next triangleA and triangleB point respectively  	double vax = triangleA.Points [i].X - pIntersect.X;  	double vay = triangleA.Points [i].Y - pIntersect.Y;  	double vbx = triangleB.Points [j].X - pIntersect.X;  	double vby = triangleB.Points [j].Y - pIntersect.Y;  	// The sideOf tells if the vb vector or the va vector is the one pointing "left"  	// If sideOf is positive' vb is pointing left' otherwise va is pointing left  	// The "left" vector is the one that is inside the polygon.  	double sideOf = vax * vby - vay * vbx;  	// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  	if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  		Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	}  	else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  		Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  	}  	// can be true if the point is on the edge of the triangleB  	// TODO: Replace with IsPointOnEdge of triangleB  	else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  		Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	}  	// can be true if the point is on the edge of the triangleA  	// Should never happen' since above test basically does the same  	// TODO: Replace with IsPointOnEdge of triangleA  	else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  		Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  	}  	else// triangleA and triangleB only touches one another but do not intersect  	 {  		area = 0;  		return area;  	}  	if (intersectionPolygon.Points.Count > 1) {  		complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  	}  	count++;  	if (count > 20) {  		throw new System.Exception ("Failed to find intersection polygon");  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: while (!complete) {  	// coordinates for vectors pointing to next triangleA and triangleB point respectively  	double vax = triangleA.Points [i].X - pIntersect.X;  	double vay = triangleA.Points [i].Y - pIntersect.Y;  	double vbx = triangleB.Points [j].X - pIntersect.X;  	double vby = triangleB.Points [j].Y - pIntersect.Y;  	// The sideOf tells if the vb vector or the va vector is the one pointing "left"  	// If sideOf is positive' vb is pointing left' otherwise va is pointing left  	// The "left" vector is the one that is inside the polygon.  	double sideOf = vax * vby - vay * vbx;  	// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  	if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  		Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	}  	else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  		Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  	}  	// can be true if the point is on the edge of the triangleB  	// TODO: Replace with IsPointOnEdge of triangleB  	else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  		Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	}  	// can be true if the point is on the edge of the triangleA  	// Should never happen' since above test basically does the same  	// TODO: Replace with IsPointOnEdge of triangleA  	else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  		Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  	}  	else// triangleA and triangleB only touches one another but do not intersect  	 {  		area = 0;  		return area;  	}  	if (intersectionPolygon.Points.Count > 1) {  		complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  	}  	count++;  	if (count > 20) {  		throw new System.Exception ("Failed to find intersection polygon");  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: while (!complete) {  	// coordinates for vectors pointing to next triangleA and triangleB point respectively  	double vax = triangleA.Points [i].X - pIntersect.X;  	double vay = triangleA.Points [i].Y - pIntersect.Y;  	double vbx = triangleB.Points [j].X - pIntersect.X;  	double vby = triangleB.Points [j].Y - pIntersect.Y;  	// The sideOf tells if the vb vector or the va vector is the one pointing "left"  	// If sideOf is positive' vb is pointing left' otherwise va is pointing left  	// The "left" vector is the one that is inside the polygon.  	double sideOf = vax * vby - vay * vbx;  	// Make sure to get out of EPSILON reach from the original point' hence 2*EPSILON  	if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  		Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	}  	else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  		Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  	}  	// can be true if the point is on the edge of the triangleB  	// TODO: Replace with IsPointOnEdge of triangleB  	else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  		Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  	}  	// can be true if the point is on the edge of the triangleA  	// Should never happen' since above test basically does the same  	// TODO: Replace with IsPointOnEdge of triangleA  	else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  		Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  	}  	else// triangleA and triangleB only touches one another but do not intersect  	 {  		area = 0;  		return area;  	}  	if (intersectionPolygon.Points.Count > 1) {  		complete = (CalculatePointToPointDistance (pIntersect' pFirst) < EPSILON);  	}  	count++;  	if (count > 20) {  		throw new System.Exception ("Failed to find intersection polygon");  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleB  // TODO: Replace with IsPointOnEdge of triangleB  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleA  // Should never happen' since above test basically does the same  // TODO: Replace with IsPointOnEdge of triangleA  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  else// triangleA and triangleB only touches one another but do not intersect   {  	area = 0;  	return area;  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleB  // TODO: Replace with IsPointOnEdge of triangleB  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleA  // Should never happen' since above test basically does the same  // TODO: Replace with IsPointOnEdge of triangleA  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  else// triangleA and triangleB only touches one another but do not intersect   {  	area = 0;  	return area;  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleB  // TODO: Replace with IsPointOnEdge of triangleB  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleA  // Should never happen' since above test basically does the same  // TODO: Replace with IsPointOnEdge of triangleA  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  else// triangleA and triangleB only touches one another but do not intersect   {  	area = 0;  	return area;  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleB  // TODO: Replace with IsPointOnEdge of triangleB  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleA  // Should never happen' since above test basically does the same  // TODO: Replace with IsPointOnEdge of triangleA  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  else// triangleA and triangleB only touches one another but do not intersect   {  	area = 0;  	return area;  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleB  // TODO: Replace with IsPointOnEdge of triangleB  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleA  // Should never happen' since above test basically does the same  // TODO: Replace with IsPointOnEdge of triangleA  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  else// triangleA and triangleB only touches one another but do not intersect   {  	area = 0;  	return area;  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleB  // TODO: Replace with IsPointOnEdge of triangleB  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleA  // Should never happen' since above test basically does the same  // TODO: Replace with IsPointOnEdge of triangleA  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  else// triangleA and triangleB only touches one another but do not intersect   {  	area = 0;  	return area;  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleB  // TODO: Replace with IsPointOnEdge of triangleB  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleA  // Should never happen' since above test basically does the same  // TODO: Replace with IsPointOnEdge of triangleA  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  else// triangleA and triangleB only touches one another but do not intersect   {  	area = 0;  	return area;  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (sideOf < 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  else if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleB  // TODO: Replace with IsPointOnEdge of triangleB  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleA  // Should never happen' since above test basically does the same  // TODO: Replace with IsPointOnEdge of triangleA  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  else// triangleA and triangleB only touches one another but do not intersect   {  	area = 0;  	return area;  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleB  // TODO: Replace with IsPointOnEdge of triangleB  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleA  // Should never happen' since above test basically does the same  // TODO: Replace with IsPointOnEdge of triangleA  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  else// triangleA and triangleB only touches one another but do not intersect   {  	area = 0;  	return area;  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleB  // TODO: Replace with IsPointOnEdge of triangleB  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleA  // Should never happen' since above test basically does the same  // TODO: Replace with IsPointOnEdge of triangleA  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  else// triangleA and triangleB only touches one another but do not intersect   {  	area = 0;  	return area;  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleB  // TODO: Replace with IsPointOnEdge of triangleB  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleA  // Should never happen' since above test basically does the same  // TODO: Replace with IsPointOnEdge of triangleA  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  else// triangleA and triangleB only touches one another but do not intersect   {  	area = 0;  	return area;  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleB  // TODO: Replace with IsPointOnEdge of triangleB  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleA  // Should never happen' since above test basically does the same  // TODO: Replace with IsPointOnEdge of triangleA  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  else// triangleA and triangleB only touches one another but do not intersect   {  	area = 0;  	return area;  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleB  // TODO: Replace with IsPointOnEdge of triangleB  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleA  // Should never happen' since above test basically does the same  // TODO: Replace with IsPointOnEdge of triangleA  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  else// triangleA and triangleB only touches one another but do not intersect   {  	area = 0;  	return area;  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (sideOf > 0 && IsPointInPolygon (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleB  // TODO: Replace with IsPointOnEdge of triangleB  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleA  // Should never happen' since above test basically does the same  // TODO: Replace with IsPointOnEdge of triangleA  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  else// triangleA and triangleB only touches one another but do not intersect   {  	area = 0;  	return area;  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleA  // Should never happen' since above test basically does the same  // TODO: Replace with IsPointOnEdge of triangleA  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  else// triangleA and triangleB only touches one another but do not intersect   {  	area = 0;  	return area;  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleA  // Should never happen' since above test basically does the same  // TODO: Replace with IsPointOnEdge of triangleA  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  else// triangleA and triangleB only touches one another but do not intersect   {  	area = 0;  	return area;  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleA  // Should never happen' since above test basically does the same  // TODO: Replace with IsPointOnEdge of triangleA  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  else// triangleA and triangleB only touches one another but do not intersect   {  	area = 0;  	return area;  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vax' pIntersect.Y + 2 * EPSILON * vay' triangleB)) {  	Intersect (triangleA' triangleB' ref pIntersect' ref i' ref j' ref intersectionPolygon);  }  // can be true if the point is on the edge of the triangleA  // Should never happen' since above test basically does the same  // TODO: Replace with IsPointOnEdge of triangleA  else if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  else// triangleA and triangleB only touches one another but do not intersect   {  	area = 0;  	return area;  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  else// triangleA and triangleB only touches one another but do not intersect   {  	area = 0;  	return area;  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (IsPointInPolygonOrOnEdge (pIntersect.X + 2 * EPSILON * vbx' pIntersect.Y + 2 * EPSILON * vby' triangleA)) {  	Intersect (triangleB' triangleA' ref pIntersect' ref j' ref i' ref intersectionPolygon);  }  else// triangleA and triangleB only touches one another but do not intersect   {  	area = 0;  	return area;  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (count > 20) {  	throw new System.Exception ("Failed to find intersection polygon");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: while ((count1 < 3) && (!found)) {  	lineA = triangleA.GetLine (im1);  	if (count1 == 0) {  		lineA = new XYLine (lineA);  		lineA.P1.X = p.X;  		lineA.P1.Y = p.Y;  	}  	double MinDist = -1;  	// Distance used when a line is crossed more than once  	int jm1 = 0;  	// "j-1"  	int jm1Store = -1;  	while (jm1 < 3) {  		lineB = triangleB.GetLine (jm1);  		found = IntersectionPoint (lineA' lineB' ref p);  		double Dist = CalculatePointToPointDistance (lineA.P1' p);  		if (Dist < EPSILON) {  			found = false;  		}  		if (found) {  			if ((MinDist < 0) || (Dist < MinDist)) {  				MinDist = Dist;  				jm1Store = jm1;  			}  		}  		jm1++;  	}  	if (jm1Store > -1) {  		lineB = triangleB.GetLine (jm1Store);  		found = IntersectionPoint (lineA' lineB' ref p);  		XYPoint HelpCoordinate = new XYPoint (p.X' p.Y);  		XYPoint HelpNode = new XYPoint (HelpCoordinate);  		intersectionPolygon.Points.Add (HelpNode);  		j = IncrementModula (jm1Store' 3);  	}  	if (!found) {  		count1++;  		im1 = IncrementModula (im1' 3);  		i = IncrementModula (i' 3);  		if (j != -1) {  			XYPoint HelpCoordinate = new XYPoint (lineA.P2.X' lineA.P2.Y);  			XYPoint HelpNode = new XYPoint (HelpCoordinate);  			intersectionPolygon.Points.Add (HelpNode);  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: while ((count1 < 3) && (!found)) {  	lineA = triangleA.GetLine (im1);  	if (count1 == 0) {  		lineA = new XYLine (lineA);  		lineA.P1.X = p.X;  		lineA.P1.Y = p.Y;  	}  	double MinDist = -1;  	// Distance used when a line is crossed more than once  	int jm1 = 0;  	// "j-1"  	int jm1Store = -1;  	while (jm1 < 3) {  		lineB = triangleB.GetLine (jm1);  		found = IntersectionPoint (lineA' lineB' ref p);  		double Dist = CalculatePointToPointDistance (lineA.P1' p);  		if (Dist < EPSILON) {  			found = false;  		}  		if (found) {  			if ((MinDist < 0) || (Dist < MinDist)) {  				MinDist = Dist;  				jm1Store = jm1;  			}  		}  		jm1++;  	}  	if (jm1Store > -1) {  		lineB = triangleB.GetLine (jm1Store);  		found = IntersectionPoint (lineA' lineB' ref p);  		XYPoint HelpCoordinate = new XYPoint (p.X' p.Y);  		XYPoint HelpNode = new XYPoint (HelpCoordinate);  		intersectionPolygon.Points.Add (HelpNode);  		j = IncrementModula (jm1Store' 3);  	}  	if (!found) {  		count1++;  		im1 = IncrementModula (im1' 3);  		i = IncrementModula (i' 3);  		if (j != -1) {  			XYPoint HelpCoordinate = new XYPoint (lineA.P2.X' lineA.P2.Y);  			XYPoint HelpNode = new XYPoint (HelpCoordinate);  			intersectionPolygon.Points.Add (HelpNode);  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: while ((count1 < 3) && (!found)) {  	lineA = triangleA.GetLine (im1);  	if (count1 == 0) {  		lineA = new XYLine (lineA);  		lineA.P1.X = p.X;  		lineA.P1.Y = p.Y;  	}  	double MinDist = -1;  	// Distance used when a line is crossed more than once  	int jm1 = 0;  	// "j-1"  	int jm1Store = -1;  	while (jm1 < 3) {  		lineB = triangleB.GetLine (jm1);  		found = IntersectionPoint (lineA' lineB' ref p);  		double Dist = CalculatePointToPointDistance (lineA.P1' p);  		if (Dist < EPSILON) {  			found = false;  		}  		if (found) {  			if ((MinDist < 0) || (Dist < MinDist)) {  				MinDist = Dist;  				jm1Store = jm1;  			}  		}  		jm1++;  	}  	if (jm1Store > -1) {  		lineB = triangleB.GetLine (jm1Store);  		found = IntersectionPoint (lineA' lineB' ref p);  		XYPoint HelpCoordinate = new XYPoint (p.X' p.Y);  		XYPoint HelpNode = new XYPoint (HelpCoordinate);  		intersectionPolygon.Points.Add (HelpNode);  		j = IncrementModula (jm1Store' 3);  	}  	if (!found) {  		count1++;  		im1 = IncrementModula (im1' 3);  		i = IncrementModula (i' 3);  		if (j != -1) {  			XYPoint HelpCoordinate = new XYPoint (lineA.P2.X' lineA.P2.Y);  			XYPoint HelpNode = new XYPoint (HelpCoordinate);  			intersectionPolygon.Points.Add (HelpNode);  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: while ((count1 < 3) && (!found)) {  	lineA = triangleA.GetLine (im1);  	if (count1 == 0) {  		lineA = new XYLine (lineA);  		lineA.P1.X = p.X;  		lineA.P1.Y = p.Y;  	}  	double MinDist = -1;  	// Distance used when a line is crossed more than once  	int jm1 = 0;  	// "j-1"  	int jm1Store = -1;  	while (jm1 < 3) {  		lineB = triangleB.GetLine (jm1);  		found = IntersectionPoint (lineA' lineB' ref p);  		double Dist = CalculatePointToPointDistance (lineA.P1' p);  		if (Dist < EPSILON) {  			found = false;  		}  		if (found) {  			if ((MinDist < 0) || (Dist < MinDist)) {  				MinDist = Dist;  				jm1Store = jm1;  			}  		}  		jm1++;  	}  	if (jm1Store > -1) {  		lineB = triangleB.GetLine (jm1Store);  		found = IntersectionPoint (lineA' lineB' ref p);  		XYPoint HelpCoordinate = new XYPoint (p.X' p.Y);  		XYPoint HelpNode = new XYPoint (HelpCoordinate);  		intersectionPolygon.Points.Add (HelpNode);  		j = IncrementModula (jm1Store' 3);  	}  	if (!found) {  		count1++;  		im1 = IncrementModula (im1' 3);  		i = IncrementModula (i' 3);  		if (j != -1) {  			XYPoint HelpCoordinate = new XYPoint (lineA.P2.X' lineA.P2.Y);  			XYPoint HelpNode = new XYPoint (HelpCoordinate);  			intersectionPolygon.Points.Add (HelpNode);  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: while ((count1 < 3) && (!found)) {  	lineA = triangleA.GetLine (im1);  	if (count1 == 0) {  		lineA = new XYLine (lineA);  		lineA.P1.X = p.X;  		lineA.P1.Y = p.Y;  	}  	double MinDist = -1;  	// Distance used when a line is crossed more than once  	int jm1 = 0;  	// "j-1"  	int jm1Store = -1;  	while (jm1 < 3) {  		lineB = triangleB.GetLine (jm1);  		found = IntersectionPoint (lineA' lineB' ref p);  		double Dist = CalculatePointToPointDistance (lineA.P1' p);  		if (Dist < EPSILON) {  			found = false;  		}  		if (found) {  			if ((MinDist < 0) || (Dist < MinDist)) {  				MinDist = Dist;  				jm1Store = jm1;  			}  		}  		jm1++;  	}  	if (jm1Store > -1) {  		lineB = triangleB.GetLine (jm1Store);  		found = IntersectionPoint (lineA' lineB' ref p);  		XYPoint HelpCoordinate = new XYPoint (p.X' p.Y);  		XYPoint HelpNode = new XYPoint (HelpCoordinate);  		intersectionPolygon.Points.Add (HelpNode);  		j = IncrementModula (jm1Store' 3);  	}  	if (!found) {  		count1++;  		im1 = IncrementModula (im1' 3);  		i = IncrementModula (i' 3);  		if (j != -1) {  			XYPoint HelpCoordinate = new XYPoint (lineA.P2.X' lineA.P2.Y);  			XYPoint HelpNode = new XYPoint (HelpCoordinate);  			intersectionPolygon.Points.Add (HelpNode);  		}  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: while (jm1 < 3) {  	lineB = triangleB.GetLine (jm1);  	found = IntersectionPoint (lineA' lineB' ref p);  	double Dist = CalculatePointToPointDistance (lineA.P1' p);  	if (Dist < EPSILON) {  		found = false;  	}  	if (found) {  		if ((MinDist < 0) || (Dist < MinDist)) {  			MinDist = Dist;  			jm1Store = jm1;  		}  	}  	jm1++;  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: if (jm1Store > -1) {  	lineB = triangleB.GetLine (jm1Store);  	found = IntersectionPoint (lineA' lineB' ref p);  	XYPoint HelpCoordinate = new XYPoint (p.X' p.Y);  	XYPoint HelpNode = new XYPoint (HelpCoordinate);  	intersectionPolygon.Points.Add (HelpNode);  	j = IncrementModula (jm1Store' 3);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: j = IncrementModula (jm1Store' 3);  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: if (!found) {  	count1++;  	im1 = IncrementModula (im1' 3);  	i = IncrementModula (i' 3);  	if (j != -1) {  		XYPoint HelpCoordinate = new XYPoint (lineA.P2.X' lineA.P2.Y);  		XYPoint HelpNode = new XYPoint (HelpCoordinate);  		intersectionPolygon.Points.Add (HelpNode);  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: if (!found) {  	count1++;  	im1 = IncrementModula (im1' 3);  	i = IncrementModula (i' 3);  	if (j != -1) {  		XYPoint HelpCoordinate = new XYPoint (lineA.P2.X' lineA.P2.Y);  		XYPoint HelpNode = new XYPoint (HelpCoordinate);  		intersectionPolygon.Points.Add (HelpNode);  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: im1 = IncrementModula (im1' 3);  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: i = IncrementModula (i' 3);  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: lineA = triangleA.GetLine (DecrementModula (i' 3));  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: if (CalculatePointToPointDistance (p' lineA.P2) < EPSILON) {  	i = IncrementModula (i' 3);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: i = IncrementModula (i' 3);  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: lineB = triangleB.GetLine (DecrementModula (j' 3));  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: if (CalculatePointToPointDistance (p' lineB.P2) < EPSILON) {  	j = IncrementModula (j' 3);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: j = IncrementModula (j' 3);  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,CalculateLineToPointDistance,The following statement contains a magic number: if ((a == 0) || (c == 0)) {  	dist = 0;  }  else if (b == 0) {  	dist = a;  }  else {  	double alpha = Math.Acos ((b * b + c * c - a * a) / (2 * b * c));  	double beta = Math.Acos ((a * a + b * b - c * c) / (2 * a * b));  	if (Math.Max (alpha' beta) < Math.PI / 2) {  		dist = Math.Abs ((line.P2.X - line.P1.X) * (line.P1.Y - point.Y) - (line.P1.X - point.X) * (line.P2.Y - line.P1.Y)) / b;  	}  	else {  		dist = Math.Min (a' c);  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,CalculateLineToPointDistance,The following statement contains a magic number: if ((a == 0) || (c == 0)) {  	dist = 0;  }  else if (b == 0) {  	dist = a;  }  else {  	double alpha = Math.Acos ((b * b + c * c - a * a) / (2 * b * c));  	double beta = Math.Acos ((a * a + b * b - c * c) / (2 * a * b));  	if (Math.Max (alpha' beta) < Math.PI / 2) {  		dist = Math.Abs ((line.P2.X - line.P1.X) * (line.P1.Y - point.Y) - (line.P1.X - point.X) * (line.P2.Y - line.P1.Y)) / b;  	}  	else {  		dist = Math.Min (a' c);  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,CalculateLineToPointDistance,The following statement contains a magic number: if ((a == 0) || (c == 0)) {  	dist = 0;  }  else if (b == 0) {  	dist = a;  }  else {  	double alpha = Math.Acos ((b * b + c * c - a * a) / (2 * b * c));  	double beta = Math.Acos ((a * a + b * b - c * c) / (2 * a * b));  	if (Math.Max (alpha' beta) < Math.PI / 2) {  		dist = Math.Abs ((line.P2.X - line.P1.X) * (line.P1.Y - point.Y) - (line.P1.X - point.X) * (line.P2.Y - line.P1.Y)) / b;  	}  	else {  		dist = Math.Min (a' c);  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,CalculateLineToPointDistance,The following statement contains a magic number: if (b == 0) {  	dist = a;  }  else {  	double alpha = Math.Acos ((b * b + c * c - a * a) / (2 * b * c));  	double beta = Math.Acos ((a * a + b * b - c * c) / (2 * a * b));  	if (Math.Max (alpha' beta) < Math.PI / 2) {  		dist = Math.Abs ((line.P2.X - line.P1.X) * (line.P1.Y - point.Y) - (line.P1.X - point.X) * (line.P2.Y - line.P1.Y)) / b;  	}  	else {  		dist = Math.Min (a' c);  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,CalculateLineToPointDistance,The following statement contains a magic number: if (b == 0) {  	dist = a;  }  else {  	double alpha = Math.Acos ((b * b + c * c - a * a) / (2 * b * c));  	double beta = Math.Acos ((a * a + b * b - c * c) / (2 * a * b));  	if (Math.Max (alpha' beta) < Math.PI / 2) {  		dist = Math.Abs ((line.P2.X - line.P1.X) * (line.P1.Y - point.Y) - (line.P1.X - point.X) * (line.P2.Y - line.P1.Y)) / b;  	}  	else {  		dist = Math.Min (a' c);  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,CalculateLineToPointDistance,The following statement contains a magic number: if (b == 0) {  	dist = a;  }  else {  	double alpha = Math.Acos ((b * b + c * c - a * a) / (2 * b * c));  	double beta = Math.Acos ((a * a + b * b - c * c) / (2 * a * b));  	if (Math.Max (alpha' beta) < Math.PI / 2) {  		dist = Math.Abs ((line.P2.X - line.P1.X) * (line.P1.Y - point.Y) - (line.P1.X - point.X) * (line.P2.Y - line.P1.Y)) / b;  	}  	else {  		dist = Math.Min (a' c);  	}  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYGeometryTools.cs,CalculateLineToPointDistance,The following statement contains a magic number: if (Math.Max (alpha' beta) < Math.PI / 2) {  	dist = Math.Abs ((line.P2.X - line.P1.X) * (line.P1.Y - point.Y) - (line.P1.X - point.X) * (line.P2.Y - line.P1.Y)) / b;  }  else {  	dist = Math.Min (a' c);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYLine,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYLine.cs,GetMidpoint,The following statement contains a magic number: return new XYPoint ((_p1.X + _p2.X) / 2' (_p1.Y + _p2.Y) / 2);  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYLine,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYLine.cs,GetMidpoint,The following statement contains a magic number: return new XYPoint ((_p1.X + _p2.X) / 2' (_p1.Y + _p2.Y) / 2);  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYPoint,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYPoint.cs,XYPoint,The following statement contains a magic number: _x = -9999;  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYPoint,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYPoint.cs,XYPoint,The following statement contains a magic number: _y = -9999;  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYPolygon,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYPolygon.cs,GetArea,The following statement contains a magic number: area = 0.5 * area;  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYPolygon,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYPolygon.cs,GetTriangulation,The following statement contains a magic number: while (LocalPolygon.Points.Count > 3) {  	i = LocalPolygon.FindEar ();  	n = LocalPolygon.Points.Count;  	im1 = i - 1;  	ip1 = i + 1;  	if (i == 0) {  		im1 = n - 1;  	}  	else if (i == n - 1) {  		ip1 = 0;  	}  	XYPoint Nodeim1 = new XYPoint ((XYPoint)LocalPolygon.Points [im1]);  	XYPoint Nodei = new XYPoint ((XYPoint)LocalPolygon.Points [i]);  	XYPoint Nodeip1 = new XYPoint ((XYPoint)LocalPolygon.Points [ip1]);  	XYPolygon Triangle = new XYPolygon ();  	Triangle.Points.Add (Nodeim1);  	Triangle.Points.Add (Nodei);  	Triangle.Points.Add (Nodeip1);  	TriangleList.Add (Triangle);  	LocalPolygon.Points.RemoveAt (i);  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYPolygon,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYPolygon.cs,Validate,The following statement contains a magic number: if (Points.Count < 3) {  	throw new System.Exception ("Number of vertices in polygon element is less than 3.");  }  
Magic Number,Oatc.OpenMI.Sdk.Spatial,XYPolyline,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\XYPolyline.cs,Validate,The following statement contains a magic number: if (_points.Count < 2) {  	throw new System.Exception ("Number of vertices in polyline element is less than 2.");  }  
Duplicate Code,Oatc.OpenMI.Sdk.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Spatial\ElementMapper.cs,UpdateMappingMatrix,The method contains a code clone-set at the following line numbers (starting from the method definition): ((17' 77)' (94' 154)' (205' 265))
Missing Default,Oatc.OpenMI.Sdk.Backbone,Dimension,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Dimension.cs,Dimension,The following switch statement is missing a default case: switch (predefinedDimension) {  case PredefinedDimensions.Length:  	SetPower (DimensionBase.Length' 1);  	break;  case PredefinedDimensions.Area:  	SetPower (DimensionBase.Length' 2);  	break;  case PredefinedDimensions.Volume:  	SetPower (DimensionBase.Length' 3);  	break;  case PredefinedDimensions.LengthPerTime:  	SetPower (DimensionBase.Length' 1);  	SetPower (DimensionBase.Time' -1);  	break;  case PredefinedDimensions.VolumePerTime:  	SetPower (DimensionBase.Length' 3);  	SetPower (DimensionBase.Time' -1);  	break;  case PredefinedDimensions.VolumePerTimePerLength:  	SetPower (DimensionBase.Length' 2);  	SetPower (DimensionBase.Time' -1);  	break;  case PredefinedDimensions.VolumePerTimePerArea:  	SetPower (DimensionBase.Length' 1);  	SetPower (DimensionBase.Time' -1);  	break;  case PredefinedDimensions.Mass:  	SetPower (DimensionBase.Mass' 1);  	break;  case PredefinedDimensions.MassPerTime:  	SetPower (DimensionBase.Mass' 1);  	SetPower (DimensionBase.Time' -1);  	break;  }  
Missing Default,Oatc.OpenMI.Sdk.Backbone,Unit,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Sdk\Backbone\Unit.cs,Unit,The following switch statement is missing a default case: switch (predefinedUnit) {  case PredefinedUnits.Meter:  	caption = "m";  	description = "meter";  	dimension = new Dimension (PredefinedDimensions.Length);  	break;  case PredefinedUnits.Liter:  	caption = "L";  	description = "Liter";  	dimension = new Dimension (PredefinedDimensions.Volume);  	ConversionFactorToSI = 0.001;  	break;  case PredefinedUnits.CubicMeterPerSecond:  	caption = "m3/s";  	description = "cubic meter per second";  	dimension = new Dimension (PredefinedDimensions.VolumePerTime);  	break;  case PredefinedUnits.LiterPerSecond:  	caption = "liter/s";  	description = "liter per second";  	dimension = new Dimension (PredefinedDimensions.VolumePerTime);  	break;  case PredefinedUnits.MillimeterPerDay:  	caption = "mm/day";  	description = "millimeters per day";  	conversionFactorToBeUsed = 1.15741E-08;  	dimension = new Dimension (PredefinedDimensions.VolumePerTimePerArea);  	break;  }  
