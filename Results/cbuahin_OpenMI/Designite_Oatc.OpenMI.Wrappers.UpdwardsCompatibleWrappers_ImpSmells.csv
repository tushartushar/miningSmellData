Implementation smell,Namespace,Class,File,Method,Description
Long Method,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,UpdateMappingMatrix,The method has 445 lines of code.
Complex Method,Oatc.UpwardsComp.Spatial,DataOperation,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\DataOperation.cs,IsValid,Cyclomatic complexity of the method is 10
Complex Method,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,UpdateMappingMatrix,Cyclomatic complexity of the method is 108
Complex Method,Oatc.UpwardsComp.Spatial,ElementSetChecker,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementSetChecker.cs,CheckElementSet,Cyclomatic complexity of the method is 14
Complex Method,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,CalculateSharedLength,Cyclomatic complexity of the method is 8
Complex Method,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,CalculateLengthOfLineInsidePolygon,Cyclomatic complexity of the method is 13
Complex Method,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,Cyclomatic complexity of the method is 10
Complex Method,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,Intersect,Cyclomatic complexity of the method is 12
Complex Method,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,IsPointInPolygon,Cyclomatic complexity of the method is 8
Complex Method,Oatc.UpwardsComp.Spatial,XYPolygon,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYPolygon.cs,Validate,Cyclomatic complexity of the method is 8
Long Parameter List,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,DoLineSegmentsIntersect,The method has 8 parameters.
Long Parameter List,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,Intersect,The method has 6 parameters.
Long Identifier,Oatc.UpwardsComp.EngineWrapper,SmartBufferDataOperation,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\SmartBufferDataOperation.cs,Prepare,The length of the parameter argumentRelaxationFactorWasFound is 32.
Long Identifier,Oatc.UpwardsComp.EngineWrapper,SmartBufferDataOperation,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\SmartBufferDataOperation.cs,Prepare,The length of the parameter argumentDoExtendedValidationWasFound is 36.
Long Identifier,Oatc.UpwardsComp.Spatial,DataOperation,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\DataOperation.cs,IsValid,The length of the parameter numberOfSelectedSpatialMappingDataOperations is 44.
Long Statement,Oatc.UpwardsComp.EngineWrapper,LinkableEngine,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\LinkableEngine.cs,Validate,The length of the statement  "		throw new Exception ("Validate method in the LinkableEngine cannot be invoked before the Initialize method has been invoked"); " is 126.
Long Statement,Oatc.UpwardsComp.EngineWrapper,LinkableEngine,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\LinkableEngine.cs,Prepare,The length of the statement  "			throw new Exception ("Prepare method in the LinkableEngine cannot be invoked before the Initialize method has been invoked"); " is 125.
Long Statement,Oatc.UpwardsComp.EngineWrapper,LinkableEngine1_4,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\LinkableEngine1_4.cs,OnValidate,The length of the statement  "		throw new Exception ("Validate method in the LinkableEngine cannot be invoked before the Initialize method has been invoked"); " is 126.
Long Statement,Oatc.UpwardsComp.EngineWrapper,LinkableEngine1_4,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\LinkableEngine1_4.cs,GetEngineValues,The length of the statement  "	IScalarSet scalarSet = (IScalarSet)_engineApiAccess.GetValues (exchangeItem.ValueDefinition.Caption' exchangeItem.SpatialDefinition.Caption); " is 141.
Long Statement,Oatc.UpwardsComp.Spatial,DataOperation,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\DataOperation.cs,IsValid,The length of the statement  "	foreach (string idString in elementMapper.GetIDsForAvailableDataOperations (outputExchangeItem.ElementSet.ElementType' inputExchangeItem.ElementSet.ElementType)) { " is 163.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,UpdateMappingMatrix,The length of the statement  "				// else if (_methodID.Equals((int) eMethods.PointToPoint.Nearest)) and else if (_methodID.Equals((int) eMethods.PointToPoint.Inverse)) " is 134.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,UpdateMappingMatrix,The length of the statement  "		else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.PolyLine)// Point to PolyLine " is 125.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,UpdateMappingMatrix,The length of the statement  "		else if (fromElements.ElementType == ElementType.Point && toElements.ElementType == ElementType.Polygon)// Point to Polygon " is 123.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,UpdateMappingMatrix,The length of the statement  "		else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Point)// Polyline to Point " is 125.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,UpdateMappingMatrix,The length of the statement  "		else if (fromElements.ElementType == ElementType.PolyLine && toElements.ElementType == ElementType.Polygon)// PolyLine to Polygon " is 129.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,UpdateMappingMatrix,The length of the statement  "							_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength (); " is 123.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,UpdateMappingMatrix,The length of the statement  "		else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Point)// Polygon to Point " is 123.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,UpdateMappingMatrix,The length of the statement  "		else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.PolyLine)// Polygon to PolyLine " is 129.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,UpdateMappingMatrix,The length of the statement  "							_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength (); " is 123.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,UpdateMappingMatrix,The length of the statement  "							_mappingMatrix [i' n] = XYGeometryTools.CalculateLengthOfPolylineInsidePolygon (polyline' polygon) / polyline.GetLength (); " is 123.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,UpdateMappingMatrix,The length of the statement  "		else if (fromElements.ElementType == ElementType.Polygon && toElements.ElementType == ElementType.Polygon)// Polygon to Polygon " is 127.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,GetAvailableDataOperations,The length of the statement  "			dataOperation.AddArgument (Argument.Create ("ID"' _availableMethods [i].ID.ToString ()' true' "Internal ElementMapper dataoperation ID")); " is 138.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,GetAvailableDataOperations,The length of the statement  "			dataOperation.AddArgument (Argument.Create ("Description"' _availableMethods [i].Description' true' "Operation description")); " is 126.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,GetAvailableDataOperations,The length of the statement  "			dataOperation.AddArgument (Argument.Create ("FromElementType"' _availableMethods [i].fromElementsShapeType.ToString ()' true' "Valid From-Element Types")); " is 155.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,GetAvailableDataOperations,The length of the statement  "			dataOperation.AddArgument (Argument.Create ("ToElementType"' _availableMethods [i].toElementsShapeType.ToString ()' true' "Valid To-Element Types")); " is 149.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,GetAvailableDataOperations,The length of the statement  "		if ((fromElementsElementType == _availableMethods [i].fromElementsShapeType) && (toElementsElementType == _availableMethods [i].toElementsShapeType)) { " is 151.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,GetAvailableDataOperations,The length of the statement  "			dataOperation.AddArgument (Argument.Create ("ID"' _availableMethods [i].ID.ToString ()' true' "Internal ElementMapper dataoperation ID")); " is 138.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,GetAvailableDataOperations,The length of the statement  "			dataOperation.AddArgument (Argument.Create ("Description"' _availableMethods [i].Description' true' "Operation description")); " is 126.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,GetAvailableDataOperations,The length of the statement  "			dataOperation.AddArgument (Argument.Create ("FromElementType"' _availableMethods [i].fromElementsShapeType.ToString ()' true' "Valid From-Element Types")); " is 155.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,GetAvailableDataOperations,The length of the statement  "			dataOperation.AddArgument (Argument.Create ("ToElementType"' _availableMethods [i].toElementsShapeType.ToString ()' true' "Valid To-Element Types")); " is 149.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,GetMethodID,The length of the statement  "	throw new Exception ("methodDescription: " + methodDescription + " not known for fromElementType: " + fromElementsElementType + " and to ElementType: " + toElementsElementType); " is 177.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,CreateXYPolyline,The length of the statement  "		xyPolyline.Points.Add (new XYPoint (elementSet.GetVertexXCoordinate (index' i)' elementSet.GetVertexYCoordinate (index' i))); " is 125.
Long Statement,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,CreateXYPolygon,The length of the statement  "		xyPolygon.Points.Add (new XYPoint (elementSet.GetVertexXCoordinate (index' i)' elementSet.GetVertexYCoordinate (index' i))); " is 124.
Long Statement,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,DoLineSegmentsIntersect,The length of the statement  "	return DoLineSegmentsIntersect (line1.P1.X' line1.P1.Y' line1.P2.X' line1.P2.Y' line2.P1.X' line2.P1.Y' line2.P2.X' line2.P2.Y); " is 128.
Long Statement,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,CalculateIntersectionPoint,The length of the statement  "		throw new Exception ("Attempt to calculate intersection point between non intersecting lines. CalculateIntersectionPoint failed."); " is 131.
Long Statement,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,CalculateSharedLength,The length of the statement  "	if (Math.Abs (lineA.P2.X - lineA.P1.X) < EPSILON && Math.Abs (lineB.P2.X - lineB.P1.X) < EPSILON && Math.Abs (lineA.P1.X - lineB.P1.X) < EPSILON) { " is 147.
Long Statement,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,IsPointInLine,The length of the statement  "			if (Math.Abs (y - line.P1.Y - (line.P2.Y - line.P1.Y) / (line.P1.X - line.P2.X) * (line.P1.X - x)) < EPSILON * EPSILON) { " is 121.
Long Statement,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,IsPointInLineInterior,The length of the statement  "			if (Math.Abs (y - line.P1.Y - (line.P2.Y - line.P1.Y) / (line.P1.X - line.P2.X) * (line.P1.X - x)) < EPSILON * EPSILON) { " is 121.
Long Statement,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,CalculateLineToPointDistance,The length of the statement  "	double b = Math.Sqrt ((line.P2.X - line.P1.X) * (line.P2.X - line.P1.X) + (line.P2.Y - line.P1.Y) * (line.P2.Y - line.P1.Y)); " is 125.
Long Statement,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,CalculateLineToPointDistance,The length of the statement  "			dist = Math.Abs ((line.P2.X - line.P1.X) * (line.P1.Y - point.Y) - (line.P1.X - point.X) * (line.P2.Y - line.P1.Y)) / b; " is 120.
Long Statement,Oatc.UpwardsComp.Spatial,XYPolygon,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYPolygon.cs,GetLine,The length of the statement  "	return new XYLine (((XYPoint)Points [lineNumber]).X' ((XYPoint)Points [lineNumber]).Y' ((XYPoint)Points [index2]).X' ((XYPoint)Points [index2]).Y); " is 147.
Complex Conditional,Oatc.UpwardsComp.Spatial,XYPolygon,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYPolygon.cs,IsIntersected,The conditional expression  "((((j != im1) && (j != i)) && (j != ip1)) && XYGeometryTools.IsPointInPolygon (x' y' localPolygon))"  is complex.
Magic Number,Oatc.UpwardsComp.Backbone,ScalarSet,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Backbone\ScalarSet.cs,ScalarSet,The following statement contains a magic number: _missingValueDefinition = -999.0;  
Magic Number,Oatc.UpwardsComp.Backbone,ScalarSet,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Backbone\ScalarSet.cs,ScalarSet,The following statement contains a magic number: _compareDoublesEpsilon = 0.000001;  
Magic Number,Oatc.UpwardsComp.Backbone,ScalarSet,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Backbone\ScalarSet.cs,ScalarSet,The following statement contains a magic number: _missingValueDefinition = -999.0;  
Magic Number,Oatc.UpwardsComp.Backbone,ScalarSet,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Backbone\ScalarSet.cs,ScalarSet,The following statement contains a magic number: _compareDoublesEpsilon = 0.000001;  
Magic Number,Oatc.UpwardsComp.EngineWrapper,LinearConversionDataOperation,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\LinearConversionDataOperation.cs,LinearConversionDataOperation,The following statement contains a magic number: _arguments = new IArgument[2];  
Magic Number,Oatc.UpwardsComp.EngineWrapper,LinearConversionDataOperation,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\LinearConversionDataOperation.cs,LinearConversionDataOperation,The following statement contains a magic number: _arguments [2] = new ArgumentDouble ("B"' 0' 0);  
Magic Number,Oatc.UpwardsComp.EngineWrapper,LinearConversionDataOperation,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\LinearConversionDataOperation.cs,LinearConversionDataOperation,The following statement contains a magic number: _arguments [2].Description = "Parameter B. Used in conversion: A*x + B";  
Magic Number,Oatc.UpwardsComp.EngineWrapper,LinearConversionDataOperation,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\LinearConversionDataOperation.cs,LinearConversionDataOperation,The following statement contains a magic number: _arguments [2].Caption = "B";  
Magic Number,Oatc.UpwardsComp.EngineWrapper,LinearConversionDataOperation,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\LinearConversionDataOperation.cs,LinearConversionDataOperation,The following statement contains a magic number: _arguments [2].Value = "0.0";  
Magic Number,Oatc.UpwardsComp.EngineWrapper,LinkableEngine,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\LinkableEngine.cs,LinkableEngine,The following statement contains a magic number: _timeEpsilon = 1.0 / (1000.0 * 3600.0 * 24.0);  
Magic Number,Oatc.UpwardsComp.EngineWrapper,LinkableEngine,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\LinkableEngine.cs,LinkableEngine,The following statement contains a magic number: _timeEpsilon = 1.0 / (1000.0 * 3600.0 * 24.0);  
Magic Number,Oatc.UpwardsComp.EngineWrapper,LinkableEngine,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\LinkableEngine.cs,LinkableEngine,The following statement contains a magic number: _timeEpsilon = 1.0 / (1000.0 * 3600.0 * 24.0);  
Magic Number,Oatc.UpwardsComp.EngineWrapper,LinkableEngine1_4,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\LinkableEngine1_4.cs,LinkableEngine1_4,The following statement contains a magic number: _timeEpsilon = 1.0 / (1000.0 * 3600.0 * 24.0);  
Magic Number,Oatc.UpwardsComp.EngineWrapper,LinkableEngine1_4,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\LinkableEngine1_4.cs,LinkableEngine1_4,The following statement contains a magic number: _timeEpsilon = 1.0 / (1000.0 * 3600.0 * 24.0);  
Magic Number,Oatc.UpwardsComp.EngineWrapper,LinkableEngine1_4,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\LinkableEngine1_4.cs,LinkableEngine1_4,The following statement contains a magic number: _timeEpsilon = 1.0 / (1000.0 * 3600.0 * 24.0);  
Magic Number,Oatc.UpwardsComp.EngineWrapper,SmartBufferDataOperation,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\SmartBufferDataOperation.cs,SmartBufferDataOperation,The following statement contains a magic number: _arguments = new IArgument[2];  
Magic Number,Oatc.UpwardsComp.EngineWrapper,SmartBufferDataOperation,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\SmartBufferDataOperation.cs,SmartBufferDataOperation,The following statement contains a magic number: _arguments [2] = new ArgumentBool ("Do Extended Data Validation"' true' true);  
Magic Number,Oatc.UpwardsComp.EngineWrapper,SmartBufferDataOperation,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\SmartBufferDataOperation.cs,SmartBufferDataOperation,The following statement contains a magic number: _arguments [2].Description = "Do extended validation. Must be \"true\" or \"false\"";  
Magic Number,Oatc.UpwardsComp.EngineWrapper,SmartBufferDataOperation,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\SmartBufferDataOperation.cs,SmartBufferDataOperation,The following statement contains a magic number: _arguments [2].Caption = "Do Extended Data Validation";  
Magic Number,Oatc.UpwardsComp.EngineWrapper,SmartBufferDataOperation,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\SmartBufferDataOperation.cs,Prepare,The following statement contains a magic number: for (int i = 0; i < _arguments.Length; i++) {  	if (_arguments [i].Caption == _arguments [1].Caption)//Relaxation Factor  	 {  		_relaxationFactor = Convert.ToDouble (_arguments [i].Value);  		argumentRelaxationFactorWasFound = true;  	}  	if (_arguments [i].Caption == _arguments [2].Caption)//Do extended validation  	 {  		_doExtendedValidation = Convert.ToBoolean (_arguments [i].Value);  		argumentDoExtendedValidationWasFound = true;  	}  }  
Magic Number,Oatc.UpwardsComp.EngineWrapper,SmartBufferDataOperation,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\EngineWrapper\SmartBufferDataOperation.cs,Prepare,The following statement contains a magic number: if (_arguments [i].Caption == _arguments [2].Caption)//Do extended validation   {  	_doExtendedValidation = Convert.ToBoolean (_arguments [i].Value);  	argumentDoExtendedValidationWasFound = true;  }  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [2].fromElementsShapeType = ElementType.Point;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [2].toElementsShapeType = ElementType.PolyLine;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [2].Description = "Nearest";  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [2].ID = (int)eMethods.PointToPolyline.Nearest;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [3].fromElementsShapeType = ElementType.Point;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [3].toElementsShapeType = ElementType.PolyLine;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [3].Description = "Inverse";  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [3].ID = (int)eMethods.PointToPolyline.Inverse;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [4].fromElementsShapeType = ElementType.Point;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [4].toElementsShapeType = ElementType.Polygon;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [4].Description = "Mean";  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [4].ID = (int)eMethods.PointToPolygon.Mean;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [5].fromElementsShapeType = ElementType.Point;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [5].toElementsShapeType = ElementType.Polygon;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [5].Description = "Sum";  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [5].ID = (int)eMethods.PointToPolygon.Sum;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [6].fromElementsShapeType = ElementType.PolyLine;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [6].toElementsShapeType = ElementType.Point;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [6].Description = "Nearest";  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [6].ID = (int)eMethods.PolylineToPoint.Nearest;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [7].fromElementsShapeType = ElementType.PolyLine;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [7].toElementsShapeType = ElementType.Point;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [7].Description = "Inverse";  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [7].ID = (int)eMethods.PolylineToPoint.Inverse;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [8].fromElementsShapeType = ElementType.PolyLine;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [8].toElementsShapeType = ElementType.Polygon;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [8].Description = "Weighted Mean";  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [8].ID = (int)eMethods.PolylineToPolygon.WeightedMean;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [9].fromElementsShapeType = ElementType.PolyLine;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [9].toElementsShapeType = ElementType.Polygon;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [9].Description = "Weighted Sum";  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [9].ID = (int)eMethods.PolylineToPolygon.WeightedSum;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [10].fromElementsShapeType = ElementType.Polygon;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [10].toElementsShapeType = ElementType.Point;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [10].Description = "Value";  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [10].ID = (int)eMethods.PolygonToPoint.Value;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [11].fromElementsShapeType = ElementType.Polygon;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [11].toElementsShapeType = ElementType.PolyLine;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [11].Description = "Weighted Mean";  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [11].ID = (int)eMethods.PolygonToPolyline.WeightedMean;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [12].fromElementsShapeType = ElementType.Polygon;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [12].toElementsShapeType = ElementType.PolyLine;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [12].Description = "Weighted Sum";  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [12].ID = (int)eMethods.PolygonToPolyline.WeightedSum;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [13].fromElementsShapeType = ElementType.Polygon;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [13].toElementsShapeType = ElementType.Polygon;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [13].Description = "Weighted Mean";  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [13].ID = (int)eMethods.PolygonToPolygon.WeightedMean;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [14].fromElementsShapeType = ElementType.Polygon;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [14].toElementsShapeType = ElementType.Polygon;  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [14].Description = "Weighted Sum";  
Magic Number,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,ElementMapper,The following statement contains a magic number: _availableMethods [14].ID = (int)eMethods.PolygonToPolygon.WeightedSum;  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,CalculateLengthOfLineInsidePolygon,The following statement contains a magic number: for (int i = 0; i < polygon.Points.Count; i++)// For all lines in the polygon   {  	for (int n = 0; n < lineList.Count; n++) {  		if (lineList.Count > 1000) {  			throw new Exception ("Problems in ElementMapper' line has been cut in more than 1000 pieces !!!");  		}  		if (DoLineSegmentsIntersect ((XYLine)lineList [n]' polygon.GetLine (i))) {  			// Split the intersecting line into two lines  			XYPoint IntersectionPoint = new XYPoint (CalculateIntersectionPoint ((XYLine)lineList [n]' polygon.GetLine (i)));  			lineList.Add (new XYLine (IntersectionPoint' ((XYLine)lineList [n]).P2));  			((XYLine)lineList [n]).P2.X = IntersectionPoint.X;  			((XYLine)lineList [n]).P2.Y = IntersectionPoint.Y;  			break;  		}  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,CalculateLengthOfLineInsidePolygon,The following statement contains a magic number: for (int n = 0; n < lineList.Count; n++) {  	if (lineList.Count > 1000) {  		throw new Exception ("Problems in ElementMapper' line has been cut in more than 1000 pieces !!!");  	}  	if (DoLineSegmentsIntersect ((XYLine)lineList [n]' polygon.GetLine (i))) {  		// Split the intersecting line into two lines  		XYPoint IntersectionPoint = new XYPoint (CalculateIntersectionPoint ((XYLine)lineList [n]' polygon.GetLine (i)));  		lineList.Add (new XYLine (IntersectionPoint' ((XYLine)lineList [n]).P2));  		((XYLine)lineList [n]).P2.X = IntersectionPoint.X;  		((XYLine)lineList [n]).P2.Y = IntersectionPoint.Y;  		break;  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,CalculateLengthOfLineInsidePolygon,The following statement contains a magic number: if (lineList.Count > 1000) {  	throw new Exception ("Problems in ElementMapper' line has been cut in more than 1000 pieces !!!");  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,CalculateLengthOfLineInsidePolygon,The following statement contains a magic number: for (int i = 0; i < lineList.Count; i++) {  	if (lineList.Count > 1000) {  		throw new Exception ("Problems in ElementMapper' line has been cuttes in more than 100 pieces !!!");  	}  	for (int j = 0; j < polygon.Points.Count; j++) {  		if (IsPointInLineInterior (polygon.GetLine (j).P1' ((XYLine)lineList [i]))) {  			lineList.Add (new XYLine (polygon.GetLine (j).P1' ((XYLine)lineList [i]).P2));  			((XYLine)lineList [i]).P2.X = polygon.GetLine (j).P1.X;  			((XYLine)lineList [i]).P2.Y = polygon.GetLine (j).P1.Y;  		}  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,CalculateLengthOfLineInsidePolygon,The following statement contains a magic number: if (lineList.Count > 1000) {  	throw new Exception ("Problems in ElementMapper' line has been cuttes in more than 100 pieces !!!");  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,CalculateLengthOfLineInsidePolygon,The following statement contains a magic number: for (int i = 0; i < lineList.Count; i++) {  	double sharedLength = 0;  	for (int j = 0; j < polygon.Points.Count; j++) {  		sharedLength += CalculateSharedLength (((XYLine)lineList [i])' polygon.GetLine (j));  	}  	if (sharedLength > EPSILON) {  		lengthInside += sharedLength / 2;  	}  	else if (IsPointInPolygon (((XYLine)lineList [i]).GetMidpoint ()' polygon)) {  		lengthInside += ((XYLine)lineList [i]).GetLength ();  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,CalculateLengthOfLineInsidePolygon,The following statement contains a magic number: if (sharedLength > EPSILON) {  	lengthInside += sharedLength / 2;  }  else if (IsPointInPolygon (((XYLine)lineList [i]).GetMidpoint ()' polygon)) {  	lengthInside += ((XYLine)lineList [i]).GetLength ();  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,CalculateLengthOfLineInsidePolygon,The following statement contains a magic number: lengthInside += sharedLength / 2;  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new Exception ("Argument must be a polygon with 3 points");  	}  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst;  	// First intersection point between triangles  	XYPoint p = new XYPoint ();  	// Latest intersection node found  	p.X = ((XYPoint)triangleA.Points [0]).X;  	p.Y = ((XYPoint)triangleA.Points [0]).Y;  	Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  	pFirst = p;  	if (j != -1) {  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = ((XYPoint)triangleA.Points [i]).X - p.X;  			double vay = ((XYPoint)triangleA.Points [i]).Y - p.Y;  			double vbx = ((XYPoint)triangleB.Points [j]).X - p.X;  			double vby = ((XYPoint)triangleB.Points [j]).Y - p.Y;  			if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vax' p.Y + EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  			}  			else if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vbx' p.Y + EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref p' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (p' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (Exception e) {  	throw new Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new Exception ("Argument must be a polygon with 3 points");  	}  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst;  	// First intersection point between triangles  	XYPoint p = new XYPoint ();  	// Latest intersection node found  	p.X = ((XYPoint)triangleA.Points [0]).X;  	p.Y = ((XYPoint)triangleA.Points [0]).Y;  	Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  	pFirst = p;  	if (j != -1) {  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = ((XYPoint)triangleA.Points [i]).X - p.X;  			double vay = ((XYPoint)triangleA.Points [i]).Y - p.Y;  			double vbx = ((XYPoint)triangleB.Points [j]).X - p.X;  			double vby = ((XYPoint)triangleB.Points [j]).Y - p.Y;  			if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vax' p.Y + EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  			}  			else if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vbx' p.Y + EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref p' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (p' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (Exception e) {  	throw new Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new Exception ("Argument must be a polygon with 3 points");  	}  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst;  	// First intersection point between triangles  	XYPoint p = new XYPoint ();  	// Latest intersection node found  	p.X = ((XYPoint)triangleA.Points [0]).X;  	p.Y = ((XYPoint)triangleA.Points [0]).Y;  	Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  	pFirst = p;  	if (j != -1) {  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = ((XYPoint)triangleA.Points [i]).X - p.X;  			double vay = ((XYPoint)triangleA.Points [i]).Y - p.Y;  			double vbx = ((XYPoint)triangleB.Points [j]).X - p.X;  			double vby = ((XYPoint)triangleB.Points [j]).Y - p.Y;  			if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vax' p.Y + EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  			}  			else if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vbx' p.Y + EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref p' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (p' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (Exception e) {  	throw new Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new Exception ("Argument must be a polygon with 3 points");  	}  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst;  	// First intersection point between triangles  	XYPoint p = new XYPoint ();  	// Latest intersection node found  	p.X = ((XYPoint)triangleA.Points [0]).X;  	p.Y = ((XYPoint)triangleA.Points [0]).Y;  	Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  	pFirst = p;  	if (j != -1) {  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = ((XYPoint)triangleA.Points [i]).X - p.X;  			double vay = ((XYPoint)triangleA.Points [i]).Y - p.Y;  			double vbx = ((XYPoint)triangleB.Points [j]).X - p.X;  			double vby = ((XYPoint)triangleB.Points [j]).Y - p.Y;  			if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vax' p.Y + EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  			}  			else if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vbx' p.Y + EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref p' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (p' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (Exception e) {  	throw new Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new Exception ("Argument must be a polygon with 3 points");  	}  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst;  	// First intersection point between triangles  	XYPoint p = new XYPoint ();  	// Latest intersection node found  	p.X = ((XYPoint)triangleA.Points [0]).X;  	p.Y = ((XYPoint)triangleA.Points [0]).Y;  	Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  	pFirst = p;  	if (j != -1) {  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = ((XYPoint)triangleA.Points [i]).X - p.X;  			double vay = ((XYPoint)triangleA.Points [i]).Y - p.Y;  			double vbx = ((XYPoint)triangleB.Points [j]).X - p.X;  			double vby = ((XYPoint)triangleB.Points [j]).Y - p.Y;  			if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vax' p.Y + EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  			}  			else if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vbx' p.Y + EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref p' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (p' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (Exception e) {  	throw new Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new Exception ("Argument must be a polygon with 3 points");  	}  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst;  	// First intersection point between triangles  	XYPoint p = new XYPoint ();  	// Latest intersection node found  	p.X = ((XYPoint)triangleA.Points [0]).X;  	p.Y = ((XYPoint)triangleA.Points [0]).Y;  	Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  	pFirst = p;  	if (j != -1) {  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = ((XYPoint)triangleA.Points [i]).X - p.X;  			double vay = ((XYPoint)triangleA.Points [i]).Y - p.Y;  			double vbx = ((XYPoint)triangleB.Points [j]).X - p.X;  			double vby = ((XYPoint)triangleB.Points [j]).Y - p.Y;  			if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vax' p.Y + EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  			}  			else if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vbx' p.Y + EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref p' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (p' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (Exception e) {  	throw new Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new Exception ("Argument must be a polygon with 3 points");  	}  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst;  	// First intersection point between triangles  	XYPoint p = new XYPoint ();  	// Latest intersection node found  	p.X = ((XYPoint)triangleA.Points [0]).X;  	p.Y = ((XYPoint)triangleA.Points [0]).Y;  	Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  	pFirst = p;  	if (j != -1) {  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = ((XYPoint)triangleA.Points [i]).X - p.X;  			double vay = ((XYPoint)triangleA.Points [i]).Y - p.Y;  			double vbx = ((XYPoint)triangleB.Points [j]).X - p.X;  			double vby = ((XYPoint)triangleB.Points [j]).Y - p.Y;  			if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vax' p.Y + EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  			}  			else if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vbx' p.Y + EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref p' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (p' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (Exception e) {  	throw new Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new Exception ("Argument must be a polygon with 3 points");  	}  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst;  	// First intersection point between triangles  	XYPoint p = new XYPoint ();  	// Latest intersection node found  	p.X = ((XYPoint)triangleA.Points [0]).X;  	p.Y = ((XYPoint)triangleA.Points [0]).Y;  	Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  	pFirst = p;  	if (j != -1) {  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = ((XYPoint)triangleA.Points [i]).X - p.X;  			double vay = ((XYPoint)triangleA.Points [i]).Y - p.Y;  			double vbx = ((XYPoint)triangleB.Points [j]).X - p.X;  			double vby = ((XYPoint)triangleB.Points [j]).Y - p.Y;  			if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vax' p.Y + EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  			}  			else if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vbx' p.Y + EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref p' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (p' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (Exception e) {  	throw new Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new Exception ("Argument must be a polygon with 3 points");  	}  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst;  	// First intersection point between triangles  	XYPoint p = new XYPoint ();  	// Latest intersection node found  	p.X = ((XYPoint)triangleA.Points [0]).X;  	p.Y = ((XYPoint)triangleA.Points [0]).Y;  	Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  	pFirst = p;  	if (j != -1) {  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = ((XYPoint)triangleA.Points [i]).X - p.X;  			double vay = ((XYPoint)triangleA.Points [i]).Y - p.Y;  			double vbx = ((XYPoint)triangleB.Points [j]).X - p.X;  			double vby = ((XYPoint)triangleB.Points [j]).Y - p.Y;  			if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vax' p.Y + EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  			}  			else if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vbx' p.Y + EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref p' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (p' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (Exception e) {  	throw new Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new Exception ("Argument must be a polygon with 3 points");  	}  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst;  	// First intersection point between triangles  	XYPoint p = new XYPoint ();  	// Latest intersection node found  	p.X = ((XYPoint)triangleA.Points [0]).X;  	p.Y = ((XYPoint)triangleA.Points [0]).Y;  	Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  	pFirst = p;  	if (j != -1) {  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = ((XYPoint)triangleA.Points [i]).X - p.X;  			double vay = ((XYPoint)triangleA.Points [i]).Y - p.Y;  			double vbx = ((XYPoint)triangleB.Points [j]).X - p.X;  			double vby = ((XYPoint)triangleB.Points [j]).Y - p.Y;  			if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vax' p.Y + EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  			}  			else if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vbx' p.Y + EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref p' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (p' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (Exception e) {  	throw new Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: try {  	if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  		throw new Exception ("Argument must be a polygon with 3 points");  	}  	int i = 1;  	// Index for "next" node in polygon a.  	int j = -1;  	// Index for "next" node in polygon b.   	// -1 indicates that the first has not yet been found.  	double area;  	// Intersection area. Returned.  	XYPolygon intersectionPolygon = new XYPolygon ();  	// Intersection polygon.  	XYPoint pFirst;  	// First intersection point between triangles  	XYPoint p = new XYPoint ();  	// Latest intersection node found  	p.X = ((XYPoint)triangleA.Points [0]).X;  	p.Y = ((XYPoint)triangleA.Points [0]).Y;  	Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  	pFirst = p;  	if (j != -1) {  		bool complete = false;  		int count = 0;  		while (!complete) {  			// coordinates for vectors pointing to next triangleA and triangleB point respectively  			double vax = ((XYPoint)triangleA.Points [i]).X - p.X;  			double vay = ((XYPoint)triangleA.Points [i]).Y - p.Y;  			double vbx = ((XYPoint)triangleB.Points [j]).X - p.X;  			double vby = ((XYPoint)triangleB.Points [j]).Y - p.Y;  			if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vax' p.Y + EPSILON * vay' triangleB)) {  				Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  			}  			else if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vbx' p.Y + EPSILON * vby' triangleA)) {  				Intersect (triangleB' triangleA' ref p' ref j' ref i' ref intersectionPolygon);  			}  			else// triangleA and triangleB only touches one another but do not intersect  			 {  				area = 0;  				return area;  			}  			if (intersectionPolygon.Points.Count > 1) {  				complete = (CalculatePointToPointDistance (p' pFirst) < EPSILON);  			}  			count++;  			if (count > 20) {  				throw new Exception ("Failed to find intersection polygon");  			}  		}  		area = intersectionPolygon.GetArea ();  	}  	else {  		XYPoint pa = new XYPoint ();  		// internal point in triangle a  		XYPoint pb = new XYPoint ();  		// internal point in triangle b  		pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  		pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  		pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  		pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  		if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  		 {  			area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  		}  		else// triangleA and triangleB do dot intersect  		 {  			area = 0;  		}  	}  	return area;  }  catch (Exception e) {  	throw new Exception ("TriangleIntersectionArea failed"' e);  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  	throw new Exception ("Argument must be a polygon with 3 points");  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (triangleA.Points.Count != 3 || triangleB.Points.Count != 3) {  	throw new Exception ("Argument must be a polygon with 3 points");  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = ((XYPoint)triangleA.Points [i]).X - p.X;  		double vay = ((XYPoint)triangleA.Points [i]).Y - p.Y;  		double vbx = ((XYPoint)triangleB.Points [j]).X - p.X;  		double vby = ((XYPoint)triangleB.Points [j]).Y - p.Y;  		if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vax' p.Y + EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  		}  		else if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vbx' p.Y + EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref p' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (p' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = ((XYPoint)triangleA.Points [i]).X - p.X;  		double vay = ((XYPoint)triangleA.Points [i]).Y - p.Y;  		double vbx = ((XYPoint)triangleB.Points [j]).X - p.X;  		double vby = ((XYPoint)triangleB.Points [j]).Y - p.Y;  		if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vax' p.Y + EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  		}  		else if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vbx' p.Y + EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref p' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (p' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = ((XYPoint)triangleA.Points [i]).X - p.X;  		double vay = ((XYPoint)triangleA.Points [i]).Y - p.Y;  		double vbx = ((XYPoint)triangleB.Points [j]).X - p.X;  		double vby = ((XYPoint)triangleB.Points [j]).Y - p.Y;  		if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vax' p.Y + EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  		}  		else if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vbx' p.Y + EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref p' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (p' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = ((XYPoint)triangleA.Points [i]).X - p.X;  		double vay = ((XYPoint)triangleA.Points [i]).Y - p.Y;  		double vbx = ((XYPoint)triangleB.Points [j]).X - p.X;  		double vby = ((XYPoint)triangleB.Points [j]).Y - p.Y;  		if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vax' p.Y + EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  		}  		else if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vbx' p.Y + EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref p' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (p' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = ((XYPoint)triangleA.Points [i]).X - p.X;  		double vay = ((XYPoint)triangleA.Points [i]).Y - p.Y;  		double vbx = ((XYPoint)triangleB.Points [j]).X - p.X;  		double vby = ((XYPoint)triangleB.Points [j]).Y - p.Y;  		if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vax' p.Y + EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  		}  		else if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vbx' p.Y + EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref p' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (p' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = ((XYPoint)triangleA.Points [i]).X - p.X;  		double vay = ((XYPoint)triangleA.Points [i]).Y - p.Y;  		double vbx = ((XYPoint)triangleB.Points [j]).X - p.X;  		double vby = ((XYPoint)triangleB.Points [j]).Y - p.Y;  		if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vax' p.Y + EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  		}  		else if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vbx' p.Y + EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref p' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (p' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = ((XYPoint)triangleA.Points [i]).X - p.X;  		double vay = ((XYPoint)triangleA.Points [i]).Y - p.Y;  		double vbx = ((XYPoint)triangleB.Points [j]).X - p.X;  		double vby = ((XYPoint)triangleB.Points [j]).Y - p.Y;  		if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vax' p.Y + EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  		}  		else if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vbx' p.Y + EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref p' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (p' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = ((XYPoint)triangleA.Points [i]).X - p.X;  		double vay = ((XYPoint)triangleA.Points [i]).Y - p.Y;  		double vbx = ((XYPoint)triangleB.Points [j]).X - p.X;  		double vby = ((XYPoint)triangleB.Points [j]).Y - p.Y;  		if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vax' p.Y + EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  		}  		else if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vbx' p.Y + EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref p' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (p' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (j != -1) {  	bool complete = false;  	int count = 0;  	while (!complete) {  		// coordinates for vectors pointing to next triangleA and triangleB point respectively  		double vax = ((XYPoint)triangleA.Points [i]).X - p.X;  		double vay = ((XYPoint)triangleA.Points [i]).Y - p.Y;  		double vbx = ((XYPoint)triangleB.Points [j]).X - p.X;  		double vby = ((XYPoint)triangleB.Points [j]).Y - p.Y;  		if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vax' p.Y + EPSILON * vay' triangleB)) {  			Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  		}  		else if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vbx' p.Y + EPSILON * vby' triangleA)) {  			Intersect (triangleB' triangleA' ref p' ref j' ref i' ref intersectionPolygon);  		}  		else// triangleA and triangleB only touches one another but do not intersect  		 {  			area = 0;  			return area;  		}  		if (intersectionPolygon.Points.Count > 1) {  			complete = (CalculatePointToPointDistance (p' pFirst) < EPSILON);  		}  		count++;  		if (count > 20) {  			throw new Exception ("Failed to find intersection polygon");  		}  	}  	area = intersectionPolygon.GetArea ();  }  else {  	XYPoint pa = new XYPoint ();  	// internal point in triangle a  	XYPoint pb = new XYPoint ();  	// internal point in triangle b  	pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  	pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  	pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  	pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  	if (IsPointInPolygon (pa' triangleB) || IsPointInPolygon (pb' triangleA))// triangleA is completely inside triangleB  	 {  		area = Math.Min (triangleA.GetArea ()' triangleB.GetArea ());  	}  	else// triangleA and triangleB do dot intersect  	 {  		area = 0;  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: while (!complete) {  	// coordinates for vectors pointing to next triangleA and triangleB point respectively  	double vax = ((XYPoint)triangleA.Points [i]).X - p.X;  	double vay = ((XYPoint)triangleA.Points [i]).Y - p.Y;  	double vbx = ((XYPoint)triangleB.Points [j]).X - p.X;  	double vby = ((XYPoint)triangleB.Points [j]).Y - p.Y;  	if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vax' p.Y + EPSILON * vay' triangleB)) {  		Intersect (triangleA' triangleB' ref p' ref i' ref j' ref intersectionPolygon);  	}  	else if (IsPointInPolygonOrOnEdge (p.X + EPSILON * vbx' p.Y + EPSILON * vby' triangleA)) {  		Intersect (triangleB' triangleA' ref p' ref j' ref i' ref intersectionPolygon);  	}  	else// triangleA and triangleB only touches one another but do not intersect  	 {  		area = 0;  		return area;  	}  	if (intersectionPolygon.Points.Count > 1) {  		complete = (CalculatePointToPointDistance (p' pFirst) < EPSILON);  	}  	count++;  	if (count > 20) {  		throw new Exception ("Failed to find intersection polygon");  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: if (count > 20) {  	throw new Exception ("Failed to find intersection polygon");  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: pa.X = (triangleA.GetX (0) + triangleA.GetX (1) + triangleA.GetX (2)) / 3;  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: pa.Y = (triangleA.GetY (0) + triangleA.GetY (1) + triangleA.GetY (2)) / 3;  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: pb.X = (triangleB.GetX (0) + triangleB.GetX (1) + triangleB.GetX (2)) / 3;  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,TriangleIntersectionArea,The following statement contains a magic number: pb.Y = (triangleB.GetY (0) + triangleB.GetY (1) + triangleB.GetY (2)) / 3;  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: while ((count1 < 3) && (!found)) {  	lineA = triangleA.GetLine (im1);  	if (count1 == 0) {  		lineA.P1.X = p.X;  		lineA.P1.Y = p.Y;  	}  	double MinDist = -1;  	// Distance used when a line is crossed more than once  	int jm1 = 0;  	// "j-1"  	int jm1Store = -1;  	while (jm1 < 3) {  		lineB = triangleB.GetLine (jm1);  		found = IntersectionPoint (lineA' lineB' ref p);  		double Dist = CalculatePointToPointDistance (lineA.P1' p);  		if (Dist < EPSILON) {  			found = false;  		}  		if (found) {  			if ((MinDist < 0) || (Dist < MinDist)) {  				MinDist = Dist;  				jm1Store = jm1;  			}  		}  		jm1++;  	}  	if (jm1Store > -1) {  		lineB = triangleB.GetLine (jm1Store);  		found = IntersectionPoint (lineA' lineB' ref p);  		XYPoint HelpCoordinate = new XYPoint (p.X' p.Y);  		XYPoint HelpNode = new XYPoint (HelpCoordinate);  		intersectionPolygon.Points.Add (HelpNode);  		j = Increase (jm1Store' 2);  	}  	if (!found) {  		count1++;  		im1 = Increase (im1' 2);  		i = Increase (i' 2);  		if (j != -1) {  			XYPoint HelpCoordinate = new XYPoint (lineA.P2.X' lineA.P2.Y);  			XYPoint HelpNode = new XYPoint (HelpCoordinate);  			intersectionPolygon.Points.Add (HelpNode);  		}  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: while ((count1 < 3) && (!found)) {  	lineA = triangleA.GetLine (im1);  	if (count1 == 0) {  		lineA.P1.X = p.X;  		lineA.P1.Y = p.Y;  	}  	double MinDist = -1;  	// Distance used when a line is crossed more than once  	int jm1 = 0;  	// "j-1"  	int jm1Store = -1;  	while (jm1 < 3) {  		lineB = triangleB.GetLine (jm1);  		found = IntersectionPoint (lineA' lineB' ref p);  		double Dist = CalculatePointToPointDistance (lineA.P1' p);  		if (Dist < EPSILON) {  			found = false;  		}  		if (found) {  			if ((MinDist < 0) || (Dist < MinDist)) {  				MinDist = Dist;  				jm1Store = jm1;  			}  		}  		jm1++;  	}  	if (jm1Store > -1) {  		lineB = triangleB.GetLine (jm1Store);  		found = IntersectionPoint (lineA' lineB' ref p);  		XYPoint HelpCoordinate = new XYPoint (p.X' p.Y);  		XYPoint HelpNode = new XYPoint (HelpCoordinate);  		intersectionPolygon.Points.Add (HelpNode);  		j = Increase (jm1Store' 2);  	}  	if (!found) {  		count1++;  		im1 = Increase (im1' 2);  		i = Increase (i' 2);  		if (j != -1) {  			XYPoint HelpCoordinate = new XYPoint (lineA.P2.X' lineA.P2.Y);  			XYPoint HelpNode = new XYPoint (HelpCoordinate);  			intersectionPolygon.Points.Add (HelpNode);  		}  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: while ((count1 < 3) && (!found)) {  	lineA = triangleA.GetLine (im1);  	if (count1 == 0) {  		lineA.P1.X = p.X;  		lineA.P1.Y = p.Y;  	}  	double MinDist = -1;  	// Distance used when a line is crossed more than once  	int jm1 = 0;  	// "j-1"  	int jm1Store = -1;  	while (jm1 < 3) {  		lineB = triangleB.GetLine (jm1);  		found = IntersectionPoint (lineA' lineB' ref p);  		double Dist = CalculatePointToPointDistance (lineA.P1' p);  		if (Dist < EPSILON) {  			found = false;  		}  		if (found) {  			if ((MinDist < 0) || (Dist < MinDist)) {  				MinDist = Dist;  				jm1Store = jm1;  			}  		}  		jm1++;  	}  	if (jm1Store > -1) {  		lineB = triangleB.GetLine (jm1Store);  		found = IntersectionPoint (lineA' lineB' ref p);  		XYPoint HelpCoordinate = new XYPoint (p.X' p.Y);  		XYPoint HelpNode = new XYPoint (HelpCoordinate);  		intersectionPolygon.Points.Add (HelpNode);  		j = Increase (jm1Store' 2);  	}  	if (!found) {  		count1++;  		im1 = Increase (im1' 2);  		i = Increase (i' 2);  		if (j != -1) {  			XYPoint HelpCoordinate = new XYPoint (lineA.P2.X' lineA.P2.Y);  			XYPoint HelpNode = new XYPoint (HelpCoordinate);  			intersectionPolygon.Points.Add (HelpNode);  		}  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: while ((count1 < 3) && (!found)) {  	lineA = triangleA.GetLine (im1);  	if (count1 == 0) {  		lineA.P1.X = p.X;  		lineA.P1.Y = p.Y;  	}  	double MinDist = -1;  	// Distance used when a line is crossed more than once  	int jm1 = 0;  	// "j-1"  	int jm1Store = -1;  	while (jm1 < 3) {  		lineB = triangleB.GetLine (jm1);  		found = IntersectionPoint (lineA' lineB' ref p);  		double Dist = CalculatePointToPointDistance (lineA.P1' p);  		if (Dist < EPSILON) {  			found = false;  		}  		if (found) {  			if ((MinDist < 0) || (Dist < MinDist)) {  				MinDist = Dist;  				jm1Store = jm1;  			}  		}  		jm1++;  	}  	if (jm1Store > -1) {  		lineB = triangleB.GetLine (jm1Store);  		found = IntersectionPoint (lineA' lineB' ref p);  		XYPoint HelpCoordinate = new XYPoint (p.X' p.Y);  		XYPoint HelpNode = new XYPoint (HelpCoordinate);  		intersectionPolygon.Points.Add (HelpNode);  		j = Increase (jm1Store' 2);  	}  	if (!found) {  		count1++;  		im1 = Increase (im1' 2);  		i = Increase (i' 2);  		if (j != -1) {  			XYPoint HelpCoordinate = new XYPoint (lineA.P2.X' lineA.P2.Y);  			XYPoint HelpNode = new XYPoint (HelpCoordinate);  			intersectionPolygon.Points.Add (HelpNode);  		}  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: while ((count1 < 3) && (!found)) {  	lineA = triangleA.GetLine (im1);  	if (count1 == 0) {  		lineA.P1.X = p.X;  		lineA.P1.Y = p.Y;  	}  	double MinDist = -1;  	// Distance used when a line is crossed more than once  	int jm1 = 0;  	// "j-1"  	int jm1Store = -1;  	while (jm1 < 3) {  		lineB = triangleB.GetLine (jm1);  		found = IntersectionPoint (lineA' lineB' ref p);  		double Dist = CalculatePointToPointDistance (lineA.P1' p);  		if (Dist < EPSILON) {  			found = false;  		}  		if (found) {  			if ((MinDist < 0) || (Dist < MinDist)) {  				MinDist = Dist;  				jm1Store = jm1;  			}  		}  		jm1++;  	}  	if (jm1Store > -1) {  		lineB = triangleB.GetLine (jm1Store);  		found = IntersectionPoint (lineA' lineB' ref p);  		XYPoint HelpCoordinate = new XYPoint (p.X' p.Y);  		XYPoint HelpNode = new XYPoint (HelpCoordinate);  		intersectionPolygon.Points.Add (HelpNode);  		j = Increase (jm1Store' 2);  	}  	if (!found) {  		count1++;  		im1 = Increase (im1' 2);  		i = Increase (i' 2);  		if (j != -1) {  			XYPoint HelpCoordinate = new XYPoint (lineA.P2.X' lineA.P2.Y);  			XYPoint HelpNode = new XYPoint (HelpCoordinate);  			intersectionPolygon.Points.Add (HelpNode);  		}  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: while (jm1 < 3) {  	lineB = triangleB.GetLine (jm1);  	found = IntersectionPoint (lineA' lineB' ref p);  	double Dist = CalculatePointToPointDistance (lineA.P1' p);  	if (Dist < EPSILON) {  		found = false;  	}  	if (found) {  		if ((MinDist < 0) || (Dist < MinDist)) {  			MinDist = Dist;  			jm1Store = jm1;  		}  	}  	jm1++;  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: if (jm1Store > -1) {  	lineB = triangleB.GetLine (jm1Store);  	found = IntersectionPoint (lineA' lineB' ref p);  	XYPoint HelpCoordinate = new XYPoint (p.X' p.Y);  	XYPoint HelpNode = new XYPoint (HelpCoordinate);  	intersectionPolygon.Points.Add (HelpNode);  	j = Increase (jm1Store' 2);  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: j = Increase (jm1Store' 2);  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: if (!found) {  	count1++;  	im1 = Increase (im1' 2);  	i = Increase (i' 2);  	if (j != -1) {  		XYPoint HelpCoordinate = new XYPoint (lineA.P2.X' lineA.P2.Y);  		XYPoint HelpNode = new XYPoint (HelpCoordinate);  		intersectionPolygon.Points.Add (HelpNode);  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: if (!found) {  	count1++;  	im1 = Increase (im1' 2);  	i = Increase (i' 2);  	if (j != -1) {  		XYPoint HelpCoordinate = new XYPoint (lineA.P2.X' lineA.P2.Y);  		XYPoint HelpNode = new XYPoint (HelpCoordinate);  		intersectionPolygon.Points.Add (HelpNode);  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: im1 = Increase (im1' 2);  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: i = Increase (i' 2);  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: lineA = triangleA.GetLine (Decrease (i' 2));  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: if (CalculatePointToPointDistance (p' lineA.P2) < EPSILON) {  	i = Increase (i' 2);  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: i = Increase (i' 2);  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: lineB = triangleB.GetLine (Decrease (j' 2));  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: if (CalculatePointToPointDistance (p' lineB.P2) < EPSILON) {  	j = Increase (j' 2);  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,Intersect,The following statement contains a magic number: j = Increase (j' 2);  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,CalculateLineToPointDistance,The following statement contains a magic number: if ((a == 0) || (c == 0)) {  	dist = 0;  }  else if (b == 0) {  	dist = a;  }  else {  	double alpha = Math.Acos ((b * b + c * c - a * a) / (2 * b * c));  	double beta = Math.Acos ((a * a + b * b - c * c) / (2 * a * b));  	if (Math.Max (alpha' beta) < Math.PI / 2) {  		dist = Math.Abs ((line.P2.X - line.P1.X) * (line.P1.Y - point.Y) - (line.P1.X - point.X) * (line.P2.Y - line.P1.Y)) / b;  	}  	else {  		dist = Math.Min (a' c);  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,CalculateLineToPointDistance,The following statement contains a magic number: if ((a == 0) || (c == 0)) {  	dist = 0;  }  else if (b == 0) {  	dist = a;  }  else {  	double alpha = Math.Acos ((b * b + c * c - a * a) / (2 * b * c));  	double beta = Math.Acos ((a * a + b * b - c * c) / (2 * a * b));  	if (Math.Max (alpha' beta) < Math.PI / 2) {  		dist = Math.Abs ((line.P2.X - line.P1.X) * (line.P1.Y - point.Y) - (line.P1.X - point.X) * (line.P2.Y - line.P1.Y)) / b;  	}  	else {  		dist = Math.Min (a' c);  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,CalculateLineToPointDistance,The following statement contains a magic number: if ((a == 0) || (c == 0)) {  	dist = 0;  }  else if (b == 0) {  	dist = a;  }  else {  	double alpha = Math.Acos ((b * b + c * c - a * a) / (2 * b * c));  	double beta = Math.Acos ((a * a + b * b - c * c) / (2 * a * b));  	if (Math.Max (alpha' beta) < Math.PI / 2) {  		dist = Math.Abs ((line.P2.X - line.P1.X) * (line.P1.Y - point.Y) - (line.P1.X - point.X) * (line.P2.Y - line.P1.Y)) / b;  	}  	else {  		dist = Math.Min (a' c);  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,CalculateLineToPointDistance,The following statement contains a magic number: if (b == 0) {  	dist = a;  }  else {  	double alpha = Math.Acos ((b * b + c * c - a * a) / (2 * b * c));  	double beta = Math.Acos ((a * a + b * b - c * c) / (2 * a * b));  	if (Math.Max (alpha' beta) < Math.PI / 2) {  		dist = Math.Abs ((line.P2.X - line.P1.X) * (line.P1.Y - point.Y) - (line.P1.X - point.X) * (line.P2.Y - line.P1.Y)) / b;  	}  	else {  		dist = Math.Min (a' c);  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,CalculateLineToPointDistance,The following statement contains a magic number: if (b == 0) {  	dist = a;  }  else {  	double alpha = Math.Acos ((b * b + c * c - a * a) / (2 * b * c));  	double beta = Math.Acos ((a * a + b * b - c * c) / (2 * a * b));  	if (Math.Max (alpha' beta) < Math.PI / 2) {  		dist = Math.Abs ((line.P2.X - line.P1.X) * (line.P1.Y - point.Y) - (line.P1.X - point.X) * (line.P2.Y - line.P1.Y)) / b;  	}  	else {  		dist = Math.Min (a' c);  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,CalculateLineToPointDistance,The following statement contains a magic number: if (b == 0) {  	dist = a;  }  else {  	double alpha = Math.Acos ((b * b + c * c - a * a) / (2 * b * c));  	double beta = Math.Acos ((a * a + b * b - c * c) / (2 * a * b));  	if (Math.Max (alpha' beta) < Math.PI / 2) {  		dist = Math.Abs ((line.P2.X - line.P1.X) * (line.P1.Y - point.Y) - (line.P1.X - point.X) * (line.P2.Y - line.P1.Y)) / b;  	}  	else {  		dist = Math.Min (a' c);  	}  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYGeometryTools,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYGeometryTools.cs,CalculateLineToPointDistance,The following statement contains a magic number: if (Math.Max (alpha' beta) < Math.PI / 2) {  	dist = Math.Abs ((line.P2.X - line.P1.X) * (line.P1.Y - point.Y) - (line.P1.X - point.X) * (line.P2.Y - line.P1.Y)) / b;  }  else {  	dist = Math.Min (a' c);  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYLine,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYLine.cs,GetMidpoint,The following statement contains a magic number: return new XYPoint ((_p1.X + _p2.X) / 2' (_p1.Y + _p2.Y) / 2);  
Magic Number,Oatc.UpwardsComp.Spatial,XYLine,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYLine.cs,GetMidpoint,The following statement contains a magic number: return new XYPoint ((_p1.X + _p2.X) / 2' (_p1.Y + _p2.Y) / 2);  
Magic Number,Oatc.UpwardsComp.Spatial,XYPoint,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYPoint.cs,XYPoint,The following statement contains a magic number: _x = -9999;  
Magic Number,Oatc.UpwardsComp.Spatial,XYPoint,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYPoint.cs,XYPoint,The following statement contains a magic number: _y = -9999;  
Magic Number,Oatc.UpwardsComp.Spatial,XYPolygon,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYPolygon.cs,GetArea,The following statement contains a magic number: area = 0.5 * area;  
Magic Number,Oatc.UpwardsComp.Spatial,XYPolygon,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYPolygon.cs,GetTriangulation,The following statement contains a magic number: while (LocalPolygon.Points.Count > 3) {  	int i = LocalPolygon.FindEar ();  	int n = LocalPolygon.Points.Count;  	int im1 = i - 1;  	int ip1 = i + 1;  	if (i == 0) {  		im1 = n - 1;  	}  	else if (i == n - 1) {  		ip1 = 0;  	}  	XYPoint Nodeim1 = new XYPoint ((XYPoint)LocalPolygon.Points [im1]);  	XYPoint Nodei = new XYPoint ((XYPoint)LocalPolygon.Points [i]);  	XYPoint Nodeip1 = new XYPoint ((XYPoint)LocalPolygon.Points [ip1]);  	XYPolygon Triangle = new XYPolygon ();  	Triangle.Points.Add (Nodeim1);  	Triangle.Points.Add (Nodei);  	Triangle.Points.Add (Nodeip1);  	TriangleList.Add (Triangle);  	LocalPolygon.Points.RemoveAt (i);  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYPolygon,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYPolygon.cs,Validate,The following statement contains a magic number: if (Points.Count < 3) {  	throw new Exception ("Number of vertices in polygon element is less than 3.");  }  
Magic Number,Oatc.UpwardsComp.Spatial,XYPolyline,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\XYPolyline.cs,Validate,The following statement contains a magic number: if (_points.Count < 2) {  	throw new Exception ("Number of vertices in polyline element is less than 2.");  }  
Duplicate Code,Oatc.UpwardsComp.Spatial,ElementMapper,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\UpdwardsCompatibleWrappers\Spatial\ElementMapper.cs,UpdateMappingMatrix,The method contains a code clone-set at the following line numbers (starting from the method definition): ((127' 160)' (245' 278))
