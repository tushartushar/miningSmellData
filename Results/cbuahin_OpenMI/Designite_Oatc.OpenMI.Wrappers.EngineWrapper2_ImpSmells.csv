Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Oatc.OpenMI.Wrappers.EngineWrapper2,ItemOutDoubleArrayBase,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\EngineWrapper2\ItemOutDoubleArrayBase.cs,CachePush,Cyclomatic complexity of the method is 10
Complex Method,Oatc.OpenMI.Wrappers.EngineWrapper2,ItemOutDoubleArrayBase,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\EngineWrapper2\ItemOutDoubleArrayBase.cs,CacheUpdateSource,Cyclomatic complexity of the method is 13
Complex Method,Oatc.OpenMI.Wrappers.EngineWrapper2,ItemOutDoubleBase,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\EngineWrapper2\ItemOutDoubleBase.cs,CachePush,Cyclomatic complexity of the method is 10
Long Statement,Oatc.OpenMI.Wrappers.EngineWrapper2,ItemBase,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\EngineWrapper2\ItemBase.cs,Initialise,The length of the statement  "	_iDescribable = new Describable (string.Format ("{0}' {1}"' _iValueDefinition.Caption' _iElementSet.Caption)' string.Format ("{0}' {1}"' _iValueDefinition.Description' _iElementSet.Description)); " is 195.
Long Statement,Oatc.OpenMI.Wrappers.EngineWrapper2,ItemOutBase,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\EngineWrapper2\ItemOutBase.cs,GetValues,The length of the statement  "		unavailable = Component.Status != LinkableComponentStatus.Initialized && Component.Status != LinkableComponentStatus.Updated && Component.Status != LinkableComponentStatus.Valid; " is 178.
Long Statement,Oatc.OpenMI.Wrappers.EngineWrapper2,ItemOutDoubleArrayBase,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\EngineWrapper2\ItemOutDoubleArrayBase.cs,CurrentState,The length of the statement  "	return string.Format ("Cache[{0}] = ({1} .. {2})"' _cache.Count.ToString ()' _cache.Count > 0 ? _cache [0].Time.ToString () : ""' _cache.Count > 0 ? _cache [_cache.Count - 1].Time.ToString () : ""); " is 198.
Long Statement,Oatc.OpenMI.Wrappers.EngineWrapper2,ItemOutDoubleBase,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\EngineWrapper2\ItemOutDoubleBase.cs,CurrentState,The length of the statement  "	return string.Format ("Cache[{0}] = ({1} .. {2})"' _cache.Count.ToString ()' _cache.Count > 0 ? _cache [0].Time.ToString () : ""' _cache.Count > 0 ? _cache [_cache.Count - 1].Time.ToString () : ""); " is 198.
Empty Catch Block,Oatc.OpenMI.Wrappers.EngineWrapper2,LinkableComponent,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\EngineWrapper2\LinkableComponent.cs,CatchTidyRethrow,The method has an empty catch block.
Empty Catch Block,Oatc.OpenMI.Wrappers.EngineWrapper2,LinkableComponent,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\EngineWrapper2\LinkableComponent.cs,Initialize,The method has an empty catch block.
Magic Number,Oatc.OpenMI.Wrappers.EngineWrapper2,ItemOutDoubleArrayBase,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\EngineWrapper2\ItemOutDoubleArrayBase.cs,CachePush,The following statement contains a magic number: if (timeLowest == null)  	_cache.Clear ();  else if (_cache.Count > 2) {  	// Only need to keep one value below lowest of consumers  	// for one point interpolation and minimum of 2 points  	// total for extrapolation  	int nLowest = 0;  	while (nLowest < _cache.Count && _cache [nLowest].Time < timeLowest.Value)  		++nLowest;  	if (nLowest == _cache.Count - 1)  		--nLowest;  	// maintain at least two items  	if (nLowest < _cache.Count && nLowest > 0)  		_cache.RemoveRange (0' nLowest);  	// O(n)  }  
Magic Number,Oatc.OpenMI.Wrappers.EngineWrapper2,ItemOutDoubleArrayBase,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\EngineWrapper2\ItemOutDoubleArrayBase.cs,CachePush,The following statement contains a magic number: if (_cache.Count > 2) {  	// Only need to keep one value below lowest of consumers  	// for one point interpolation and minimum of 2 points  	// total for extrapolation  	int nLowest = 0;  	while (nLowest < _cache.Count && _cache [nLowest].Time < timeLowest.Value)  		++nLowest;  	if (nLowest == _cache.Count - 1)  		--nLowest;  	// maintain at least two items  	if (nLowest < _cache.Count && nLowest > 0)  		_cache.RemoveRange (0' nLowest);  	// O(n)  }  
Magic Number,Oatc.OpenMI.Wrappers.EngineWrapper2,ItemOutDoubleArrayBase,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\EngineWrapper2\ItemOutDoubleArrayBase.cs,CacheUpdateSource,The following statement contains a magic number: if (nAbove == -1) {  	if (!forceCacheUpdate)  		return false;  	if (_cache.Count == 0)  		for (int n = 0; n < nValues; ++n)  			source.Values.SetValue (0' n' _initial.Values [n]);  	else if (_cache.Count == 1)  		for (int n = 0; n < nValues; ++n)  			source.Values.SetValue (0' n' _cache [0].Values [n]);  	else {  		DataPair prev = _cache [_cache.Count - 2];  		DataPair last = _cache [_cache.Count - 1];  		timeRatio = (required - prev.Time) / (last.Time - prev.Time);  		for (int n = 0; n < nValues; ++n) {  			extrapolated = prev.Values [n] + timeRatio * (last.Values [n] - prev.Values [n]);  			value = last.Values [n] + (1 - _relaxation) * (extrapolated - last.Values [n]);  			source.Values.SetValue (0' n' value);  		}  	}  	return true;  }  
Magic Number,Oatc.OpenMI.Wrappers.EngineWrapper2,ItemOutDoubleArrayBase,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\EngineWrapper2\ItemOutDoubleArrayBase.cs,CacheUpdateSource,The following statement contains a magic number: if (_cache.Count == 0)  	for (int n = 0; n < nValues; ++n)  		source.Values.SetValue (0' n' _initial.Values [n]);  else if (_cache.Count == 1)  	for (int n = 0; n < nValues; ++n)  		source.Values.SetValue (0' n' _cache [0].Values [n]);  else {  	DataPair prev = _cache [_cache.Count - 2];  	DataPair last = _cache [_cache.Count - 1];  	timeRatio = (required - prev.Time) / (last.Time - prev.Time);  	for (int n = 0; n < nValues; ++n) {  		extrapolated = prev.Values [n] + timeRatio * (last.Values [n] - prev.Values [n]);  		value = last.Values [n] + (1 - _relaxation) * (extrapolated - last.Values [n]);  		source.Values.SetValue (0' n' value);  	}  }  
Magic Number,Oatc.OpenMI.Wrappers.EngineWrapper2,ItemOutDoubleArrayBase,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\EngineWrapper2\ItemOutDoubleArrayBase.cs,CacheUpdateSource,The following statement contains a magic number: if (_cache.Count == 1)  	for (int n = 0; n < nValues; ++n)  		source.Values.SetValue (0' n' _cache [0].Values [n]);  else {  	DataPair prev = _cache [_cache.Count - 2];  	DataPair last = _cache [_cache.Count - 1];  	timeRatio = (required - prev.Time) / (last.Time - prev.Time);  	for (int n = 0; n < nValues; ++n) {  		extrapolated = prev.Values [n] + timeRatio * (last.Values [n] - prev.Values [n]);  		value = last.Values [n] + (1 - _relaxation) * (extrapolated - last.Values [n]);  		source.Values.SetValue (0' n' value);  	}  }  
Magic Number,Oatc.OpenMI.Wrappers.EngineWrapper2,ItemOutDoubleBase,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\EngineWrapper2\ItemOutDoubleBase.cs,CachePush,The following statement contains a magic number: if (timeLowest == null)  	_cache.Clear ();  else if (_cache.Count > 2) {  	// Only need to keep one value below lowest of consumers  	// for one point interpolation and minimum of 2 points  	// total for extrapolation  	int nLowest = 0;  	while (nLowest < _cache.Count && _cache [nLowest].Time < timeLowest.Value)  		++nLowest;  	if (nLowest == _cache.Count - 1)  		--nLowest;  	// maintain at least two items  	if (nLowest < _cache.Count && nLowest > 0)  		_cache.RemoveRange (0' nLowest);  	// O(n)  }  
Magic Number,Oatc.OpenMI.Wrappers.EngineWrapper2,ItemOutDoubleBase,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\EngineWrapper2\ItemOutDoubleBase.cs,CachePush,The following statement contains a magic number: if (_cache.Count > 2) {  	// Only need to keep one value below lowest of consumers  	// for one point interpolation and minimum of 2 points  	// total for extrapolation  	int nLowest = 0;  	while (nLowest < _cache.Count && _cache [nLowest].Time < timeLowest.Value)  		++nLowest;  	if (nLowest == _cache.Count - 1)  		--nLowest;  	// maintain at least two items  	if (nLowest < _cache.Count && nLowest > 0)  		_cache.RemoveRange (0' nLowest);  	// O(n)  }  
Magic Number,Oatc.OpenMI.Wrappers.EngineWrapper2,ItemOutDoubleBase,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\EngineWrapper2\ItemOutDoubleBase.cs,CacheUpdateSource,The following statement contains a magic number: if (nAbove == -1) {  	if (!forceCacheUpdate)  		return false;  	if (_cache.Count == 0)  		value = _initial.Value;  	else if (_cache.Count == 1)  		value = _cache [0].Value;  	else {  		DataPair prev = _cache [_cache.Count - 2];  		DataPair last = _cache [_cache.Count - 1];  		timeRatio = (required - prev.Time) / (last.Time - prev.Time);  		double extrapolated = prev.Value + timeRatio * (last.Value - prev.Value);  		value = last.Value + (1 - _relaxation) * (extrapolated - last.Value);  	}  	list.Add (new List<double> {  		value  	});  	source.Values = new TimeSpaceValueSet<double> (list);  	return true;  }  
Magic Number,Oatc.OpenMI.Wrappers.EngineWrapper2,ItemOutDoubleBase,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\EngineWrapper2\ItemOutDoubleBase.cs,CacheUpdateSource,The following statement contains a magic number: if (_cache.Count == 0)  	value = _initial.Value;  else if (_cache.Count == 1)  	value = _cache [0].Value;  else {  	DataPair prev = _cache [_cache.Count - 2];  	DataPair last = _cache [_cache.Count - 1];  	timeRatio = (required - prev.Time) / (last.Time - prev.Time);  	double extrapolated = prev.Value + timeRatio * (last.Value - prev.Value);  	value = last.Value + (1 - _relaxation) * (extrapolated - last.Value);  }  
Magic Number,Oatc.OpenMI.Wrappers.EngineWrapper2,ItemOutDoubleBase,C:\repos\cbuahin_OpenMI\Source\csharp\Oatc.OpenMI\Wrappers\EngineWrapper2\ItemOutDoubleBase.cs,CacheUpdateSource,The following statement contains a magic number: if (_cache.Count == 1)  	value = _cache [0].Value;  else {  	DataPair prev = _cache [_cache.Count - 2];  	DataPair last = _cache [_cache.Count - 1];  	timeRatio = (required - prev.Time) / (last.Time - prev.Time);  	double extrapolated = prev.Value + timeRatio * (last.Value - prev.Value);  	value = last.Value + (1 - _relaxation) * (extrapolated - last.Value);  }  
