Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiKeyBlob,Cyclomatic complexity of the method is 8
Complex Method,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,Verify,Cyclomatic complexity of the method is 8
Complex Method,InsertIcons,Program,F:\newReposMay17\einaregilsson_InsertIcons\Program.cs,Main,Cyclomatic complexity of the method is 11
Complex Method,Vestris.ResourceLib,DirectoryResource,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\DirectoryResource.cs,DirectoryResource,Cyclomatic complexity of the method is 8
Long Parameter List,Vestris.ResourceLib,DirectoryResource,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\DirectoryResource.cs,DirectoryResource,The method has 6 parameters.
Long Parameter List,Vestris.ResourceLib,Gdi32,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\Gdi32.cs,SetDIBitsToDevice,The method has 12 parameters.
Long Parameter List,Vestris.ResourceLib,Gdi32,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\Gdi32.cs,SetDIBitsToDevice,The method has 12 parameters.
Long Parameter List,Vestris.ResourceLib,Gdi32,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\Gdi32.cs,GetDIBits,The method has 7 parameters.
Long Parameter List,Vestris.ResourceLib,Gdi32,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\Gdi32.cs,CreateDIBSection,The method has 6 parameters.
Long Parameter List,Vestris.ResourceLib,IconDirectoryResource,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\IconDirectoryResource.cs,IconDirectoryResource,The method has 6 parameters.
Long Parameter List,Vestris.ResourceLib,IconImageResource,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\IconImageResource.cs,IconImageResource,The method has 6 parameters.
Long Parameter List,Vestris.ResourceLib,IconResource,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\IconResource.cs,IconResource,The method has 6 parameters.
Long Parameter List,Vestris.ResourceLib,Kernel32,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\Kernel32.cs,EnumResourceLanguages,The method has 5 parameters.
Long Parameter List,Vestris.ResourceLib,Kernel32,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\Kernel32.cs,UpdateResource,The method has 6 parameters.
Long Parameter List,Vestris.ResourceLib,Resource,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\Resource.cs,Resource,The method has 6 parameters.
Long Parameter List,Vestris.ResourceLib,Resource,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\Resource.cs,SaveTo,The method has 5 parameters.
Long Parameter List,Vestris.ResourceLib,ResourceInfo,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\ResourceInfo.cs,CreateResource,The method has 6 parameters.
Long Parameter List,Vestris.ResourceLib,ResourceInfo,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\ResourceInfo.cs,EnumResourceLanguages,The method has 5 parameters.
Long Statement,InsertIcons,Program,F:\newReposMay17\einaregilsson_InsertIcons\Program.cs,Main,The length of the statement  "					throw new ArgumentException ("Assembly is not strong named' InsertIcons can only re-sign assemblies' not sign unsigned assemblies."); " is 133.
Long Statement,InsertIcons,Program,F:\newReposMay17\einaregilsson_InsertIcons\Program.cs,Main,The length of the statement  "			Console.WriteLine (" {0} {1} inserted into {2}"' newIcon.Name.Id' Path.GetFileName (icoFile)' Path.GetFileName (assembly)); " is 123.
Long Statement,Vestris.ResourceLib,Resource,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\Resource.cs,LoadFrom,The length of the statement  "		hModule = Kernel32.LoadLibraryEx (filename' IntPtr.Zero' Kernel32.DONT_RESOLVE_DLL_REFERENCES | Kernel32.LOAD_LIBRARY_AS_DATAFILE); " is 131.
Long Statement,Vestris.ResourceLib,ResourceInfo,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\ResourceInfo.cs,Load,The length of the statement  "	_hModule = Kernel32.LoadLibraryEx (filename' IntPtr.Zero' Kernel32.DONT_RESOLVE_DLL_REFERENCES | Kernel32.LOAD_LIBRARY_AS_DATAFILE); " is 132.
Long Statement,Vestris.ResourceLib,ResourceInfo,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\ResourceInfo.cs,EnumResourceTypesImpl,The length of the statement  "	if (!Kernel32.EnumResourceNames (hModule' lpszType' new Kernel32.EnumResourceNamesDelegate (EnumResourceNamesImpl)' IntPtr.Zero)) " is 129.
Long Statement,Vestris.ResourceLib,ResourceInfo,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\ResourceInfo.cs,EnumResourceNamesImpl,The length of the statement  "	if (!Kernel32.EnumResourceLanguages (hModule' lpszType' lpszName' new Kernel32.EnumResourceLanguagesDelegate (EnumResourceLanguages)' IntPtr.Zero)) " is 147.
Complex Conditional,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The conditional expression  "(blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352)"  is complex.
Complex Conditional,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The conditional expression  "(blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344)"  is complex.
Complex Conditional,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The conditional expression  "(blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352)"  is complex.
Complex Conditional,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The conditional expression  "(blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344)"  is complex.
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToInt32LE,The following statement contains a magic number: return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToInt32LE,The following statement contains a magic number: return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToInt32LE,The following statement contains a magic number: return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToInt32LE,The following statement contains a magic number: return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToInt32LE,The following statement contains a magic number: return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToUInt32LE,The following statement contains a magic number: return (uint)((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToUInt32LE,The following statement contains a magic number: return (uint)((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToUInt32LE,The following statement contains a magic number: return (uint)((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToUInt32LE,The following statement contains a magic number: return (uint)((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToUInt32LE,The following statement contains a magic number: return (uint)((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,GetBytesLE,The following statement contains a magic number: return new byte[] {  	(byte)(val & 0xff)'  	(byte)((val >> 8) & 0xff)'  	(byte)((val >> 16) & 0xff)'  	(byte)((val >> 24) & 0xff)  };  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,GetBytesLE,The following statement contains a magic number: return new byte[] {  	(byte)(val & 0xff)'  	(byte)((val >> 8) & 0xff)'  	(byte)((val >> 16) & 0xff)'  	(byte)((val >> 24) & 0xff)  };  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,GetBytesLE,The following statement contains a magic number: return new byte[] {  	(byte)(val & 0xff)'  	(byte)((val >> 8) & 0xff)'  	(byte)((val >> 16) & 0xff)'  	(byte)((val >> 24) & 0xff)  };  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  	// DWORD magic = RSA2  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  	// DWORD magic = RSA2  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  	// DWORD magic = RSA2  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  	// DWORD magic  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  	// DWORD magic  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  	// DWORD magic  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: dsap.Q = new byte[20];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: pos += 20;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: dsap.X = new byte[20];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: pos += 20;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: pos += 4;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: dsap.Seed = new byte[20];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: pos += 20;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [5] = 0x24;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [8] = 0x52;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [9] = 0x53;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [10] = 0x41;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [11] = 0x32;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [12] = bitlen [0];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [13] = bitlen [1];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [14] = bitlen [2];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [14] = bitlen [2];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [15] = bitlen [3];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [15] = bitlen [3];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: pos = 20;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [5] = 0x22;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [8] = 0x44;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [9] = 0x53;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [10] = 0x53;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [11] = 0x32;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [12] = bitlen [0];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [13] = bitlen [1];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [14] = bitlen [2];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [14] = bitlen [2];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [15] = bitlen [3];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [15] = bitlen [3];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (part' 0' blob' pos' 20);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: pos += 20;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (part' 0' blob' pos' 20);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: pos += 20;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (GetBytesLE (p.Counter)' 0' blob' pos' 4);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: pos += 4;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (part' 0' blob' pos' 20);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if NET_2_1  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if NET_2_1  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if NET_2_1  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if NET_2_1  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if NET_2_1  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if NET_2_1  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if NET_2_1  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if NET_2_1  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if NET_2_1  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if NET_2_1  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if NET_2_1  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  	// DWORD magic = RSA1  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  	// DWORD magic = RSA1  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  	// DWORD magic = RSA1  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: rsap.Exponent = new byte[3];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: rsap.Exponent [0] = blob [offset + 18];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: rsap.Exponent [1] = blob [offset + 17];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: rsap.Exponent [2] = blob [offset + 16];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: rsap.Exponent [2] = blob [offset + 16];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  	// DWORD magic  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  	// DWORD magic  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  	// DWORD magic  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: dsap.Q = new byte[20];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: pos += 20;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: pos += 4;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: dsap.Seed = new byte[20];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: pos += 20;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [5] = 0x24;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [8] = 0x52;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [9] = 0x53;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [10] = 0x41;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [11] = 0x31;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [12] = bitlen [0];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [13] = bitlen [1];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [14] = bitlen [2];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [14] = bitlen [2];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [15] = bitlen [3];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [15] = bitlen [3];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: pos = 20;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [5] = 0x22;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [8] = 0x44;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [9] = 0x53;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [10] = 0x53;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [11] = 0x31;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [12] = bitlen [0];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [13] = bitlen [1];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [14] = bitlen [2];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [14] = bitlen [2];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [15] = bitlen [3];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [15] = bitlen [3];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (part' 0' blob' pos' 20);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: pos += 20;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (GetBytesLE (p.Counter)' 0' blob' pos' 4);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: pos += 4;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (part' 0' blob' pos' 20);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiKeyBlob,The following statement contains a magic number: switch (blob [offset]) {  case 0x00:  	// this could be a public key inside an header  	// like "sn -e" would produce  	if (blob [offset + 12] == 0x06) {  		return FromCapiPublicKeyBlob (blob' offset + 12);  	}  	break;  case 0x06:  	return FromCapiPublicKeyBlob (blob' offset);  case 0x07:  	return FromCapiPrivateKeyBlob (blob' offset);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiKeyBlob,The following statement contains a magic number: switch (blob [offset]) {  case 0x00:  	// this could be a public key inside an header  	// like "sn -e" would produce  	if (blob [offset + 12] == 0x06) {  		return FromCapiPublicKeyBlob (blob' offset + 12);  	}  	break;  case 0x06:  	return FromCapiPublicKeyBlob (blob' offset);  case 0x07:  	return FromCapiPrivateKeyBlob (blob' offset);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiKeyBlob,The following statement contains a magic number: if (blob [offset + 12] == 0x06) {  	return FromCapiPublicKeyBlob (blob' offset + 12);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiKeyBlob,The following statement contains a magic number: if (blob [offset + 12] == 0x06) {  	return FromCapiPublicKeyBlob (blob' offset + 12);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiKeyBlob,The following statement contains a magic number: return FromCapiPublicKeyBlob (blob' offset + 12);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromHexChar,The following statement contains a magic number: if ((c >= 'a') && (c <= 'f'))  	return (byte)(c - 'a' + 10);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromHexChar,The following statement contains a magic number: return (byte)(c - 'a' + 10);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromHexChar,The following statement contains a magic number: if ((c >= 'A') && (c <= 'F'))  	return (byte)(c - 'A' + 10);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromHexChar,The following statement contains a magic number: return (byte)(c - 'A' + 10);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromHex,The following statement contains a magic number: while (n < result.Length) {  	result [n] = (byte)(FromHexChar (hex [i++]) << 4);  	result [n++] += FromHexChar (hex [i++]);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromHex,The following statement contains a magic number: result [n] = (byte)(FromHexChar (hex [i++]) << 4);  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,StrongName,The following statement contains a magic number: if (data.Length == 16) {  	int i = 0;  	int sum = 0;  	while (i < data.Length)  		sum += data [i++];  	if (sum == 4) {  		// it is the ECMA key  		publicKey = (byte[])data.Clone ();  	}  } else {  	RSA = CryptoConvert.FromCapiKeyBlob (data);  	if (rsa == null)  		throw new ArgumentException ("data isn't a correctly encoded RSA public key");  }  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,StrongName,The following statement contains a magic number: if (data.Length == 16) {  	int i = 0;  	int sum = 0;  	while (i < data.Length)  		sum += data [i++];  	if (sum == 4) {  		// it is the ECMA key  		publicKey = (byte[])data.Clone ();  	}  } else {  	RSA = CryptoConvert.FromCapiKeyBlob (data);  	if (rsa == null)  		throw new ArgumentException ("data isn't a correctly encoded RSA public key");  }  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,StrongName,The following statement contains a magic number: if (sum == 4) {  	// it is the ECMA key  	publicKey = (byte[])data.Clone ();  }  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,RVAtoPosition,The following statement contains a magic number: for (int i = 0; i < sections; i++) {  	UInt32 p = BitConverter.ToUInt32 (headers' i * 40 + 20);  	UInt32 s = BitConverter.ToUInt32 (headers' i * 40 + 12);  	int l = (int)BitConverter.ToUInt32 (headers' i * 40 + 8);  	if ((s <= r) && (r < s + l)) {  		return p + r - s;  	}  }  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,RVAtoPosition,The following statement contains a magic number: for (int i = 0; i < sections; i++) {  	UInt32 p = BitConverter.ToUInt32 (headers' i * 40 + 20);  	UInt32 s = BitConverter.ToUInt32 (headers' i * 40 + 12);  	int l = (int)BitConverter.ToUInt32 (headers' i * 40 + 8);  	if ((s <= r) && (r < s + l)) {  		return p + r - s;  	}  }  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,RVAtoPosition,The following statement contains a magic number: for (int i = 0; i < sections; i++) {  	UInt32 p = BitConverter.ToUInt32 (headers' i * 40 + 20);  	UInt32 s = BitConverter.ToUInt32 (headers' i * 40 + 12);  	int l = (int)BitConverter.ToUInt32 (headers' i * 40 + 8);  	if ((s <= r) && (r < s + l)) {  		return p + r - s;  	}  }  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,RVAtoPosition,The following statement contains a magic number: for (int i = 0; i < sections; i++) {  	UInt32 p = BitConverter.ToUInt32 (headers' i * 40 + 20);  	UInt32 s = BitConverter.ToUInt32 (headers' i * 40 + 12);  	int l = (int)BitConverter.ToUInt32 (headers' i * 40 + 8);  	if ((s <= r) && (r < s + l)) {  		return p + r - s;  	}  }  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,RVAtoPosition,The following statement contains a magic number: for (int i = 0; i < sections; i++) {  	UInt32 p = BitConverter.ToUInt32 (headers' i * 40 + 20);  	UInt32 s = BitConverter.ToUInt32 (headers' i * 40 + 12);  	int l = (int)BitConverter.ToUInt32 (headers' i * 40 + 8);  	if ((s <= r) && (r < s + l)) {  		return p + r - s;  	}  }  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,RVAtoPosition,The following statement contains a magic number: for (int i = 0; i < sections; i++) {  	UInt32 p = BitConverter.ToUInt32 (headers' i * 40 + 20);  	UInt32 s = BitConverter.ToUInt32 (headers' i * 40 + 12);  	int l = (int)BitConverter.ToUInt32 (headers' i * 40 + 8);  	if ((s <= r) && (r < s + l)) {  		return p + r - s;  	}  }  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,StrongHash,The following statement contains a magic number: stream.Read (mz' 0' 128);  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,StrongHash,The following statement contains a magic number: cs.Write (mz' 0' 128);  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,StrongHash,The following statement contains a magic number: if (peHeader != 128) {  	byte[] mzextra = new byte[peHeader - 128];  	stream.Read (mzextra' 0' mzextra.Length);  	cs.Write (mzextra' 0' mzextra.Length);  }  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,StrongHash,The following statement contains a magic number: if (peHeader != 128) {  	byte[] mzextra = new byte[peHeader - 128];  	stream.Read (mzextra' 0' mzextra.Length);  	cs.Write (mzextra' 0' mzextra.Length);  }  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,StrongHash,The following statement contains a magic number: stream.Read (pe' 0' 248);  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,StrongHash,The following statement contains a magic number: if (BitConverter.ToUInt16 (pe' 4) != 0x14c)  	return null;  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,StrongHash,The following statement contains a magic number: Buffer.BlockCopy (v' 0' pe' 88' 4);  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,StrongHash,The following statement contains a magic number: Buffer.BlockCopy (v' 0' pe' 88' 4);  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,StrongHash,The following statement contains a magic number: Buffer.BlockCopy (v' 0' pe' 152' 8);  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,StrongHash,The following statement contains a magic number: Buffer.BlockCopy (v' 0' pe' 152' 8);  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,StrongHash,The following statement contains a magic number: cs.Write (pe' 0' 248);  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,StrongHash,The following statement contains a magic number: info.SignatureLength = BitConverter.ToUInt32 (cli' 36);  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,StrongHash,The following statement contains a magic number: info.MetadataLength = BitConverter.ToUInt32 (cli' 12);  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,StrongHash,The following statement contains a magic number: for (int i = 0; i < numSection; i++) {  	UInt32 start = BitConverter.ToUInt32 (sectionHeaders' i * 40 + 20);  	int length = (int)BitConverter.ToUInt32 (sectionHeaders' i * 40 + 16);  	byte[] section = new byte[length];  	stream.Position = start;  	stream.Read (section' 0' length);  	if ((start <= info.SignaturePosition) && (info.SignaturePosition < start + length)) {  		// hash before the signature  		int before = (int)(info.SignaturePosition - start);  		if (before > 0) {  			cs.Write (section' 0' before);  		}  		// copy signature  		info.Signature = new byte[info.SignatureLength];  		Buffer.BlockCopy (section' before' info.Signature' 0' (int)info.SignatureLength);  		Array.Reverse (info.Signature);  		// hash after the signature  		int s = (int)(before + info.SignatureLength);  		int after = (int)(length - s);  		if (after > 0) {  			cs.Write (section' s' after);  		}  	} else  		cs.Write (section' 0' length);  }  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,StrongHash,The following statement contains a magic number: for (int i = 0; i < numSection; i++) {  	UInt32 start = BitConverter.ToUInt32 (sectionHeaders' i * 40 + 20);  	int length = (int)BitConverter.ToUInt32 (sectionHeaders' i * 40 + 16);  	byte[] section = new byte[length];  	stream.Position = start;  	stream.Read (section' 0' length);  	if ((start <= info.SignaturePosition) && (info.SignaturePosition < start + length)) {  		// hash before the signature  		int before = (int)(info.SignaturePosition - start);  		if (before > 0) {  			cs.Write (section' 0' before);  		}  		// copy signature  		info.Signature = new byte[info.SignatureLength];  		Buffer.BlockCopy (section' before' info.Signature' 0' (int)info.SignatureLength);  		Array.Reverse (info.Signature);  		// hash after the signature  		int s = (int)(before + info.SignatureLength);  		int after = (int)(length - s);  		if (after > 0) {  			cs.Write (section' s' after);  		}  	} else  		cs.Write (section' 0' length);  }  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,StrongHash,The following statement contains a magic number: for (int i = 0; i < numSection; i++) {  	UInt32 start = BitConverter.ToUInt32 (sectionHeaders' i * 40 + 20);  	int length = (int)BitConverter.ToUInt32 (sectionHeaders' i * 40 + 16);  	byte[] section = new byte[length];  	stream.Position = start;  	stream.Read (section' 0' length);  	if ((start <= info.SignaturePosition) && (info.SignaturePosition < start + length)) {  		// hash before the signature  		int before = (int)(info.SignaturePosition - start);  		if (before > 0) {  			cs.Write (section' 0' before);  		}  		// copy signature  		info.Signature = new byte[info.SignatureLength];  		Buffer.BlockCopy (section' before' info.Signature' 0' (int)info.SignatureLength);  		Array.Reverse (info.Signature);  		// hash after the signature  		int s = (int)(before + info.SignatureLength);  		int after = (int)(length - s);  		if (after > 0) {  			cs.Write (section' s' after);  		}  	} else  		cs.Write (section' 0' length);  }  
Magic Number,Mono.Security,StrongName,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\StrongName.cs,StrongHash,The following statement contains a magic number: for (int i = 0; i < numSection; i++) {  	UInt32 start = BitConverter.ToUInt32 (sectionHeaders' i * 40 + 20);  	int length = (int)BitConverter.ToUInt32 (sectionHeaders' i * 40 + 16);  	byte[] section = new byte[length];  	stream.Position = start;  	stream.Read (section' 0' length);  	if ((start <= info.SignaturePosition) && (info.SignaturePosition < start + length)) {  		// hash before the signature  		int before = (int)(info.SignaturePosition - start);  		if (before > 0) {  			cs.Write (section' 0' before);  		}  		// copy signature  		info.Signature = new byte[info.SignatureLength];  		Buffer.BlockCopy (section' before' info.Signature' 0' (int)info.SignatureLength);  		Array.Reverse (info.Signature);  		// hash after the signature  		int s = (int)(before + info.SignatureLength);  		int after = (int)(length - s);  		if (after > 0) {  			cs.Write (section' s' after);  		}  	} else  		cs.Write (section' 0' length);  }  
Magic Number,InsertIcons,Program,F:\newReposMay17\einaregilsson_InsertIcons\Program.cs,Main,The following statement contains a magic number: try {  	string assembly = args [0];  	if (!File.Exists (assembly)) {  		throw new FileNotFoundException ("The file " + args [0] + " doesn't exist!");  	}  	List<string> iconFiles = GetIconFiles (args);  	VerifyIconFiles (iconFiles);  	string strongNameKeyFile = args.Length > 2 ? args [2] : null;  	//Verify that the assembly is signed to begin with. We don't support signing unsigned assemblies'  	//only re-signing them.  	if (strongNameKeyFile != null) {  		using (var stream = new FileStream (assembly' FileMode.Open' FileAccess.Read)) {  			var signature = new StrongName ().StrongHash (stream' StrongName.StrongNameOptions.Signature);  			if (signature.SignaturePosition == 0 && signature.SignatureLength == 0) {  				throw new ArgumentException ("Assembly is not strong named' InsertIcons can only re-sign assemblies' not sign unsigned assemblies.");  			}  		}  	}  	ushort iconMaxId = GetMaxIconId (assembly);  	int groupIconIdCounter = StartIconId;  	foreach (string icoFile in iconFiles) {  		groupIconIdCounter++;  		IconDirectoryResource newIcon = new IconDirectoryResource (new IconFile (icoFile));  		newIcon.Name.Id = new IntPtr (groupIconIdCounter);  		foreach (var icon in newIcon.Icons) {  			icon.Id = ++iconMaxId;  		}  		Console.WriteLine (" {0} {1} inserted into {2}"' newIcon.Name.Id' Path.GetFileName (icoFile)' Path.GetFileName (assembly));  		newIcon.SaveTo (assembly);  	}  	if (strongNameKeyFile != null) {  		ResignAssembly (assembly' strongNameKeyFile);  	}  	Console.WriteLine ("Successfully inserted {0} icons into {1}"' iconFiles.Count' Path.GetFileName (assembly));  	return 0;  } catch (Exception ex) {  	Console.Error.WriteLine ("error: {0}"' ex.Message);  	return 1;  }  
Magic Number,InsertIcons,Program,F:\newReposMay17\einaregilsson_InsertIcons\Program.cs,Main,The following statement contains a magic number: try {  	string assembly = args [0];  	if (!File.Exists (assembly)) {  		throw new FileNotFoundException ("The file " + args [0] + " doesn't exist!");  	}  	List<string> iconFiles = GetIconFiles (args);  	VerifyIconFiles (iconFiles);  	string strongNameKeyFile = args.Length > 2 ? args [2] : null;  	//Verify that the assembly is signed to begin with. We don't support signing unsigned assemblies'  	//only re-signing them.  	if (strongNameKeyFile != null) {  		using (var stream = new FileStream (assembly' FileMode.Open' FileAccess.Read)) {  			var signature = new StrongName ().StrongHash (stream' StrongName.StrongNameOptions.Signature);  			if (signature.SignaturePosition == 0 && signature.SignatureLength == 0) {  				throw new ArgumentException ("Assembly is not strong named' InsertIcons can only re-sign assemblies' not sign unsigned assemblies.");  			}  		}  	}  	ushort iconMaxId = GetMaxIconId (assembly);  	int groupIconIdCounter = StartIconId;  	foreach (string icoFile in iconFiles) {  		groupIconIdCounter++;  		IconDirectoryResource newIcon = new IconDirectoryResource (new IconFile (icoFile));  		newIcon.Name.Id = new IntPtr (groupIconIdCounter);  		foreach (var icon in newIcon.Icons) {  			icon.Id = ++iconMaxId;  		}  		Console.WriteLine (" {0} {1} inserted into {2}"' newIcon.Name.Id' Path.GetFileName (icoFile)' Path.GetFileName (assembly));  		newIcon.SaveTo (assembly);  	}  	if (strongNameKeyFile != null) {  		ResignAssembly (assembly' strongNameKeyFile);  	}  	Console.WriteLine ("Successfully inserted {0} icons into {1}"' iconFiles.Count' Path.GetFileName (assembly));  	return 0;  } catch (Exception ex) {  	Console.Error.WriteLine ("error: {0}"' ex.Message);  	return 1;  }  
Magic Number,Vestris.ResourceLib,DeviceIndependentBitmap,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\DeviceIndependentBitmap.cs,GetDIBRowWidth,The following statement contains a magic number: return (Int32)((width + 31) / 32) * 4;  
Magic Number,Vestris.ResourceLib,DeviceIndependentBitmap,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\DeviceIndependentBitmap.cs,GetDIBRowWidth,The following statement contains a magic number: return (Int32)((width + 31) / 32) * 4;  
Magic Number,Vestris.ResourceLib,DeviceIndependentBitmap,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\DeviceIndependentBitmap.cs,GetDIBRowWidth,The following statement contains a magic number: return (Int32)((width + 31) / 32) * 4;  
Magic Number,Vestris.ResourceLib,DirectoryResource,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\DirectoryResource.cs,DirectoryResource,The following statement contains a magic number: switch (resourceType) {  case Kernel32.ResourceTypes.RT_GROUP_CURSOR:  	_header.wType = 2;  	break;  case Kernel32.ResourceTypes.RT_GROUP_ICON:  	_header.wType = 1;  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Vestris.ResourceLib,DirectoryResource,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\DirectoryResource.cs,DirectoryResource,The following statement contains a magic number: _header.wType = 2;  
Magic Number,Vestris.ResourceLib,ResourceUtil,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\ResourceUtil.cs,PadToWORD,The following statement contains a magic number: if (pos % 2 != 0) {  	long count = 2 - pos % 2;  	Pad (w' (UInt16)count);  	pos += count;  }  
Magic Number,Vestris.ResourceLib,ResourceUtil,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\ResourceUtil.cs,PadToWORD,The following statement contains a magic number: if (pos % 2 != 0) {  	long count = 2 - pos % 2;  	Pad (w' (UInt16)count);  	pos += count;  }  
Magic Number,Vestris.ResourceLib,ResourceUtil,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\ResourceUtil.cs,PadToWORD,The following statement contains a magic number: if (pos % 2 != 0) {  	long count = 2 - pos % 2;  	Pad (w' (UInt16)count);  	pos += count;  }  
Magic Number,Vestris.ResourceLib,ResourceUtil,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\ResourceUtil.cs,MAKELANGID,The following statement contains a magic number: return (UInt16)((((UInt16)sub) << 10) | ((UInt16)primary));  
Magic Number,Vestris.ResourceLib,ResourceUtil,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\ResourceUtil.cs,SUBLANGID,The following statement contains a magic number: return (UInt16)(((UInt16)lcid) >> 10);  
Missing Default,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiKeyBlob,The following switch statement is missing a default case: switch (blob [offset]) {  case 0x00:  	// this could be a public key inside an header  	// like "sn -e" would produce  	if (blob [offset + 12] == 0x06) {  		return FromCapiPublicKeyBlob (blob' offset + 12);  	}  	break;  case 0x06:  	return FromCapiPublicKeyBlob (blob' offset);  case 0x07:  	return FromCapiPrivateKeyBlob (blob' offset);  }  
Missing Default,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\einaregilsson_InsertIcons\lib\Mono.Security\Cryptography\CryptoConvert.cs,FromCapiKeyBlobDSA,The following switch statement is missing a default case: switch (blob [offset]) {  case 0x06:  	return FromCapiPublicKeyBlobDSA (blob' offset);  case 0x07:  	return FromCapiPrivateKeyBlobDSA (blob' offset);  }  
Missing Default,Vestris.ResourceLib,ResourceInfo,F:\newReposMay17\einaregilsson_InsertIcons\lib\ResourceLib\ResourceInfo.cs,CreateResource,The following switch statement is missing a default case: switch (type.ResourceType) {  case Kernel32.ResourceTypes.RT_GROUP_ICON:  	return new IconDirectoryResource (hModule' hResourceGlobal' type' name' wIDLanguage' size);  }  
