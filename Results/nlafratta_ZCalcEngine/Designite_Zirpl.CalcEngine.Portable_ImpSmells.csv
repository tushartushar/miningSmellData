Implementation smell,Namespace,Class,File,Method,Description
Long Method,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The method has 179 lines of code.
Complex Method,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,ParseAtom,Cyclomatic complexity of the method is 28
Complex Method,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,Cyclomatic complexity of the method is 33
Complex Method,Zirpl.CalcEngine,BinaryExpression,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Expressions\BinaryExpression.cs,Evaluate,Cyclomatic complexity of the method is 23
Complex Method,Zirpl.CalcEngine,Tally,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Tally.cs,AddValue,Cyclomatic complexity of the method is 8
Long Statement,Zirpl.CalcEngine,BinaryExpression,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Expressions\BinaryExpression.cs,Optimize,The length of the statement  "	return _lft._token.Type == TokenType.LITERAL && _rgt._token.Type == TokenType.LITERAL ? new Expression (this.Evaluate ()) : this; " is 129.
Long Statement,Zirpl.CalcEngine,Statistical,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Statistical.cs,Register,The length of the statement  "	//CRITBINOM	Returns the smallest value for which the cumulative binomial distribution is less than or equal to a criterion value " is 128.
Long Statement,Zirpl.CalcEngine,Text,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Text.cs,Register,The length of the statement  "	//ce.RegisterFunction("ASC	Changes full-width (double-byte) English letters or katakana within a character string to half-width (single-byte) characters " is 152.
Long Statement,Zirpl.CalcEngine,Text,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Text.cs,Register,The length of the statement  "	//ce.RegisterFunction("JIS	Changes half-width (single-byte) English letters or katakana within a character string to full-width (double-byte) characters " is 152.
Complex Conditional,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The conditional expression  "_ptr < _len && (c == '|' || c == '&' || c == '>' || c == '<' || c == '=')"  is complex.
Complex Conditional,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The conditional expression  "!isLetter && c != '_' && (_idChars == null || _idChars.IndexOf (c) < 0)"  is complex.
Complex Conditional,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The conditional expression  "!isLetter && !isDigit && c != '_' && (_idChars == null || _idChars.IndexOf (c) < 0)"  is complex.
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: if (!isLetter && !isDigit) {  	// if this is a number starting with a decimal' don't parse as operator  	var nxt = _ptr + 1 < _len ? _expr [_ptr + 1] : 0;  	bool isNumber = c == _decimal && nxt >= '0' && nxt <= '9';  	if (!isNumber) {  		// look up localized list separator  		if (c == _listSep) {  			_token = new Token (c' TokenId.COMMA' TokenType.GROUP);  			_ptr++;  			return;  		}  		// look up single-char tokens on table  		/*                     foreach (var key in _tkTbl.Keys)                     {                         if (_expr.IndexOf(key' _ptr' StringComparison.OrdinalIgnoreCase) == _ptr)                         {                             _token = _tkTbl[key];                             _ptr += key.Length;                             return;                         }                     }                     */Token tk;  		if (_tkTbl.TryGetValue (c' out tk)) {  			// save token we found  			_token = tk;  			_ptr++;  			// look for double-char tokens (special case)  			if (_ptr < _len && (c == '|' || c == '&' || c == '>' || c == '<' || c == '=')) {  				if (_tkTbl.TryGetValue (_expr.Substring (_ptr - 1' 2)' out tk)) {  					_token = tk;  					_ptr++;  				}  			}  			// found token on the table  			return;  		}  		else if (_tkTbl.TryGetValue (_expr.Substring (_ptr' 2)' out tk)) {  			_token = tk;  			_ptr++;  			_ptr++;  			return;  		}  	}  }  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: if (!isLetter && !isDigit) {  	// if this is a number starting with a decimal' don't parse as operator  	var nxt = _ptr + 1 < _len ? _expr [_ptr + 1] : 0;  	bool isNumber = c == _decimal && nxt >= '0' && nxt <= '9';  	if (!isNumber) {  		// look up localized list separator  		if (c == _listSep) {  			_token = new Token (c' TokenId.COMMA' TokenType.GROUP);  			_ptr++;  			return;  		}  		// look up single-char tokens on table  		/*                     foreach (var key in _tkTbl.Keys)                     {                         if (_expr.IndexOf(key' _ptr' StringComparison.OrdinalIgnoreCase) == _ptr)                         {                             _token = _tkTbl[key];                             _ptr += key.Length;                             return;                         }                     }                     */Token tk;  		if (_tkTbl.TryGetValue (c' out tk)) {  			// save token we found  			_token = tk;  			_ptr++;  			// look for double-char tokens (special case)  			if (_ptr < _len && (c == '|' || c == '&' || c == '>' || c == '<' || c == '=')) {  				if (_tkTbl.TryGetValue (_expr.Substring (_ptr - 1' 2)' out tk)) {  					_token = tk;  					_ptr++;  				}  			}  			// found token on the table  			return;  		}  		else if (_tkTbl.TryGetValue (_expr.Substring (_ptr' 2)' out tk)) {  			_token = tk;  			_ptr++;  			_ptr++;  			return;  		}  	}  }  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: if (!isNumber) {  	// look up localized list separator  	if (c == _listSep) {  		_token = new Token (c' TokenId.COMMA' TokenType.GROUP);  		_ptr++;  		return;  	}  	// look up single-char tokens on table  	/*                     foreach (var key in _tkTbl.Keys)                     {                         if (_expr.IndexOf(key' _ptr' StringComparison.OrdinalIgnoreCase) == _ptr)                         {                             _token = _tkTbl[key];                             _ptr += key.Length;                             return;                         }                     }                     */Token tk;  	if (_tkTbl.TryGetValue (c' out tk)) {  		// save token we found  		_token = tk;  		_ptr++;  		// look for double-char tokens (special case)  		if (_ptr < _len && (c == '|' || c == '&' || c == '>' || c == '<' || c == '=')) {  			if (_tkTbl.TryGetValue (_expr.Substring (_ptr - 1' 2)' out tk)) {  				_token = tk;  				_ptr++;  			}  		}  		// found token on the table  		return;  	}  	else if (_tkTbl.TryGetValue (_expr.Substring (_ptr' 2)' out tk)) {  		_token = tk;  		_ptr++;  		_ptr++;  		return;  	}  }  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: if (!isNumber) {  	// look up localized list separator  	if (c == _listSep) {  		_token = new Token (c' TokenId.COMMA' TokenType.GROUP);  		_ptr++;  		return;  	}  	// look up single-char tokens on table  	/*                     foreach (var key in _tkTbl.Keys)                     {                         if (_expr.IndexOf(key' _ptr' StringComparison.OrdinalIgnoreCase) == _ptr)                         {                             _token = _tkTbl[key];                             _ptr += key.Length;                             return;                         }                     }                     */Token tk;  	if (_tkTbl.TryGetValue (c' out tk)) {  		// save token we found  		_token = tk;  		_ptr++;  		// look for double-char tokens (special case)  		if (_ptr < _len && (c == '|' || c == '&' || c == '>' || c == '<' || c == '=')) {  			if (_tkTbl.TryGetValue (_expr.Substring (_ptr - 1' 2)' out tk)) {  				_token = tk;  				_ptr++;  			}  		}  		// found token on the table  		return;  	}  	else if (_tkTbl.TryGetValue (_expr.Substring (_ptr' 2)' out tk)) {  		_token = tk;  		_ptr++;  		_ptr++;  		return;  	}  }  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: if (_tkTbl.TryGetValue (c' out tk)) {  	// save token we found  	_token = tk;  	_ptr++;  	// look for double-char tokens (special case)  	if (_ptr < _len && (c == '|' || c == '&' || c == '>' || c == '<' || c == '=')) {  		if (_tkTbl.TryGetValue (_expr.Substring (_ptr - 1' 2)' out tk)) {  			_token = tk;  			_ptr++;  		}  	}  	// found token on the table  	return;  }  else if (_tkTbl.TryGetValue (_expr.Substring (_ptr' 2)' out tk)) {  	_token = tk;  	_ptr++;  	_ptr++;  	return;  }  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: if (_tkTbl.TryGetValue (c' out tk)) {  	// save token we found  	_token = tk;  	_ptr++;  	// look for double-char tokens (special case)  	if (_ptr < _len && (c == '|' || c == '&' || c == '>' || c == '<' || c == '=')) {  		if (_tkTbl.TryGetValue (_expr.Substring (_ptr - 1' 2)' out tk)) {  			_token = tk;  			_ptr++;  		}  	}  	// found token on the table  	return;  }  else if (_tkTbl.TryGetValue (_expr.Substring (_ptr' 2)' out tk)) {  	_token = tk;  	_ptr++;  	_ptr++;  	return;  }  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: if (_ptr < _len && (c == '|' || c == '&' || c == '>' || c == '<' || c == '=')) {  	if (_tkTbl.TryGetValue (_expr.Substring (_ptr - 1' 2)' out tk)) {  		_token = tk;  		_ptr++;  	}  }  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: if (_tkTbl.TryGetValue (_expr.Substring (_ptr - 1' 2)' out tk)) {  	_token = tk;  	_ptr++;  }  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: if (_tkTbl.TryGetValue (_expr.Substring (_ptr' 2)' out tk)) {  	_token = tk;  	_ptr++;  	_ptr++;  	return;  }  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: if (isDigit || c == _decimal) {  	var div = -1;  	var sci = false;  	var pct = false;  	var val = 0.0;  	for (i = 0; i + _ptr < _len; i++) {  		c = _expr [_ptr + i];  		// digits always OK  		if (c >= '0' && c <= '9') {  			val = val * 10 + (c - '0');  			if (div > -1) {  				div *= 10;  			}  			continue;  		}  		// one decimal is OK  		if (c == _decimal && div < 0) {  			div = 1;  			continue;  		}  		// scientific notation?  		if ((c == 'E' || c == 'e') && !sci) {  			sci = true;  			c = _expr [_ptr + i + 1];  			if (c == '+' || c == '-')  				i++;  			continue;  		}  		// percentage?  		if (c == _percent) {  			pct = true;  			i++;  			break;  		}  		// end of literal  		break;  	}  	// end of number' get value  	if (!sci) {  		// much faster than ParseDouble  		if (div > 1) {  			val /= div;  		}  		if (pct) {  			val /= 100.0;  		}  	}  	else {  		var lit = _expr.Substring (_ptr' i);  		val = ParseDouble (lit' _ci);  	}  	// build token  	_token = new Token (val' TokenId.ATOM' TokenType.LITERAL);  	// advance pointer and return  	_ptr += i;  	return;  }  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: if (isDigit || c == _decimal) {  	var div = -1;  	var sci = false;  	var pct = false;  	var val = 0.0;  	for (i = 0; i + _ptr < _len; i++) {  		c = _expr [_ptr + i];  		// digits always OK  		if (c >= '0' && c <= '9') {  			val = val * 10 + (c - '0');  			if (div > -1) {  				div *= 10;  			}  			continue;  		}  		// one decimal is OK  		if (c == _decimal && div < 0) {  			div = 1;  			continue;  		}  		// scientific notation?  		if ((c == 'E' || c == 'e') && !sci) {  			sci = true;  			c = _expr [_ptr + i + 1];  			if (c == '+' || c == '-')  				i++;  			continue;  		}  		// percentage?  		if (c == _percent) {  			pct = true;  			i++;  			break;  		}  		// end of literal  		break;  	}  	// end of number' get value  	if (!sci) {  		// much faster than ParseDouble  		if (div > 1) {  			val /= div;  		}  		if (pct) {  			val /= 100.0;  		}  	}  	else {  		var lit = _expr.Substring (_ptr' i);  		val = ParseDouble (lit' _ci);  	}  	// build token  	_token = new Token (val' TokenId.ATOM' TokenType.LITERAL);  	// advance pointer and return  	_ptr += i;  	return;  }  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: if (isDigit || c == _decimal) {  	var div = -1;  	var sci = false;  	var pct = false;  	var val = 0.0;  	for (i = 0; i + _ptr < _len; i++) {  		c = _expr [_ptr + i];  		// digits always OK  		if (c >= '0' && c <= '9') {  			val = val * 10 + (c - '0');  			if (div > -1) {  				div *= 10;  			}  			continue;  		}  		// one decimal is OK  		if (c == _decimal && div < 0) {  			div = 1;  			continue;  		}  		// scientific notation?  		if ((c == 'E' || c == 'e') && !sci) {  			sci = true;  			c = _expr [_ptr + i + 1];  			if (c == '+' || c == '-')  				i++;  			continue;  		}  		// percentage?  		if (c == _percent) {  			pct = true;  			i++;  			break;  		}  		// end of literal  		break;  	}  	// end of number' get value  	if (!sci) {  		// much faster than ParseDouble  		if (div > 1) {  			val /= div;  		}  		if (pct) {  			val /= 100.0;  		}  	}  	else {  		var lit = _expr.Substring (_ptr' i);  		val = ParseDouble (lit' _ci);  	}  	// build token  	_token = new Token (val' TokenId.ATOM' TokenType.LITERAL);  	// advance pointer and return  	_ptr += i;  	return;  }  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: for (i = 0; i + _ptr < _len; i++) {  	c = _expr [_ptr + i];  	// digits always OK  	if (c >= '0' && c <= '9') {  		val = val * 10 + (c - '0');  		if (div > -1) {  			div *= 10;  		}  		continue;  	}  	// one decimal is OK  	if (c == _decimal && div < 0) {  		div = 1;  		continue;  	}  	// scientific notation?  	if ((c == 'E' || c == 'e') && !sci) {  		sci = true;  		c = _expr [_ptr + i + 1];  		if (c == '+' || c == '-')  			i++;  		continue;  	}  	// percentage?  	if (c == _percent) {  		pct = true;  		i++;  		break;  	}  	// end of literal  	break;  }  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: for (i = 0; i + _ptr < _len; i++) {  	c = _expr [_ptr + i];  	// digits always OK  	if (c >= '0' && c <= '9') {  		val = val * 10 + (c - '0');  		if (div > -1) {  			div *= 10;  		}  		continue;  	}  	// one decimal is OK  	if (c == _decimal && div < 0) {  		div = 1;  		continue;  	}  	// scientific notation?  	if ((c == 'E' || c == 'e') && !sci) {  		sci = true;  		c = _expr [_ptr + i + 1];  		if (c == '+' || c == '-')  			i++;  		continue;  	}  	// percentage?  	if (c == _percent) {  		pct = true;  		i++;  		break;  	}  	// end of literal  	break;  }  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: if (c >= '0' && c <= '9') {  	val = val * 10 + (c - '0');  	if (div > -1) {  		div *= 10;  	}  	continue;  }  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: if (c >= '0' && c <= '9') {  	val = val * 10 + (c - '0');  	if (div > -1) {  		div *= 10;  	}  	continue;  }  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: val = val * 10 + (c - '0');  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: if (div > -1) {  	div *= 10;  }  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: div *= 10;  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: if (!sci) {  	// much faster than ParseDouble  	if (div > 1) {  		val /= div;  	}  	if (pct) {  		val /= 100.0;  	}  }  else {  	var lit = _expr.Substring (_ptr' i);  	val = ParseDouble (lit' _ci);  }  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: if (pct) {  	val /= 100.0;  }  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,GetToken,The following statement contains a magic number: val /= 100.0;  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,ParseDouble,The following statement contains a magic number: if (str.Length > 0 && str [str.Length - 1] == ci.NumberFormat.PercentSymbol [0]) {  	str = str.Substring (0' str.Length - 1);  	return double.Parse (str' NumberStyles.Any' ci) / 100.0;  }  
Magic Number,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,ParseDouble,The following statement contains a magic number: return double.Parse (str' NumberStyles.Any' ci) / 100.0;  
Magic Number,Zirpl.CalcEngine,BinaryExpression,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Expressions\BinaryExpression.cs,Evaluate,The following statement contains a magic number: switch (_token.ID) {  case TokenId.AND:  	return (bool)_lft && (bool)_rgt;  case TokenId.OR:  	return (bool)_lft || (bool)_rgt;  case TokenId.ADD:  	return (double)_lft + (double)_rgt;  case TokenId.SUB:  	return (double)_lft - (double)_rgt;  case TokenId.MUL:  	return (double)_lft * (double)_rgt;  case TokenId.DIV:  	return (double)_lft / (double)_rgt;  case TokenId.DIVINT:  	return (double)(int)((double)_lft / (double)_rgt);  case TokenId.MOD:  	return (double)(int)((double)_lft % (double)_rgt);  case TokenId.POWER:  	var a = (double)_lft;  	var b = (double)_rgt;  	if (b == 0.0)  		return 1.0;  	if (b == 0.5)  		return Math.Sqrt (a);  	if (b == 1.0)  		return a;  	if (b == 2.0)  		return a * a;  	if (b == 3.0)  		return a * a * a;  	if (b == 4.0)  		return a * a * a * a;  	return Math.Pow ((double)_lft' (double)_rgt);  }  
Magic Number,Zirpl.CalcEngine,BinaryExpression,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Expressions\BinaryExpression.cs,Evaluate,The following statement contains a magic number: switch (_token.ID) {  case TokenId.AND:  	return (bool)_lft && (bool)_rgt;  case TokenId.OR:  	return (bool)_lft || (bool)_rgt;  case TokenId.ADD:  	return (double)_lft + (double)_rgt;  case TokenId.SUB:  	return (double)_lft - (double)_rgt;  case TokenId.MUL:  	return (double)_lft * (double)_rgt;  case TokenId.DIV:  	return (double)_lft / (double)_rgt;  case TokenId.DIVINT:  	return (double)(int)((double)_lft / (double)_rgt);  case TokenId.MOD:  	return (double)(int)((double)_lft % (double)_rgt);  case TokenId.POWER:  	var a = (double)_lft;  	var b = (double)_rgt;  	if (b == 0.0)  		return 1.0;  	if (b == 0.5)  		return Math.Sqrt (a);  	if (b == 1.0)  		return a;  	if (b == 2.0)  		return a * a;  	if (b == 3.0)  		return a * a * a;  	if (b == 4.0)  		return a * a * a * a;  	return Math.Pow ((double)_lft' (double)_rgt);  }  
Magic Number,Zirpl.CalcEngine,BinaryExpression,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Expressions\BinaryExpression.cs,Evaluate,The following statement contains a magic number: switch (_token.ID) {  case TokenId.AND:  	return (bool)_lft && (bool)_rgt;  case TokenId.OR:  	return (bool)_lft || (bool)_rgt;  case TokenId.ADD:  	return (double)_lft + (double)_rgt;  case TokenId.SUB:  	return (double)_lft - (double)_rgt;  case TokenId.MUL:  	return (double)_lft * (double)_rgt;  case TokenId.DIV:  	return (double)_lft / (double)_rgt;  case TokenId.DIVINT:  	return (double)(int)((double)_lft / (double)_rgt);  case TokenId.MOD:  	return (double)(int)((double)_lft % (double)_rgt);  case TokenId.POWER:  	var a = (double)_lft;  	var b = (double)_rgt;  	if (b == 0.0)  		return 1.0;  	if (b == 0.5)  		return Math.Sqrt (a);  	if (b == 1.0)  		return a;  	if (b == 2.0)  		return a * a;  	if (b == 3.0)  		return a * a * a;  	if (b == 4.0)  		return a * a * a * a;  	return Math.Pow ((double)_lft' (double)_rgt);  }  
Magic Number,Zirpl.CalcEngine,BinaryExpression,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Expressions\BinaryExpression.cs,Evaluate,The following statement contains a magic number: switch (_token.ID) {  case TokenId.AND:  	return (bool)_lft && (bool)_rgt;  case TokenId.OR:  	return (bool)_lft || (bool)_rgt;  case TokenId.ADD:  	return (double)_lft + (double)_rgt;  case TokenId.SUB:  	return (double)_lft - (double)_rgt;  case TokenId.MUL:  	return (double)_lft * (double)_rgt;  case TokenId.DIV:  	return (double)_lft / (double)_rgt;  case TokenId.DIVINT:  	return (double)(int)((double)_lft / (double)_rgt);  case TokenId.MOD:  	return (double)(int)((double)_lft % (double)_rgt);  case TokenId.POWER:  	var a = (double)_lft;  	var b = (double)_rgt;  	if (b == 0.0)  		return 1.0;  	if (b == 0.5)  		return Math.Sqrt (a);  	if (b == 1.0)  		return a;  	if (b == 2.0)  		return a * a;  	if (b == 3.0)  		return a * a * a;  	if (b == 4.0)  		return a * a * a * a;  	return Math.Pow ((double)_lft' (double)_rgt);  }  
Magic Number,Zirpl.CalcEngine,BinaryExpression,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Expressions\BinaryExpression.cs,Evaluate,The following statement contains a magic number: if (b == 0.5)  	return Math.Sqrt (a);  
Magic Number,Zirpl.CalcEngine,BinaryExpression,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Expressions\BinaryExpression.cs,Evaluate,The following statement contains a magic number: if (b == 2.0)  	return a * a;  
Magic Number,Zirpl.CalcEngine,BinaryExpression,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Expressions\BinaryExpression.cs,Evaluate,The following statement contains a magic number: if (b == 3.0)  	return a * a * a;  
Magic Number,Zirpl.CalcEngine,BinaryExpression,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Expressions\BinaryExpression.cs,Evaluate,The following statement contains a magic number: if (b == 4.0)  	return a * a * a * a;  
Magic Number,Zirpl.CalcEngine,Logical,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Logical.cs,Register,The following statement contains a magic number: ce.RegisterFunction ("IF"' 3' If);  
Magic Number,Zirpl.CalcEngine,Logical,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Logical.cs,If,The following statement contains a magic number: return (bool)p [0] ? p [1].Evaluate () : p [2].Evaluate ();  
Magic Number,Zirpl.CalcEngine,MathTrig,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\MathTrig.cs,Register,The following statement contains a magic number: ce.RegisterFunction ("ATAN2"' 2' Atan2);  
Magic Number,Zirpl.CalcEngine,MathTrig,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\MathTrig.cs,Register,The following statement contains a magic number: ce.RegisterFunction ("LOG"' 1' 2' Log);  
Magic Number,Zirpl.CalcEngine,MathTrig,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\MathTrig.cs,Register,The following statement contains a magic number: ce.RegisterFunction ("POWER"' 2' Power);  
Magic Number,Zirpl.CalcEngine,MathTrig,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\MathTrig.cs,Register,The following statement contains a magic number: ce.RegisterFunction ("RANDBETWEEN"' 2' RandBetween);  
Magic Number,Zirpl.CalcEngine,Statistical,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Statistical.cs,Register,The following statement contains a magic number: ce.RegisterFunction ("COUNTIF"' 2' CountIf);  
Magic Number,Zirpl.CalcEngine,Text,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction ("FIND"' 2' 3' Find);  
Magic Number,Zirpl.CalcEngine,Text,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction ("FIND"' 2' 3' Find);  
Magic Number,Zirpl.CalcEngine,Text,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction ("LEFT"' 1' 2' Left);  
Magic Number,Zirpl.CalcEngine,Text,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction ("MID"' 3' Mid);  
Magic Number,Zirpl.CalcEngine,Text,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction ("REPLACE"' 4' Replace);  
Magic Number,Zirpl.CalcEngine,Text,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction ("REPT"' 2' Rept);  
Magic Number,Zirpl.CalcEngine,Text,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction ("RIGHT"' 1' 2' Right);  
Magic Number,Zirpl.CalcEngine,Text,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction ("SEARCH"' 2' Search);  
Magic Number,Zirpl.CalcEngine,Text,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction ("SUBSTITUTE"' 3' 4' Substitute);  
Magic Number,Zirpl.CalcEngine,Text,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction ("SUBSTITUTE"' 3' 4' Substitute);  
Magic Number,Zirpl.CalcEngine,Text,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction ("TEXT"' 2' _Text);  
Magic Number,Zirpl.CalcEngine,Text,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Text.cs,IndexOf,The following statement contains a magic number: if (p.Count > 2) {  	start = (int)p [2] - 1;  }  
Magic Number,Zirpl.CalcEngine,Text,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Text.cs,IndexOf,The following statement contains a magic number: if (p.Count > 2) {  	start = (int)p [2] - 1;  }  
Magic Number,Zirpl.CalcEngine,Text,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Text.cs,IndexOf,The following statement contains a magic number: start = (int)p [2] - 1;  
Magic Number,Zirpl.CalcEngine,Text,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Text.cs,Mid,The following statement contains a magic number: return ((string)p [0]).Substring ((int)p [1] - 1' (int)p [2]);  
Magic Number,Zirpl.CalcEngine,Text,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Functions\Text.cs,Substitute,The following statement contains a magic number: if (p.Count == 3) {  	return text.Replace (oldText' newText);  }  
Missing Default,Zirpl.CalcEngine,CalculationEngine,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\CalculationEngine.cs,ParseAtom,The following switch statement is missing a default case: switch (_token.Type) {  // literals  case TokenType.LITERAL:  	x = new Expression (_token);  	break;  // identifiers  case TokenType.IDENTIFIER:  	// get identifier  	id = (string)_token.Value;  	// look for functions  	if (_fnTbl.TryGetValue (id' out fnDef)) {  		var p = GetParameters ();  		var pCnt = p == null ? 0 : p.Count;  		if (fnDef.ParmMin != -1 && pCnt < fnDef.ParmMin) {  			Throw ("Too few parameters.");  		}  		if (fnDef.ParmMax != -1 && pCnt > fnDef.ParmMax) {  			Throw ("Too many parameters.");  		}  		x = new FunctionExpression (fnDef' p);  		break;  	}  	// look for simple variables (much faster than binding!)  	if (_vars.ContainsKey (id)) {  		x = new VariableExpression (_vars' id);  		break;  	}  	// look for external objects  	var xObj = GetExternalObject (id);  	if (xObj != null) {  		x = new XObjectExpression (xObj);  		break;  	}  	// look for bindings  	if (DataContext != null) {  		var list = new List<BindingInfo> ();  		for (var t = _token; t != null; t = GetMember ()) {  			list.Add (new BindingInfo ((string)t.Value' GetParameters ()));  		}  		x = new BindingExpression (this' list' _ci);  		break;  	}  	Throw ("Unexpected identifier");  	break;  // sub-expressions  case TokenType.GROUP:  	// anything other than opening parenthesis is illegal here  	if (_token.ID != TokenId.OPEN) {  		Throw ("Expression expected.");  	}  	// get expression  	GetToken ();  	x = ParseLogical ();  	// check that the parenthesis was closed  	if (_token.ID != TokenId.CLOSE) {  		Throw ("Unbalanced parenthesis.");  	}  	break;  }  
Missing Default,Zirpl.CalcEngine,BinaryExpression,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Expressions\BinaryExpression.cs,Evaluate,The following switch statement is missing a default case: switch (_token.ID) {  case TokenId.GT:  	return cmp > 0;  case TokenId.LT:  	return cmp < 0;  case TokenId.GE:  	return cmp >= 0;  case TokenId.LE:  	return cmp <= 0;  case TokenId.EQ:  	return cmp == 0;  case TokenId.NE:  	return cmp != 0;  }  
Missing Default,Zirpl.CalcEngine,BinaryExpression,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Expressions\BinaryExpression.cs,Evaluate,The following switch statement is missing a default case: switch (_token.ID) {  case TokenId.AND:  	return (bool)_lft && (bool)_rgt;  case TokenId.OR:  	return (bool)_lft || (bool)_rgt;  case TokenId.ADD:  	return (double)_lft + (double)_rgt;  case TokenId.SUB:  	return (double)_lft - (double)_rgt;  case TokenId.MUL:  	return (double)_lft * (double)_rgt;  case TokenId.DIV:  	return (double)_lft / (double)_rgt;  case TokenId.DIVINT:  	return (double)(int)((double)_lft / (double)_rgt);  case TokenId.MOD:  	return (double)(int)((double)_lft % (double)_rgt);  case TokenId.POWER:  	var a = (double)_lft;  	var b = (double)_rgt;  	if (b == 0.0)  		return 1.0;  	if (b == 0.5)  		return Math.Sqrt (a);  	if (b == 1.0)  		return a;  	if (b == 2.0)  		return a * a;  	if (b == 3.0)  		return a * a * a;  	if (b == 4.0)  		return a * a * a * a;  	return Math.Pow ((double)_lft' (double)_rgt);  }  
Missing Default,Zirpl.CalcEngine,UnaryExpression,C:\repos\nlafratta_ZCalcEngine\Zirpl.CalcEngine.Portable\Expressions\UnaryExpression.cs,Evaluate,The following switch statement is missing a default case: switch (_token.ID) {  case TokenId.ADD:  	return +(double)_expr;  case TokenId.SUB:  	return -(double)_expr;  }  
