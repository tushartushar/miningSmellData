Implementation smell,Namespace,Class,File,Method,Description
Long Method,D_Parser.Completion.Providers,MethodOverrideCompletionProvider,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\MethodOverrideCompletionProvider.cs,GenerateOverridingMethodStub,The method has 81 lines of code.
Long Method,D_Parser.Completion.Providers,CtrlSpaceCompletionProvider,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\CtrlSpaceCompletionProvider.cs,BuildCompletionDataInternal,The method has 65 lines of code.
Long Method,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,DDocToMarkup,The method has 74 lines of code.
Long Method,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,VisitChildren,The method has 80 lines of code.
Long Method,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushNewLine,The method has 120 lines of code.
Long Method,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,Push,The method has 174 lines of code.
Long Method,D_Parser.Formatting.Indent,IndentStack,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,The method has 125 lines of code.
Long Method,D_Parser.Misc,GlobalParseCache,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\GlobalParseCache.cs,preparationTh,The method has 64 lines of code.
Long Method,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Type,The method has 134 lines of code.
Long Method,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Function,The method has 71 lines of code.
Long Method,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The method has 69 lines of code.
Long Method,D_Parser.Refactoring,SortImportsRefactoring,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\SortImportsRefactoring.cs,ResortImports,The method has 60 lines of code.
Long Method,D_Parser.Resolver,MixinAnalysis,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\MixinAnalysis.cs,GetMixinContent,The method has 65 lines of code.
Long Method,D_Parser.Resolver,ResultComparer,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ResultComparer.cs,IsImplicitlyConvertible,The method has 64 lines of code.
Long Method,D_Parser.Resolver,StaticProperties,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,StaticProperties,The method has 240 lines of code.
Long Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_BoolOp,The method has 82 lines of code.
Long Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The method has 115 lines of code.
Long Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalConcatenation,The method has 88 lines of code.
Long Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_EvalSpecToken,The method has 84 lines of code.
Long Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The method has 74 lines of code.
Long Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalMethodCall,The method has 165 lines of code.
Long Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,HandleDMethodOverload,The method has 71 lines of code.
Long Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,TryHandleMethodArgumentTuple,The method has 68 lines of code.
Long Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The method has 198 lines of code.
Long Method,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,The method has 64 lines of code.
Long Method,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,AccessArrayAtIndex,The method has 71 lines of code.
Long Method,D_Parser.Resolver.ResolutionHooks,bitfields,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\bitfields.cs,TryDeduce,The method has 63 lines of code.
Long Method,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,ResolveClassOrInterface,The method has 108 lines of code.
Long Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,SkipCurrentBlock,The method has 68 lines of code.
Long Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The method has 146 lines of code.
Long Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadTokenStringLiteral_IdentInit,The method has 82 lines of code.
Long Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The method has 204 lines of code.
Long Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The method has 155 lines of code.
Long Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The method has 238 lines of code.
Long Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,IsLetter,The method has 74 lines of code.
Long Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,DeclDef,The method has 178 lines of code.
Long Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Condition,The method has 127 lines of code.
Long Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Declaration,The method has 83 lines of code.
Long Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,AliasDeclaration,The method has 68 lines of code.
Long Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Decl,The method has 109 lines of code.
Long Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,BasicType,The method has 62 lines of code.
Long Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,BasicType2,The method has 79 lines of code.
Long Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,AttributeSpecifier,The method has 90 lines of code.
Long Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,IsAssignExpression,The method has 114 lines of code.
Long Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,UnaryExpression,The method has 78 lines of code.
Long Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,NewExpression,The method has 103 lines of code.
Long Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,PostfixExpression,The method has 126 lines of code.
Long Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,PrimaryExpression,The method has 346 lines of code.
Long Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ArrayLiteral,The method has 61 lines of code.
Long Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Statement,The method has 423 lines of code.
Long Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmStatement,The method has 162 lines of code.
Long Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmUnaryExpression,The method has 81 lines of code.
Long Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmPrimaryExpression,The method has 118 lines of code.
Long Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,TemplateParameter,The method has 105 lines of code.
Long Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,TemplateInstance,The method has 109 lines of code.
Complex Method,D_Parser.Completion.Providers,MethodOverrideCompletionProvider,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\MethodOverrideCompletionProvider.cs,GenerateOverridingMethodStub,Cyclomatic complexity of the method is 31
Complex Method,D_Parser.Completion.Providers,CtrlSpaceCompletionProvider,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\CtrlSpaceCompletionProvider.cs,IsBlockKw,Cyclomatic complexity of the method is 14
Complex Method,D_Parser.Completion.Providers,CtrlSpaceCompletionProvider,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\CtrlSpaceCompletionProvider.cs,BuildCompletionDataInternal,Cyclomatic complexity of the method is 27
Complex Method,D_Parser.Completion.Providers,ImportStatementCompletionProvider,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\ImportStatementCompletionProvider.cs,BuildCompletionDataInternal,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Completion.Providers,InlineAsmCompletionProvider,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\InlineAsmCompletionProvider.cs,InlineAsmCompletionProvider,Cyclomatic complexity of the method is 33
Complex Method,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,DDocToMarkup,Cyclomatic complexity of the method is 54
Complex Method,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,GenDelegateSignature,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,AppendParameters,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,AppendTemplateParams,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Dom,DBlockNode,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Nodes\DBlockNode.cs,GetMetaBlockStack,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Dom,DClassLike,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Nodes\OtherNodeDefinitions.cs,ToString,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Dom,EponymousTemplate,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Nodes\OtherNodeDefinitions.cs,ToString,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Dom,ModulePackage,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\ModulePackage.cs,GetEnumerator,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Dom,ImportStatement,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\ImportStatement.cs,ToCode,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Dom,ImportStatement,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\ImportStatement.cs,CreatePseudoAliases,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Dom,DNode,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Nodes\DNode.cs,ContainsPropertyAttribute,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Dom,DNode,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Nodes\DNode.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Dom,DelegateDeclaration,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\DDeclarations.cs,ToString,Cyclomatic complexity of the method is 14
Complex Method,D_Parser.Dom,DefaultDepthFirstVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\DefaultDepthFirstVisitor.cs,VisitBlock,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Dom,DefaultDepthFirstVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\DefaultDepthFirstVisitor.cs,Visit,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Dom,DefaultDepthFirstVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\DefaultDepthFirstVisitor.cs,VisitDNode,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Dom,DefaultDepthFirstVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\DefaultDepthFirstVisitor.cs,Visit,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Dom,DefaultDepthFirstVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\DefaultDepthFirstVisitor.cs,Visit,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Dom,DefaultDepthFirstVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\DefaultDepthFirstVisitor.cs,Visit,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Dom,DefaultDepthFirstVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\DefaultDepthFirstVisitor.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,EnforceBraceStyle,Cyclomatic complexity of the method is 27
Complex Method,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,FixIndentationForceNewLine,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,SearchLastNonWsChar,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,VisitChildren,Cyclomatic complexity of the method is 31
Complex Method,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,Visit,Cyclomatic complexity of the method is 16
Complex Method,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,Visit,Cyclomatic complexity of the method is 15
Complex Method,D_Parser.Formatting.Indent,IndentEngineWrapper,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CorrectIndent,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,TrimIndent,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushSlash,Cyclomatic complexity of the method is 16
Complex Method,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushColon,Cyclomatic complexity of the method is 15
Complex Method,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushOpenSq,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushOpenBrace,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushCloseBrace,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushNewLine,Cyclomatic complexity of the method is 30
Complex Method,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,Push,Cyclomatic complexity of the method is 84
Complex Method,D_Parser.Formatting.Indent,IndentStack,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,Cyclomatic complexity of the method is 57
Complex Method,D_Parser.Misc,CompletionOptions,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\CompletionOptions.cs,Load,Cyclomatic complexity of the method is 28
Complex Method,D_Parser.Misc,VersionIdEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\VersionIdEvaluation.cs,GetOSAndCPUVersions,Cyclomatic complexity of the method is 31
Complex Method,D_Parser.Misc,VersionIdEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\VersionIdEvaluation.cs,GetVersionIds,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Misc,GlobalParseCache,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\GlobalParseCache.cs,BeginAddOrUpdatePaths,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Misc,GlobalParseCache,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\GlobalParseCache.cs,preparationTh,Cyclomatic complexity of the method is 18
Complex Method,D_Parser.Misc,GlobalParseCache,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\GlobalParseCache.cs,parseTh,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Misc,GlobalParseCache,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\GlobalParseCache.cs,noticeFinish,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Misc,ConsoleLogger,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Logger.cs,Log,Cyclomatic complexity of the method is 17
Complex Method,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,MangledName,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,QualifiedName,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,RemoveNestedTemplateRefsFromQualifier,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Type,Cyclomatic complexity of the method is 71
Complex Method,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Function,Cyclomatic complexity of the method is 46
Complex Method,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Argument,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,Cyclomatic complexity of the method is 41
Complex Method,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,HexFloat,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Refactoring,SortImportsRefactoring,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\SortImportsRefactoring.cs,ResortImports,Cyclomatic complexity of the method is 17
Complex Method,D_Parser.Refactoring,SortImportsRefactoring,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\SortImportsRefactoring.cs,CalculateImportsToSort,Cyclomatic complexity of the method is 15
Complex Method,D_Parser.Refactoring,TypeReferenceFinder,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,VisitBlock,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Refactoring,TypeReferenceFinder,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,Visit,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Refactoring,TypeReferenceFinder,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,VisitAttributeMetaDeclarationBlock,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Refactoring,ClassInterfaceDerivativeFinder,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\ClassInterfaceDerivativeFinder.cs,HandleItem,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver,DTypeToTypeDeclVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\DTypeToTypeDeclVisitor.cs,VisitDSymbol,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver,MixinAnalysis,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\MixinAnalysis.cs,GetMixinContent,Cyclomatic complexity of the method is 18
Complex Method,D_Parser.Resolver,ResultComparer,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ResultComparer.cs,IsEqual,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver,ResultComparer,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ResultComparer.cs,IsImplicitlyConvertible,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver,StaticProperties,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,ListProperties,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver,MutableConditionFlagSet,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ConditionalCompilationFlags.cs,Add,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver,LooseResolution,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,SearchNodesByName,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver,LooseResolution,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,SearchNodesByName,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Resolver,LooseResolution,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,LookupIdRawly,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Resolver.ExpressionSemantics.CTFE,FunctionEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\CTFE\FunctionEvaluation.cs,AssignCallArgumentsToIC,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,Cyclomatic complexity of the method is 18
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalConcatenation,Cyclomatic complexity of the method is 22
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,mult,Cyclomatic complexity of the method is 25
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_WithAliases,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_EvalSpecToken,Cyclomatic complexity of the method is 41
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,GetStringType,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,Cyclomatic complexity of the method is 22
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalMethodCall,Cyclomatic complexity of the method is 39
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,HandleDMethodOverload,Cyclomatic complexity of the method is 17
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,TryHandleMethodArgumentTuple,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,GetRawCallOverloads,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalPostfixAccessExpression,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,AccessArrayAtIndex,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,SliceArray,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,Cyclomatic complexity of the method is 102
Complex Method,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetUnfilteredMethodOverloads,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetConstructors,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,Cyclomatic complexity of the method is 21
Complex Method,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,AccessArrayAtIndex,Cyclomatic complexity of the method is 17
Complex Method,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,Cyclomatic complexity of the method is 17
Complex Method,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,ResolveIdentifier,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,Cyclomatic complexity of the method is 21
Complex Method,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,Cyclomatic complexity of the method is 30
Complex Method,D_Parser.Resolver.ExpressionSemantics,AssocArrayPointer,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\LeftValues.cs,Set,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Resolver.ExpressionSemantics,MathOperationEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MathOperationEvaluation.cs,TryCalc,Cyclomatic complexity of the method is 27
Complex Method,D_Parser.Resolver.ExpressionSemantics,ArrayValue,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver.ExpressionSemantics,SymbolValueComparer,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\SymbolValueComparer.cs,IsEqual,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,IterateThroughScopeLayers,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,DeepScanClass,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,scanChildren,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,HandleAliasThisDeclarations,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,MatchesCompilationConditions,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,SearchAttributesForIsExprDecls,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,CanAddMemberOfType,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.ASTScanner,ConditionsFrame,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\ConditionsFrame.cs,GetNextMetaBlockOrStatStmt,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Resolver.ResolutionHooks,bitfields,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\bitfields.cs,TryDeduce,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver.ResolutionHooks,TupleHook,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\Tuple.cs,TryDeduce,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,Handle,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,Handle,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,Set,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,PreResolveTemplateArgs,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParamsAndFilterOverloads,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceOverloads,Cyclomatic complexity of the method is 14
Complex Method,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParam,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,ResolveFurtherTypeIdentifier,Cyclomatic complexity of the method is 19
Complex Method,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,ResetDeducedSymbols,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,HandleNodeMatch,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,GetMethodReturnType,Cyclomatic complexity of the method is 13
Complex Method,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,ResolveClassOrInterface,Cyclomatic complexity of the method is 31
Complex Method,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,SearchRegionAt,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,SearchRegionAt,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,FilterOutByResultPriority,Cyclomatic complexity of the method is 14
Complex Method,D_Parser.Resolver.TypeResolution,UFCSResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\UFCSResolver.cs,HandleItem,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver.TypeResolution,OpDispatchResolution,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\OpDispatchResolution.cs,TryResolveFurtherIdViaOpDispatch,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Completion,ParameterInsightResolution,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\ParameterInsightResolution.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Completion,CodeCompletion,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\CodeCompletion.cs,FindCurrentCaretContext,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Completion,CompletionProviderVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,Cyclomatic complexity of the method is 7
Complex Method,D_Parser,DocumentHelper,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\DocumentHelper.cs,GetOffsetByRelativeLocation,Cyclomatic complexity of the method is 9
Complex Method,D_Parser,StringExtension,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\StringExtension.cs,Trim,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,SkipCurrentBlock,Cyclomatic complexity of the method is 36
Complex Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,Cyclomatic complexity of the method is 65
Complex Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadTokenStringLiteral_IdentInit,Cyclomatic complexity of the method is 32
Complex Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadTokenStringLiteral_CurlyInit,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,TokenStringParsing_AppendToken,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,TokenStringParsing_AppendLiteralSubFormat,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadIdent,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,TryReadExplicitStringFormat,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadVerbatimString,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,Cyclomatic complexity of the method is 66
Complex Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,Cyclomatic complexity of the method is 43
Complex Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadComment,Cyclomatic complexity of the method is 15
Complex Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadMultiLineComment,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadSpecialTokenSequence,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,IsLetter,Cyclomatic complexity of the method is 67
Complex Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,IsDigit,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,IsHex,Cyclomatic complexity of the method is 23
Complex Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,Cyclomatic complexity of the method is 23
Complex Method,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ParseFloatValue,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,GetCurrentAttributeSet,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,OverPeekBrackets,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,DeclDef,Cyclomatic complexity of the method is 93
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,AttributeBlock,Cyclomatic complexity of the method is 13
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Condition,Cyclomatic complexity of the method is 45
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ImportBindings,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Declaration,Cyclomatic complexity of the method is 46
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,AliasDeclaration,Cyclomatic complexity of the method is 13
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Decl,Cyclomatic complexity of the method is 25
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,IsBasicType,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,BasicType,Cyclomatic complexity of the method is 13
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,BasicType2,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Declarator,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,DeclaratorSuffixes,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,IdentifierList,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Parameters,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Parameter,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,AttributeSpecifier,Cyclomatic complexity of the method is 46
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,AtAttribute,Cyclomatic complexity of the method is 18
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,IsAssignExpression,Cyclomatic complexity of the method is 29
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,CmpExpression,Cyclomatic complexity of the method is 28
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,AddExpression,Cyclomatic complexity of the method is 13
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,UnaryExpression,Cyclomatic complexity of the method is 30
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,NewExpression,Cyclomatic complexity of the method is 18
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,PostfixExpression,Cyclomatic complexity of the method is 48
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,PrimaryExpression,Cyclomatic complexity of the method is 149
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ArrayLiteral,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Statement,Cyclomatic complexity of the method is 187
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ForeachStatement,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmStatement,Cyclomatic complexity of the method is 52
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmRelExpression,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmUnaryExpression,Cyclomatic complexity of the method is 29
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmPrimaryExpression,Cyclomatic complexity of the method is 46
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,BlockStatement,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,AggregateDeclaration,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ClassDeclaration,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ClassBody,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,InterfaceDeclaration,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,FunctionBody,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,TemplateMixin,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,TemplateParameter,Cyclomatic complexity of the method is 17
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,TemplateInstance,Cyclomatic complexity of the method is 32
Complex Method,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,TraitsExpression,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Parser,DTokens,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DTokens.cs,RemoveVisMod,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Parser,DTokens,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DTokens.cs,GetDescription,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Parser,DTokens,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DTokens.cs,IsAssignOperator,Cyclomatic complexity of the method is 15
Complex Method,D_Parser.Parser,DTokens,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DTokens.cs,IsBasicType,Cyclomatic complexity of the method is 25
Complex Method,D_Parser.Parser,DTokens,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DTokens.cs,IsBasicType_FloatingPoint,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Parser,DTokens,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DTokens.cs,IsBasicType_Integral,Cyclomatic complexity of the method is 15
Complex Method,D_Parser.Parser,DTokens,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DTokens.cs,IsMemberFunctionAttribute,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser,DTokens,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DTokens.cs,IsMetaIdentifier,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Parser,DTokens,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DTokens.cs,IsModifier,Cyclomatic complexity of the method is 24
Complex Method,D_Parser.Parser,DTokens,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DTokens.cs,IsParamModifier,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser,DTokens,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DTokens.cs,IsStorageClass,Cyclomatic complexity of the method is 18
Complex Method,D_Parser.Parser,DDocParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,MacroName,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Parser,DDocParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,Parameters,Cyclomatic complexity of the method is 16
Complex Method,D_Parser.Parser,DDocParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,SkipParameterText,Cyclomatic complexity of the method is 18
Complex Method,D_Parser.Parser,DDocParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,SkipHtmlComment,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Parser,DDocParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,SkipString,Cyclomatic complexity of the method is 13
Complex Method,D_Parser.Dom.Statements,ForeachStatement,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Statements\ForeachStatement.cs,ToCode,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Dom.Expressions,NewExpression,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Expressions\NewExpression.cs,ToString,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Dom.Expressions,AnonymousClassExpression,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Expressions\AnonymousClassExpression.cs,ToString,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Dom.Expressions,TemplateInstanceExpression,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Expressions\TemplateInstanceExpression.cs,ToString,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Dom.Expressions,FunctionLiteral,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Expressions\FunctionLiteral.cs,ToString,Cyclomatic complexity of the method is 7
Complex Method,D_Parser.Dom.Expressions,IsExpression,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Expressions\IsExpression.cs,ToString,Cyclomatic complexity of the method is 7
Long Parameter List,D_Parser.Completion.Providers,CtrlSpaceCompletionProvider,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\CtrlSpaceCompletionProvider.cs,CtrlSpaceCompletionProvider,The method has 4 parameters.
Long Parameter List,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,AppendFormat,The method has 6 parameters.
Long Parameter List,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,GenTooltipSignature,The method has 5 parameters.
Long Parameter List,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,GenDelegateSignature,The method has 4 parameters.
Long Parameter List,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,AppendParameters,The method has 4 parameters.
Long Parameter List,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,S,The method has 6 parameters.
Long Parameter List,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,AttributesTypeAndName,The method has 5 parameters.
Long Parameter List,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,AppendTemplateParams,The method has 4 parameters.
Long Parameter List,D_Parser.Dom,ParserError,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\ParserError.cs,ParserError,The method has 4 parameters.
Long Parameter List,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,HashEnum,The method has 5 parameters.
Long Parameter List,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,HashEnum,The method has 4 parameters.
Long Parameter List,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,HashEnum,The method has 4 parameters.
Long Parameter List,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,HashEnum,The method has 4 parameters.
Long Parameter List,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,HashEnum,The method has 4 parameters.
Long Parameter List,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,HashEnum,The method has 4 parameters.
Long Parameter List,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,HashEnum,The method has 4 parameters.
Long Parameter List,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,HashEnum,The method has 4 parameters.
Long Parameter List,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,HashEnum,The method has 4 parameters.
Long Parameter List,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,ApplyChanges,The method has 4 parameters.
Long Parameter List,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,DFormattingVisitor,The method has 4 parameters.
Long Parameter List,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,EnforceBraceStyle,The method has 4 parameters.
Long Parameter List,D_Parser.Formatting,Formatter,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Formatter.cs,FormatCode,The method has 5 parameters.
Long Parameter List,D_Parser.Formatting.Indent,IndentEngineWrapper,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CalculateIndent,The method has 4 parameters.
Long Parameter List,D_Parser.Formatting.Indent,IndentEngineWrapper,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CalculateIndent,The method has 4 parameters.
Long Parameter List,D_Parser.Formatting.Indent,IndentEngineWrapper,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CorrectIndent,The method has 7 parameters.
Long Parameter List,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,IndentEngine,The method has 4 parameters.
Long Parameter List,D_Parser.Formatting.Indent,IndentStack,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,The method has 4 parameters.
Long Parameter List,D_Parser.Formatting.Indent,IndentStack,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,The method has 5 parameters.
Long Parameter List,D_Parser.Misc,VersionIdEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\VersionIdEvaluation.cs,GetVersionIds,The method has 4 parameters.
Long Parameter List,D_Parser.Misc,ParsingFinishedEventArgs,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\GlobalParseCache.cs,ParsingFinishedEventArgs,The method has 5 parameters.
Long Parameter List,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Demangle,The method has 4 parameters.
Long Parameter List,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Function,The method has 4 parameters.
Long Parameter List,D_Parser.Refactoring,ReferencesFinder,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\ReferencesFinder.cs,SearchModuleForASTNodeReferences,The method has 4 parameters.
Long Parameter List,D_Parser.Refactoring,SortImportsRefactoring,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\SortImportsRefactoring.cs,ResortImports,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver,ConditionalCompilation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ConditionalCompilation.cs,EnumConditions,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver,ClassType,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\DType.cs,ClassType,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver,TemplateIntermediateType,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\DType.cs,TemplateIntermediateType,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver,MixinAnalysis,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\MixinAnalysis.cs,GetMixinContent,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver,StaticProperties,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,ListProperties,The method has 5 parameters.
Long Parameter List,D_Parser.Resolver,StaticProperties,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,TryEvalPropertyType,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver,ResolutionContext,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ResolutionContext.cs,Create,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver,ResolutionContext,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ResolutionContext.cs,ResolutionContext,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver,ConditionalCompilationFlags,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ConditionalCompilationFlags.cs,ConditionalCompilationFlags,The method has 5 parameters.
Long Parameter List,D_Parser.Resolver,LooseResolution,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,ResolveTypeLoosely,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver,LooseResolution,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,ResolveTypeLoosely,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver,LooseResolution,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,SearchNodesByName,The method has 5 parameters.
Long Parameter List,D_Parser.Resolver.ExpressionSemantics.CTFE,FunctionEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\CTFE\FunctionEvaluation.cs,AssignCallArgumentsToIC,The method has 5 parameters.
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,TryDoCTFEOrGetValueRefs,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,HandleSingleMathOp,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,HandleSingleMathOp,The method has 5 parameters.
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalMethodCall,The method has 9 parameters.
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,HandleDMethodOverload,The method has 9 parameters.
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,HandleCallDelegateType,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,TryHandleMethodArgumentTuple,The method has 7 parameters.
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,GetRawCallOverloads,The method has 5 parameters.
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalPostfixAccessExpression,The method has 7 parameters.
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetRawCallOverloads,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetUnfilteredMethodOverloads_Helper,The method has 6 parameters.
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetAccessedOverloads,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,AccessArrayAtIndex,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,ResolveIdentifier,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetOverloads,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,prepareMemberTraitExpression,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,MathOperationEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MathOperationEvaluation.cs,TryCalc,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,PrimitiveValue,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,PrimitiveValue,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.ASTScanner,NameScan,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\NameScan.cs,SearchAndResolve,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.ASTScanner,SingleNodeNameScan,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\NameScan.cs,SearchChildrenAndResolve,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.ASTScanner,SingleNodeNameScan,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\NameScan.cs,SearchChildrenAndResolve,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParamsAndFilterOverloads,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParamsAndFilterOverloads,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceOverloads,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParams,The method has 6 parameters.
Long Parameter List,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParam,The method has 5 parameters.
Long Parameter List,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,CheckAndDeduceTypeAgainstTplParameter,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,CheckAndDeduceTypeTuple,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,ResolveFurtherTypeIdentifier,The method has 5 parameters.
Long Parameter List,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,HandleNodeMatch,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,HandleNodeMatches,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,ResolveClassOrInterface,The method has 5 parameters.
Long Parameter List,D_Parser.Resolver.TypeResolution,UFCSResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\UFCSResolver.cs,UFCSResolver,The method has 4 parameters.
Long Parameter List,D_Parser.Resolver.TypeResolution,UFCSResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\UFCSResolver.cs,TryResolveUFCS,The method has 5 parameters.
Long Parameter List,D_Parser.Resolver.TypeResolution,OpDispatchResolution,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\OpDispatchResolution.cs,TryResolveFurtherIdViaOpDispatch,The method has 4 parameters.
Long Parameter List,D_Parser.Completion,ParameterInsightResolution,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\ParameterInsightResolution.cs,ParameterInsightResolution,The method has 4 parameters.
Long Parameter List,D_Parser.Completion,ParameterInsightResolution,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\ParameterInsightResolution.cs,HandleNewExpression_Ctor,The method has 4 parameters.
Long Parameter List,D_Parser.Completion,ParameterInsightResolution,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\ParameterInsightResolution.cs,CalculateCurrentArgument,The method has 5 parameters.
Long Parameter List,D_Parser.Completion,MemberCompletionEnumeration,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\MemberCompletionEnumeration.cs,EnumAllAvailableMembers,The method has 6 parameters.
Long Parameter List,D_Parser.Completion,MemberCompletionEnumeration,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\MemberCompletionEnumeration.cs,EnumChildren,The method has 4 parameters.
Long Parameter List,D_Parser.Completion,MemberCompletionEnumeration,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\MemberCompletionEnumeration.cs,EnumChildren,The method has 6 parameters.
Long Parameter List,D_Parser.Completion,CodeCompletion,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\CodeCompletion.cs,GenerateCompletionData,The method has 4 parameters.
Long Parameter List,D_Parser.Completion,CodeCompletion,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\CodeCompletion.cs,DoTimeoutableCompletionTask,The method has 4 parameters.
Long Parameter List,D_Parser.Completion,CodeCompletion,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\CodeCompletion.cs,DoTimeoutableCompletionTask,The method has 4 parameters.
Long Parameter List,D_Parser,DocumentHelper,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\DocumentHelper.cs,GetOffsetByRelativeLocation,The method has 4 parameters.
Long Parameter List,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Token,The method has 7 parameters.
Long Parameter List,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Token,The method has 9 parameters.
Long Parameter List,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Token,The method has 4 parameters.
Long Parameter List,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Token,The method has 4 parameters.
Long Parameter List,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Statement,The method has 4 parameters.
Long Parameter List,D_Parser.Parser,Comment,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DToken.cs,Comment,The method has 5 parameters.
Long Parameter List,D_Parser.Parser,IncrementalParsing,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\IncrementalParsing.cs,UpdateBlockPartly,The method has 5 parameters.
Long Parameter List,D_Parser.Parser,IncrementalParsing,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\IncrementalParsing.cs,UpdateBlockPartly,The method has 5 parameters.
Long Parameter List,D_Parser.Parser,DDocParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,FindNextMacro,The method has 6 parameters.
Long Parameter List,D_Parser.Dom.Expressions,IdentifierExpression,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Expressions\IdentifierExpression.cs,IdentifierExpression,The method has 4 parameters.
Long Identifier,D_Parser.Completion.Providers,MethodOverrideCompletionProvider,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\MethodOverrideCompletionProvider.cs,GenerateOverridingMethodStub,The length of the parameter generateExecuteSuperFunctionStmt is 32.
Long Identifier,D_Parser.Dom,DNode,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Nodes\DNode.cs,ContainsPropertyAttribute,The length of the parameter userDefinedAttributeExpression is 30.
Long Identifier,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The length of the parameter includeFinalNonOverridingMethods is 32.
Long Identifier,D_Parser.Resolver.Templates,SpecializationOrdering,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\SpecializationOrdering.cs,FilterFromMostToLeastSpecialized,The length of the parameter lastEquallySpecializedOverloads is 31.
Long Identifier,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The length of the parameter paramTix_TemplateMatchPossibilities is 35.
Long Identifier,D_Parser.Completion,CodeCompletion,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\CodeCompletion.cs,GenerateCompletionData,The length of the parameter alreadyCheckedCompletionContext is 31.
Long Statement,D_Parser.Completion.Providers,MethodOverrideCompletionProvider,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\MethodOverrideCompletionProvider.cs,BuildCompletionDataInternal,The length of the statement  "	CodeCompletion.DoTimeoutableCompletionTask (null' ctxt' () => classType = DResolver.ResolveClassOrInterface (dc' ctxt' null) as TemplateIntermediateType); " is 154.
Long Statement,D_Parser.Completion.Providers,MethodOverrideCompletionProvider,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\MethodOverrideCompletionProvider.cs,BuildCompletionDataInternal,The length of the statement  "			CompletionDataGenerator.AddCodeGeneratingNodeItem (dm' GenerateOverridingMethodStub (dm' begunNode' !(t is InterfaceType))); " is 124.
Long Statement,D_Parser.Completion.Providers,CtrlSpaceCompletionProvider,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\CtrlSpaceCompletionProvider.cs,IsBlockKw,The length of the statement  "		return DTokens.IsBasicType (tk) || DTokens.IsClassLike (tk) || DTokens.IsStorageClass (tk) || DTokens.IsParamModifier (tk) || DTokens.IsVisibilityModifier (tk); " is 160.
Long Statement,D_Parser.Completion.Providers,CtrlSpaceCompletionProvider,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\CtrlSpaceCompletionProvider.cs,BuildCompletionDataInternal,The length of the statement  "	MemberCompletionEnumeration.EnumAllAvailableMembers (CompletionDataGenerator' curBlock' Editor.CaretLocation' Editor.ParseCache' visibleMembers' new ConditionalCompilationFlags (Editor)); " is 187.
Long Statement,D_Parser.Completion.Providers,CtrlSpaceCompletionProvider,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\CtrlSpaceCompletionProvider.cs,BuildCompletionDataInternal,The length of the statement  "		CompletionDataGenerator.AddTextItem ("seg"' "The seg means load the segment number that the symbol is in. This is not relevant for flat model code. Instead' do a move from the relevant segment register."); " is 205.
Long Statement,D_Parser.Completion.Providers,MemberCompletionProvider,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\MemberCompletionProvider.cs,VisitTemplateParameterSymbol,The length of the statement  "		var tpp = tps.Parameter is TemplateThisParameter ? (tps.Parameter as TemplateThisParameter).FollowParameter : tps.Parameter; " is 124.
Long Statement,D_Parser.Completion.Providers,SelectiveImportCompletionProvider,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\SelectiveImportCompletionProvider.cs,BuildCompletionDataInternal,The length of the statement  "	var module = Editor.ParseCache.LookupModuleName (Editor.SyntaxTree' import.ModuleIdentifier.ToString (true)).FirstOrDefault (); " is 127.
Long Statement,D_Parser.Completion.Providers,AbstractCompletionProvider,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\AbstractCompletionProvider.cs,CanItemBeShownGenerally,The length of the statement  "		if (dm.SpecialType == DMethod.MethodType.Unittest || dm.SpecialType == DMethod.MethodType.Destructor || dm.SpecialType == DMethod.MethodType.Constructor) " is 153.
Long Statement,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,GenTooltipSignature,The length of the statement  "		return GenTooltipSignature (aliasedSymbol == null || currentMethodParam >= 0 ? ds.Definition : aliasedSymbol.aliasDefinition' templateParamCompletion' currentMethodParam' DTypeToTypeDeclVisitor.GenerateTypeDecl (ds.Base)' new DeducedTypeDictionary (ds)); " is 254.
Long Statement,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,GenDelegateSignature,The length of the statement  "		S ((dt.delegateTypeBase as FunctionLiteral).AnonymousMethod' sb' templArgs' curArg' DTypeToTypeDeclVisitor.GenerateTypeDecl (dt.ReturnType)); " is 141.
Long Statement,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,AppendParameters,The length of the statement  "		var isOpt = (this.SignatureFlags & TooltipSignatureFlags.NoDefaultParams) == 0 && parm is DVariable && (parm as DVariable).Initializer != null; " is 143.
Long Statement,D_Parser.Dom,DBlockNode,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Nodes\DBlockNode.cs,GetMetaBlockStack,The length of the statement  "		if (lastSr != null && !(mindAttributeSections && lastSr is AttributeMetaDeclarationSection) && mb.Location < lastSr.Location && mb.EndLocation > lastSr.EndLocation) " is 164.
Long Statement,D_Parser.Dom,DBlockNode,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Nodes\DBlockNode.cs,GetMetaBlockStack,The length of the statement  "		if (((takeBlockStartLocations && mb is IMetaDeclarationBlock) ? ((IMetaDeclarationBlock)mb).BlockStartLocation : mb.Location) <= Where && mb.EndLocation >= Where) { " is 164.
Long Statement,D_Parser.Dom,DVariable,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Nodes\OtherNodeDefinitions.cs,ToString,The length of the statement  "	return (IsAlias ? "alias " : "") + base.ToString (Attributes' IncludePath) + (initializer && Initializer != null ? (" = " + Initializer.ToString ()) : ""); " is 155.
Long Statement,D_Parser.Dom,TemplateValueParameter,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\TemplateParameters.cs,ToString,The length of the statement  "	return (Type != null ? (Type.ToString () + " ") : "") + Name/*+ (SpecializationExpression!=null?(":"+SpecializationExpression.ToString()):"")+" is 142.
Long Statement,D_Parser.Dom,DModule,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Nodes\DModule.cs,GetModuleName,The length of the statement  "		return Path.ChangeExtension (file.Substring (baseDirectory.Length)' null).Replace (Path.DirectorySeparatorChar' '.').Trim ('.'); " is 128.
Long Statement,D_Parser.Dom,IdentifierDeclaration,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\DDeclarations.cs,ToString,The length of the statement  "	return (ModuleScoped ? "." : "") + (IncludesBase && InnerDeclaration != null ? (InnerDeclaration.ToString () + ".") : "") + Id; " is 127.
Long Statement,D_Parser.Dom,DTokenDeclaration,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\DDeclarations.cs,ToString,The length of the statement  "	return (IncludesBase && InnerDeclaration != null ? (InnerDeclaration.ToString () + '.') : "") + DTokens.GetTokenString (Token); " is 127.
Long Statement,D_Parser.Dom,MemberFunctionAttributeDecl,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\DDeclarations.cs,ToString,The length of the statement  "	return (IncludesBase && InnerDeclaration != null ? (InnerDeclaration.ToString () + " ") : "") + DTokens.GetTokenString (Modifier) + "(" + (InnerType != null ? InnerType.ToString () : "") + ")"; " is 193.
Long Statement,D_Parser.Dom,TypeOfDeclaration,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\DDeclarations.cs,ToString,The length of the statement  "	return (IncludesBase && InnerDeclaration != null ? (InnerDeclaration.ToString () + " ") : "") + "typeof(" + (Expression != null ? Expression.ToString () : "") + ")"; " is 165.
Long Statement,D_Parser.Dom,VectorDeclaration,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\DDeclarations.cs,ToString,The length of the statement  "	return (IncludesBase && InnerDeclaration != null ? (InnerDeclaration.ToString () + " ") : "") + "__vector(" + (Id != null ? Id.ToString () : "") + ")"; " is 151.
Long Statement,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitDTuple,The length of the statement  "	HashEnum (ref h' prime' t.Items' o => o is ISymbolValue ? (o as ISymbolValue).Accept (Instance) : o is AbstractType ? (o as AbstractType).Accept (Instance) : 0' true); " is 167.
Long Statement,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAssociativeArrayValue,The length of the statement  "	HashEnum (ref h' prime' v.Elements' kv => ((kv.Key != null ? kv.Key.Accept (Instance) : 0) ^ (kv.Value != null ? kv.Value.Accept (Instance) : 0))); " is 147.
Long Statement,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,EnforceBraceStyle,The length of the statement  "		endIndent = IsLineIsEmptyUpToEol (rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString; " is 123.
Long Statement,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,EnforceBraceStyle,The length of the statement  "		endIndent = IsLineIsEmptyUpToEol (rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString; " is 123.
Long Statement,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,EnforceBraceStyle,The length of the statement  "		endIndent = IsLineIsEmptyUpToEol (rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString; " is 123.
Long Statement,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,EnforceBraceStyle,The length of the statement  "		endIndent = IsLineIsEmptyUpToEol (rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString; " is 123.
Long Statement,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,FixStatementIndentation,The length of the statement  "	string indentString = nextStatementIndent == null ? (isEmpty ? "" : this.options.EolMarker) + this.curIndent.IndentString : nextStatementIndent; " is 144.
Long Statement,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,VisitChildren,The length of the statement  "			if (mbStack.Count == 0 || (mb.Location > (peekMb = mbStack.Peek ()).Location && mb.EndLocation < peekMb.EndLocation && !(peekMb is AttributeMetaDeclarationSection))) { " is 167.
Long Statement,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,VisitBlock,The length of the statement  "	EnforceBraceStyle (policy.TypeBlockBraces' block.BlockStartLocation' block.EndLocation.Line' block.EndLocation.Column - 1); " is 123.
Long Statement,D_Parser.Formatting,FormattingIndentStack,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\FormattingIndentStack.cs,Update,The length of the statement  "	indentString = new string ('\t'' curIndent / options.TabSize) + new string (' '' curIndent % options.TabSize) + new string (' '' ExtraSpaces); " is 142.
Long Statement,D_Parser.Formatting.Indent,IndentEngineWrapper,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CorrectIndent,The length of the statement  "	var eng = new IndentEngine (options ?? DFormattingOptions.CreateDStandard ()' textStyle.TabsToSpaces' textStyle.IndentSize' textStyle.KeepAlignmentSpaces); " is 155.
Long Statement,D_Parser.Formatting.Indent,IndentEngineWrapper,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CorrectIndent,The length of the statement  "				replaceActions.Add (new DFormattingVisitor.TextReplaceAction (eng.Position - eng.LineOffset' originalIndent' eng.ThisLineIndent)); " is 130.
Long Statement,D_Parser.Formatting.Indent,IndentEngineWrapper,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CorrectIndent,The length of the statement  "			replaceActions.Add (new DFormattingVisitor.TextReplaceAction (eng.Position - eng.LineOffset' originalIndent' eng.ThisLineIndent)); " is 130.
Long Statement,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,Folded2LevelsNonSpecial,The length of the statement  "	return stack.PeekInside (0) == Inside.FoldedStatement && stack.PeekInside (1) == Inside.FoldedStatement && !KeywordIsSpecial (stack.PeekKeyword) && !KeywordIsSpecial (keyword); " is 176.
Long Statement,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,FoldedClassDeclaration,The length of the statement  "	return stack.PeekInside (0) == Inside.FoldedStatement && (keyword == DTokens.Super || keyword == DTokens.Class || keyword == DTokens.Interface || keyword == DTokens.Template); " is 175.
Long Statement,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushAccGrave,The length of the statement  "	if ((inside & (Inside.PreProcessor | Inside.Comment | Inside.CharLiteral | Inside.StringLiteral | Inside.VerbatimString)) != 0) " is 127.
Long Statement,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushNewLine,The length of the statement  "			if ((stack.PeekInside (0) == Inside.Block && stack.PeekKeyword == DTokens.Enum) || (inside == Inside.FoldedStatement || inside == Inside.SquareBracketList)) " is 156.
Long Statement,D_Parser.Formatting.Indent,IndentStack,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,The length of the statement  "			((inside != Inside.SquareBracketList || ie.Options.KeepArgumentIndentOnSquareBracketOpen) && stack [sp].inside == Inside.ParenList)) { " is 134.
Long Statement,D_Parser.Misc,GlobalParseCache,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\GlobalParseCache.cs,preparationTh,The length of the statement  "						throw new InvalidOperationException ("Race-condition during parse process: There must be two or more parse tasks active!"); " is 123.
Long Statement,D_Parser.Misc,GlobalParseCache,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\GlobalParseCache.cs,preparationTh,The length of the statement  "			if (ParsedDirectories.TryGetValue (path' out oldRoot) && oldRoot.LastParseTime >= Directory.GetLastWriteTimeUtc (path)) { " is 121.
Long Statement,D_Parser.Misc,GlobalParseCache,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\GlobalParseCache.cs,noticeFinish,The length of the statement  "	var pf = new ParsingFinishedEventArgs (im.basePath' p.root' im.actualTimeNeeded' im.ActualParseTimeNeeded' im.totalFiles); " is 122.
Long Statement,D_Parser.Misc,GlobalParseCache,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\GlobalParseCache.cs,noticeFinish,The length of the statement  "		// Generic issue: The wrong statistics will be passed' if we fire the event for a task which was added some time afterwards " is 123.
Long Statement,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,RemoveNestedTemplateRefsFromQualifier,The length of the statement  "					(arg as TypeDeclarationExpression).Declaration = RemoveNestedTemplateRefsFromQualifier ((arg as TypeDeclarationExpression).Declaration); " is 136.
Long Statement,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,RemoveNestedTemplateRefsFromQualifier,The length of the statement  "	if (td.InnerDeclaration is TemplateInstanceExpression && (td.InnerDeclaration as TemplateInstanceExpression).TemplateIdHash == id) " is 130.
Long Statement,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The length of the statement  "		return new IdentifierExpression (-Number ()' LiteralFormat.Scalar' LiteralSubformat.Integer | LiteralSubformat.Imaginary); " is 122.
Long Statement,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The length of the statement  "		return new IdentifierExpression (sb.ToString ()' LiteralFormat.StringLiteral' p == 'a' ? LiteralSubformat.Utf8 : (p == 'w' ? LiteralSubformat.Utf16 : LiteralSubformat.Utf32)); " is 175.
Long Statement,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,HexFloat,The length of the statement  "	return new IdentifierExpression (n' LiteralFormat.Scalar | ((Math.Truncate (n) == n) ? 0 : LiteralFormat.FloatingPoint)' LiteralSubformat.Double); " is 146.
Long Statement,D_Parser.Refactoring,ReferencesFinder,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\ReferencesFinder.cs,SearchModuleForASTNodeReferences,The length of the statement  "		bool add = !f.l.AsParallel ().Any (o => (o is TemplateParameter && (o as TemplateParameter).NameLocation == loc) || (o is INode && (o as INode).NameLocation == loc)); " is 166.
Long Statement,D_Parser.Refactoring,ReferencesFinder,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\ReferencesFinder.cs,Visit,The length of the statement  "	var id = acc.AccessExpression is NewExpression ? (acc.AccessExpression as NewExpression).Type as IntermediateIdType : acc.AccessExpression as IntermediateIdType; " is 161.
Long Statement,D_Parser.Refactoring,ReferencesFinder,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\ReferencesFinder.cs,Visit,The length of the statement  "	if (x.TypeAliasIdentifierHash == searchHash && symbol is TemplateParameter.Node && (symbol as TemplateParameter.Node).TemplateParameter == x.ArtificialFirstSpecParam) { " is 168.
Long Statement,D_Parser.Refactoring,SortImportsRefactoring,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\SortImportsRefactoring.cs,ResortImports,The length of the statement  "			if (prevId != null && iid != null && (iid.InnerDeclaration ?? iid).ToString (true) != (prevId.InnerDeclaration ?? prevId).ToString (true)) " is 138.
Long Statement,D_Parser.Refactoring,TypeReferenceFinder,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,OnScopedBlockChanged,The length of the statement  "	foreach (var n in ItemEnumeration.EnumScopedBlockChildren (ctxt' MemberFilter.Types | MemberFilter.Enums | MemberFilter.TypeParameters | MemberFilter.Variables)) { " is 163.
Long Statement,D_Parser.Refactoring,TypeReferenceFinder,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,Visit,The length of the statement  "	//TODO: If there is a type result' try to resolve x (or postfix-access expressions etc.) to find out whether it's overwritten by some local non-type " is 148.
Long Statement,D_Parser.Refactoring,TypeReferenceFinder,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,CheckCondition,The length of the statement  "	if (c == null || c is StaticIfCondition || (c is NegatedDeclarationCondition && (c as NegatedDeclarationCondition).FirstCondition is NegatedDeclarationCondition)) " is 162.
Long Statement,D_Parser.Refactoring,TypeReferenceFinder,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,CheckCondition,The length of the statement  "	retCode = ((ret || (!(c is NegatedDeclarationCondition) && ctxt.CompilationEnvironment.IsMatching (c' null))) ? 1 : -1); " is 120.
Long Statement,D_Parser.Refactoring,ClassInterfaceDerivativeFinder,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\ClassInterfaceDerivativeFinder.cs,SearchForClassDerivatives,The length of the statement  "		throw new ArgumentException ("t is expected to be a class or an interface' not " + (t != null ? t.ToString () : "null")); " is 121.
Long Statement,D_Parser.Resolver,DTypeToCodeVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\DTypeToCodeVisitor.cs,AcceptType,The length of the statement  "			sb.Append (aliasTag.typeBase != null ? aliasTag.typeBase.ToString () : aliasTag.aliasDefinition.ToString (false' false)).Append ('='); " is 134.
Long Statement,D_Parser.Resolver,AssocArrayType,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\DType.cs,Clone,The length of the statement  "	return new AssocArrayType (cloneBase && Base != null ? Base.Clone (true) : Base' cloneBase && KeyType != null ? KeyType.Clone (true) : KeyType); " is 144.
Long Statement,D_Parser.Resolver,DelegateCallSymbol,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\DType.cs,Clone,The length of the statement  "	return new DelegateCallSymbol (cloneBase && Delegate != null ? Delegate.Clone (true) as DelegateType : Delegate' callExpression); " is 129.
Long Statement,D_Parser.Resolver,DelegateType,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\DType.cs,Clone,The length of the statement  "		return new DelegateType (cloneBase && Base != null ? Base.Clone (true) : Base' delegateTypeBase as FunctionLiteral' Parameters); " is 128.
Long Statement,D_Parser.Resolver,DelegateType,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\DType.cs,Clone,The length of the statement  "	return new DelegateType (cloneBase && Base != null ? Base.Clone (true) : Base' delegateTypeBase as DelegateDeclaration' Parameters); " is 132.
Long Statement,D_Parser.Resolver,ClassType,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\DType.cs,Clone,The length of the statement  "	return new ClassType (Definition' cloneBase && Base != null ? Base.Clone (true) as TemplateIntermediateType : Base as TemplateIntermediateType' BaseInterfaces' DeducedTypes) { " is 175.
Long Statement,D_Parser.Resolver,TemplateParameterSymbol,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\DType.cs,ToString,The length of the statement  "	return "<" + (Parameter == null ? "(unknown)" : Parameter.Name) + ">" + (ParameterValue != null ? ParameterValue.ToString () : (Base == null ? "" : Base.ToString ())); " is 167.
Long Statement,D_Parser.Resolver,TemplateParameterSymbol,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\DType.cs,Clone,The length of the statement  "	return new TemplateParameterSymbol (Parameter' ParameterValue ?? (cloneBase && Base != null ? Base.Clone (true) : Base) as ISemantic) { " is 135.
Long Statement,D_Parser.Resolver,ModuleSymbol,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\DType.cs,Clone,The length of the statement  "	return new ModuleSymbol (Definition' cloneBase && Base != null ? Base.Clone (true) as PackageSymbol : Base as PackageSymbol) { " is 126.
Long Statement,D_Parser.Resolver,ResultComparer,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ResultComparer.cs,IsImplicitlyConvertible,The length of the statement  "	else if (!isVariable && resToCheck is ArrayType && targetType is PointerType && ((targetType = (targetType as PointerType).Base) is PrimitiveType) && DTokens.IsBasicType_Character ((targetType as PrimitiveType).TypeToken)) " is 222.
Long Statement,D_Parser.Resolver,StaticProperties,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,GetOwnerType,The length of the statement  "		if (tps != null && (tps.Parameter is TemplateThisParameter ? (tps.Parameter as TemplateThisParameter).FollowParameter : tps.Parameter) is TemplateTupleParameter) " is 161.
Long Statement,D_Parser.Resolver,StaticProperties,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,GetLookedUpType,The length of the statement  "	if (tps != null && tps.Base == null && (tps.Parameter is TemplateThisParameter ? (tps.Parameter as TemplateThisParameter).FollowParameter : tps.Parameter) is TemplateTupleParameter) " is 181.
Long Statement,D_Parser.Resolver,StaticProperties,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,TryEvalPropertyType,The length of the statement  "	if (props.TryGetValue (propName' out prop) || (Properties.TryGetValue (GetOwnerType (t)' out props) && props.TryGetValue (propName' out prop))) { " is 145.
Long Statement,D_Parser.Resolver,StaticProperties,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,TryEvalPropertyValue,The length of the statement  "	if (props.TryGetValue (propName' out prop) || (Properties.TryGetValue (GetOwnerType (baseSymbol)' out props) && props.TryGetValue (propName' out prop))) { " is 154.
Long Statement,D_Parser.Resolver,ResolutionContext,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ResolutionContext.cs,Push,The length of the statement  "	return Push (DResolver.SearchBlockAt (editor.SyntaxTree' editor.CaretLocation) ?? editor.SyntaxTree' editor.CaretLocation); " is 123.
Long Statement,D_Parser.Resolver,ConditionalCompilationFlags,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ConditionalCompilationFlags.cs,IsMatching,The length of the statement  "			return vc.VersionIdHash == 0 ? vc.VersionNumber < versionNumber : (!setVersions.Contains (vc.VersionId) || setVersions.Contains ("!" + vc.VersionId)); " is 150.
Long Statement,D_Parser.Resolver,ConditionalCompilationFlags,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ConditionalCompilationFlags.cs,IsMatching,The length of the statement  "			return dc.DebugIdHash == 0 ? debugLevel < dc.DebugLevel : (!setDebugVersions.Contains (dc.DebugId) || setDebugVersions.Contains ("!" + dc.DebugId)); " is 148.
Long Statement,D_Parser.Resolver,ConditionalCompilationFlags,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ConditionalCompilationFlags.cs,IsMatching,The length of the statement  "	//TODO: Just because the expression evaluation isn't working properly currently' let it return true to have it e.g. in the completion list " is 138.
Long Statement,D_Parser.Resolver,LooseResolution,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,ResolveTypeLoosely,The length of the statement  "		ctxt.CurrentContext.ContextDependentOptions |= ResolutionOptions.ReturnMethodReferencesOnly | ResolutionOptions.DontResolveAliases; " is 131.
Long Statement,D_Parser.Resolver,LooseResolution,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,ResolveTypeLoosely,The length of the statement  "		ctxt.CurrentContext.ContextDependentOptions |= ResolutionOptions.ReturnMethodReferencesOnly | ResolutionOptions.DontResolveAliases; " is 131.
Long Statement,D_Parser.Resolver,LooseResolution,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,ResolveTypeLoosely,The length of the statement  "			ret = AmbiguousType.Get (ExpressionTypeEvaluation.GetOverloads (o as IdentifierExpression' ctxt' deduceParameters: false)); " is 123.
Long Statement,D_Parser.Resolver,LooseResolution,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,SearchNodesByName,The length of the statement  "	ctxt.ContextIndependentOptions = ResolutionOptions.DontResolveBaseTypes | ResolutionOptions.NoTemplateParameterDeduction; " is 121.
Long Statement,D_Parser.Resolver,LooseResolution,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,LookupIdRawly,The length of the statement  "			 */ctxt.ContextIndependentOptions = ResolutionOptions.DontResolveBaseTypes | ResolutionOptions.IgnoreAllProtectionAttributes | ResolutionOptions.IgnoreDeclarationConditions | ResolutionOptions.NoTemplateParameterDeduction | ResolutionOptions.ReturnMethodReferencesOnly; " is 268.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,TryDoCTFEOrGetValueRefs,The length of the statement  "	return r != null ? r.Accept (new CTFEOrValueRefsVisitor (ValueProvider' idOrTemplateInstance' ImplicitlyExecute' executionArguments)) : null; " is 141.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The length of the statement  "	return TryDoCTFEOrGetValueRefs (AmbiguousType.Get (ExpressionTypeEvaluation.GetOverloads (tix' ctxt))' tix' ImplicitlyExecute); " is 127.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The length of the statement  "		var tk = id.Subformat == LiteralSubformat.Utf32 ? DTokens.Dchar : id.Subformat == LiteralSubformat.Utf16 ? DTokens.Wchar : DTokens.Char; " is 136.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_BoolOp,The length of the statement  "				relationIsTrue = (a.Value < b.Value || a.Value > b.Value) && (!cmpIm || (a.ImaginaryPart < b.ImaginaryPart || a.ImaginaryPart > b.ImaginaryPart)); " is 146.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_BoolOp,The length of the statement  "				relationIsTrue = (a.Value < b.Value || a.Value >= b.Value) && (!cmpIm || (a.ImaginaryPart < b.ImaginaryPart || a.ImaginaryPart >= b.ImaginaryPart)); " is 148.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The length of the statement  "			if (x.RightOperand is OperatorBasedExpression && !(x.RightOperand is AssignExpression))//TODO: This must be true only if it's a math expression' so not an assign expression etc. " is 177.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The length of the statement  "			return HandleSingleMathOp (x' l' TryGetValue (rValue ?? (x.RightOperand != null ? x.RightOperand.Accept (this) : null))' mult); " is 127.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalConcatenation,The length of the statement  "	// Notable: If one element is of the value type of the array' the element is added (either at the front or at the back) to the array " is 132.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalConcatenation,The length of the statement  "		EvalError (x' "At least one operand must be an (non-associative) array. If so' the other operand must be of the array's element type."' catQueue.ToArray ()); " is 157.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalConcatenation,The length of the statement  "			EvalError (x' "Element with type " + (e.RepresentedType != null ? e.RepresentedType.ToCode () : "") + " doesn't fit into array with type " + lastArrayType.ToCode ()' catQueue.ToArray ()); " is 187.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,HandleSingleMathOp,The length of the statement  "			return PrimitiveValue.CreateNaNValue (pl.IsNaN ? pl.BaseTypeToken : pr.BaseTypeToken' pl.IsNaN ? pl.Modifier : pr.Modifier); " is 124.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,HandleSingleMathOp,The length of the statement  "			return PrimitiveValue.CreateNaNValue (pl.IsNaN ? pl.BaseTypeToken : pr.BaseTypeToken' pl.IsNaN ? pl.Modifier : pr.Modifier); " is 124.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_WithAliases,The length of the statement  "			 */var expectedTemplateParams = new TemplateParameter[isExpression.TemplateParameterList == null ? 1 : (isExpression.TemplateParameterList.Length + 1)]; " is 151.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_WithAliases,The length of the statement  "			tpl_params [isExpression.ArtificialFirstSpecParam] = new TemplateParameterSymbol (isExpression.ArtificialFirstSpecParam' r.Item2); " is 130.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_NoAlias,The length of the statement  "		return spec != null && (isExpression.EqualityTest ? ResultComparer.IsEqual (typeToCheck' spec) : ResultComparer.IsImplicitlyConvertible (typeToCheck' spec' ctxt)); " is 163.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_EvalSpecToken,The length of the statement  "		if (r = typeToCheck is UserDefinedType && ((TemplateIntermediateType)typeToCheck).Definition.ClassType == isExpression.TypeSpecializationToken) " is 143.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_EvalSpecToken,The length of the statement  "					// TypeTuple of the function parameter types. For C- and D-style variadic functions' only the non-variadic parameters are included.  " is 131.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_EvalSpecToken,The length of the statement  "			r = isExpression.TypeSpecializationToken == DTokens.Delegate && typeToCheck is MemberSymbol && ((DSymbol)typeToCheck).Definition is DMethod; " is 140.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The length of the statement  "	var assertVal = x.AssignExpressions.Length > 0 && x.AssignExpressions [0] != null ? x.AssignExpressions [0].Accept (this) as ISymbolValue : null; " is 145.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The length of the statement  "	var fn = Path.IsPathRooted (v.StringValue) ? v.StringValue : Path.Combine (Path.GetDirectoryName ((ctxt.ScopedBlock.NodeRoot as DModule).FileName)' v.StringValue); " is 163.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The length of the statement  "	return new AssociativeArrayValue (new AssocArrayType (elements [0].Value.RepresentedType' elements [0].Key.RepresentedType)' elements); " is 135.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The length of the statement  "	var dg = new DelegateType ((ctxt.Options & ResolutionOptions.DontResolveBaseTypes | ResolutionOptions.ReturnMethodReferencesOnly) != 0 ? null : TypeDeclarationResolver.GetMethodReturnType (x.AnonymousMethod' ctxt)' x' TypeResolution.TypeDeclarationResolver.HandleNodeMatches (x.AnonymousMethod.Parameters' ctxt)); " is 313.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The length of the statement  "	var returnBaseTypeOnly = !this.returnBaseTypeOnly.HasValue ? !ctxt.Options.HasFlag (ResolutionOptions.ReturnMethodReferencesOnly) : this.returnBaseTypeOnly.Value; " is 162.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The length of the statement  "	var argTypeFilteredOverloads = EvalMethodCall (baseExpression' baseValue' tix' ctxt' call' out callArguments' out delegValue' returnBaseTypeOnly' ValueProvider); " is 161.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalMethodCall,The length of the statement  "			HandleDMethodOverload (ctxt' ValueProvider != null' baseValue' callArguments' returnBaseTypeOnly' argTypeFilteredOverloads' ref hasHandledUfcsResultBefore' ov as MemberSymbol' ref untemplatedMethodResult); " is 205.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,HandleDMethodOverload,The length of the statement  "	} else if (!isUfcs && hasHandledUfcsResultBefore)// In the rare case of having a ufcs result occuring _after_ a normal member result' remove the initial arg again " is 162.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,HandleDMethodOverload,The length of the statement  "				if (paramType is IdentifierDeclaration && (hadDTuples |= TryHandleMethodArgumentTuple (ctxt' ref add' callArguments' dm' deducedTypeDict' i' ref currentArg))) " is 158.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,TryHandleMethodArgumentTuple,The length of the statement  "		var nextExpectedParameter = DResolver.StripMemberSymbols (TypeDeclarationResolver.ResolveSingle (dm.Parameters [currentParameter + 1].Type' ctxt)); " is 147.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,TryHandleMethodArgumentTuple,The length of the statement  "				if (currentArg >= callArguments.Count || !ResultComparer.IsImplicitlyConvertible (callArguments [currentArg++]' AbstractType.Get (item)' ctxt)) { " is 145.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,GetRawCallOverloads,The length of the statement  "		// Explicitly don't resolve the methods' return types - it'll be done after filtering to e.g. resolve template types to the deduced one " is 135.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,GetRawCallOverloads,The length of the statement  "			baseExpression = ExpressionTypeEvaluation.GetResolvedConstructorOverloads ((TokenExpression)call.PostfixForeExpression' ctxt); " is 126.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalPostfixAccessExpression,The length of the statement  "	var baseExpression = resultBase ?? (acc.PostfixForeExpression != null ? acc.PostfixForeExpression.Accept (vis) as ISemantic : null); " is 132.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalPostfixAccessExpression,The length of the statement  "		// Do not deduce and filter if superior expression is a method call since call arguments' types also count as template arguments! " is 129.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalPostfixAccessExpression,The length of the statement  "		overloads = ExpressionTypeEvaluation.GetOverloads (tix' ctxt' AbstractType.Get (baseExpression)' EvalAndFilterOverloads); " is 121.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalPostfixAccessExpression,The length of the statement  "		overloads = ExpressionTypeEvaluation.GetOverloads (id' ctxt' AbstractType.Get (baseExpression)' EvalAndFilterOverloads); " is 120.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,SliceArray,The length of the statement  "		EvalError (lower != -1 ? sl.LowerBoundExpression : sl.UpperBoundExpression' "Boundary expression must base an integral type"); " is 126.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The length of the statement  "						ret = ms.Definition.ContainsAttribute (DTokens.Abstract) || (ms.Definition.Parent is DClassLike && (ms.Definition.Parent as DClassLike).ContainsAttribute (DTokens.Final)); " is 171.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,EvaluateType,The length of the statement  "	if (!(t is TemplateParameterSymbol) || !ctxt.DeducedTypesInHierarchy.Any (tps => tps.Parameter == (t as TemplateParameterSymbol).Parameter)) " is 140.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,The length of the statement  "	return Evaluation.EvalMethodCall (baseExpression' null' tix' ctxt' call' out callArgs' out delegValue' !ctxt.Options.HasFlag (ResolutionOptions.ReturnMethodReferencesOnly)); " is 173.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetRawCallOverloads,The length of the statement  "		// Explicitly don't resolve the methods' return types - it'll be done after filtering to e.g. resolve template types to the deduced one " is 135.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetUnfilteredMethodOverloads_Helper,The length of the statement  "		var m = TypeDeclarationResolver.HandleNodeMatches (GetOpCalls (tit' staticOnly)' ctxt' null' supExpression ?? foreExpression); " is 126.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetUnfilteredMethodOverloads_Helper,The length of the statement  "		m = TypeDeclarationResolver.HandleNodeMatches (GetConstructors (tit' canCreateExplicitStructCtor)' ctxt' null' supExpression ?? foreExpression); " is 144.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetAccessedOverloads,The length of the statement  "	return Evaluation.EvalPostfixAccessExpression<AbstractType> (new ExpressionTypeEvaluation (ctxt)' ctxt' acc' resultBase' DeducePostfixTemplateParams); " is 150.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetResolvedConstructorOverloads,The length of the statement  "			return D_Parser.Resolver.TypeResolution.TypeDeclarationResolver.HandleNodeMatches (GetConstructors (classRef)' ctxt' classRef' tk); " is 131.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,The length of the statement  "	return x.TrueCaseExpression != null ? x.TrueCaseExpression.Accept (this) : (x.FalseCaseExpression != null ? x.FalseCaseExpression.Accept (this) : null); " is 152.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,AccessArrayAtIndex,The length of the statement  "				foreExpression = DResolver.StripMemberSymbols (TypeDeclarationResolver.HandleNodeMatch (aliasThis' ctxt' foreExpression)); " is 122.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,AccessArrayAtIndex,The length of the statement  "			foreExpression = TryPretendMethodExecution (AmbiguousType.Get (overloads)' x' indexArgs.Count != 0 ? indexArgs.ToArray () : null); " is 130.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,The length of the statement  "		var tk = id.Subformat == LiteralSubformat.Utf32 ? DTokens.Dchar : id.Subformat == LiteralSubformat.Utf16 ? DTokens.Wchar : DTokens.Char; " is 136.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,ResolveIdentifier,The length of the statement  "			}*/if (hasBaseValue || (ctxt.Options & ResolutionOptions.DontResolveBaseClasses | ResolutionOptions.DontResolveBaseTypes) != 0) { " is 129.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetOverloads,The length of the statement  "		Trace.WriteLine (string.Format ("Finished resolving base type {0} => {1}. {2} ms."' (id as ITypeDeclaration).InnerDeclaration' resultBases' sw.ElapsedMilliseconds)); " is 165.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,The length of the statement  "	return new DelegateType ((ctxt.Options & ResolutionOptions.DontResolveBaseTypes | ResolutionOptions.ReturnMethodReferencesOnly) != 0 ? null : TypeDeclarationResolver.GetMethodReturnType (x.AnonymousMethod' ctxt)' x' TypeResolution.TypeDeclarationResolver.HandleNodeMatches (x.AnonymousMethod.Parameters' ctxt)); " is 311.
Long Statement,D_Parser.Resolver.ExpressionSemantics,StandardValueProvider,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ISymbolValueProvider.cs,GetLocal,The length of the statement  "	var res = ExpressionTypeEvaluation.GetOverloads (id ?? new IdentifierExpression (LocalName)' ResolutionContext' null' false); " is 125.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,DeepScanClass,The length of the statement  "		takeStaticChildrenOnly = (udt == null || !udt.NonStaticAccess) && ctxt.ScopedBlock is DMethod && (ctxt.ScopedBlock as DMethod).IsStatic " is 135.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,VisitStatementHierarchy,The length of the statement  "	return dm != null && (s = dm.GetSubBlockAt (caret)) != null && s.Accept (new StatementHandler (dm' this' parms' caret)); " is 120.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,HandleAliasThisDeclarations,The length of the statement  "	if (aliasThisDefsBeingParsed.TryGetValue (tit.Definition' out alreadyParsedAliasThis) && alreadyParsedAliasThis == aliasDef) " is 124.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,HandleAliasThisDeclarations,The length of the statement  "		aliasedSymbolOverloads = DResolver.StripMemberSymbols (DResolver.StripMemberSymbols (TypeDeclarationResolver.ResolveSingle (aliasDef.Type' ctxt))); " is 147.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,MatchesCompilationConditions,The length of the statement  "				res = neg != null ? !ctxt.CurrentContext.MatchesDeclarationEnvironment (neg) : ctxt.CurrentContext.MatchesDeclarationEnvironment (cond); " is 136.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,CanHandleNode,The length of the statement  "	if (CompletionOptions.Instance.HideDisabledNodes && dn.ContainsPropertyAttribute (BuiltInAtAttribute.BuiltInAttributes.Disable)) " is 128.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,CanHandleNode,The length of the statement  "	if ((ctxt.Options & ResolutionOptions.IgnoreAllProtectionAttributes) != ResolutionOptions.IgnoreAllProtectionAttributes) { " is 122.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,CanHandleNode,The length of the statement  "		if ((CanShowMember (dn' ctxt.ScopedBlock) || (parms.isBaseClass && !parms.isMixinAst)) && ((!parms.takeStaticChildrenOnly && (!parms.publicImportsOnly || !parms.isBaseClass)) || IsConstOrStatic (dn))) { " is 202.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,CanHandleNode,The length of the statement  "	if (dm3 != null && !(dm3.SpecialType == DMethod.MethodType.Normal || dm3.SpecialType == DMethod.MethodType.Delegate || dm3.NameHash != 0)) " is 138.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,CanShowMember,The length of the statement  "		return scope == null || dn.NodeRoot is DModule && ModuleNameHelper.ExtractPackageName ((dn.NodeRoot as DModule).ModuleName) == ModuleNameHelper.ExtractPackageName ((scope.NodeRoot as DModule).ModuleName); " is 204.
Long Statement,D_Parser.Resolver.ResolutionHooks,bitfields,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\bitfields.cs,TryDeduce,The length of the statement  "						sb.Append ("@property @safe ").Append (templateParamName).Append (' ').Append (name).AppendLine ("() pure nothrow const {}"); " is 125.
Long Statement,D_Parser.Resolver.ResolutionHooks,bitfields,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\bitfields.cs,TryDeduce,The length of the statement  "						sb.Append ("@property @safe void ").Append (name).AppendLine ("(").Append (templateParamName).AppendLine (" v) pure nothrow {}"); " is 129.
Long Statement,D_Parser.Resolver.ResolutionHooks,bitfields,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\bitfields.cs,TryDeduce,The length of the statement  "						sb.Append ("enum ").Append (templateParamName).Append (" ").Append (name).Append ("_min = cast(").Append (templateParamName).AppendLine (") 0;"); " is 145.
Long Statement,D_Parser.Resolver.ResolutionHooks,bitfields,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\bitfields.cs,TryDeduce,The length of the statement  "						sb.Append ("enum ").Append (templateParamName).Append (" ").Append (name).Append ("_max = cast(").Append (templateParamName).AppendLine (") 0;"); " is 145.
Long Statement,D_Parser.Resolver.Templates,SpecializationOrdering,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\SpecializationOrdering.cs,IsMoreSpecialized,The length of the statement  "	if (t1 is TemplateTypeParameter && t2 is TemplateTypeParameter && !IsMoreSpecialized ((TemplateTypeParameter)t1' (TemplateTypeParameter)t2' t1_dummyParameterList)) " is 163.
Long Statement,D_Parser.Resolver.Templates,SpecializationOrdering,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\SpecializationOrdering.cs,IsMoreSpecialized,The length of the statement  "	else if (t1 is TemplateValueParameter && t2 is TemplateValueParameter && !IsMoreSpecialized ((TemplateValueParameter)t1' (TemplateValueParameter)t2)) " is 149.
Long Statement,D_Parser.Resolver.Templates,SpecializationOrdering,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\SpecializationOrdering.cs,IsMoreSpecialized,The length of the statement  "	else if (t1 is TemplateAliasParameter && t2 is TemplateAliasParameter && !IsMoreSpecialized ((TemplateAliasParameter)t1' (TemplateAliasParameter)t2' t1_dummyParameterList)) " is 172.
Long Statement,D_Parser.Resolver.Templates,SpecializationOrdering,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\SpecializationOrdering.cs,IsMoreSpecialized,The length of the statement  "	else if (t1 is TemplateThisParameter && t2 is TemplateThisParameter && !IsMoreSpecialized (((TemplateThisParameter)t1).FollowParameter' ((TemplateThisParameter)t2).FollowParameter' t1_dummyParameterList)) " is 204.
Long Statement,D_Parser.Resolver.Templates,SpecializationOrdering,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\SpecializationOrdering.cs,IsMoreSpecialized,The length of the statement  "		// It's not needed to test both expressions for equality because they actually were equal to the given template instance argument " is 129.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,Handle,The length of the statement  "	//TODO: Handle __FILE__ and __LINE__ correctly - so don't evaluate them at the template declaration but at the point of instantiation " is 133.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,TryAssignDefaultType,The length of the statement  "	using (ctxt.Push (DResolver.SearchBlockAt (ctxt.ScopedBlock.NodeRoot as IBlockNode' p.Default.Location)' p.Default.Location)) { " is 127.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The length of the statement  "		var physicalParentType = TypeDeclarationResolver.HandleNodeMatch (deducee.Definition.Parent' ctxt' null' id.InnerDeclaration); " is 126.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The length of the statement  "	return _r != null && (EnforceTypeEqualityWhenDeducing ? ResultComparer.IsEqual (r' _r) : ResultComparer.IsImplicitlyConvertible (r' _r)); " is 137.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The length of the statement  "			 * Therefore' it's needed to manually resolve the identifier' and look out for aliases or such unprecise aliases..confusing as s**t!" is 131.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The length of the statement  "			 * If the param tix id is part of the template param list' the behaviour is currently undefined! - so instantly return false' I'll leave it as TODO/FIXME" is 152.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The length of the statement  "		if (tixBasedArgumentType != null && CheckForTixIdentifierEquality (paramTix_TemplateMatchPossibilities' tixBasedArgumentType.Definition)) " is 137.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,ResolveTemplateInstanceId,The length of the statement  "			 * When having a cascaded tix as parameter' it uses the left-most part (i.e. the inner most) of the typedeclaration construct." is 125.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,ResolveTemplateInstanceId,The length of the statement  "	ctxt.CurrentContext.ContextDependentOptions = ResolutionOptions.DontResolveBaseClasses | ResolutionOptions.DontResolveBaseTypes; " is 128.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The length of the statement  "	if ((arrayDeclToCheckAgainst.ClampsEmpty == (at == null)) && (at == null || !at.IsStaticArray || arrayDeclToCheckAgainst.KeyExpression == null)) " is 144.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The length of the statement  "			// If an expression (the usual case) has been passed as argument' evaluate its value' otherwise is its type already resolved. " is 125.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The length of the statement  "			var finalArg = argumentArrayType is ArrayType ? (ISemantic)new PrimitiveValue ((argumentArrayType as ArrayType).FixedLength) : argumentArrayType.KeyType; " is 153.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The length of the statement  "			// Just test for equality of the argument and parameter expression' e.g. if both param and arg are 123' the result will be true. " is 128.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The length of the statement  "			result = SymbolValueComparer.IsEqual (Evaluation.EvaluateValue (arrayDeclToCheckAgainst.KeyExpression' ctxt)' new PrimitiveValue ((argumentArrayType as ArrayType).FixedLength)); " is 177.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,Handle,The length of the statement  "	if (paramType == null || valueArgument.RepresentedType == null || !ResultComparer.IsImplicitlyConvertible (paramType' valueArgument.RepresentedType)) " is 149.
Long Statement,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,IsNonFinalArgument,The length of the statement  "	return (v is TypeValue && (v as TypeValue).RepresentedType is TemplateParameterSymbol) || (v is TemplateParameterSymbol && (v as TemplateParameterSymbol).Base == null) || v is ErrorValue; " is 187.
Long Statement,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,TryGetImplicitProperty,The length of the statement  "	var matchingChild = TypeDeclarationResolver.ResolveFurtherTypeIdentifier (template.NameHash' template' ctxt' null' false); " is 122.
Long Statement,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceEponymousTemplate,The length of the statement  "	deducedType = new MemberSymbol (def' def.Type != null ? TypeDeclarationResolver.ResolveSingle (def.Type' ctxt) : ExpressionTypeEvaluation.EvaluateType (def.Initializer' ctxt)' ept.DeducedTypes); " is 194.
Long Statement,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceOverloads,The length of the statement  "		} else if ((aliasTag = overload.Tag<TypeDeclarationResolver.AliasTag> (TypeDeclarationResolver.AliasTag.Id)) != null && (hasTemplateArgsPassed || !(aliasTag.aliasDefinition.Type is TemplateInstanceExpression))) " is 210.
Long Statement,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceOverloads,The length of the statement  "		var hook = D_Parser.Resolver.ResolutionHooks.HookRegistry.TryDeduce (overload' givenTemplateArguments' out ignoreOtherOverloads); " is 129.
Long Statement,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParam,The length of the statement  "	} // There might be too few args - but that doesn't mean that it's not correct - it's only required that all parameters got satisfied with a type " is 145.
Long Statement,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,ResolveFurtherTypeIdentifier,The length of the statement  "					r.AddRange (UFCSResolver.TryResolveUFCS (b' nextIdentifierHash' ctxt.ScopedBlock != udt.Definition && typeIdObject != null ? typeIdObject.Location : ctxt.ScopedBlock.BlockStartLocation' ctxt' typeIdObject)); " is 207.
Long Statement,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,ResolveFurtherTypeIdentifier,The length of the statement  "				r.AddRange (UFCSResolver.TryResolveUFCS (b' nextIdentifierHash' typeIdObject != null ? typeIdObject.Location : ctxt.ScopedBlock.BlockStartLocation' ctxt' typeIdObject)); " is 169.
Long Statement,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,TryPostDeduceAliasDefinition,The length of the statement  "	if (typeBase != null && b != null && b.Tag<AliasTag> (AliasTag.Id) != null && (ctxt.Options & ResolutionOptions.DontResolveAliases) == 0) { " is 139.
Long Statement,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,TryPostDeduceAliasDefinition,The length of the statement  "			b = AmbiguousType.Get (TemplateInstanceHandler.DeduceParamsAndFilterOverloads (bases' typeBase as TemplateInstanceExpression' ctxt' false)); " is 140.
Long Statement,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,ResolveClassOrInterface,The length of the statement  "		// Pop a context frame as we still need to resolve the template instance expression args in the place where the expression occurs' not the instantiated class' location " is 167.
Long Statement,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,ResolveClassOrInterface,The length of the statement  "		return isClass ? new ClassType (dc' dc.NameHash != ObjectNameHash ? ResolveObjectClass (ctxt) : null' null' deducedTypes) : new InterfaceType (dc' null' deducedTypes) as TemplateIntermediateType; " is 195.
Long Statement,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,ResolveClassOrInterface,The length of the statement  "				if (type == null || (type is IdentifierDeclaration && (type as IdentifierDeclaration).IdHash == dc.NameHash) || dc.NodeRoot == dc) { " is 132.
Long Statement,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,ResolveClassOrInterface,The length of the statement  "						ctxt.LogError (new ResolutionError (dc' "The base " + (r is ClassType ? "class" : "template") + " name must preceed base interfaces")); " is 135.
Long Statement,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,GetResultMember,The length of the statement  "		if (aliasTag != null && (!(aliasTag.aliasDefinition is ImportSymbolAlias) || // Only if the import symbol alias definition was selected' go to its base " is 151.
Long Statement,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,StripMemberSymbols,The length of the statement  "		// auto o = new Class(); -- o will be MemberSymbol and its base type will be a MemberSymbol either (i.e. the constructor reference) " is 131.
Long Statement,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,StripMemberSymbols,The length of the statement  "		if (ds is MemberSymbol && (ds as DSymbol).Definition is DMethod && (ds as DSymbol).NameHash == DMethod.ConstructorIdentifierHash) " is 129.
Long Statement,D_Parser.Resolver.TypeResolution,OpDispatchResolution,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\OpDispatchResolution.cs,TryResolveFurtherIdViaOpDispatch,The length of the statement  "		if (dn.TemplateParameters != null && dn.TemplateParameters.Length > 0 && dn.TemplateParameters [0] is TemplateValueParameter) { " is 127.
Long Statement,D_Parser.Completion,ParameterInsightResolution,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\ParameterInsightResolution.cs,Visit,The length of the statement  "	res.ResolvedTypesOrMethods = ExpressionTypeEvaluation.GetUnfilteredMethodOverloads (call.PostfixForeExpression' ctxt' call); " is 124.
Long Statement,D_Parser.Completion,ParameterInsightResolution,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\ParameterInsightResolution.cs,Visit,The length of the statement  "	var ov = TypeDeclarationResolver.ResolveFurtherTypeIdentifier (ExpressionTypeEvaluation.OpSliceIdHash' b' ctxt' x' false); " is 122.
Long Statement,D_Parser.Completion,MemberCompletionEnumeration,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\MemberCompletionEnumeration.cs,PreCheckItem,The length of the statement  "	return isVarInst || !(n is DMethod || dv != null || n is TemplateParameter.Node) || (n as DNode).IsStatic || n is DEnumValue || (dv != null && (dv.IsConst || dv.IsAlias)); " is 171.
Long Statement,D_Parser.Completion,CodeCompletion,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\CodeCompletion.cs,IsCompletionAllowed,The length of the statement  "		else if ((Lexer.IsIdentifierPart (enteredChar) || enteredChar == '\0') && Lexer.IsIdentifierPart (Editor.ModuleCode [Editor.CaretOffset - 1])) " is 142.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The length of the statement  "	if (!halt && n.NameHash == 0 && (n.ContainsAttribute (DTokens.Auto) || DParser.ContainsStorageClass (n.Attributes) != Modifier.Empty)) { " is 136.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,VisitAttribute,The length of the statement  "	if (a.ContentHash == DTokens.IncompleteIdHash || ((c = a.LiteralContent as string) != null && c.EndsWith (DTokens.IncompleteId))) { " is 131.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,VisitAttribute,The length of the statement  "	if (a.AttributeExpression != null && a.AttributeExpression.Length > 0 && IsIncompleteExpression (a.AttributeExpression [0])) { " is 126.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,VisitAttribute,The length of the statement  "		prv = new CtrlSpaceCompletionProvider (cdgen' scopedBlock' MemberFilter.BuiltInPropertyAttributes | MemberFilter.Methods | MemberFilter.Variables | MemberFilter.Types); " is 168.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The length of the statement  "		const MemberFilter BaseAsmFlags = MemberFilter.Classes | MemberFilter.StructsAndUnions | MemberFilter.Enums | MemberFilter.Methods | MemberFilter.TypeParameters | MemberFilter.Types | MemberFilter.Variables; " is 207.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The length of the statement  "			prv = new CtrlSpaceCompletionProvider (cdgen' scopedBlock' BaseAsmFlags | MemberFilter.x86Registers | MemberFilter.x64Registers | MemberFilter.Labels); " is 151.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The length of the statement  "			prv = new CtrlSpaceCompletionProvider (cdgen' scopedBlock' shownKeywords.Count == 0 ? MemberFilter.All | MemberFilter.ExpressionKeywords : shownKeywords.Peek ()); " is 162.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The length of the statement  "			// When typing a dot without anything following' trigger completion and show types' methods and vars that are located in the module & import scope " is 146.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The length of the statement  "			prv = new CtrlSpaceCompletionProvider (cdgen' scopedBlock' MemberFilter.Methods | MemberFilter.Types | MemberFilter.Variables | MemberFilter.TypeParameters); " is 157.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The length of the statement  "	if (x.TypeAliasIdentifierHash == DTokens.IncompleteIdHash && x.TestedType != null && !IsIncompleteDeclaration (x.TestedType)) { " is 127.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The length of the statement  "		prv = new CtrlSpaceCompletionProvider (cdgen' scopedBlock' MemberFilter.Types | MemberFilter.ExpressionKeywords | MemberFilter.StatementBlockKeywords); " is 151.
Long Statement,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The length of the statement  "					return Token (DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue (numString' 16)' /*numString'*/LiteralFormat.Scalar); " is 137.
Long Statement,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The length of the statement  "							literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString (3) + " by Alexander Bothe"; " is 137.
Long Statement,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The length of the statement  "							return Token (DTokens.Literal' x' y' s.Length' literalValue' //literalValue is string ? (string)literalValue : literalValue.ToString()' " is 135.
Long Statement,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadTokenStringLiteral_IdentInit,The length of the statement  "	return Token (DTokens.Literal' x' y' Col' Line' tokenString.ToString ().Trim ()' LiteralFormat.VerbatimStringLiteral' subFmt); " is 126.
Long Statement,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadTokenStringLiteral_CurlyInit,The length of the statement  "	return Token (DTokens.Literal' x' y' Col' Line' tokenString.ToString ().Trim ()' LiteralFormat.VerbatimStringLiteral' subFmt); " is 126.
Long Statement,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadIdent,The length of the statement  "					OnError (Line' Col' "Unicode escape sequences in identifiers cannot be used to represent characters that are invalid in identifiers"); " is 134.
Long Statement,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadIdent,The length of the statement  "					OnError (Line' Col' "Unicode escape sequences in identifiers cannot be used to represent characters that are invalid in identifiers"); " is 134.
Long Statement,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The length of the statement  "		if (NumBase == 10 || (ch != '.' && NumBase == 0))// Only allow further digits for 10-based integers' not for binary or hex values " is 129.
Long Statement,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The length of the statement  "		var token = Token (DTokens.Literal' x' y' Col - x/*stringValue.Length*/' num' /* stringValue'*/HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar' subFmt); " is 215.
Long Statement,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadString,The length of the statement  "	return Token (DTokens.Literal' x' y' Col' Line' /*originalValue.ToString()'*/sb.ToString ()' LiteralFormat.StringLiteral' subFmt); " is 130.
Long Statement,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadVerbatimString,The length of the statement  "	return Token (DTokens.Literal' x' y' Col' Line' /*originalValue.ToString()'*/sb.ToString ()' LiteralFormat.VerbatimStringLiteral' subFmt); " is 138.
Long Statement,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadChar,The length of the statement  "	return Token (DTokens.Literal' x' y' Col' Line' string.IsNullOrEmpty (surrogatePair) ? (object)chValue : surrogatePair' LiteralFormat.CharLiteral' surrogatePair == null ? LiteralSubformat.Utf8 : LiteralSubformat.Utf16' escapeSequence); " is 235.
Long Statement,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadMultiLineComment,The length of the statement  "					Comments.Add (new Comment (commentType' scCurWord.ToString ().Trim (ch' ' '' '\t'' '\r'' '\n'' isNestingComment ? '+' : '*')' st.Column < 2' st' new CodeLocation (Col' Line))); " is 176.
Long Statement,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadMultiLineComment,The length of the statement  "		Comments.Add (new Comment (commentType' scCurWord.ToString ().Trim ()' st.Column < 2' st' new CodeLocation (Col' Line))); " is 121.
Long Statement,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadSpecialTokenSequence,The length of the statement  "		if (nextToken.Line > prevLine || nextToken.Kind != DTokens.Literal || nextToken.LiteralFormat != LiteralFormat.StringLiteral) " is 125.
Long Statement,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,OnError,The length of the statement  "		LexerErrors.Add (new ParserError (false' message' CurrentToken != null ? CurrentToken.Kind : -1' new CodeLocation (col' line))); " is 128.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,PushAttribute,The length of the statement  "		// If attr would change the accessability of an item' remove all previously found (so the most near attribute that's next to the item is significant) " is 149.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,GetCurrentAttributeSet,The length of the statement  "		// ISSUE: Theoretically' when having two identically written but semantically different UDA attributes' the first one will become overridden. " is 141.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,SynErr,The length of the statement  "	SynErr (n' DTokens.GetTokenString (n) + " expected" + (t != null ? ("' " + DTokens.GetTokenString (t.Kind) + " found") : "")); " is 126.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,AttributeBlock,The length of the statement  "			 * Also' pop them from the declarationAttributes stack on to the block attributes so they will be assigned to all child items later on." is 134.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Condition,The length of the statement  "						SemErr (DTokens.Version' "Can't handle " + t.LiteralValue.ToString () + " as version constraint; taking ulong.max instead"); " is 124.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Condition,The length of the statement  "						SemErr (DTokens.Debug' "Can't handle " + t.LiteralValue.ToString () + " as debug constraint; taking ulong.max instead"); " is 120.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ImportDeclaration,The length of the statement  "	bool isPublic = Modifier.ContainsAttribute (DeclarationAttributes' Public) || Modifier.ContainsAttribute (BlockAttributes' Public); " is 131.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ImportBindings,The length of the statement  "				importBindings.SelectedSymbols.Add (new ImportStatement.ImportBinding (new IdentifierDeclaration (DTokens.IncompleteIdHash)' symbolAlias)); " is 139.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,AliasDeclaration,The length of the statement  "	if ((laKind == Identifier && Lexer.CurrentPeekToken.Kind == This) || (laKind == This && Lexer.CurrentPeekToken.Kind == Assign)) { " is 129.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,AliasDeclaration,The length of the statement  "	else if (laKind == Identifier && (Lexer.CurrentPeekToken.Kind == Assign || (Lexer.CurrentPeekToken.Kind == OpenParenthesis && OverPeekBrackets (OpenParenthesis) && Lexer.CurrentPeekToken.Kind == Assign))) { " is 206.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,AliasDeclaration,The length of the statement  "	foreach (var n in Decl (Scope' laKind != Identifier || Lexer.CurrentPeekToken.Kind != OpenParenthesis ? null : new Modifier (DTokens.Alias)' true)) { " is 149.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Decl,The length of the statement  "	if ((StorageClass != Modifier.Empty && laKind == (Identifier) && (DeclarationAttributes.Count > 0 || Lexer.CurrentPeekToken.Kind == OpenParenthesis))) { " is 152.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Decl,The length of the statement  "			if (tix.Arguments == null || tix.Arguments.Length == 0 || (tix.Arguments [tix.Arguments.Length - 1] is TokenExpression && (tix.Arguments [tix.Arguments.Length - 1] as TokenExpression).Token == DTokens.INVALID)) { " is 212.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Declarator,The length of the statement  "				(ad == null || !(ad.KeyExpression is TokenExpression) || (ad.KeyExpression as TokenExpression).Token != DTokens.Incomplete)) " is 124.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Declarator,The length of the statement  "			if (laKind == OpenParenthesis && OverPeekBrackets (DTokens.OpenParenthesis' true) && Lexer.CurrentPeekToken.Kind == Assign) { " is 125.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,OldCStyleFunctionPointer,The length of the statement  "	//SynErr(OpenParenthesis'"C-style function pointers are deprecated. Use the function() syntax instead."); // Only deprecated in D2 " is 130.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Declarator2,The length of the statement  "		if (AllowWeakTypeParsing && (td == null || (t.Kind == OpenParenthesis && laKind == CloseParenthesis) /* -- means if an argumentless function call has been made' return null because this would be an expression */|| laKind != CloseParenthesis)) " is 242.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Parameters,The length of the statement  "	// It's not specified in the official D syntax spec' but we treat id-only typed anonymous parameters as non-typed id-full parameters " is 132.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Parameter,The length of the statement  "	while ((IsParamModifier (laKind) && laKind != InOut) || (IsMemberFunctionAttribute (laKind) && Lexer.CurrentPeekToken.Kind != OpenParenthesis)) { " is 145.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,IsAssignExpression,The length of the statement  "			if (IsBasicType (Lexer.CurrentPeekToken) && !(Lexer.CurrentPeekToken.Kind == DTokens.Identifier || Lexer.CurrentPeekToken.Kind == DTokens.Dot)) { " is 145.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,IsAssignExpression,The length of the statement  "	// Addition: If a times token ('*') follows an identifier list' we can assume that we have a declaration and NOT an expression! " is 127.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,IsAssignExpression,The length of the statement  "	// Example: *a=b is an expression; a*=b is not possible (and a Multiply-Assign-Expression) - instead something like A* a should be taken... " is 139.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,AndExpression,The length of the statement  "	// Note: Since we ignored all kinds of CmpExpressions in AndAndExpression()' we have to take CmpExpression instead of ShiftExpression here! " is 139.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,PostfixExpression,The length of the statement  "		if (Lexer.CurrentPeekToken.Kind == DTokens.Dot && (Peek ().Kind == DTokens.Identifier || Lexer.CurrentPeekToken.Kind == EOF)) { " is 127.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,PostfixExpression,The length of the statement  "					 */if (td != null && laKind == CloseParenthesis && Lexer.CurrentPeekToken == dotToken)// Also take it as a type declaration if there's nothing following (see Expression Resolving) " is 178.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,PostfixExpression,The length of the statement  "			var peid = t.Kind == Increment ? (PostfixExpression)new PostfixExpression_Increment () : new PostfixExpression_Decrement (); " is 124.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,PrimaryExpression,The length of the statement  "		//else if (t.LiteralFormat == LiteralFormat.CharLiteral)return new IdentifierExpression(t.LiteralValue) { LiteralFormat=t.LiteralFormat'Location = startLoc' EndLocation = t.EndLocation }; " is 187.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,PrimaryExpression,The length of the statement  "			// HACK -- not only on AllowWeakTypeParsing! But apparently' this stuff may be parsed twice' so force-skip results of the first attempt although this is a rather stupid solution " is 177.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,PrimaryExpression,The length of the statement  "			if (laKind == Identifier && (Lexer.CurrentPeekToken.Kind == CloseParenthesis || Lexer.CurrentPeekToken.Kind == Equal || Lexer.CurrentPeekToken.Kind == Colon)) { " is 160.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,IfCondition,The length of the statement  "	if (tp != null && ((laKind == Identifier && (Peek (1).Kind == Assign || Lexer.CurrentPeekToken.Kind == CloseParenthesis)) || // if(a * b * c) is an expression' if(a * b = 123) may be a pointer variable " is 201.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Statement,The length of the statement  "		if (ds.Declarations != null && ds.Declarations.Length == 1 && !(ds.Declarations [0] is DVariable) && !AllowWeakTypeParsing) " is 123.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ForeachStatement,The length of the statement  "		} else if (laKind == (Identifier) && (Lexer.CurrentPeekToken.Kind == (Semicolon) || Lexer.CurrentPeekToken.Kind == Comma)) { " is 124.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,EnumValue,The length of the statement  "	if (laKind == Identifier && (Lexer.CurrentPeekToken.Kind == Assign || Lexer.CurrentPeekToken.Kind == Comma || Lexer.CurrentPeekToken.Kind == CloseCurlyBrace)) { " is 160.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,FunctionBody,The length of the statement  "	// Although there can be in&out constraints' there doesn't have to be a direct body definition. Used on abstract class/interface methods. " is 137.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,FunctionBody,The length of the statement  "	par.EndLocation = IsEOF && t.Kind != DTokens.CloseCurlyBrace ? la.Location : par.Body != null ? par.Body.EndLocation : t.EndLocation; " is 133.
Long Statement,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,TemplateParameter,The length of the statement  "	else if (laKind == (Identifier) && (Lexer.CurrentPeekToken.Kind == (Colon) || Lexer.CurrentPeekToken.Kind == (Assign) || Lexer.CurrentPeekToken.Kind == (Comma) || Lexer.CurrentPeekToken.Kind == (CloseParenthesis))) { " is 216.
Long Statement,D_Parser.Parser,DTokens,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DTokens.cs,GetDescription,The length of the statement  "		return "Disables a declaration\nA reference to a declaration marked with the @disable attribute causes a compile time error\n\nThis can be used to explicitly disallow certain operations \nor overloads at compile time \nrather than relying on generating a runtime error."; " is 271.
Long Statement,D_Parser.Parser,DTokens,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DTokens.cs,GetDescription,The length of the statement  "		return "Property functions \ncan be called without parentheses (hence acting like properties).\n\nstruct S {\n  int m_x;\n  @property {\n    int x() { return m_x; }\n    int x(int newx) { return m_x = newx; }\n  }\n}\n\nvoid foo() {\n  S s;\n  s.x = 3;   // calls s.x(int)\n  bar(s.x);  // calls bar(s.x())\n}"; " is 311.
Long Statement,D_Parser.Parser,DTokens,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DTokens.cs,GetDescription,The length of the statement  "		return "Safe functions\n\nThe following operations are not allowed in safe functions:\n\n- No casting from a pointer type to any type other than void*.\n- No casting from any non-pointer type to a pointer type.\n- No modification of pointer values.\n- Cannot access unions that have pointers or references overlapping with other types.\n- Calling any system functions.\n- No catching of exceptions that are not derived from class Exception.\n- No inline assembler.\n- No explicit casting of mutable objects to immutable.\n- No explicit casting of immutable objects to mutable.\n- No explicit casting of thread local objects to shared.\n- No explicit casting of shared objects to thread local.\n- No taking the address of a local variable or function parameter.\n- Cannot access __gshared variables.\n- Functions nested inside safe functions default to being safe functions.\n\nSafe functions are covariant with trusted or system functions."; " is 941.
Long Statement,D_Parser.Parser,DTokens,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DTokens.cs,GetDescription,The length of the statement  "		return "System functions \nare functions not marked with @safe or @trusted and are not nested inside @safe functions\n\nSystem functions may be marked with the @system attribute.\n \nA function being system does not mean it actually is unsafe' it just means that the compiler is unable to verify that it cannot exhibit undefined behavior.\n\nSystem functions are not covariant with trusted or safe functions."; " is 410.
Long Statement,D_Parser.Parser,DTokens,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DTokens.cs,GetDescription,The length of the statement  "		return "Trusted functions\n\n- Are marked with the @trusted attribute'\n- Are guaranteed by the programmer to not exhibit \n  any undefined behavior if called by a safe function'\n- May call safe' trusted' or system functions'\n- Are covariant with safe or system functions"; " is 275.
Long Statement,D_Parser.Parser,DTokens,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DTokens.cs,GetDescription,The length of the statement  "		return "foreach" + (token == Foreach_Reverse ? "_reverse" : "") + "(element; array)\n{\n   foo(element);\n}\n\nOr:\nforeach" + (token == Foreach_Reverse ? "_reverse" : "") + "(element' index; array)\n{\n   foo(element);\n}"; " is 224.
Long Statement,D_Parser.Parser,DTokens,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DTokens.cs,GetDescription,The length of the statement  "		return "switch(a)\n{\n   case 1:\n      foo();\n      break;\n   case 2:\n      bar();\n      break;\n   default:\n      break;\n}"; " is 132.
Long Statement,D_Parser.Parser,IncrementalParsing,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\IncrementalParsing.cs,UpdateBlockPartly,The length of the statement  "	return new BlockStmtIncrParsing ().ParseIncrementally (bs' code' caretOffset' caretLocation' out isInsideNonCodeSegment); " is 121.
Long Statement,D_Parser.Parser,IncrementalParsing,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\IncrementalParsing.cs,UpdateBlockPartly,The length of the statement  "	return new IncrBlockNodeParsing ().ParseIncrementally (bn' code' caretOffset' caretLocation' out isInsideNonCodeSegment); " is 121.
Long Statement,D_Parser.Dom.Statements,StaticAssertStatement,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Statements\StaticAssertStatement.cs,ToCode,The length of the statement  "	return "static assert(" + (AssertedExpression != null ? AssertedExpression.ToString () : "") + (Message == null ? "" : ("'" + Message)) + ");"; " is 143.
Long Statement,D_Parser.Dom.Expressions,OperatorBasedExpression,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Expressions\OperatorBasedExpression.cs,ToString,The length of the statement  "	return LeftOperand.ToString () + DTokens.GetTokenString (OperatorToken) + (RightOperand != null ? RightOperand.ToString () : ""); " is 129.
Long Statement,D_Parser.Dom.Expressions,ConditionalExpression,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Expressions\ConditionalExpression.cs,ToString,The length of the statement  "	return (OrOrExpression != null ? OrOrExpression.ToString () : "") + "?" + (TrueCaseExpression != null ? TrueCaseExpression.ToString () : "") + ':' + (FalseCaseExpression != null ? FalseCaseExpression.ToString () : ""); " is 218.
Long Statement,D_Parser.Dom.Expressions,FunctionLiteral,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Expressions\FunctionLiteral.cs,ToString,The length of the statement  "	return DTokens.GetTokenString (LiteralToken) + (AnonymousMethod.NameHash == 0 ? "" : " ") + AnonymousMethod.ToString (); " is 120.
Long Statement,D_Parser.Dom.Expressions,IsExpression,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Expressions\IsExpression.cs,ToString,The length of the statement  "		ret += (EqualityTest ? "==" : ":") + (TypeSpecialization != null ? TypeSpecialization.ToString () : // Either the specialization declaration " is 140.
Complex Conditional,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,GenTooltipSignature,The conditional expression  "currentMethodParam >= 0 && !templateParamCompletion && ds.Definition is DVariable && ds.Base != null"  is complex.
Complex Conditional,D_Parser.Dom,DBlockNode,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Nodes\DBlockNode.cs,GetMetaBlockStack,The conditional expression  "lastSr != null && !(mindAttributeSections && lastSr is AttributeMetaDeclarationSection) && mb.Location < lastSr.Location && mb.EndLocation > lastSr.EndLocation"  is complex.
Complex Conditional,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,GetCommentsBefore,The conditional expression  "c == ' ' || c == '\t' || c == '\r' || c == '\n'"  is complex.
Complex Conditional,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,VisitChildren,The conditional expression  "mbStack.Count == 0 || (mb.Location > (peekMb = mbStack.Peek ()).Location && mb.EndLocation < peekMb.EndLocation && !(peekMb is AttributeMetaDeclarationSection))"  is complex.
Complex Conditional,D_Parser.Formatting.Indent,IndentEngineWrapper,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CorrectIndent,The conditional expression  "code.Peek () == -1 || (formatLastLine && n != '\r' && n != '\n')"  is complex.
Complex Conditional,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushNewLine,The conditional expression  "keyword == DTokens.Case || keyword == DTokens.Default || !canBeLabel || inside == Inside.Empty"  is complex.
Complex Conditional,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushNewLine,The conditional expression  "(stack.PeekInside (0) == Inside.Block && stack.PeekKeyword == DTokens.Enum) || (inside == Inside.FoldedStatement || inside == Inside.SquareBracketList)"  is complex.
Complex Conditional,D_Parser.Formatting.Indent,IndentStack,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,The conditional expression  "(stack [sp].inside & Inside.FoldedBlockOrCase) != 0 || // If there's myFoo( \n { \n' keep the ( indent + 1 tab  // If there's myFoo( \n [ \n' keep the ( indent only if ie.Options.KeepArgumentIndentOnSquareBracketOpen says so.  ((inside != Inside.SquareBracketList || ie.Options.KeepArgumentIndentOnSquareBracketOpen) && stack [sp].inside == Inside.ParenList)"  is complex.
Complex Conditional,D_Parser.Refactoring,TypeReferenceFinder,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,CheckCondition,The conditional expression  "c == null || c is StaticIfCondition || (c is NegatedDeclarationCondition && (c as NegatedDeclarationCondition).FirstCondition is NegatedDeclarationCondition)"  is complex.
Complex Conditional,D_Parser.Resolver,ResultComparer,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ResultComparer.cs,IsImplicitlyConvertible,The conditional expression  "!isVariable && resToCheck is ArrayType && targetType is PointerType && ((targetType = (targetType as PointerType).Base) is PrimitiveType) && DTokens.IsBasicType_Character ((targetType as PrimitiveType).TypeToken)"  is complex.
Complex Conditional,D_Parser.Resolver,StaticProperties,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,GetOwnerType,The conditional expression  "t is InstanceValue || t is ClassType || t is InterfaceType || t is TemplateType"  is complex.
Complex Conditional,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,mult,The conditional expression  "(a.Value != 0 && b.Value == 0) || (a.ImaginaryPart != 0 && b.ImaginaryPart == 0)"  is complex.
Complex Conditional,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,mult,The conditional expression  "(a.Value != 0 && b.Value == 0) || (a.ImaginaryPart != 0 && b.ImaginaryPart == 0)"  is complex.
Complex Conditional,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetConstructors,The conditional expression  "dv != null && !dv.IsStatic && !dv.IsAlias && !dv.IsConst"  is complex.
Complex Conditional,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,DeepScanClass,The conditional expression  "resolveBaseClassIfRequired && udt.Base == null && (type == DTokens.Class || type == DTokens.Interface)"  is complex.
Complex Conditional,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,CanHandleNode,The conditional expression  "(CanShowMember (dn' ctxt.ScopedBlock) || (parms.isBaseClass && !parms.isMixinAst)) && ((!parms.takeStaticChildrenOnly && (!parms.publicImportsOnly || !parms.isBaseClass)) || IsConstOrStatic (dn))"  is complex.
Complex Conditional,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,CanHandleNode,The conditional expression  "dm3 != null && !(dm3.SpecialType == DMethod.MethodType.Normal || dm3.SpecialType == DMethod.MethodType.Delegate || dm3.NameHash != 0)"  is complex.
Complex Conditional,D_Parser.Resolver.Templates,SpecializationOrdering,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\SpecializationOrdering.cs,IsMoreSpecialized,The conditional expression  "dn1 == null || dn1.TemplateParameters == null || dn2 == null || dn2.TemplateParameters == null"  is complex.
Complex Conditional,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The conditional expression  "(arrayDeclToCheckAgainst.ClampsEmpty == (at == null)) && (at == null || !at.IsStaticArray || arrayDeclToCheckAgainst.KeyExpression == null)"  is complex.
Complex Conditional,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The conditional expression  "(d.Parameters == null || d.Parameters.Count == 0) && dr_decl.Parameters == null || dr_decl.Parameters.Count == 0"  is complex.
Complex Conditional,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The conditional expression  "(dn.Attributes == null || dn.Attributes.Count == 0) && (dn_arg.Attributes == null || dn_arg.Attributes.Count == 0)"  is complex.
Complex Conditional,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,TryPostDeduceAliasDefinition,The conditional expression  "typeBase != null && b != null && b.Tag<AliasTag> (AliasTag.Id) != null && (ctxt.Options & ResolutionOptions.DontResolveAliases) == 0"  is complex.
Complex Conditional,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,ResolveClassOrInterface,The conditional expression  "type == null || (type is IdentifierDeclaration && (type as IdentifierDeclaration).IdHash == dc.NameHash) || dc.NodeRoot == dc"  is complex.
Complex Conditional,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,GetResultMember,The conditional expression  "aliasTag != null && (!(aliasTag.aliasDefinition is ImportSymbolAlias) || // Only if the import symbol alias definition was selected' go to its base  (aliasTag.typeBase != null && aliasTag.aliasDefinition.NameLocation != aliasTag.typeBase.Location))"  is complex.
Complex Conditional,D_Parser.Resolver.TypeResolution,UFCSResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\UFCSResolver.cs,PreCheckItem,The conditional expression  "(nameFilterHash != 0 && n.NameHash != nameFilterHash) || (!(n is ImportSymbolNode) && !(n.Parent is DModule))"  is complex.
Complex Conditional,D_Parser.Completion,CompletionProviderVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The conditional expression  "!halt && n.NameHash == 0 && (n.ContainsAttribute (DTokens.Auto) || DParser.ContainsStorageClass (n.Attributes) != Modifier.Empty)"  is complex.
Complex Conditional,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,AliasDeclaration,The conditional expression  "(laKind == Identifier && Lexer.CurrentPeekToken.Kind == This) || (laKind == This && Lexer.CurrentPeekToken.Kind == Assign)"  is complex.
Complex Conditional,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,AliasDeclaration,The conditional expression  "laKind == Identifier && (Lexer.CurrentPeekToken.Kind == Assign || (Lexer.CurrentPeekToken.Kind == OpenParenthesis && OverPeekBrackets (OpenParenthesis) && Lexer.CurrentPeekToken.Kind == Assign))"  is complex.
Complex Conditional,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Decl,The conditional expression  "(StorageClass != Modifier.Empty && laKind == (Identifier) && (DeclarationAttributes.Count > 0 || Lexer.CurrentPeekToken.Kind == OpenParenthesis))"  is complex.
Complex Conditional,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Decl,The conditional expression  "isAlias && (laKind == DTokens.This || laKind == DTokens.Super) && Lexer.CurrentPeekToken.Kind != DTokens.Dot"  is complex.
Complex Conditional,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Decl,The conditional expression  "tix.Arguments == null || tix.Arguments.Length == 0 || (tix.Arguments [tix.Arguments.Length - 1] is TokenExpression && (tix.Arguments [tix.Arguments.Length - 1] as TokenExpression).Token == DTokens.INVALID)"  is complex.
Complex Conditional,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Declarator,The conditional expression  "(tokDecl == null || tokDecl.Token != DTokens.Incomplete) && // 'T!|' or similar  (ad == null || !(ad.KeyExpression is TokenExpression) || (ad.KeyExpression as TokenExpression).Token != DTokens.Incomplete)"  is complex.
Complex Conditional,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Declarator2,The conditional expression  "AllowWeakTypeParsing && (td == null || (t.Kind == OpenParenthesis && laKind == CloseParenthesis) /* -- means if an argumentless function call has been made' return null because this would be an expression */|| laKind != CloseParenthesis)"  is complex.
Complex Conditional,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,PostfixExpression,The conditional expression  "(laKind == DTokens.Identifier && Peek (1).Kind != Not && Peek (1).Kind != OpenParenthesis) || IsEOF"  is complex.
Complex Conditional,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,PrimaryExpression,The conditional expression  "laKind == Identifier && (Lexer.CurrentPeekToken.Kind == CloseParenthesis || Lexer.CurrentPeekToken.Kind == Equal || Lexer.CurrentPeekToken.Kind == Colon)"  is complex.
Complex Conditional,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,IfCondition,The conditional expression  "tp != null && ((laKind == Identifier && (Peek (1).Kind == Assign || Lexer.CurrentPeekToken.Kind == CloseParenthesis)) || // if(a * b * c) is an expression' if(a * b = 123) may be a pointer variable  (IsEOF && tp.InnerDeclaration == null))"  is complex.
Complex Conditional,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Statement,The conditional expression  "ds.Declarations != null && ds.Declarations.Length == 1 && !(ds.Declarations [0] is DVariable) && !AllowWeakTypeParsing"  is complex.
Complex Conditional,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Statement,The conditional expression  "IsClassLike (laKind) || (IsBasicType (laKind) && Lexer.CurrentPeekToken.Kind != Dot) || IsModifier (laKind)"  is complex.
Complex Conditional,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmStatement,The conditional expression  "!Expect (CloseCurlyBrace) && (t.Kind == OpenCurlyBrace || t.Kind == Semicolon) && IsEOF"  is complex.
Complex Conditional,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,EnumValue,The conditional expression  "laKind == Identifier && (Lexer.CurrentPeekToken.Kind == Assign || Lexer.CurrentPeekToken.Kind == Comma || Lexer.CurrentPeekToken.Kind == CloseCurlyBrace)"  is complex.
Complex Conditional,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,TemplateParameter,The conditional expression  "laKind == (Identifier) && (Lexer.CurrentPeekToken.Kind == (Colon) || Lexer.CurrentPeekToken.Kind == (Assign) || Lexer.CurrentPeekToken.Kind == (Comma) || Lexer.CurrentPeekToken.Kind == (CloseParenthesis))"  is complex.
Complex Conditional,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,TraitsExpression,The conditional expression  "td != null && (laKind == Comma || laKind == CloseParenthesis || IsEOF)"  is complex.
Complex Conditional,D_Parser.Parser,DDocParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,SkipParameterText,The conditional expression  "Peek () == '!' && nextOffset + 2 < text.Length && text [nextOffset + 1] == '-' && text [nextOffset + 2] == '-'"  is complex.
Empty Catch Block,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,IsFalseZeroOrNull,The method has an empty catch block.
Empty Catch Block,D_Parser.Resolver.ExpressionSemantics,MathOperationEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MathOperationEvaluation.cs,ToBool,The method has an empty catch block.
Empty Catch Block,D_Parser.Resolver.ExpressionSemantics,MathOperationEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MathOperationEvaluation.cs,ToDouble,The method has an empty catch block.
Empty Catch Block,D_Parser.Resolver.ExpressionSemantics,MathOperationEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MathOperationEvaluation.cs,ToLong,The method has an empty catch block.
Empty Catch Block,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParamsAndFilterOverloads,The method has an empty catch block.
Empty Catch Block,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,DeclDef,The method has an empty catch block.
Magic Number,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,AppendFormat,The following statement contains a magic number: if ((flags & FormatFlags.Color) != 0) {  	sb.Append (string.Format (" color='#{0:x2}{1:x2}{2:x2}'"' (int)(r * 255.0)' (int)(g * 255.0)' (int)(b * 255.0)));  }  
Magic Number,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,AppendFormat,The following statement contains a magic number: if ((flags & FormatFlags.Color) != 0) {  	sb.Append (string.Format (" color='#{0:x2}{1:x2}{2:x2}'"' (int)(r * 255.0)' (int)(g * 255.0)' (int)(b * 255.0)));  }  
Magic Number,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,AppendFormat,The following statement contains a magic number: if ((flags & FormatFlags.Color) != 0) {  	sb.Append (string.Format (" color='#{0:x2}{1:x2}{2:x2}'"' (int)(r * 255.0)' (int)(g * 255.0)' (int)(b * 255.0)));  }  
Magic Number,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,AppendFormat,The following statement contains a magic number: sb.Append (string.Format (" color='#{0:x2}{1:x2}{2:x2}'"' (int)(r * 255.0)' (int)(g * 255.0)' (int)(b * 255.0)));  
Magic Number,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,AppendFormat,The following statement contains a magic number: sb.Append (string.Format (" color='#{0:x2}{1:x2}{2:x2}'"' (int)(r * 255.0)' (int)(g * 255.0)' (int)(b * 255.0)));  
Magic Number,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,AppendFormat,The following statement contains a magic number: sb.Append (string.Format (" color='#{0:x2}{1:x2}{2:x2}'"' (int)(r * 255.0)' (int)(g * 255.0)' (int)(b * 255.0)));  
Magic Number,D_Parser.Dom,DClassLike,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Nodes\OtherNodeDefinitions.cs,ToString,The following statement contains a magic number: if (BaseClasses.Count > 0) {  	sb.Append (':');  	foreach (var c in BaseClasses)  		sb.Append (c.ToString ()).Append ("' ");  	sb.Remove (sb.Length - 2' 2);  }  
Magic Number,D_Parser.Dom,DClassLike,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Nodes\OtherNodeDefinitions.cs,ToString,The following statement contains a magic number: if (BaseClasses.Count > 0) {  	sb.Append (':');  	foreach (var c in BaseClasses)  		sb.Append (c.ToString ()).Append ("' ");  	sb.Remove (sb.Length - 2' 2);  }  
Magic Number,D_Parser.Dom,DClassLike,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Nodes\OtherNodeDefinitions.cs,ToString,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2);  
Magic Number,D_Parser.Dom,DClassLike,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Nodes\OtherNodeDefinitions.cs,ToString,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2);  
Magic Number,D_Parser.Dom,CodeLocation,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\CodeLocation.cs,GetHashCode,The following statement contains a magic number: return unchecked(87 * Column.GetHashCode () ^ Line.GetHashCode ());  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return unchecked(100003 * Visit (n as DVariable));  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return unchecked(1000081 * VisitBlockNode (n));  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return unchecked(1000133 * n.Mixin.Accept (this));  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return unchecked(1000231 * Visit ((DVariable)ep));  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: return 1000159;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: return unchecked(1000171 * VisitAttribute ((Modifier)attr));  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: return 1000183 * (long)a.Kind;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: return 1000193 * ((long)a.VersionNumber + (long)a.VersionIdHash);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: return 1000199 * ((long)a.DebugLevel + (long)a.DebugIdHash);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: return unchecked(1000213 * a.FirstCondition.Accept (this));  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000289;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000291;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitImport,The following statement contains a magic number: return 1000303;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitImport,The following statement contains a magic number: return 1000313;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitImport,The following statement contains a magic number: return 1000333;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000357;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000367;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000381;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000393;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000397;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000403;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000409;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000423;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000427;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000429;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000453;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000457;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000507;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000537;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000541;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000547;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000577;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000579;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000589;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000609;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000619;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000621;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000639;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000651;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000667;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000679;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000691;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000697;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000721;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000723;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000763;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000777;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000793;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitMixinStatement,The following statement contains a magic number: return 1000829;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression (x' 1000849);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression (x' 1000861);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression (x' 1000889);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression (x' 1000907);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression (x' 1000919);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression (x' 1000921);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression (x' 1000931);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression (x' 1000973);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: Hash (ref h' prime' x.Not ? 2 : 1);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression (x' 1000999);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression (x' 1001003);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression (x' 1001017);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression (x' 1001023);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression (x' 1001027);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression (x' 1001041);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression (x' 1001069);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression (x' 1001081);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression (x' 1001087);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression (x' 1001089);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression (x' 1001093);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression (x' 1001107);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression (x' 1001123);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression (x' 1001177);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitPostfixExpression (x' 1001219);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitPostfixExpression (x' 1001237);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001321 + (long)x.Token >> 8;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001321 + (long)x.Token >> 8;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001323 + x.Declaration.Accept (this);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001347;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001353;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001369;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001381;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001387;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001389;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001411;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001431;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001447;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001459;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001467;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001491;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001501 * x.Register.GetHashCode ();  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001527;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitTypeDeclaration (td' 1001569);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitTypeDeclaration (td' 1001629);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitPointerType,The following statement contains a magic number: return VisitDerivedType (t' 1001669);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAliasedType,The following statement contains a magic number: return VisitMemberSymbol (t' 1001743);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitEnumType,The following statement contains a magic number: return VisitUserDefinedType (t' 1001783);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitStructType,The following statement contains a magic number: return VisitTemplateIntermediaryType (t' 1001797);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitUnionType,The following statement contains a magic number: return VisitTemplateIntermediaryType (t' 1001801);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitClassType,The following statement contains a magic number: return VisitTemplateIntermediaryType (t' 1001807);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitInterfaceType,The following statement contains a magic number: return VisitTemplateIntermediaryType (t' 1001809);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitTemplateType,The following statement contains a magic number: return VisitTemplateIntermediaryType (t' 1001821);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitMixinTemplateType,The following statement contains a magic number: return VisitTemplateIntermediaryType (t' 1001831);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitEponymousTemplateType,The following statement contains a magic number: return VisitUserDefinedType (t' 1001839);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitStaticProperty,The following statement contains a magic number: return VisitMemberSymbol (t' 1001911);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitMemberSymbol,The following statement contains a magic number: return VisitDSymbol (t' 1001933);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitArrayAccessSymbol,The following statement contains a magic number: return VisitDerivedType (t' 1001947);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitModuleSymbol,The following statement contains a magic number: return VisitDSymbol (t' 1001953);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitUnknownType,The following statement contains a magic number: return VisitAbstractType (t' 1001983);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitMetaDeclarationBlock,The following statement contains a magic number: return 1002017;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttributeMetaDeclarationBlock,The following statement contains a magic number: return 1002049;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttributeMetaDeclarationSection,The following statement contains a magic number: return 1002061;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitElseMetaDeclarationBlock,The following statement contains a magic number: return 1002073;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitElseMetaDeclarationSection,The following statement contains a magic number: return 1002151;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitElseMetaDeclaration,The following statement contains a magic number: return 1002077;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttributeMetaDeclaration,The following statement contains a magic number: return 1002083;  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1002149 * VisitTemplateParameter (tp);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitVoidValue,The following statement contains a magic number: return VisitExpressionValue (v' 1002227);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitNullValue,The following statement contains a magic number: return VisitExpressionValue (v' 1002259);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitVariableValue,The following statement contains a magic number: return VisitReferenceValue (v' 1002289);  
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitTypeValue,The following statement contains a magic number: return VisitExpressionValue (v' 1002299);  
Magic Number,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,Visit,The following statement contains a magic number: switch (n.SpecialType) {  case DMethod.MethodType.Destructor:  case DMethod.MethodType.Constructor:  	nameLength = 4;  	// this  	break;  case DMethod.MethodType.Normal:  	nameLength = n.Name.Length;  	break;  }  
Magic Number,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,Visit,The following statement contains a magic number: nameLength = 4;  
Magic Number,D_Parser.Formatting,TextDocument,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DocumentAdapter.cs,ToLocation,The following statement contains a magic number: if (offset < text.Length / 2) {  	for (int i = 1; i < lines.Length; i++) {  		if (lines [i] > offset)  			return new CodeLocation (offset - lines [i - 1] + 1' i);  	}  	return new CodeLocation (offset - lines [lines.Length - 1] + 1' lines.Length);  } else {  	for (int i = lines.Length - 1; i > 0; i--) {  		if (lines [i] < offset)  			return new CodeLocation (offset - lines [i] + 1' i + 1);  	}  	return new CodeLocation (offset + 1' 1);  }  
Magic Number,D_Parser.Formatting.Indent,IndentEngineWrapper,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CalculateIndent,The following statement contains a magic number: if (line < 2)  	return string.Empty;  
Magic Number,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,Push,The following statement contains a magic number: switch (c) {  case '#':  	PushHash (inside);  	lastChar = '#';  	break;  case '/':  	PushSlash (inside);  	break;  case '\\':  	PushBackSlash (inside);  	break;  case '+':  case '*':  	PushStar (inside' c);  	break;  case '`':  	PushAccGrave (inside);  	break;  case '"':  	PushQuote (inside);  	break;  case '\'':  	PushSQuote (inside);  	break;  case ':':  	PushColon (inside);  	break;  case ';':  	PushSemicolon (inside);  	break;  case '[':  	PushOpenSq (inside);  	break;  case ']':  	PushCloseSq (inside);  	break;  case '(':  	PushOpenParen (inside);  	break;  case ')':  	PushCloseParen (inside);  	break;  case '{':  	PushOpenBrace (inside);  	break;  case '}':  	PushCloseBrace (inside);  	break;  case '\r':  	CheckForParentList ();  	PushNewLine (inside);  	lastChar = c;  	return;  case '\n':  	CheckForParentList ();  	if (lastChar == '\r') {  		cursor++;  	} else {  		PushNewLine (inside);  	}  	lastChar = c;  	return;  case 'e':  	// If there's an 'else'' look if there has been a if-else backup stack prepared  	//KNOWN ISSUE: Reset this backup stack if there's anything else than an 'else' following the recently closed if-stmt;   	// Anyway this shouldn't be noticed that often as there can't be a stand-alone 'else' dangling around somewhere.   	if (linebuf.Length > 2 && linebuf.ToString (linebuf.Length - 3' 3) == "els") {  		var backup = stack.PeekIfElseBackupStack;  		stack.PeekIfElseBackupStack = null;  		if (backup != null && backup.Count > 0) {  			keyword = DTokens.Else;  			inside = Inside.FoldedStatement;  			stack = backup;  			stack.Pop ();  			var newIndent = stack.PeekIndent (0);  			if (curIndent != newIndent) {  				curIndent = newIndent;  				needsReindent = true;  			}  		}  	}  	break;  default:  	break;  }  
Magic Number,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,Push,The following statement contains a magic number: switch (c) {  case '#':  	PushHash (inside);  	lastChar = '#';  	break;  case '/':  	PushSlash (inside);  	break;  case '\\':  	PushBackSlash (inside);  	break;  case '+':  case '*':  	PushStar (inside' c);  	break;  case '`':  	PushAccGrave (inside);  	break;  case '"':  	PushQuote (inside);  	break;  case '\'':  	PushSQuote (inside);  	break;  case ':':  	PushColon (inside);  	break;  case ';':  	PushSemicolon (inside);  	break;  case '[':  	PushOpenSq (inside);  	break;  case ']':  	PushCloseSq (inside);  	break;  case '(':  	PushOpenParen (inside);  	break;  case ')':  	PushCloseParen (inside);  	break;  case '{':  	PushOpenBrace (inside);  	break;  case '}':  	PushCloseBrace (inside);  	break;  case '\r':  	CheckForParentList ();  	PushNewLine (inside);  	lastChar = c;  	return;  case '\n':  	CheckForParentList ();  	if (lastChar == '\r') {  		cursor++;  	} else {  		PushNewLine (inside);  	}  	lastChar = c;  	return;  case 'e':  	// If there's an 'else'' look if there has been a if-else backup stack prepared  	//KNOWN ISSUE: Reset this backup stack if there's anything else than an 'else' following the recently closed if-stmt;   	// Anyway this shouldn't be noticed that often as there can't be a stand-alone 'else' dangling around somewhere.   	if (linebuf.Length > 2 && linebuf.ToString (linebuf.Length - 3' 3) == "els") {  		var backup = stack.PeekIfElseBackupStack;  		stack.PeekIfElseBackupStack = null;  		if (backup != null && backup.Count > 0) {  			keyword = DTokens.Else;  			inside = Inside.FoldedStatement;  			stack = backup;  			stack.Pop ();  			var newIndent = stack.PeekIndent (0);  			if (curIndent != newIndent) {  				curIndent = newIndent;  				needsReindent = true;  			}  		}  	}  	break;  default:  	break;  }  
Magic Number,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,Push,The following statement contains a magic number: switch (c) {  case '#':  	PushHash (inside);  	lastChar = '#';  	break;  case '/':  	PushSlash (inside);  	break;  case '\\':  	PushBackSlash (inside);  	break;  case '+':  case '*':  	PushStar (inside' c);  	break;  case '`':  	PushAccGrave (inside);  	break;  case '"':  	PushQuote (inside);  	break;  case '\'':  	PushSQuote (inside);  	break;  case ':':  	PushColon (inside);  	break;  case ';':  	PushSemicolon (inside);  	break;  case '[':  	PushOpenSq (inside);  	break;  case ']':  	PushCloseSq (inside);  	break;  case '(':  	PushOpenParen (inside);  	break;  case ')':  	PushCloseParen (inside);  	break;  case '{':  	PushOpenBrace (inside);  	break;  case '}':  	PushCloseBrace (inside);  	break;  case '\r':  	CheckForParentList ();  	PushNewLine (inside);  	lastChar = c;  	return;  case '\n':  	CheckForParentList ();  	if (lastChar == '\r') {  		cursor++;  	} else {  		PushNewLine (inside);  	}  	lastChar = c;  	return;  case 'e':  	// If there's an 'else'' look if there has been a if-else backup stack prepared  	//KNOWN ISSUE: Reset this backup stack if there's anything else than an 'else' following the recently closed if-stmt;   	// Anyway this shouldn't be noticed that often as there can't be a stand-alone 'else' dangling around somewhere.   	if (linebuf.Length > 2 && linebuf.ToString (linebuf.Length - 3' 3) == "els") {  		var backup = stack.PeekIfElseBackupStack;  		stack.PeekIfElseBackupStack = null;  		if (backup != null && backup.Count > 0) {  			keyword = DTokens.Else;  			inside = Inside.FoldedStatement;  			stack = backup;  			stack.Pop ();  			var newIndent = stack.PeekIndent (0);  			if (curIndent != newIndent) {  				curIndent = newIndent;  				needsReindent = true;  			}  		}  	}  	break;  default:  	break;  }  
Magic Number,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,Push,The following statement contains a magic number: if (linebuf.Length > 2 && linebuf.ToString (linebuf.Length - 3' 3) == "els") {  	var backup = stack.PeekIfElseBackupStack;  	stack.PeekIfElseBackupStack = null;  	if (backup != null && backup.Count > 0) {  		keyword = DTokens.Else;  		inside = Inside.FoldedStatement;  		stack = backup;  		stack.Pop ();  		var newIndent = stack.PeekIndent (0);  		if (curIndent != newIndent) {  			curIndent = newIndent;  			needsReindent = true;  		}  	}  }  
Magic Number,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,Push,The following statement contains a magic number: if (linebuf.Length > 2 && linebuf.ToString (linebuf.Length - 3' 3) == "els") {  	var backup = stack.PeekIfElseBackupStack;  	stack.PeekIfElseBackupStack = null;  	if (backup != null && backup.Count > 0) {  		keyword = DTokens.Else;  		inside = Inside.FoldedStatement;  		stack = backup;  		stack.Pop ();  		var newIndent = stack.PeekIndent (0);  		if (curIndent != newIndent) {  			curIndent = newIndent;  			needsReindent = true;  		}  	}  }  
Magic Number,D_Parser.Formatting.Indent,IndentEngine,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,Push,The following statement contains a magic number: if (linebuf.Length > 2 && linebuf.ToString (linebuf.Length - 3' 3) == "els") {  	var backup = stack.PeekIfElseBackupStack;  	stack.PeekIfElseBackupStack = null;  	if (backup != null && backup.Count > 0) {  		keyword = DTokens.Else;  		inside = Inside.FoldedStatement;  		stack = backup;  		stack.Pop ();  		var newIndent = stack.PeekIndent (0);  		if (curIndent != newIndent) {  			curIndent = newIndent;  			needsReindent = true;  		}  	}  }  
Magic Number,D_Parser.Formatting.Indent,IndentStack,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,The following statement contains a magic number: if (size == stack.Length)  	Array.Resize<Node> (ref stack' 2 * size);  
Magic Number,D_Parser.Formatting.Indent,IndentStack,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,The following statement contains a magic number: Array.Resize<Node> (ref stack' 2 * size);  
Magic Number,D_Parser.Formatting.Indent,IndentStack,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,The following statement contains a magic number: if (size == stack.Length)  	Array.Resize<Node> (ref stack' 2 * size);  
Magic Number,D_Parser.Formatting.Indent,IndentStack,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,The following statement contains a magic number: Array.Resize<Node> (ref stack' 2 * size);  
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The following statement contains a magic number: switch (p) {  case 'n':  	r.Read ();  	return new TokenExpression (DTokens.Null);  case 'N':  	r.Read ();  	return new IdentifierExpression (-Number ()' LiteralFormat.Scalar' LiteralSubformat.Integer);  case 'i':  	r.Read ();  	return new IdentifierExpression (-Number ()' LiteralFormat.Scalar' LiteralSubformat.Integer | LiteralSubformat.Imaginary);  case 'e':  	// HexFloat  	r.Read ();  	return HexFloat ();  case 'c':  	// Complex  	r.Read ();  	var re = HexFloat ();  	r.Read ();  	// Skip further c  	var im = HexFloat ();  	//TODO  	return re;  case 'H':  case 'A':  case 'S':  	r.Read ();  	var n = (int)Number ();  	var xx = new List<IExpression> ();  	for (int i = n; i > 0; i--)  		xx.Add (Value ());  	if (p == 'S') {  		var inits = new List<StructMemberInitializer> (xx.Count);  		for (int i = n - 1; i >= 0; i--)  			inits.Add (new StructMemberInitializer {  				Value = xx [i]  			});  		return new StructInitializer {  			MemberInitializers = inits.ToArray ()  		};  	}  	if (p == 'H' || PeekIsValue)// We've got an AA  	 {  		for (int i = n; i > 0; i--)  			xx.Add (Value ());  		var kv = new List<KeyValuePair<IExpression' IExpression>> (n);  		for (int i = (n * 2) - 1; i > 0; i -= 2)  			kv.Add (new KeyValuePair<IExpression' IExpression> (xx [i - 1]' xx [i]));  		return new AssocArrayExpression {  			Elements = kv  		};  	}  	return new ArrayLiteralExpression (xx);  case 'a':  case 'w':  case 'd':  	r.Read ();  	var len = (int)Number ();  	sb.Clear ();  	for (; len > 0; len--)  		sb.Append ((char)(Lexer.GetHexNumber ((char)r.Read ()) << 4 + Lexer.GetHexNumber ((char)r.Read ())));  	return new IdentifierExpression (sb.ToString ()' LiteralFormat.StringLiteral' p == 'a' ? LiteralSubformat.Utf8 : (p == 'w' ? LiteralSubformat.Utf16 : LiteralSubformat.Utf32));  }  
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The following statement contains a magic number: switch (p) {  case 'n':  	r.Read ();  	return new TokenExpression (DTokens.Null);  case 'N':  	r.Read ();  	return new IdentifierExpression (-Number ()' LiteralFormat.Scalar' LiteralSubformat.Integer);  case 'i':  	r.Read ();  	return new IdentifierExpression (-Number ()' LiteralFormat.Scalar' LiteralSubformat.Integer | LiteralSubformat.Imaginary);  case 'e':  	// HexFloat  	r.Read ();  	return HexFloat ();  case 'c':  	// Complex  	r.Read ();  	var re = HexFloat ();  	r.Read ();  	// Skip further c  	var im = HexFloat ();  	//TODO  	return re;  case 'H':  case 'A':  case 'S':  	r.Read ();  	var n = (int)Number ();  	var xx = new List<IExpression> ();  	for (int i = n; i > 0; i--)  		xx.Add (Value ());  	if (p == 'S') {  		var inits = new List<StructMemberInitializer> (xx.Count);  		for (int i = n - 1; i >= 0; i--)  			inits.Add (new StructMemberInitializer {  				Value = xx [i]  			});  		return new StructInitializer {  			MemberInitializers = inits.ToArray ()  		};  	}  	if (p == 'H' || PeekIsValue)// We've got an AA  	 {  		for (int i = n; i > 0; i--)  			xx.Add (Value ());  		var kv = new List<KeyValuePair<IExpression' IExpression>> (n);  		for (int i = (n * 2) - 1; i > 0; i -= 2)  			kv.Add (new KeyValuePair<IExpression' IExpression> (xx [i - 1]' xx [i]));  		return new AssocArrayExpression {  			Elements = kv  		};  	}  	return new ArrayLiteralExpression (xx);  case 'a':  case 'w':  case 'd':  	r.Read ();  	var len = (int)Number ();  	sb.Clear ();  	for (; len > 0; len--)  		sb.Append ((char)(Lexer.GetHexNumber ((char)r.Read ()) << 4 + Lexer.GetHexNumber ((char)r.Read ())));  	return new IdentifierExpression (sb.ToString ()' LiteralFormat.StringLiteral' p == 'a' ? LiteralSubformat.Utf8 : (p == 'w' ? LiteralSubformat.Utf16 : LiteralSubformat.Utf32));  }  
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The following statement contains a magic number: switch (p) {  case 'n':  	r.Read ();  	return new TokenExpression (DTokens.Null);  case 'N':  	r.Read ();  	return new IdentifierExpression (-Number ()' LiteralFormat.Scalar' LiteralSubformat.Integer);  case 'i':  	r.Read ();  	return new IdentifierExpression (-Number ()' LiteralFormat.Scalar' LiteralSubformat.Integer | LiteralSubformat.Imaginary);  case 'e':  	// HexFloat  	r.Read ();  	return HexFloat ();  case 'c':  	// Complex  	r.Read ();  	var re = HexFloat ();  	r.Read ();  	// Skip further c  	var im = HexFloat ();  	//TODO  	return re;  case 'H':  case 'A':  case 'S':  	r.Read ();  	var n = (int)Number ();  	var xx = new List<IExpression> ();  	for (int i = n; i > 0; i--)  		xx.Add (Value ());  	if (p == 'S') {  		var inits = new List<StructMemberInitializer> (xx.Count);  		for (int i = n - 1; i >= 0; i--)  			inits.Add (new StructMemberInitializer {  				Value = xx [i]  			});  		return new StructInitializer {  			MemberInitializers = inits.ToArray ()  		};  	}  	if (p == 'H' || PeekIsValue)// We've got an AA  	 {  		for (int i = n; i > 0; i--)  			xx.Add (Value ());  		var kv = new List<KeyValuePair<IExpression' IExpression>> (n);  		for (int i = (n * 2) - 1; i > 0; i -= 2)  			kv.Add (new KeyValuePair<IExpression' IExpression> (xx [i - 1]' xx [i]));  		return new AssocArrayExpression {  			Elements = kv  		};  	}  	return new ArrayLiteralExpression (xx);  case 'a':  case 'w':  case 'd':  	r.Read ();  	var len = (int)Number ();  	sb.Clear ();  	for (; len > 0; len--)  		sb.Append ((char)(Lexer.GetHexNumber ((char)r.Read ()) << 4 + Lexer.GetHexNumber ((char)r.Read ())));  	return new IdentifierExpression (sb.ToString ()' LiteralFormat.StringLiteral' p == 'a' ? LiteralSubformat.Utf8 : (p == 'w' ? LiteralSubformat.Utf16 : LiteralSubformat.Utf32));  }  
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The following statement contains a magic number: if (p == 'H' || PeekIsValue)// We've got an AA   {  	for (int i = n; i > 0; i--)  		xx.Add (Value ());  	var kv = new List<KeyValuePair<IExpression' IExpression>> (n);  	for (int i = (n * 2) - 1; i > 0; i -= 2)  		kv.Add (new KeyValuePair<IExpression' IExpression> (xx [i - 1]' xx [i]));  	return new AssocArrayExpression {  		Elements = kv  	};  }  
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The following statement contains a magic number: if (p == 'H' || PeekIsValue)// We've got an AA   {  	for (int i = n; i > 0; i--)  		xx.Add (Value ());  	var kv = new List<KeyValuePair<IExpression' IExpression>> (n);  	for (int i = (n * 2) - 1; i > 0; i -= 2)  		kv.Add (new KeyValuePair<IExpression' IExpression> (xx [i - 1]' xx [i]));  	return new AssocArrayExpression {  		Elements = kv  	};  }  
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The following statement contains a magic number: for (int i = (n * 2) - 1; i > 0; i -= 2)  	kv.Add (new KeyValuePair<IExpression' IExpression> (xx [i - 1]' xx [i]));  
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The following statement contains a magic number: for (int i = (n * 2) - 1; i > 0; i -= 2)  	kv.Add (new KeyValuePair<IExpression' IExpression> (xx [i - 1]' xx [i]));  
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The following statement contains a magic number: i -= 2
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The following statement contains a magic number: for (; len > 0; len--)  	sb.Append ((char)(Lexer.GetHexNumber ((char)r.Read ()) << 4 + Lexer.GetHexNumber ((char)r.Read ())));  
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The following statement contains a magic number: sb.Append ((char)(Lexer.GetHexNumber ((char)r.Read ()) << 4 + Lexer.GetHexNumber ((char)r.Read ())));  
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The following statement contains a magic number: if (Lexer.IsLegalDigit (p' 10))  	return new IdentifierExpression (Number ()' LiteralFormat.Scalar' LiteralSubformat.Integer);  
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,HexFloat,The following statement contains a magic number: if (r.Peek () == 'P') {  	r.Read ();  	var exp = Exponent ();  	n *= (decimal)Math.Pow (10' exp);  }  
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,HexFloat,The following statement contains a magic number: n *= (decimal)Math.Pow (10' exp);  
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,HexDigits,The following statement contains a magic number: return Lexer.ParseFloatValue (sb' 16);  
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Number,The following statement contains a magic number: return Lexer.ParseFloatValue (sb' 10);  
Magic Number,D_Parser.Refactoring,SortImportsRefactoring,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\SortImportsRefactoring.cs,ResortImports,The following statement contains a magic number: if (importsToSort.Count < 2)  	return;  
Magic Number,D_Parser.Refactoring,SortImportsRefactoring,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\SortImportsRefactoring.cs,CalculateImportsToSort,The following statement contains a magic number: if (importsToSort.Count < 2)  	return new List<KeyValuePair<List<DAttribute>' List<ImportStatement>>> ();  
Magic Number,D_Parser.Resolver,MixinAnalysis,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\MixinAnalysis.cs,CheckAndPushAnalysisStack,The following statement contains a magic number: if (stmtsBeingAnalysed.Count != 0) {  	if (stmtsBeingAnalysed.Count > 5)  		return null;  	/* 				 * Only accept mixins that are located somewhere BEFORE the mixin that is the last inserted one in the stack. 				 * Also make sure mx and the peek mixin do have the same module root! 				 */var nr = mx.ParentNode != null ? mx.ParentNode.NodeRoot : null;  	foreach (var pk in stmtsBeingAnalysed) {  		if (nr == pk.ParentNode.NodeRoot) {  			if (mx == pk || mx.Location >= pk.Location)  				return null;  			break;  		}  	}  }  
Magic Number,D_Parser.Resolver,MixinAnalysis,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\MixinAnalysis.cs,CheckAndPushAnalysisStack,The following statement contains a magic number: if (stmtsBeingAnalysed.Count > 5)  	return null;  
Magic Number,D_Parser.Resolver,ResultComparer,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ResultComparer.cs,IsPrimitiveTypeImplicitlyConvertible,The following statement contains a magic number: return fromType == toType || ImplicitConvertabilityTable.Contains ((fromType << 8) + toType);  
Magic Number,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The following statement contains a magic number: if (x is XorExpression) {  	return HandleSingleMathOp (x' l' r' (a' b) => {  		if (ev.EnsureIntegralType (x.LeftOperand' a) && ev.EnsureIntegralType (x.RightOperand' b))  			return (long)a.Value ^ (long)b.Value;  		return 0L;  	});  } else if (x is OrExpression) {  	return HandleSingleMathOp (x' l' r' (a' b) => {  		if (ev.EnsureIntegralType (x.LeftOperand' a) && ev.EnsureIntegralType (x.RightOperand' b))  			return (long)a.Value | (long)b.Value;  		return 0L;  	});  } else if (x is AndExpression) {  	return HandleSingleMathOp (x' l' r' (a' b) => {  		if (ev.EnsureIntegralType (x.LeftOperand' a) && ev.EnsureIntegralType (x.RightOperand' b))  			return (long)a.Value & (long)b.Value;  		return 0L;  	});  } else if (x is ShiftExpression)  	return HandleSingleMathOp (x' l' r' (a' b) => {  		if (!ev.EnsureIntegralType (x.LeftOperand' a) || !ev.EnsureIntegralType (x.RightOperand' b))  			return 0L;  		if (b.Value < 0 || b.Value > 31) {  			ev.EvalError (x' "Shift operand must be between 0 and 31"' new[] {  				b  			});  			return 0m;  		}  		switch (x.OperatorToken) {  		case DTokens.ShiftLeft:  			return (long)a.Value << (int)b.Value;  		// TODO: Handle the imaginary part  		case DTokens.ShiftRight:  			return (long)a.Value >> (int)b.Value;  		case DTokens.ShiftRightUnsigned:  			//TODO: Find out where's the difference between >> and >>>  			return (ulong)a.Value >> (int)(uint)b.Value;  		}  		ev.EvalError (x' "Invalid token for shift expression"' new[] {  			l'  			r  		});  		return 0m;  	});  else if (x is AddExpression)  	return HandleSingleMathOp (x' l' r' (a' b' op) => {  		switch (op.OperatorToken) {  		case DTokens.Plus:  			return new PrimitiveValue (a.BaseTypeToken' a.Value + b.Value' a.ImaginaryPart + b.ImaginaryPart' a.Modifier);  		case DTokens.Minus:  			return new PrimitiveValue (a.BaseTypeToken' a.Value - b.Value' a.ImaginaryPart - b.ImaginaryPart' a.Modifier);  		}  		ev.EvalError (op' "Invalid token for add/sub expression"' new[] {  			l'  			r  		});  		return null;  	});  
Magic Number,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The following statement contains a magic number: if (x is OrExpression) {  	return HandleSingleMathOp (x' l' r' (a' b) => {  		if (ev.EnsureIntegralType (x.LeftOperand' a) && ev.EnsureIntegralType (x.RightOperand' b))  			return (long)a.Value | (long)b.Value;  		return 0L;  	});  } else if (x is AndExpression) {  	return HandleSingleMathOp (x' l' r' (a' b) => {  		if (ev.EnsureIntegralType (x.LeftOperand' a) && ev.EnsureIntegralType (x.RightOperand' b))  			return (long)a.Value & (long)b.Value;  		return 0L;  	});  } else if (x is ShiftExpression)  	return HandleSingleMathOp (x' l' r' (a' b) => {  		if (!ev.EnsureIntegralType (x.LeftOperand' a) || !ev.EnsureIntegralType (x.RightOperand' b))  			return 0L;  		if (b.Value < 0 || b.Value > 31) {  			ev.EvalError (x' "Shift operand must be between 0 and 31"' new[] {  				b  			});  			return 0m;  		}  		switch (x.OperatorToken) {  		case DTokens.ShiftLeft:  			return (long)a.Value << (int)b.Value;  		// TODO: Handle the imaginary part  		case DTokens.ShiftRight:  			return (long)a.Value >> (int)b.Value;  		case DTokens.ShiftRightUnsigned:  			//TODO: Find out where's the difference between >> and >>>  			return (ulong)a.Value >> (int)(uint)b.Value;  		}  		ev.EvalError (x' "Invalid token for shift expression"' new[] {  			l'  			r  		});  		return 0m;  	});  else if (x is AddExpression)  	return HandleSingleMathOp (x' l' r' (a' b' op) => {  		switch (op.OperatorToken) {  		case DTokens.Plus:  			return new PrimitiveValue (a.BaseTypeToken' a.Value + b.Value' a.ImaginaryPart + b.ImaginaryPart' a.Modifier);  		case DTokens.Minus:  			return new PrimitiveValue (a.BaseTypeToken' a.Value - b.Value' a.ImaginaryPart - b.ImaginaryPart' a.Modifier);  		}  		ev.EvalError (op' "Invalid token for add/sub expression"' new[] {  			l'  			r  		});  		return null;  	});  
Magic Number,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The following statement contains a magic number: if (x is AndExpression) {  	return HandleSingleMathOp (x' l' r' (a' b) => {  		if (ev.EnsureIntegralType (x.LeftOperand' a) && ev.EnsureIntegralType (x.RightOperand' b))  			return (long)a.Value & (long)b.Value;  		return 0L;  	});  } else if (x is ShiftExpression)  	return HandleSingleMathOp (x' l' r' (a' b) => {  		if (!ev.EnsureIntegralType (x.LeftOperand' a) || !ev.EnsureIntegralType (x.RightOperand' b))  			return 0L;  		if (b.Value < 0 || b.Value > 31) {  			ev.EvalError (x' "Shift operand must be between 0 and 31"' new[] {  				b  			});  			return 0m;  		}  		switch (x.OperatorToken) {  		case DTokens.ShiftLeft:  			return (long)a.Value << (int)b.Value;  		// TODO: Handle the imaginary part  		case DTokens.ShiftRight:  			return (long)a.Value >> (int)b.Value;  		case DTokens.ShiftRightUnsigned:  			//TODO: Find out where's the difference between >> and >>>  			return (ulong)a.Value >> (int)(uint)b.Value;  		}  		ev.EvalError (x' "Invalid token for shift expression"' new[] {  			l'  			r  		});  		return 0m;  	});  else if (x is AddExpression)  	return HandleSingleMathOp (x' l' r' (a' b' op) => {  		switch (op.OperatorToken) {  		case DTokens.Plus:  			return new PrimitiveValue (a.BaseTypeToken' a.Value + b.Value' a.ImaginaryPart + b.ImaginaryPart' a.Modifier);  		case DTokens.Minus:  			return new PrimitiveValue (a.BaseTypeToken' a.Value - b.Value' a.ImaginaryPart - b.ImaginaryPart' a.Modifier);  		}  		ev.EvalError (op' "Invalid token for add/sub expression"' new[] {  			l'  			r  		});  		return null;  	});  
Magic Number,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The following statement contains a magic number: if (x is ShiftExpression)  	return HandleSingleMathOp (x' l' r' (a' b) => {  		if (!ev.EnsureIntegralType (x.LeftOperand' a) || !ev.EnsureIntegralType (x.RightOperand' b))  			return 0L;  		if (b.Value < 0 || b.Value > 31) {  			ev.EvalError (x' "Shift operand must be between 0 and 31"' new[] {  				b  			});  			return 0m;  		}  		switch (x.OperatorToken) {  		case DTokens.ShiftLeft:  			return (long)a.Value << (int)b.Value;  		// TODO: Handle the imaginary part  		case DTokens.ShiftRight:  			return (long)a.Value >> (int)b.Value;  		case DTokens.ShiftRightUnsigned:  			//TODO: Find out where's the difference between >> and >>>  			return (ulong)a.Value >> (int)(uint)b.Value;  		}  		ev.EvalError (x' "Invalid token for shift expression"' new[] {  			l'  			r  		});  		return 0m;  	});  else if (x is AddExpression)  	return HandleSingleMathOp (x' l' r' (a' b' op) => {  		switch (op.OperatorToken) {  		case DTokens.Plus:  			return new PrimitiveValue (a.BaseTypeToken' a.Value + b.Value' a.ImaginaryPart + b.ImaginaryPart' a.Modifier);  		case DTokens.Minus:  			return new PrimitiveValue (a.BaseTypeToken' a.Value - b.Value' a.ImaginaryPart - b.ImaginaryPart' a.Modifier);  		}  		ev.EvalError (op' "Invalid token for add/sub expression"' new[] {  			l'  			r  		});  		return null;  	});  
Magic Number,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The following statement contains a magic number: return HandleSingleMathOp (x' l' r' (a' b) => {  	if (!ev.EnsureIntegralType (x.LeftOperand' a) || !ev.EnsureIntegralType (x.RightOperand' b))  		return 0L;  	if (b.Value < 0 || b.Value > 31) {  		ev.EvalError (x' "Shift operand must be between 0 and 31"' new[] {  			b  		});  		return 0m;  	}  	switch (x.OperatorToken) {  	case DTokens.ShiftLeft:  		return (long)a.Value << (int)b.Value;  	// TODO: Handle the imaginary part  	case DTokens.ShiftRight:  		return (long)a.Value >> (int)b.Value;  	case DTokens.ShiftRightUnsigned:  		//TODO: Find out where's the difference between >> and >>>  		return (ulong)a.Value >> (int)(uint)b.Value;  	}  	ev.EvalError (x' "Invalid token for shift expression"' new[] {  		l'  		r  	});  	return 0m;  });  
Magic Number,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The following statement contains a magic number: if (b.Value < 0 || b.Value > 31) {  	ev.EvalError (x' "Shift operand must be between 0 and 31"' new[] {  		b  	});  	return 0m;  }  
Magic Number,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The following statement contains a magic number: switch (te.Keyword) {  case "":  case null:  	return null;  case "hasMember":  	bool ret = false;  	var optionsBackup = ctxt.ContextIndependentOptions;  	ctxt.ContextIndependentOptions = ResolutionOptions.IgnoreAllProtectionAttributes;  	AbstractType t;  	var pfa = ExpressionTypeEvaluation.prepareMemberTraitExpression (ctxt' te' out t' ValueProvider);  	if (pfa != null && t != null) {  		t.NonStaticAccess = true;  		ignoreErrors = true;  		var res = ExpressionTypeEvaluation.EvaluateType (pfa' ctxt' false);  		ret = res != null;  		ignoreErrors = false;  	}  	ctxt.ContextIndependentOptions = optionsBackup;  	return new PrimitiveValue (ret);  case "identifier":  	if (te.Arguments != null && te.Arguments.Length == 1)  		return new ArrayValue (GetStringType ()' te.Arguments [0].ToString ());  	break;  case "getMember":  	pfa = ExpressionTypeEvaluation.prepareMemberTraitExpression (ctxt' te' out t' ValueProvider);  	if (pfa == null || t == null)  		break;  	var vs = EvalPostfixAccessExpression (this' ctxt' pfa' t' ValueProvider: ValueProvider);  	if (vs == null || vs.Length == 0)  		return null;  	return vs [0];  case "getOverloads":  	optionsBackup = ctxt.ContextIndependentOptions;  	ctxt.ContextIndependentOptions = ResolutionOptions.IgnoreAllProtectionAttributes;  	pfa = ExpressionTypeEvaluation.prepareMemberTraitExpression (ctxt' te' out t' ValueProvider);  	if (pfa != null && t != null)  		vs = EvalPostfixAccessExpression (this' ctxt' pfa' t);  	else  		vs = null;  	ctxt.ContextIndependentOptions = optionsBackup;  	return new TypeValue (new DTuple (vs));  case "getProtection":  	optionsBackup = ctxt.ContextIndependentOptions;  	ctxt.ContextIndependentOptions = ResolutionOptions.IgnoreAllProtectionAttributes;  	var prot = "public";  	if (te.Arguments == null || te.Arguments.Length != 1 || te.Arguments [0] == null)  		EvalError (te' "First trait argument must be a symbol identifier");  	else {  		t = ExpressionTypeEvaluation.ResolveTraitArgument (ctxt' te.Arguments [0]);  		if (t is DSymbol) {  			var dn = (t as DSymbol).Definition;  			if (dn.ContainsAttribute (DTokens.Private))  				prot = "private";  			else if (dn.ContainsAttribute (DTokens.Protected))  				prot = "protected";  			else if (dn.ContainsAttribute (DTokens.Package))  				prot = "package";  			else if (dn.ContainsAttribute (DTokens.Export))  				prot = "export";  		} else  			EvalError (te' "First argument must evaluate to an existing code symbol");  	}  	ctxt.ContextIndependentOptions = optionsBackup;  	return new ArrayValue (GetStringType ()' prot);  case "getVirtualFunctions":  	break;  case "getVirtualMethods":  	break;  case "parent":  	break;  case "classInstanceSize":  	break;  case "allMembers":  	break;  case "derivedMembers":  	break;  case "isSame":  	ret = false;  	if (te.Arguments == null || te.Arguments.Length < 2) {  		EvalError (te' "isSame requires two arguments to compare");  	} else {  		t = ExpressionTypeEvaluation.ResolveTraitArgument (ctxt' te.Arguments [0]);  		if (t != null) {  			var t2 = ExpressionTypeEvaluation.ResolveTraitArgument (ctxt' te.Arguments [1]);  			if (t2 != null)  				ret = Resolver.ResultComparer.IsEqual (t' t2);  		}  	}  	return new PrimitiveValue (ret);  case "compiles":  	ret = false;  	if (te.Arguments != null) {  		foreach (var arg in te.Arguments) {  			ret = arg == null || ExpressionTypeEvaluation.ResolveTraitArgument (ctxt' arg) != null;  			if (!ret)  				break;  		}  	}  	return new PrimitiveValue (ret);  }  
Magic Number,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The following statement contains a magic number: if (te.Arguments == null || te.Arguments.Length < 2) {  	EvalError (te' "isSame requires two arguments to compare");  } else {  	t = ExpressionTypeEvaluation.ResolveTraitArgument (ctxt' te.Arguments [0]);  	if (t != null) {  		var t2 = ExpressionTypeEvaluation.ResolveTraitArgument (ctxt' te.Arguments [1]);  		if (t2 != null)  			ret = Resolver.ResultComparer.IsEqual (t' t2);  	}  }  
Magic Number,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,prepareMemberTraitExpression,The following statement contains a magic number: if (te.Arguments != null && te.Arguments.Length == 2) {  	var tEx = te.Arguments [0];  	t = DResolver.StripMemberSymbols (ResolveTraitArgument (ctxt' tEx));  	if (t == null)  		ctxt.LogError (te' "First argument didn't resolve to a type");  	else if (te.Arguments [1].AssignExpression != null) {  		var litEx = te.Arguments [1].AssignExpression;  		var v = vp != null ? Evaluation.EvaluateValue (litEx' vp) : Evaluation.EvaluateValue (litEx' ctxt);  		if (v is ArrayValue && (v as ArrayValue).IsString) {  			var av = v as ArrayValue;  			// Mock up a postfix_access expression to ensure static properties & ufcs methods are checked either  			return new PostfixExpression_Access {  				PostfixForeExpression = tEx.AssignExpression ?? new TypeDeclarationExpression (tEx.Type)'  				AccessExpression = new IdentifierExpression (av.StringValue) {  					Location = litEx.Location'  					EndLocation = litEx.EndLocation  				}'  				EndLocation = litEx.EndLocation  			};  		} else  			ctxt.LogError (litEx' "Second traits argument must evaluate to a string literal");  	} else  		ctxt.LogError (te' "Second traits argument must be an expression");  }  
Magic Number,D_Parser.Resolver.ExpressionSemantics,ArrayValue,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,The following statement contains a magic number: if (elements != null) {  	foreach (var e in elements)  		if (e == null)  			sb.Append ("[null]' ");  		else  			sb.Append (e.ToCode ()).Append ("' ");  	if (elements.Length > 0)  		sb.Remove (sb.Length - 2' 2);  }  
Magic Number,D_Parser.Resolver.ExpressionSemantics,ArrayValue,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,The following statement contains a magic number: if (elements != null) {  	foreach (var e in elements)  		if (e == null)  			sb.Append ("[null]' ");  		else  			sb.Append (e.ToCode ()).Append ("' ");  	if (elements.Length > 0)  		sb.Remove (sb.Length - 2' 2);  }  
Magic Number,D_Parser.Resolver.ExpressionSemantics,ArrayValue,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,The following statement contains a magic number: if (elements.Length > 0)  	sb.Remove (sb.Length - 2' 2);  
Magic Number,D_Parser.Resolver.ExpressionSemantics,ArrayValue,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,The following statement contains a magic number: if (elements.Length > 0)  	sb.Remove (sb.Length - 2' 2);  
Magic Number,D_Parser.Resolver.ExpressionSemantics,ArrayValue,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2);  
Magic Number,D_Parser.Resolver.ExpressionSemantics,ArrayValue,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2);  
Magic Number,D_Parser.Resolver.ExpressionSemantics,AssociativeArrayValue,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,The following statement contains a magic number: if (Elements != null) {  	foreach (var e in Elements) {  		sb.Append (e.Key == null ? "[null]" : e.Key.ToCode ()).Append (':');  		sb.Append (e.Value == null ? "[null]" : e.Value.ToCode ()).Append ("' ");  	}  	sb.Remove (sb.Length - 2' 2);  }  
Magic Number,D_Parser.Resolver.ExpressionSemantics,AssociativeArrayValue,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,The following statement contains a magic number: if (Elements != null) {  	foreach (var e in Elements) {  		sb.Append (e.Key == null ? "[null]" : e.Key.ToCode ()).Append (':');  		sb.Append (e.Value == null ? "[null]" : e.Value.ToCode ()).Append ("' ");  	}  	sb.Remove (sb.Length - 2' 2);  }  
Magic Number,D_Parser.Resolver.ExpressionSemantics,AssociativeArrayValue,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2);  
Magic Number,D_Parser.Resolver.ExpressionSemantics,AssociativeArrayValue,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2);  
Magic Number,D_Parser.Resolver.ASTScanner,NameScan,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\NameScan.cs,SearchAndResolve,The following statement contains a magic number: if (stackSize++ < 7)  	scan.IterateThroughScopeLayers (caret);  
Magic Number,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,ResolveClassOrInterface,The following statement contains a magic number: if (bcStack > 6 || (instanceDeclaration != null && parsedClassInstanceDecls.Contains (instanceDeclaration))) {  	return isClass ? new ClassType (dc' null) as TemplateIntermediateType : new InterfaceType (dc);  }  
Magic Number,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,SearchRegionAt,The following statement contains a magic number: while (len > 0) {  	midIndex = (len % 2 + len) / 2;  	// Take an element from the middle  	if ((midElement = childGetter (start + midIndex - 1)) == null)  		break;  	// If 'Where' is beyond its start location  	if (Where >= midElement.Location) {  		start += midIndex;  		// If we've reached the (temporary) goal' break immediately  		if (Where <= midElement.EndLocation)  			break;  		// If it's the last tested element and if the caret is beyond the end location'   		// return the Parent instead the last tested child  		else if (midIndex == len) {  			midElement = default(SR);  			break;  		}  	} else if (midIndex == len) {  		midElement = default(SR);  		break;  	}  	len -= midIndex;  }  
Magic Number,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,SearchRegionAt,The following statement contains a magic number: while (len > 0) {  	midIndex = (len % 2 + len) / 2;  	// Take an element from the middle  	if ((midElement = childGetter (start + midIndex - 1)) == null)  		break;  	// If 'Where' is beyond its start location  	if (Where >= midElement.Location) {  		start += midIndex;  		// If we've reached the (temporary) goal' break immediately  		if (Where <= midElement.EndLocation)  			break;  		// If it's the last tested element and if the caret is beyond the end location'   		// return the Parent instead the last tested child  		else if (midIndex == len) {  			midElement = default(SR);  			break;  		}  	} else if (midIndex == len) {  		midElement = default(SR);  		break;  	}  	len -= midIndex;  }  
Magic Number,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,SearchRegionAt,The following statement contains a magic number: midIndex = (len % 2 + len) / 2;  
Magic Number,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,SearchRegionAt,The following statement contains a magic number: midIndex = (len % 2 + len) / 2;  
Magic Number,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,SearchRegionAt,The following statement contains a magic number: while (len > 0) {  	midIndex = (len % 2 + len) / 2;  	// Take an element from the middle  	if ((midElement = children [start + midIndex - 1]) == null)  		break;  	// If 'Where' is beyond its start location  	if (Where > midElement.Location) {  		start += midIndex;  		// If we've reached the (temporary) goal' break immediately  		if (Where < midElement.EndLocation)  			break;  		// If it's the last tested element and if the caret is beyond the end location'   		// return the Parent instead the last tested child  		else if (midIndex == len) {  			midElement = default(SR);  			break;  		}  	} else if (midIndex == len) {  		midElement = default(SR);  		break;  	}  	len -= midIndex;  }  
Magic Number,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,SearchRegionAt,The following statement contains a magic number: while (len > 0) {  	midIndex = (len % 2 + len) / 2;  	// Take an element from the middle  	if ((midElement = children [start + midIndex - 1]) == null)  		break;  	// If 'Where' is beyond its start location  	if (Where > midElement.Location) {  		start += midIndex;  		// If we've reached the (temporary) goal' break immediately  		if (Where < midElement.EndLocation)  			break;  		// If it's the last tested element and if the caret is beyond the end location'   		// return the Parent instead the last tested child  		else if (midIndex == len) {  			midElement = default(SR);  			break;  		}  	} else if (midIndex == len) {  		midElement = default(SR);  		break;  	}  	len -= midIndex;  }  
Magic Number,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,SearchRegionAt,The following statement contains a magic number: midIndex = (len % 2 + len) / 2;  
Magic Number,D_Parser.Resolver.TypeResolution,DResolver,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,SearchRegionAt,The following statement contains a magic number: midIndex = (len % 2 + len) / 2;  
Magic Number,D_Parser.Completion,CodeCompletion,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\CodeCompletion.cs,IsCompletionAllowed,The following statement contains a magic number: if (Editor.CaretOffset > 0) {  	if (Editor.CaretLocation.Line == 1 && Editor.ModuleCode.Length > 0 && Editor.ModuleCode [0] == '#')  		return false;  	if (enteredChar == '.' || enteredChar == '_') {  		// Don't complete on a double/multi-dot  		if (Editor.CaretOffset > 1 && Editor.ModuleCode [Editor.CaretOffset - 2] == enteredChar)  			// ISSUE: When a dot was typed' off-1 is the dot position'   			// if a letter was typed' off-1 is the char before the typed letter..  			return false;  	} // If typing a begun identifier' return immediately  	else if ((Lexer.IsIdentifierPart (enteredChar) || enteredChar == '\0') && Lexer.IsIdentifierPart (Editor.ModuleCode [Editor.CaretOffset - 1]))  		return false;  }  
Magic Number,D_Parser.Completion,CodeCompletion,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\CodeCompletion.cs,IsCompletionAllowed,The following statement contains a magic number: if (enteredChar == '.' || enteredChar == '_') {  	// Don't complete on a double/multi-dot  	if (Editor.CaretOffset > 1 && Editor.ModuleCode [Editor.CaretOffset - 2] == enteredChar)  		// ISSUE: When a dot was typed' off-1 is the dot position'   		// if a letter was typed' off-1 is the char before the typed letter..  		return false;  } // If typing a begun identifier' return immediately  else if ((Lexer.IsIdentifierPart (enteredChar) || enteredChar == '\0') && Lexer.IsIdentifierPart (Editor.ModuleCode [Editor.CaretOffset - 1]))  	return false;  
Magic Number,D_Parser.Completion,CodeCompletion,D:\newReposJune17\aBothe_D_Parser\DParser2\Completion\CodeCompletion.cs,IsCompletionAllowed,The following statement contains a magic number: if (Editor.CaretOffset > 1 && Editor.ModuleCode [Editor.CaretOffset - 2] == enteredChar)  	// ISSUE: When a dot was typed' off-1 is the dot position'   	// if a letter was typed' off-1 is the char before the typed letter..  	return false;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: while ((nextChar = ReaderRead ()) != -1) {  	DToken token;  	switch (nextChar) {  	case ' ':  	case '\t':  		continue;  	case '\r':  	case '\n':  		if (hadLineEnd) {  			// second line end before getting to a token  			// -> here was a blank line  			//specialTracker.AddEndOfLine(new Location(Col' Line));  		}  		HandleLineEnd ((char)nextChar);  		hadLineEnd = true;  		continue;  	case '/':  		int peek = ReaderPeek ();  		if (peek == '/' || peek == '*' || peek == '+') {  			ReadComment ();  			continue;  		} else {  			token = ReadOperator ('/');  		}  		break;  	case 'r':  		peek = ReaderPeek ();  		if (peek == '"') {  			ReaderRead ();  			token = ReadVerbatimString (peek);  			break;  		} else  			goto default;  	case '`':  		token = ReadVerbatimString (nextChar);  		break;  	case '"':  		token = ReadString (nextChar);  		break;  	case '\\':  		// http://digitalmars.com/d/1.0/lex.html#EscapeSequence  		// - It's actually deprecated' but parse such literals anyway  		string surr = "";  		x = Col - 1;  		y = Line;  		var lit = ReadEscapeSequence (out ch' out surr);  		token = Token (DTokens.Literal' x' y' lit.Length + 1' lit/*' ch.ToString()*/' LiteralFormat.StringLiteral);  		token.RawCodeRepresentation = ch.ToString ();  		OnError (y' x' "Escape sequence strings are deprecated!");  		break;  	case '\'':  		token = ReadChar ();  		break;  	case '@':  		token = Token (DTokens.At' Col - 1' Line' 1);  		break;  	case '#':  		if ((token = ReadSpecialTokenSequence ()) != null)  			break;  		continue;  	default:  		ch = (char)nextChar;  		if (ch == 'x') {  			peek = ReaderPeek ();  			if (peek == '"')// HexString  			 {  				ReaderRead ();  				// Skip the "  				var numString = new StringBuilder ();  				while ((next = ReaderRead ()) != -1) {  					ch = (char)next;  					if (IsHex (ch))  						numString.Append (ch);  					else if (!Char.IsWhiteSpace (ch))  						break;  				}  				return Token (DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue (numString' 16)' /*numString'*/LiteralFormat.Scalar);  			}  		} else if (ch == 'q')// Token strings  		 {  			switch (ReaderPeek ()) {  			case '{':  				return ReadTokenStringLiteral_CurlyInit ();  			case '"'/* q"{{ ...}}   }}"*/:  				return ReadTokenStringLiteral_IdentInit ();  			}  		}  		if (IsLetter (ch) || ch == '\\') {  			x = Col - 1;  			// Col was incremented above' but we want the start of the identifier  			y = Line;  			bool canBeKeyword;  			var s = ReadIdent (ch' out canBeKeyword);  			if (canBeKeyword) {  				// A micro-optimization..  				if (s.Length >= 8 && s [0] == '_' && s [1] == '_') {  					LiteralFormat literalFormat = 0;  					var subFormat = LiteralSubformat.Utf8;  					object literalValue = null;  					// Fill in static string surrogates directly  					if (s == "__VENDOR__") {  						literalFormat = LiteralFormat.StringLiteral;  						literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString (3) + " by Alexander Bothe";  					} else if (s == "__VERSION__") {  						subFormat = LiteralSubformat.Integer;  						var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version;  						literalFormat = LiteralFormat.Scalar;  						literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  					}  					if (literalFormat != 0)  						return Token (DTokens.Literal' x' y' s.Length' literalValue' //literalValue is string ? (string)literalValue : literalValue.ToString()'  						literalFormat' subFormat);  				}  				byte key;  				if (DTokens.Keywords_Lookup.TryGetValue (s' out key))  					return Token (key' x' y' s.Length);  			}  			return Token (DTokens.Identifier' x' y' s);  		} else if (IsDigit (ch))  			token = ReadDigit (ch' Col - 1);  		else  			token = ReadOperator (ch);  		break;  	}  	// try error recovery (token = null -> continue with next char)  	if (token != null) {  		//token.prev = base.curToken;  		return token;  	} else {  		OnError (Line' Col' "Invalid character");  		//StopLexing();  		break;  	}  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: while ((nextChar = ReaderRead ()) != -1) {  	DToken token;  	switch (nextChar) {  	case ' ':  	case '\t':  		continue;  	case '\r':  	case '\n':  		if (hadLineEnd) {  			// second line end before getting to a token  			// -> here was a blank line  			//specialTracker.AddEndOfLine(new Location(Col' Line));  		}  		HandleLineEnd ((char)nextChar);  		hadLineEnd = true;  		continue;  	case '/':  		int peek = ReaderPeek ();  		if (peek == '/' || peek == '*' || peek == '+') {  			ReadComment ();  			continue;  		} else {  			token = ReadOperator ('/');  		}  		break;  	case 'r':  		peek = ReaderPeek ();  		if (peek == '"') {  			ReaderRead ();  			token = ReadVerbatimString (peek);  			break;  		} else  			goto default;  	case '`':  		token = ReadVerbatimString (nextChar);  		break;  	case '"':  		token = ReadString (nextChar);  		break;  	case '\\':  		// http://digitalmars.com/d/1.0/lex.html#EscapeSequence  		// - It's actually deprecated' but parse such literals anyway  		string surr = "";  		x = Col - 1;  		y = Line;  		var lit = ReadEscapeSequence (out ch' out surr);  		token = Token (DTokens.Literal' x' y' lit.Length + 1' lit/*' ch.ToString()*/' LiteralFormat.StringLiteral);  		token.RawCodeRepresentation = ch.ToString ();  		OnError (y' x' "Escape sequence strings are deprecated!");  		break;  	case '\'':  		token = ReadChar ();  		break;  	case '@':  		token = Token (DTokens.At' Col - 1' Line' 1);  		break;  	case '#':  		if ((token = ReadSpecialTokenSequence ()) != null)  			break;  		continue;  	default:  		ch = (char)nextChar;  		if (ch == 'x') {  			peek = ReaderPeek ();  			if (peek == '"')// HexString  			 {  				ReaderRead ();  				// Skip the "  				var numString = new StringBuilder ();  				while ((next = ReaderRead ()) != -1) {  					ch = (char)next;  					if (IsHex (ch))  						numString.Append (ch);  					else if (!Char.IsWhiteSpace (ch))  						break;  				}  				return Token (DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue (numString' 16)' /*numString'*/LiteralFormat.Scalar);  			}  		} else if (ch == 'q')// Token strings  		 {  			switch (ReaderPeek ()) {  			case '{':  				return ReadTokenStringLiteral_CurlyInit ();  			case '"'/* q"{{ ...}}   }}"*/:  				return ReadTokenStringLiteral_IdentInit ();  			}  		}  		if (IsLetter (ch) || ch == '\\') {  			x = Col - 1;  			// Col was incremented above' but we want the start of the identifier  			y = Line;  			bool canBeKeyword;  			var s = ReadIdent (ch' out canBeKeyword);  			if (canBeKeyword) {  				// A micro-optimization..  				if (s.Length >= 8 && s [0] == '_' && s [1] == '_') {  					LiteralFormat literalFormat = 0;  					var subFormat = LiteralSubformat.Utf8;  					object literalValue = null;  					// Fill in static string surrogates directly  					if (s == "__VENDOR__") {  						literalFormat = LiteralFormat.StringLiteral;  						literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString (3) + " by Alexander Bothe";  					} else if (s == "__VERSION__") {  						subFormat = LiteralSubformat.Integer;  						var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version;  						literalFormat = LiteralFormat.Scalar;  						literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  					}  					if (literalFormat != 0)  						return Token (DTokens.Literal' x' y' s.Length' literalValue' //literalValue is string ? (string)literalValue : literalValue.ToString()'  						literalFormat' subFormat);  				}  				byte key;  				if (DTokens.Keywords_Lookup.TryGetValue (s' out key))  					return Token (key' x' y' s.Length);  			}  			return Token (DTokens.Identifier' x' y' s);  		} else if (IsDigit (ch))  			token = ReadDigit (ch' Col - 1);  		else  			token = ReadOperator (ch);  		break;  	}  	// try error recovery (token = null -> continue with next char)  	if (token != null) {  		//token.prev = base.curToken;  		return token;  	} else {  		OnError (Line' Col' "Invalid character");  		//StopLexing();  		break;  	}  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: while ((nextChar = ReaderRead ()) != -1) {  	DToken token;  	switch (nextChar) {  	case ' ':  	case '\t':  		continue;  	case '\r':  	case '\n':  		if (hadLineEnd) {  			// second line end before getting to a token  			// -> here was a blank line  			//specialTracker.AddEndOfLine(new Location(Col' Line));  		}  		HandleLineEnd ((char)nextChar);  		hadLineEnd = true;  		continue;  	case '/':  		int peek = ReaderPeek ();  		if (peek == '/' || peek == '*' || peek == '+') {  			ReadComment ();  			continue;  		} else {  			token = ReadOperator ('/');  		}  		break;  	case 'r':  		peek = ReaderPeek ();  		if (peek == '"') {  			ReaderRead ();  			token = ReadVerbatimString (peek);  			break;  		} else  			goto default;  	case '`':  		token = ReadVerbatimString (nextChar);  		break;  	case '"':  		token = ReadString (nextChar);  		break;  	case '\\':  		// http://digitalmars.com/d/1.0/lex.html#EscapeSequence  		// - It's actually deprecated' but parse such literals anyway  		string surr = "";  		x = Col - 1;  		y = Line;  		var lit = ReadEscapeSequence (out ch' out surr);  		token = Token (DTokens.Literal' x' y' lit.Length + 1' lit/*' ch.ToString()*/' LiteralFormat.StringLiteral);  		token.RawCodeRepresentation = ch.ToString ();  		OnError (y' x' "Escape sequence strings are deprecated!");  		break;  	case '\'':  		token = ReadChar ();  		break;  	case '@':  		token = Token (DTokens.At' Col - 1' Line' 1);  		break;  	case '#':  		if ((token = ReadSpecialTokenSequence ()) != null)  			break;  		continue;  	default:  		ch = (char)nextChar;  		if (ch == 'x') {  			peek = ReaderPeek ();  			if (peek == '"')// HexString  			 {  				ReaderRead ();  				// Skip the "  				var numString = new StringBuilder ();  				while ((next = ReaderRead ()) != -1) {  					ch = (char)next;  					if (IsHex (ch))  						numString.Append (ch);  					else if (!Char.IsWhiteSpace (ch))  						break;  				}  				return Token (DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue (numString' 16)' /*numString'*/LiteralFormat.Scalar);  			}  		} else if (ch == 'q')// Token strings  		 {  			switch (ReaderPeek ()) {  			case '{':  				return ReadTokenStringLiteral_CurlyInit ();  			case '"'/* q"{{ ...}}   }}"*/:  				return ReadTokenStringLiteral_IdentInit ();  			}  		}  		if (IsLetter (ch) || ch == '\\') {  			x = Col - 1;  			// Col was incremented above' but we want the start of the identifier  			y = Line;  			bool canBeKeyword;  			var s = ReadIdent (ch' out canBeKeyword);  			if (canBeKeyword) {  				// A micro-optimization..  				if (s.Length >= 8 && s [0] == '_' && s [1] == '_') {  					LiteralFormat literalFormat = 0;  					var subFormat = LiteralSubformat.Utf8;  					object literalValue = null;  					// Fill in static string surrogates directly  					if (s == "__VENDOR__") {  						literalFormat = LiteralFormat.StringLiteral;  						literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString (3) + " by Alexander Bothe";  					} else if (s == "__VERSION__") {  						subFormat = LiteralSubformat.Integer;  						var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version;  						literalFormat = LiteralFormat.Scalar;  						literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  					}  					if (literalFormat != 0)  						return Token (DTokens.Literal' x' y' s.Length' literalValue' //literalValue is string ? (string)literalValue : literalValue.ToString()'  						literalFormat' subFormat);  				}  				byte key;  				if (DTokens.Keywords_Lookup.TryGetValue (s' out key))  					return Token (key' x' y' s.Length);  			}  			return Token (DTokens.Identifier' x' y' s);  		} else if (IsDigit (ch))  			token = ReadDigit (ch' Col - 1);  		else  			token = ReadOperator (ch);  		break;  	}  	// try error recovery (token = null -> continue with next char)  	if (token != null) {  		//token.prev = base.curToken;  		return token;  	} else {  		OnError (Line' Col' "Invalid character");  		//StopLexing();  		break;  	}  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: while ((nextChar = ReaderRead ()) != -1) {  	DToken token;  	switch (nextChar) {  	case ' ':  	case '\t':  		continue;  	case '\r':  	case '\n':  		if (hadLineEnd) {  			// second line end before getting to a token  			// -> here was a blank line  			//specialTracker.AddEndOfLine(new Location(Col' Line));  		}  		HandleLineEnd ((char)nextChar);  		hadLineEnd = true;  		continue;  	case '/':  		int peek = ReaderPeek ();  		if (peek == '/' || peek == '*' || peek == '+') {  			ReadComment ();  			continue;  		} else {  			token = ReadOperator ('/');  		}  		break;  	case 'r':  		peek = ReaderPeek ();  		if (peek == '"') {  			ReaderRead ();  			token = ReadVerbatimString (peek);  			break;  		} else  			goto default;  	case '`':  		token = ReadVerbatimString (nextChar);  		break;  	case '"':  		token = ReadString (nextChar);  		break;  	case '\\':  		// http://digitalmars.com/d/1.0/lex.html#EscapeSequence  		// - It's actually deprecated' but parse such literals anyway  		string surr = "";  		x = Col - 1;  		y = Line;  		var lit = ReadEscapeSequence (out ch' out surr);  		token = Token (DTokens.Literal' x' y' lit.Length + 1' lit/*' ch.ToString()*/' LiteralFormat.StringLiteral);  		token.RawCodeRepresentation = ch.ToString ();  		OnError (y' x' "Escape sequence strings are deprecated!");  		break;  	case '\'':  		token = ReadChar ();  		break;  	case '@':  		token = Token (DTokens.At' Col - 1' Line' 1);  		break;  	case '#':  		if ((token = ReadSpecialTokenSequence ()) != null)  			break;  		continue;  	default:  		ch = (char)nextChar;  		if (ch == 'x') {  			peek = ReaderPeek ();  			if (peek == '"')// HexString  			 {  				ReaderRead ();  				// Skip the "  				var numString = new StringBuilder ();  				while ((next = ReaderRead ()) != -1) {  					ch = (char)next;  					if (IsHex (ch))  						numString.Append (ch);  					else if (!Char.IsWhiteSpace (ch))  						break;  				}  				return Token (DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue (numString' 16)' /*numString'*/LiteralFormat.Scalar);  			}  		} else if (ch == 'q')// Token strings  		 {  			switch (ReaderPeek ()) {  			case '{':  				return ReadTokenStringLiteral_CurlyInit ();  			case '"'/* q"{{ ...}}   }}"*/:  				return ReadTokenStringLiteral_IdentInit ();  			}  		}  		if (IsLetter (ch) || ch == '\\') {  			x = Col - 1;  			// Col was incremented above' but we want the start of the identifier  			y = Line;  			bool canBeKeyword;  			var s = ReadIdent (ch' out canBeKeyword);  			if (canBeKeyword) {  				// A micro-optimization..  				if (s.Length >= 8 && s [0] == '_' && s [1] == '_') {  					LiteralFormat literalFormat = 0;  					var subFormat = LiteralSubformat.Utf8;  					object literalValue = null;  					// Fill in static string surrogates directly  					if (s == "__VENDOR__") {  						literalFormat = LiteralFormat.StringLiteral;  						literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString (3) + " by Alexander Bothe";  					} else if (s == "__VERSION__") {  						subFormat = LiteralSubformat.Integer;  						var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version;  						literalFormat = LiteralFormat.Scalar;  						literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  					}  					if (literalFormat != 0)  						return Token (DTokens.Literal' x' y' s.Length' literalValue' //literalValue is string ? (string)literalValue : literalValue.ToString()'  						literalFormat' subFormat);  				}  				byte key;  				if (DTokens.Keywords_Lookup.TryGetValue (s' out key))  					return Token (key' x' y' s.Length);  			}  			return Token (DTokens.Identifier' x' y' s);  		} else if (IsDigit (ch))  			token = ReadDigit (ch' Col - 1);  		else  			token = ReadOperator (ch);  		break;  	}  	// try error recovery (token = null -> continue with next char)  	if (token != null) {  		//token.prev = base.curToken;  		return token;  	} else {  		OnError (Line' Col' "Invalid character");  		//StopLexing();  		break;  	}  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: switch (nextChar) {  case ' ':  case '\t':  	continue;  case '\r':  case '\n':  	if (hadLineEnd) {  		// second line end before getting to a token  		// -> here was a blank line  		//specialTracker.AddEndOfLine(new Location(Col' Line));  	}  	HandleLineEnd ((char)nextChar);  	hadLineEnd = true;  	continue;  case '/':  	int peek = ReaderPeek ();  	if (peek == '/' || peek == '*' || peek == '+') {  		ReadComment ();  		continue;  	} else {  		token = ReadOperator ('/');  	}  	break;  case 'r':  	peek = ReaderPeek ();  	if (peek == '"') {  		ReaderRead ();  		token = ReadVerbatimString (peek);  		break;  	} else  		goto default;  case '`':  	token = ReadVerbatimString (nextChar);  	break;  case '"':  	token = ReadString (nextChar);  	break;  case '\\':  	// http://digitalmars.com/d/1.0/lex.html#EscapeSequence  	// - It's actually deprecated' but parse such literals anyway  	string surr = "";  	x = Col - 1;  	y = Line;  	var lit = ReadEscapeSequence (out ch' out surr);  	token = Token (DTokens.Literal' x' y' lit.Length + 1' lit/*' ch.ToString()*/' LiteralFormat.StringLiteral);  	token.RawCodeRepresentation = ch.ToString ();  	OnError (y' x' "Escape sequence strings are deprecated!");  	break;  case '\'':  	token = ReadChar ();  	break;  case '@':  	token = Token (DTokens.At' Col - 1' Line' 1);  	break;  case '#':  	if ((token = ReadSpecialTokenSequence ()) != null)  		break;  	continue;  default:  	ch = (char)nextChar;  	if (ch == 'x') {  		peek = ReaderPeek ();  		if (peek == '"')// HexString  		 {  			ReaderRead ();  			// Skip the "  			var numString = new StringBuilder ();  			while ((next = ReaderRead ()) != -1) {  				ch = (char)next;  				if (IsHex (ch))  					numString.Append (ch);  				else if (!Char.IsWhiteSpace (ch))  					break;  			}  			return Token (DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue (numString' 16)' /*numString'*/LiteralFormat.Scalar);  		}  	} else if (ch == 'q')// Token strings  	 {  		switch (ReaderPeek ()) {  		case '{':  			return ReadTokenStringLiteral_CurlyInit ();  		case '"'/* q"{{ ...}}   }}"*/:  			return ReadTokenStringLiteral_IdentInit ();  		}  	}  	if (IsLetter (ch) || ch == '\\') {  		x = Col - 1;  		// Col was incremented above' but we want the start of the identifier  		y = Line;  		bool canBeKeyword;  		var s = ReadIdent (ch' out canBeKeyword);  		if (canBeKeyword) {  			// A micro-optimization..  			if (s.Length >= 8 && s [0] == '_' && s [1] == '_') {  				LiteralFormat literalFormat = 0;  				var subFormat = LiteralSubformat.Utf8;  				object literalValue = null;  				// Fill in static string surrogates directly  				if (s == "__VENDOR__") {  					literalFormat = LiteralFormat.StringLiteral;  					literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString (3) + " by Alexander Bothe";  				} else if (s == "__VERSION__") {  					subFormat = LiteralSubformat.Integer;  					var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version;  					literalFormat = LiteralFormat.Scalar;  					literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  				}  				if (literalFormat != 0)  					return Token (DTokens.Literal' x' y' s.Length' literalValue' //literalValue is string ? (string)literalValue : literalValue.ToString()'  					literalFormat' subFormat);  			}  			byte key;  			if (DTokens.Keywords_Lookup.TryGetValue (s' out key))  				return Token (key' x' y' s.Length);  		}  		return Token (DTokens.Identifier' x' y' s);  	} else if (IsDigit (ch))  		token = ReadDigit (ch' Col - 1);  	else  		token = ReadOperator (ch);  	break;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: switch (nextChar) {  case ' ':  case '\t':  	continue;  case '\r':  case '\n':  	if (hadLineEnd) {  		// second line end before getting to a token  		// -> here was a blank line  		//specialTracker.AddEndOfLine(new Location(Col' Line));  	}  	HandleLineEnd ((char)nextChar);  	hadLineEnd = true;  	continue;  case '/':  	int peek = ReaderPeek ();  	if (peek == '/' || peek == '*' || peek == '+') {  		ReadComment ();  		continue;  	} else {  		token = ReadOperator ('/');  	}  	break;  case 'r':  	peek = ReaderPeek ();  	if (peek == '"') {  		ReaderRead ();  		token = ReadVerbatimString (peek);  		break;  	} else  		goto default;  case '`':  	token = ReadVerbatimString (nextChar);  	break;  case '"':  	token = ReadString (nextChar);  	break;  case '\\':  	// http://digitalmars.com/d/1.0/lex.html#EscapeSequence  	// - It's actually deprecated' but parse such literals anyway  	string surr = "";  	x = Col - 1;  	y = Line;  	var lit = ReadEscapeSequence (out ch' out surr);  	token = Token (DTokens.Literal' x' y' lit.Length + 1' lit/*' ch.ToString()*/' LiteralFormat.StringLiteral);  	token.RawCodeRepresentation = ch.ToString ();  	OnError (y' x' "Escape sequence strings are deprecated!");  	break;  case '\'':  	token = ReadChar ();  	break;  case '@':  	token = Token (DTokens.At' Col - 1' Line' 1);  	break;  case '#':  	if ((token = ReadSpecialTokenSequence ()) != null)  		break;  	continue;  default:  	ch = (char)nextChar;  	if (ch == 'x') {  		peek = ReaderPeek ();  		if (peek == '"')// HexString  		 {  			ReaderRead ();  			// Skip the "  			var numString = new StringBuilder ();  			while ((next = ReaderRead ()) != -1) {  				ch = (char)next;  				if (IsHex (ch))  					numString.Append (ch);  				else if (!Char.IsWhiteSpace (ch))  					break;  			}  			return Token (DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue (numString' 16)' /*numString'*/LiteralFormat.Scalar);  		}  	} else if (ch == 'q')// Token strings  	 {  		switch (ReaderPeek ()) {  		case '{':  			return ReadTokenStringLiteral_CurlyInit ();  		case '"'/* q"{{ ...}}   }}"*/:  			return ReadTokenStringLiteral_IdentInit ();  		}  	}  	if (IsLetter (ch) || ch == '\\') {  		x = Col - 1;  		// Col was incremented above' but we want the start of the identifier  		y = Line;  		bool canBeKeyword;  		var s = ReadIdent (ch' out canBeKeyword);  		if (canBeKeyword) {  			// A micro-optimization..  			if (s.Length >= 8 && s [0] == '_' && s [1] == '_') {  				LiteralFormat literalFormat = 0;  				var subFormat = LiteralSubformat.Utf8;  				object literalValue = null;  				// Fill in static string surrogates directly  				if (s == "__VENDOR__") {  					literalFormat = LiteralFormat.StringLiteral;  					literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString (3) + " by Alexander Bothe";  				} else if (s == "__VERSION__") {  					subFormat = LiteralSubformat.Integer;  					var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version;  					literalFormat = LiteralFormat.Scalar;  					literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  				}  				if (literalFormat != 0)  					return Token (DTokens.Literal' x' y' s.Length' literalValue' //literalValue is string ? (string)literalValue : literalValue.ToString()'  					literalFormat' subFormat);  			}  			byte key;  			if (DTokens.Keywords_Lookup.TryGetValue (s' out key))  				return Token (key' x' y' s.Length);  		}  		return Token (DTokens.Identifier' x' y' s);  	} else if (IsDigit (ch))  		token = ReadDigit (ch' Col - 1);  	else  		token = ReadOperator (ch);  	break;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: switch (nextChar) {  case ' ':  case '\t':  	continue;  case '\r':  case '\n':  	if (hadLineEnd) {  		// second line end before getting to a token  		// -> here was a blank line  		//specialTracker.AddEndOfLine(new Location(Col' Line));  	}  	HandleLineEnd ((char)nextChar);  	hadLineEnd = true;  	continue;  case '/':  	int peek = ReaderPeek ();  	if (peek == '/' || peek == '*' || peek == '+') {  		ReadComment ();  		continue;  	} else {  		token = ReadOperator ('/');  	}  	break;  case 'r':  	peek = ReaderPeek ();  	if (peek == '"') {  		ReaderRead ();  		token = ReadVerbatimString (peek);  		break;  	} else  		goto default;  case '`':  	token = ReadVerbatimString (nextChar);  	break;  case '"':  	token = ReadString (nextChar);  	break;  case '\\':  	// http://digitalmars.com/d/1.0/lex.html#EscapeSequence  	// - It's actually deprecated' but parse such literals anyway  	string surr = "";  	x = Col - 1;  	y = Line;  	var lit = ReadEscapeSequence (out ch' out surr);  	token = Token (DTokens.Literal' x' y' lit.Length + 1' lit/*' ch.ToString()*/' LiteralFormat.StringLiteral);  	token.RawCodeRepresentation = ch.ToString ();  	OnError (y' x' "Escape sequence strings are deprecated!");  	break;  case '\'':  	token = ReadChar ();  	break;  case '@':  	token = Token (DTokens.At' Col - 1' Line' 1);  	break;  case '#':  	if ((token = ReadSpecialTokenSequence ()) != null)  		break;  	continue;  default:  	ch = (char)nextChar;  	if (ch == 'x') {  		peek = ReaderPeek ();  		if (peek == '"')// HexString  		 {  			ReaderRead ();  			// Skip the "  			var numString = new StringBuilder ();  			while ((next = ReaderRead ()) != -1) {  				ch = (char)next;  				if (IsHex (ch))  					numString.Append (ch);  				else if (!Char.IsWhiteSpace (ch))  					break;  			}  			return Token (DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue (numString' 16)' /*numString'*/LiteralFormat.Scalar);  		}  	} else if (ch == 'q')// Token strings  	 {  		switch (ReaderPeek ()) {  		case '{':  			return ReadTokenStringLiteral_CurlyInit ();  		case '"'/* q"{{ ...}}   }}"*/:  			return ReadTokenStringLiteral_IdentInit ();  		}  	}  	if (IsLetter (ch) || ch == '\\') {  		x = Col - 1;  		// Col was incremented above' but we want the start of the identifier  		y = Line;  		bool canBeKeyword;  		var s = ReadIdent (ch' out canBeKeyword);  		if (canBeKeyword) {  			// A micro-optimization..  			if (s.Length >= 8 && s [0] == '_' && s [1] == '_') {  				LiteralFormat literalFormat = 0;  				var subFormat = LiteralSubformat.Utf8;  				object literalValue = null;  				// Fill in static string surrogates directly  				if (s == "__VENDOR__") {  					literalFormat = LiteralFormat.StringLiteral;  					literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString (3) + " by Alexander Bothe";  				} else if (s == "__VERSION__") {  					subFormat = LiteralSubformat.Integer;  					var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version;  					literalFormat = LiteralFormat.Scalar;  					literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  				}  				if (literalFormat != 0)  					return Token (DTokens.Literal' x' y' s.Length' literalValue' //literalValue is string ? (string)literalValue : literalValue.ToString()'  					literalFormat' subFormat);  			}  			byte key;  			if (DTokens.Keywords_Lookup.TryGetValue (s' out key))  				return Token (key' x' y' s.Length);  		}  		return Token (DTokens.Identifier' x' y' s);  	} else if (IsDigit (ch))  		token = ReadDigit (ch' Col - 1);  	else  		token = ReadOperator (ch);  	break;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: switch (nextChar) {  case ' ':  case '\t':  	continue;  case '\r':  case '\n':  	if (hadLineEnd) {  		// second line end before getting to a token  		// -> here was a blank line  		//specialTracker.AddEndOfLine(new Location(Col' Line));  	}  	HandleLineEnd ((char)nextChar);  	hadLineEnd = true;  	continue;  case '/':  	int peek = ReaderPeek ();  	if (peek == '/' || peek == '*' || peek == '+') {  		ReadComment ();  		continue;  	} else {  		token = ReadOperator ('/');  	}  	break;  case 'r':  	peek = ReaderPeek ();  	if (peek == '"') {  		ReaderRead ();  		token = ReadVerbatimString (peek);  		break;  	} else  		goto default;  case '`':  	token = ReadVerbatimString (nextChar);  	break;  case '"':  	token = ReadString (nextChar);  	break;  case '\\':  	// http://digitalmars.com/d/1.0/lex.html#EscapeSequence  	// - It's actually deprecated' but parse such literals anyway  	string surr = "";  	x = Col - 1;  	y = Line;  	var lit = ReadEscapeSequence (out ch' out surr);  	token = Token (DTokens.Literal' x' y' lit.Length + 1' lit/*' ch.ToString()*/' LiteralFormat.StringLiteral);  	token.RawCodeRepresentation = ch.ToString ();  	OnError (y' x' "Escape sequence strings are deprecated!");  	break;  case '\'':  	token = ReadChar ();  	break;  case '@':  	token = Token (DTokens.At' Col - 1' Line' 1);  	break;  case '#':  	if ((token = ReadSpecialTokenSequence ()) != null)  		break;  	continue;  default:  	ch = (char)nextChar;  	if (ch == 'x') {  		peek = ReaderPeek ();  		if (peek == '"')// HexString  		 {  			ReaderRead ();  			// Skip the "  			var numString = new StringBuilder ();  			while ((next = ReaderRead ()) != -1) {  				ch = (char)next;  				if (IsHex (ch))  					numString.Append (ch);  				else if (!Char.IsWhiteSpace (ch))  					break;  			}  			return Token (DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue (numString' 16)' /*numString'*/LiteralFormat.Scalar);  		}  	} else if (ch == 'q')// Token strings  	 {  		switch (ReaderPeek ()) {  		case '{':  			return ReadTokenStringLiteral_CurlyInit ();  		case '"'/* q"{{ ...}}   }}"*/:  			return ReadTokenStringLiteral_IdentInit ();  		}  	}  	if (IsLetter (ch) || ch == '\\') {  		x = Col - 1;  		// Col was incremented above' but we want the start of the identifier  		y = Line;  		bool canBeKeyword;  		var s = ReadIdent (ch' out canBeKeyword);  		if (canBeKeyword) {  			// A micro-optimization..  			if (s.Length >= 8 && s [0] == '_' && s [1] == '_') {  				LiteralFormat literalFormat = 0;  				var subFormat = LiteralSubformat.Utf8;  				object literalValue = null;  				// Fill in static string surrogates directly  				if (s == "__VENDOR__") {  					literalFormat = LiteralFormat.StringLiteral;  					literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString (3) + " by Alexander Bothe";  				} else if (s == "__VERSION__") {  					subFormat = LiteralSubformat.Integer;  					var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version;  					literalFormat = LiteralFormat.Scalar;  					literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  				}  				if (literalFormat != 0)  					return Token (DTokens.Literal' x' y' s.Length' literalValue' //literalValue is string ? (string)literalValue : literalValue.ToString()'  					literalFormat' subFormat);  			}  			byte key;  			if (DTokens.Keywords_Lookup.TryGetValue (s' out key))  				return Token (key' x' y' s.Length);  		}  		return Token (DTokens.Identifier' x' y' s);  	} else if (IsDigit (ch))  		token = ReadDigit (ch' Col - 1);  	else  		token = ReadOperator (ch);  	break;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: if (ch == 'x') {  	peek = ReaderPeek ();  	if (peek == '"')// HexString  	 {  		ReaderRead ();  		// Skip the "  		var numString = new StringBuilder ();  		while ((next = ReaderRead ()) != -1) {  			ch = (char)next;  			if (IsHex (ch))  				numString.Append (ch);  			else if (!Char.IsWhiteSpace (ch))  				break;  		}  		return Token (DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue (numString' 16)' /*numString'*/LiteralFormat.Scalar);  	}  } else if (ch == 'q')// Token strings   {  	switch (ReaderPeek ()) {  	case '{':  		return ReadTokenStringLiteral_CurlyInit ();  	case '"'/* q"{{ ...}}   }}"*/:  		return ReadTokenStringLiteral_IdentInit ();  	}  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: if (peek == '"')// HexString   {  	ReaderRead ();  	// Skip the "  	var numString = new StringBuilder ();  	while ((next = ReaderRead ()) != -1) {  		ch = (char)next;  		if (IsHex (ch))  			numString.Append (ch);  		else if (!Char.IsWhiteSpace (ch))  			break;  	}  	return Token (DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue (numString' 16)' /*numString'*/LiteralFormat.Scalar);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: return Token (DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue (numString' 16)' /*numString'*/LiteralFormat.Scalar);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: if (IsLetter (ch) || ch == '\\') {  	x = Col - 1;  	// Col was incremented above' but we want the start of the identifier  	y = Line;  	bool canBeKeyword;  	var s = ReadIdent (ch' out canBeKeyword);  	if (canBeKeyword) {  		// A micro-optimization..  		if (s.Length >= 8 && s [0] == '_' && s [1] == '_') {  			LiteralFormat literalFormat = 0;  			var subFormat = LiteralSubformat.Utf8;  			object literalValue = null;  			// Fill in static string surrogates directly  			if (s == "__VENDOR__") {  				literalFormat = LiteralFormat.StringLiteral;  				literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString (3) + " by Alexander Bothe";  			} else if (s == "__VERSION__") {  				subFormat = LiteralSubformat.Integer;  				var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version;  				literalFormat = LiteralFormat.Scalar;  				literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  			}  			if (literalFormat != 0)  				return Token (DTokens.Literal' x' y' s.Length' literalValue' //literalValue is string ? (string)literalValue : literalValue.ToString()'  				literalFormat' subFormat);  		}  		byte key;  		if (DTokens.Keywords_Lookup.TryGetValue (s' out key))  			return Token (key' x' y' s.Length);  	}  	return Token (DTokens.Identifier' x' y' s);  } else if (IsDigit (ch))  	token = ReadDigit (ch' Col - 1);  else  	token = ReadOperator (ch);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: if (IsLetter (ch) || ch == '\\') {  	x = Col - 1;  	// Col was incremented above' but we want the start of the identifier  	y = Line;  	bool canBeKeyword;  	var s = ReadIdent (ch' out canBeKeyword);  	if (canBeKeyword) {  		// A micro-optimization..  		if (s.Length >= 8 && s [0] == '_' && s [1] == '_') {  			LiteralFormat literalFormat = 0;  			var subFormat = LiteralSubformat.Utf8;  			object literalValue = null;  			// Fill in static string surrogates directly  			if (s == "__VENDOR__") {  				literalFormat = LiteralFormat.StringLiteral;  				literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString (3) + " by Alexander Bothe";  			} else if (s == "__VERSION__") {  				subFormat = LiteralSubformat.Integer;  				var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version;  				literalFormat = LiteralFormat.Scalar;  				literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  			}  			if (literalFormat != 0)  				return Token (DTokens.Literal' x' y' s.Length' literalValue' //literalValue is string ? (string)literalValue : literalValue.ToString()'  				literalFormat' subFormat);  		}  		byte key;  		if (DTokens.Keywords_Lookup.TryGetValue (s' out key))  			return Token (key' x' y' s.Length);  	}  	return Token (DTokens.Identifier' x' y' s);  } else if (IsDigit (ch))  	token = ReadDigit (ch' Col - 1);  else  	token = ReadOperator (ch);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: if (IsLetter (ch) || ch == '\\') {  	x = Col - 1;  	// Col was incremented above' but we want the start of the identifier  	y = Line;  	bool canBeKeyword;  	var s = ReadIdent (ch' out canBeKeyword);  	if (canBeKeyword) {  		// A micro-optimization..  		if (s.Length >= 8 && s [0] == '_' && s [1] == '_') {  			LiteralFormat literalFormat = 0;  			var subFormat = LiteralSubformat.Utf8;  			object literalValue = null;  			// Fill in static string surrogates directly  			if (s == "__VENDOR__") {  				literalFormat = LiteralFormat.StringLiteral;  				literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString (3) + " by Alexander Bothe";  			} else if (s == "__VERSION__") {  				subFormat = LiteralSubformat.Integer;  				var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version;  				literalFormat = LiteralFormat.Scalar;  				literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  			}  			if (literalFormat != 0)  				return Token (DTokens.Literal' x' y' s.Length' literalValue' //literalValue is string ? (string)literalValue : literalValue.ToString()'  				literalFormat' subFormat);  		}  		byte key;  		if (DTokens.Keywords_Lookup.TryGetValue (s' out key))  			return Token (key' x' y' s.Length);  	}  	return Token (DTokens.Identifier' x' y' s);  } else if (IsDigit (ch))  	token = ReadDigit (ch' Col - 1);  else  	token = ReadOperator (ch);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: if (canBeKeyword) {  	// A micro-optimization..  	if (s.Length >= 8 && s [0] == '_' && s [1] == '_') {  		LiteralFormat literalFormat = 0;  		var subFormat = LiteralSubformat.Utf8;  		object literalValue = null;  		// Fill in static string surrogates directly  		if (s == "__VENDOR__") {  			literalFormat = LiteralFormat.StringLiteral;  			literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString (3) + " by Alexander Bothe";  		} else if (s == "__VERSION__") {  			subFormat = LiteralSubformat.Integer;  			var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version;  			literalFormat = LiteralFormat.Scalar;  			literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  		}  		if (literalFormat != 0)  			return Token (DTokens.Literal' x' y' s.Length' literalValue' //literalValue is string ? (string)literalValue : literalValue.ToString()'  			literalFormat' subFormat);  	}  	byte key;  	if (DTokens.Keywords_Lookup.TryGetValue (s' out key))  		return Token (key' x' y' s.Length);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: if (canBeKeyword) {  	// A micro-optimization..  	if (s.Length >= 8 && s [0] == '_' && s [1] == '_') {  		LiteralFormat literalFormat = 0;  		var subFormat = LiteralSubformat.Utf8;  		object literalValue = null;  		// Fill in static string surrogates directly  		if (s == "__VENDOR__") {  			literalFormat = LiteralFormat.StringLiteral;  			literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString (3) + " by Alexander Bothe";  		} else if (s == "__VERSION__") {  			subFormat = LiteralSubformat.Integer;  			var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version;  			literalFormat = LiteralFormat.Scalar;  			literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  		}  		if (literalFormat != 0)  			return Token (DTokens.Literal' x' y' s.Length' literalValue' //literalValue is string ? (string)literalValue : literalValue.ToString()'  			literalFormat' subFormat);  	}  	byte key;  	if (DTokens.Keywords_Lookup.TryGetValue (s' out key))  		return Token (key' x' y' s.Length);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: if (canBeKeyword) {  	// A micro-optimization..  	if (s.Length >= 8 && s [0] == '_' && s [1] == '_') {  		LiteralFormat literalFormat = 0;  		var subFormat = LiteralSubformat.Utf8;  		object literalValue = null;  		// Fill in static string surrogates directly  		if (s == "__VENDOR__") {  			literalFormat = LiteralFormat.StringLiteral;  			literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString (3) + " by Alexander Bothe";  		} else if (s == "__VERSION__") {  			subFormat = LiteralSubformat.Integer;  			var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version;  			literalFormat = LiteralFormat.Scalar;  			literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  		}  		if (literalFormat != 0)  			return Token (DTokens.Literal' x' y' s.Length' literalValue' //literalValue is string ? (string)literalValue : literalValue.ToString()'  			literalFormat' subFormat);  	}  	byte key;  	if (DTokens.Keywords_Lookup.TryGetValue (s' out key))  		return Token (key' x' y' s.Length);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: if (s.Length >= 8 && s [0] == '_' && s [1] == '_') {  	LiteralFormat literalFormat = 0;  	var subFormat = LiteralSubformat.Utf8;  	object literalValue = null;  	// Fill in static string surrogates directly  	if (s == "__VENDOR__") {  		literalFormat = LiteralFormat.StringLiteral;  		literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString (3) + " by Alexander Bothe";  	} else if (s == "__VERSION__") {  		subFormat = LiteralSubformat.Integer;  		var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version;  		literalFormat = LiteralFormat.Scalar;  		literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  	}  	if (literalFormat != 0)  		return Token (DTokens.Literal' x' y' s.Length' literalValue' //literalValue is string ? (string)literalValue : literalValue.ToString()'  		literalFormat' subFormat);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: if (s.Length >= 8 && s [0] == '_' && s [1] == '_') {  	LiteralFormat literalFormat = 0;  	var subFormat = LiteralSubformat.Utf8;  	object literalValue = null;  	// Fill in static string surrogates directly  	if (s == "__VENDOR__") {  		literalFormat = LiteralFormat.StringLiteral;  		literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString (3) + " by Alexander Bothe";  	} else if (s == "__VERSION__") {  		subFormat = LiteralSubformat.Integer;  		var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version;  		literalFormat = LiteralFormat.Scalar;  		literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  	}  	if (literalFormat != 0)  		return Token (DTokens.Literal' x' y' s.Length' literalValue' //literalValue is string ? (string)literalValue : literalValue.ToString()'  		literalFormat' subFormat);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: if (s.Length >= 8 && s [0] == '_' && s [1] == '_') {  	LiteralFormat literalFormat = 0;  	var subFormat = LiteralSubformat.Utf8;  	object literalValue = null;  	// Fill in static string surrogates directly  	if (s == "__VENDOR__") {  		literalFormat = LiteralFormat.StringLiteral;  		literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString (3) + " by Alexander Bothe";  	} else if (s == "__VERSION__") {  		subFormat = LiteralSubformat.Integer;  		var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version;  		literalFormat = LiteralFormat.Scalar;  		literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  	}  	if (literalFormat != 0)  		return Token (DTokens.Literal' x' y' s.Length' literalValue' //literalValue is string ? (string)literalValue : literalValue.ToString()'  		literalFormat' subFormat);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: if (s == "__VENDOR__") {  	literalFormat = LiteralFormat.StringLiteral;  	literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString (3) + " by Alexander Bothe";  } else if (s == "__VERSION__") {  	subFormat = LiteralSubformat.Integer;  	var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version;  	literalFormat = LiteralFormat.Scalar;  	literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: if (s == "__VENDOR__") {  	literalFormat = LiteralFormat.StringLiteral;  	literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString (3) + " by Alexander Bothe";  } else if (s == "__VERSION__") {  	subFormat = LiteralSubformat.Integer;  	var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version;  	literalFormat = LiteralFormat.Scalar;  	literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString (3) + " by Alexander Bothe";  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: if (s == "__VERSION__") {  	subFormat = LiteralSubformat.Integer;  	var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version;  	literalFormat = LiteralFormat.Scalar;  	literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked {  	// prevent exception when ReaderPeek() = -1 is cast to char  	int y = Line;  	sb.Length = 0;  	sb.Append (ch);  	//string prefix = null;  	string expSuffix = "";  	string suffix = null;  	int exponent = 0;  	bool HasDot = false;  	LiteralSubformat subFmt = 0;  	bool isFloat = false;  	bool isImaginary = false;  	//bool isUnsigned = false;  	//bool isLong = false;  	int NumBase = 0;  	// Set it to 0 initially - it'll be set to another value later for sure  	char peek = (char)ReaderPeek ();  	// At first' check pre-comma values  	if (ch == '0') {  		if (peek == 'x' || peek == 'X')// Hex values  		 {  			//prefix = "0x";  			ReaderRead ();  			// skip 'x'  			sb.Length = 0;  			// Remove '0' from 0x prefix from the stringvalue  			NumBase = 16;  			peek = (char)ReaderPeek ();  			while (IsHex (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} else if (peek == 'b' || peek == 'B')// Bin values  		 {  			//prefix = "0b";  			ReaderRead ();  			// skip 'b'  			sb.Length = 0;  			NumBase = 2;  			peek = (char)ReaderPeek ();  			while (IsBin (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} // Oct values have been removed in dmd 2.053  		/*else if (IsOct(peek) || peek == '_') // Oct values 					{ 						NumBase = 8; 						prefix = "0"; 						sb.Length = 0;  						while (IsOct(peek) || peek == '_') 						{ 							if (peek != '_') 								sb.Append((char)ReaderRead()); 							else ReaderRead(); 							peek = (char)ReaderPeek(); 						} 					}*/else  			NumBase = 10;  		// Enables pre-comma parsing .. in this case we'd 000 literals or something like that  	}  	if (NumBase == 10 || (ch != '.' && NumBase == 0))// Only allow further digits for 10-based integers' not for binary or hex values  	 {  		NumBase = 10;  		while (IsDigit (peek) || peek == '_') {  			if (peek != '_')  				sb.Append ((char)ReaderRead ());  			else  				ReaderRead ();  			peek = (char)ReaderPeek ();  		}  	}  	#region Read digits that occur after a comma  	DToken nextToken = null;  	// if we accidently read a 'dot'  	bool AllowSuffixes = true;  	if ((NumBase == 0 && ch == '.') || peek == '.') {  		if (ch != '.')  			ReaderRead ();  		else {  			NumBase = 10;  			sb.Length = 0;  			sb.Append ('0');  		}  		peek = (char)ReaderPeek ();  		if (!IsLegalDigit (peek' NumBase)) {  			if (peek == '.') {  				ReaderRead ();  				nextToken = Token (DTokens.DoubleDot' Col - 1' Line' 2);  			} else if (IsIdentifierPart (peek))  				nextToken = Token (DTokens.Dot' Col - 1' Line' 1);  			AllowSuffixes = false;  		} else {  			HasDot = true;  			sb.Append ('.');  			do {  				if (peek == '_')  					ReaderRead ();  				else  					sb.Append ((char)ReaderRead ());  				peek = (char)ReaderPeek ();  			} while (IsLegalDigit (peek' NumBase));  		}  	}  	#endregion  	#region Exponents  	if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E')) {  		// read exponent  		string suff = peek.ToString ();  		ReaderRead ();  		peek = (char)ReaderPeek ();  		if (peek == '-' || peek == '+')  			expSuffix += (char)ReaderRead ();  		peek = (char)ReaderPeek ();  		while ((peek >= '0' && peek <= '9') || peek == '_') {  			// read exponent value  			if (peek == '_')  				ReaderRead ();  			else  				expSuffix += (char)ReaderRead ();  			peek = (char)ReaderPeek ();  		}  		// Exponents just can be decimal integers  		int.TryParse (expSuffix' out exponent);  		expSuffix = suff + expSuffix;  		peek = (char)ReaderPeek ();  	}  	#endregion  	#region Suffixes  	if (!HasDot) {  		unsigned:  		if (peek == 'u' || peek == 'U') {  			ReaderRead ();  			suffix += "u";  			subFmt |= LiteralSubformat.Unsigned;  			//isUnsigned = true;  			peek = (char)ReaderPeek ();  		}  		if (peek == 'L') {  			subFmt |= LiteralSubformat.Long;  			ReaderRead ();  			suffix += "L";  			//isLong = true;  			peek = (char)ReaderPeek ();  			if (!subFmt.HasFlag (LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  				goto unsigned;  		}  	}  	if (HasDot || AllowSuffixes) {  		if (peek == 'f' || peek == 'F') {  			// float value  			ReaderRead ();  			suffix += "f";  			isFloat = true;  			subFmt |= LiteralSubformat.Float;  			peek = (char)ReaderPeek ();  		} else if (peek == 'L') {  			// real value  			ReaderRead ();  			//isLong = true;  			suffix += 'L';  			subFmt |= LiteralSubformat.Real;  			peek = (char)ReaderPeek ();  		}  	}  	if (peek == 'i') {  		// imaginary value  		ReaderRead ();  		suffix += "i";  		subFmt |= LiteralSubformat.Imaginary;  		isImaginary = true;  	}  	#endregion  	#region Parse the digit string  	var num = ParseFloatValue (sb' NumBase);  	if (exponent != 0) {  		try {  			num *= (decimal)Math.Pow (NumBase == 16 ? 2 : 10' exponent);  		} catch (OverflowException) {  			num = decimal.MaxValue;  			//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  			//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  		}  	}  	#endregion  	var token = Token (DTokens.Literal' x' y' Col - x/*stringValue.Length*/' num' /* stringValue'*/HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar' subFmt);  	if (token != null)  		token.next = nextToken;  	return token;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked {  	// prevent exception when ReaderPeek() = -1 is cast to char  	int y = Line;  	sb.Length = 0;  	sb.Append (ch);  	//string prefix = null;  	string expSuffix = "";  	string suffix = null;  	int exponent = 0;  	bool HasDot = false;  	LiteralSubformat subFmt = 0;  	bool isFloat = false;  	bool isImaginary = false;  	//bool isUnsigned = false;  	//bool isLong = false;  	int NumBase = 0;  	// Set it to 0 initially - it'll be set to another value later for sure  	char peek = (char)ReaderPeek ();  	// At first' check pre-comma values  	if (ch == '0') {  		if (peek == 'x' || peek == 'X')// Hex values  		 {  			//prefix = "0x";  			ReaderRead ();  			// skip 'x'  			sb.Length = 0;  			// Remove '0' from 0x prefix from the stringvalue  			NumBase = 16;  			peek = (char)ReaderPeek ();  			while (IsHex (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} else if (peek == 'b' || peek == 'B')// Bin values  		 {  			//prefix = "0b";  			ReaderRead ();  			// skip 'b'  			sb.Length = 0;  			NumBase = 2;  			peek = (char)ReaderPeek ();  			while (IsBin (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} // Oct values have been removed in dmd 2.053  		/*else if (IsOct(peek) || peek == '_') // Oct values 					{ 						NumBase = 8; 						prefix = "0"; 						sb.Length = 0;  						while (IsOct(peek) || peek == '_') 						{ 							if (peek != '_') 								sb.Append((char)ReaderRead()); 							else ReaderRead(); 							peek = (char)ReaderPeek(); 						} 					}*/else  			NumBase = 10;  		// Enables pre-comma parsing .. in this case we'd 000 literals or something like that  	}  	if (NumBase == 10 || (ch != '.' && NumBase == 0))// Only allow further digits for 10-based integers' not for binary or hex values  	 {  		NumBase = 10;  		while (IsDigit (peek) || peek == '_') {  			if (peek != '_')  				sb.Append ((char)ReaderRead ());  			else  				ReaderRead ();  			peek = (char)ReaderPeek ();  		}  	}  	#region Read digits that occur after a comma  	DToken nextToken = null;  	// if we accidently read a 'dot'  	bool AllowSuffixes = true;  	if ((NumBase == 0 && ch == '.') || peek == '.') {  		if (ch != '.')  			ReaderRead ();  		else {  			NumBase = 10;  			sb.Length = 0;  			sb.Append ('0');  		}  		peek = (char)ReaderPeek ();  		if (!IsLegalDigit (peek' NumBase)) {  			if (peek == '.') {  				ReaderRead ();  				nextToken = Token (DTokens.DoubleDot' Col - 1' Line' 2);  			} else if (IsIdentifierPart (peek))  				nextToken = Token (DTokens.Dot' Col - 1' Line' 1);  			AllowSuffixes = false;  		} else {  			HasDot = true;  			sb.Append ('.');  			do {  				if (peek == '_')  					ReaderRead ();  				else  					sb.Append ((char)ReaderRead ());  				peek = (char)ReaderPeek ();  			} while (IsLegalDigit (peek' NumBase));  		}  	}  	#endregion  	#region Exponents  	if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E')) {  		// read exponent  		string suff = peek.ToString ();  		ReaderRead ();  		peek = (char)ReaderPeek ();  		if (peek == '-' || peek == '+')  			expSuffix += (char)ReaderRead ();  		peek = (char)ReaderPeek ();  		while ((peek >= '0' && peek <= '9') || peek == '_') {  			// read exponent value  			if (peek == '_')  				ReaderRead ();  			else  				expSuffix += (char)ReaderRead ();  			peek = (char)ReaderPeek ();  		}  		// Exponents just can be decimal integers  		int.TryParse (expSuffix' out exponent);  		expSuffix = suff + expSuffix;  		peek = (char)ReaderPeek ();  	}  	#endregion  	#region Suffixes  	if (!HasDot) {  		unsigned:  		if (peek == 'u' || peek == 'U') {  			ReaderRead ();  			suffix += "u";  			subFmt |= LiteralSubformat.Unsigned;  			//isUnsigned = true;  			peek = (char)ReaderPeek ();  		}  		if (peek == 'L') {  			subFmt |= LiteralSubformat.Long;  			ReaderRead ();  			suffix += "L";  			//isLong = true;  			peek = (char)ReaderPeek ();  			if (!subFmt.HasFlag (LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  				goto unsigned;  		}  	}  	if (HasDot || AllowSuffixes) {  		if (peek == 'f' || peek == 'F') {  			// float value  			ReaderRead ();  			suffix += "f";  			isFloat = true;  			subFmt |= LiteralSubformat.Float;  			peek = (char)ReaderPeek ();  		} else if (peek == 'L') {  			// real value  			ReaderRead ();  			//isLong = true;  			suffix += 'L';  			subFmt |= LiteralSubformat.Real;  			peek = (char)ReaderPeek ();  		}  	}  	if (peek == 'i') {  		// imaginary value  		ReaderRead ();  		suffix += "i";  		subFmt |= LiteralSubformat.Imaginary;  		isImaginary = true;  	}  	#endregion  	#region Parse the digit string  	var num = ParseFloatValue (sb' NumBase);  	if (exponent != 0) {  		try {  			num *= (decimal)Math.Pow (NumBase == 16 ? 2 : 10' exponent);  		} catch (OverflowException) {  			num = decimal.MaxValue;  			//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  			//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  		}  	}  	#endregion  	var token = Token (DTokens.Literal' x' y' Col - x/*stringValue.Length*/' num' /* stringValue'*/HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar' subFmt);  	if (token != null)  		token.next = nextToken;  	return token;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked {  	// prevent exception when ReaderPeek() = -1 is cast to char  	int y = Line;  	sb.Length = 0;  	sb.Append (ch);  	//string prefix = null;  	string expSuffix = "";  	string suffix = null;  	int exponent = 0;  	bool HasDot = false;  	LiteralSubformat subFmt = 0;  	bool isFloat = false;  	bool isImaginary = false;  	//bool isUnsigned = false;  	//bool isLong = false;  	int NumBase = 0;  	// Set it to 0 initially - it'll be set to another value later for sure  	char peek = (char)ReaderPeek ();  	// At first' check pre-comma values  	if (ch == '0') {  		if (peek == 'x' || peek == 'X')// Hex values  		 {  			//prefix = "0x";  			ReaderRead ();  			// skip 'x'  			sb.Length = 0;  			// Remove '0' from 0x prefix from the stringvalue  			NumBase = 16;  			peek = (char)ReaderPeek ();  			while (IsHex (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} else if (peek == 'b' || peek == 'B')// Bin values  		 {  			//prefix = "0b";  			ReaderRead ();  			// skip 'b'  			sb.Length = 0;  			NumBase = 2;  			peek = (char)ReaderPeek ();  			while (IsBin (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} // Oct values have been removed in dmd 2.053  		/*else if (IsOct(peek) || peek == '_') // Oct values 					{ 						NumBase = 8; 						prefix = "0"; 						sb.Length = 0;  						while (IsOct(peek) || peek == '_') 						{ 							if (peek != '_') 								sb.Append((char)ReaderRead()); 							else ReaderRead(); 							peek = (char)ReaderPeek(); 						} 					}*/else  			NumBase = 10;  		// Enables pre-comma parsing .. in this case we'd 000 literals or something like that  	}  	if (NumBase == 10 || (ch != '.' && NumBase == 0))// Only allow further digits for 10-based integers' not for binary or hex values  	 {  		NumBase = 10;  		while (IsDigit (peek) || peek == '_') {  			if (peek != '_')  				sb.Append ((char)ReaderRead ());  			else  				ReaderRead ();  			peek = (char)ReaderPeek ();  		}  	}  	#region Read digits that occur after a comma  	DToken nextToken = null;  	// if we accidently read a 'dot'  	bool AllowSuffixes = true;  	if ((NumBase == 0 && ch == '.') || peek == '.') {  		if (ch != '.')  			ReaderRead ();  		else {  			NumBase = 10;  			sb.Length = 0;  			sb.Append ('0');  		}  		peek = (char)ReaderPeek ();  		if (!IsLegalDigit (peek' NumBase)) {  			if (peek == '.') {  				ReaderRead ();  				nextToken = Token (DTokens.DoubleDot' Col - 1' Line' 2);  			} else if (IsIdentifierPart (peek))  				nextToken = Token (DTokens.Dot' Col - 1' Line' 1);  			AllowSuffixes = false;  		} else {  			HasDot = true;  			sb.Append ('.');  			do {  				if (peek == '_')  					ReaderRead ();  				else  					sb.Append ((char)ReaderRead ());  				peek = (char)ReaderPeek ();  			} while (IsLegalDigit (peek' NumBase));  		}  	}  	#endregion  	#region Exponents  	if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E')) {  		// read exponent  		string suff = peek.ToString ();  		ReaderRead ();  		peek = (char)ReaderPeek ();  		if (peek == '-' || peek == '+')  			expSuffix += (char)ReaderRead ();  		peek = (char)ReaderPeek ();  		while ((peek >= '0' && peek <= '9') || peek == '_') {  			// read exponent value  			if (peek == '_')  				ReaderRead ();  			else  				expSuffix += (char)ReaderRead ();  			peek = (char)ReaderPeek ();  		}  		// Exponents just can be decimal integers  		int.TryParse (expSuffix' out exponent);  		expSuffix = suff + expSuffix;  		peek = (char)ReaderPeek ();  	}  	#endregion  	#region Suffixes  	if (!HasDot) {  		unsigned:  		if (peek == 'u' || peek == 'U') {  			ReaderRead ();  			suffix += "u";  			subFmt |= LiteralSubformat.Unsigned;  			//isUnsigned = true;  			peek = (char)ReaderPeek ();  		}  		if (peek == 'L') {  			subFmt |= LiteralSubformat.Long;  			ReaderRead ();  			suffix += "L";  			//isLong = true;  			peek = (char)ReaderPeek ();  			if (!subFmt.HasFlag (LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  				goto unsigned;  		}  	}  	if (HasDot || AllowSuffixes) {  		if (peek == 'f' || peek == 'F') {  			// float value  			ReaderRead ();  			suffix += "f";  			isFloat = true;  			subFmt |= LiteralSubformat.Float;  			peek = (char)ReaderPeek ();  		} else if (peek == 'L') {  			// real value  			ReaderRead ();  			//isLong = true;  			suffix += 'L';  			subFmt |= LiteralSubformat.Real;  			peek = (char)ReaderPeek ();  		}  	}  	if (peek == 'i') {  		// imaginary value  		ReaderRead ();  		suffix += "i";  		subFmt |= LiteralSubformat.Imaginary;  		isImaginary = true;  	}  	#endregion  	#region Parse the digit string  	var num = ParseFloatValue (sb' NumBase);  	if (exponent != 0) {  		try {  			num *= (decimal)Math.Pow (NumBase == 16 ? 2 : 10' exponent);  		} catch (OverflowException) {  			num = decimal.MaxValue;  			//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  			//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  		}  	}  	#endregion  	var token = Token (DTokens.Literal' x' y' Col - x/*stringValue.Length*/' num' /* stringValue'*/HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar' subFmt);  	if (token != null)  		token.next = nextToken;  	return token;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked {  	// prevent exception when ReaderPeek() = -1 is cast to char  	int y = Line;  	sb.Length = 0;  	sb.Append (ch);  	//string prefix = null;  	string expSuffix = "";  	string suffix = null;  	int exponent = 0;  	bool HasDot = false;  	LiteralSubformat subFmt = 0;  	bool isFloat = false;  	bool isImaginary = false;  	//bool isUnsigned = false;  	//bool isLong = false;  	int NumBase = 0;  	// Set it to 0 initially - it'll be set to another value later for sure  	char peek = (char)ReaderPeek ();  	// At first' check pre-comma values  	if (ch == '0') {  		if (peek == 'x' || peek == 'X')// Hex values  		 {  			//prefix = "0x";  			ReaderRead ();  			// skip 'x'  			sb.Length = 0;  			// Remove '0' from 0x prefix from the stringvalue  			NumBase = 16;  			peek = (char)ReaderPeek ();  			while (IsHex (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} else if (peek == 'b' || peek == 'B')// Bin values  		 {  			//prefix = "0b";  			ReaderRead ();  			// skip 'b'  			sb.Length = 0;  			NumBase = 2;  			peek = (char)ReaderPeek ();  			while (IsBin (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} // Oct values have been removed in dmd 2.053  		/*else if (IsOct(peek) || peek == '_') // Oct values 					{ 						NumBase = 8; 						prefix = "0"; 						sb.Length = 0;  						while (IsOct(peek) || peek == '_') 						{ 							if (peek != '_') 								sb.Append((char)ReaderRead()); 							else ReaderRead(); 							peek = (char)ReaderPeek(); 						} 					}*/else  			NumBase = 10;  		// Enables pre-comma parsing .. in this case we'd 000 literals or something like that  	}  	if (NumBase == 10 || (ch != '.' && NumBase == 0))// Only allow further digits for 10-based integers' not for binary or hex values  	 {  		NumBase = 10;  		while (IsDigit (peek) || peek == '_') {  			if (peek != '_')  				sb.Append ((char)ReaderRead ());  			else  				ReaderRead ();  			peek = (char)ReaderPeek ();  		}  	}  	#region Read digits that occur after a comma  	DToken nextToken = null;  	// if we accidently read a 'dot'  	bool AllowSuffixes = true;  	if ((NumBase == 0 && ch == '.') || peek == '.') {  		if (ch != '.')  			ReaderRead ();  		else {  			NumBase = 10;  			sb.Length = 0;  			sb.Append ('0');  		}  		peek = (char)ReaderPeek ();  		if (!IsLegalDigit (peek' NumBase)) {  			if (peek == '.') {  				ReaderRead ();  				nextToken = Token (DTokens.DoubleDot' Col - 1' Line' 2);  			} else if (IsIdentifierPart (peek))  				nextToken = Token (DTokens.Dot' Col - 1' Line' 1);  			AllowSuffixes = false;  		} else {  			HasDot = true;  			sb.Append ('.');  			do {  				if (peek == '_')  					ReaderRead ();  				else  					sb.Append ((char)ReaderRead ());  				peek = (char)ReaderPeek ();  			} while (IsLegalDigit (peek' NumBase));  		}  	}  	#endregion  	#region Exponents  	if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E')) {  		// read exponent  		string suff = peek.ToString ();  		ReaderRead ();  		peek = (char)ReaderPeek ();  		if (peek == '-' || peek == '+')  			expSuffix += (char)ReaderRead ();  		peek = (char)ReaderPeek ();  		while ((peek >= '0' && peek <= '9') || peek == '_') {  			// read exponent value  			if (peek == '_')  				ReaderRead ();  			else  				expSuffix += (char)ReaderRead ();  			peek = (char)ReaderPeek ();  		}  		// Exponents just can be decimal integers  		int.TryParse (expSuffix' out exponent);  		expSuffix = suff + expSuffix;  		peek = (char)ReaderPeek ();  	}  	#endregion  	#region Suffixes  	if (!HasDot) {  		unsigned:  		if (peek == 'u' || peek == 'U') {  			ReaderRead ();  			suffix += "u";  			subFmt |= LiteralSubformat.Unsigned;  			//isUnsigned = true;  			peek = (char)ReaderPeek ();  		}  		if (peek == 'L') {  			subFmt |= LiteralSubformat.Long;  			ReaderRead ();  			suffix += "L";  			//isLong = true;  			peek = (char)ReaderPeek ();  			if (!subFmt.HasFlag (LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  				goto unsigned;  		}  	}  	if (HasDot || AllowSuffixes) {  		if (peek == 'f' || peek == 'F') {  			// float value  			ReaderRead ();  			suffix += "f";  			isFloat = true;  			subFmt |= LiteralSubformat.Float;  			peek = (char)ReaderPeek ();  		} else if (peek == 'L') {  			// real value  			ReaderRead ();  			//isLong = true;  			suffix += 'L';  			subFmt |= LiteralSubformat.Real;  			peek = (char)ReaderPeek ();  		}  	}  	if (peek == 'i') {  		// imaginary value  		ReaderRead ();  		suffix += "i";  		subFmt |= LiteralSubformat.Imaginary;  		isImaginary = true;  	}  	#endregion  	#region Parse the digit string  	var num = ParseFloatValue (sb' NumBase);  	if (exponent != 0) {  		try {  			num *= (decimal)Math.Pow (NumBase == 16 ? 2 : 10' exponent);  		} catch (OverflowException) {  			num = decimal.MaxValue;  			//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  			//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  		}  	}  	#endregion  	var token = Token (DTokens.Literal' x' y' Col - x/*stringValue.Length*/' num' /* stringValue'*/HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar' subFmt);  	if (token != null)  		token.next = nextToken;  	return token;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked {  	// prevent exception when ReaderPeek() = -1 is cast to char  	int y = Line;  	sb.Length = 0;  	sb.Append (ch);  	//string prefix = null;  	string expSuffix = "";  	string suffix = null;  	int exponent = 0;  	bool HasDot = false;  	LiteralSubformat subFmt = 0;  	bool isFloat = false;  	bool isImaginary = false;  	//bool isUnsigned = false;  	//bool isLong = false;  	int NumBase = 0;  	// Set it to 0 initially - it'll be set to another value later for sure  	char peek = (char)ReaderPeek ();  	// At first' check pre-comma values  	if (ch == '0') {  		if (peek == 'x' || peek == 'X')// Hex values  		 {  			//prefix = "0x";  			ReaderRead ();  			// skip 'x'  			sb.Length = 0;  			// Remove '0' from 0x prefix from the stringvalue  			NumBase = 16;  			peek = (char)ReaderPeek ();  			while (IsHex (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} else if (peek == 'b' || peek == 'B')// Bin values  		 {  			//prefix = "0b";  			ReaderRead ();  			// skip 'b'  			sb.Length = 0;  			NumBase = 2;  			peek = (char)ReaderPeek ();  			while (IsBin (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} // Oct values have been removed in dmd 2.053  		/*else if (IsOct(peek) || peek == '_') // Oct values 					{ 						NumBase = 8; 						prefix = "0"; 						sb.Length = 0;  						while (IsOct(peek) || peek == '_') 						{ 							if (peek != '_') 								sb.Append((char)ReaderRead()); 							else ReaderRead(); 							peek = (char)ReaderPeek(); 						} 					}*/else  			NumBase = 10;  		// Enables pre-comma parsing .. in this case we'd 000 literals or something like that  	}  	if (NumBase == 10 || (ch != '.' && NumBase == 0))// Only allow further digits for 10-based integers' not for binary or hex values  	 {  		NumBase = 10;  		while (IsDigit (peek) || peek == '_') {  			if (peek != '_')  				sb.Append ((char)ReaderRead ());  			else  				ReaderRead ();  			peek = (char)ReaderPeek ();  		}  	}  	#region Read digits that occur after a comma  	DToken nextToken = null;  	// if we accidently read a 'dot'  	bool AllowSuffixes = true;  	if ((NumBase == 0 && ch == '.') || peek == '.') {  		if (ch != '.')  			ReaderRead ();  		else {  			NumBase = 10;  			sb.Length = 0;  			sb.Append ('0');  		}  		peek = (char)ReaderPeek ();  		if (!IsLegalDigit (peek' NumBase)) {  			if (peek == '.') {  				ReaderRead ();  				nextToken = Token (DTokens.DoubleDot' Col - 1' Line' 2);  			} else if (IsIdentifierPart (peek))  				nextToken = Token (DTokens.Dot' Col - 1' Line' 1);  			AllowSuffixes = false;  		} else {  			HasDot = true;  			sb.Append ('.');  			do {  				if (peek == '_')  					ReaderRead ();  				else  					sb.Append ((char)ReaderRead ());  				peek = (char)ReaderPeek ();  			} while (IsLegalDigit (peek' NumBase));  		}  	}  	#endregion  	#region Exponents  	if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E')) {  		// read exponent  		string suff = peek.ToString ();  		ReaderRead ();  		peek = (char)ReaderPeek ();  		if (peek == '-' || peek == '+')  			expSuffix += (char)ReaderRead ();  		peek = (char)ReaderPeek ();  		while ((peek >= '0' && peek <= '9') || peek == '_') {  			// read exponent value  			if (peek == '_')  				ReaderRead ();  			else  				expSuffix += (char)ReaderRead ();  			peek = (char)ReaderPeek ();  		}  		// Exponents just can be decimal integers  		int.TryParse (expSuffix' out exponent);  		expSuffix = suff + expSuffix;  		peek = (char)ReaderPeek ();  	}  	#endregion  	#region Suffixes  	if (!HasDot) {  		unsigned:  		if (peek == 'u' || peek == 'U') {  			ReaderRead ();  			suffix += "u";  			subFmt |= LiteralSubformat.Unsigned;  			//isUnsigned = true;  			peek = (char)ReaderPeek ();  		}  		if (peek == 'L') {  			subFmt |= LiteralSubformat.Long;  			ReaderRead ();  			suffix += "L";  			//isLong = true;  			peek = (char)ReaderPeek ();  			if (!subFmt.HasFlag (LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  				goto unsigned;  		}  	}  	if (HasDot || AllowSuffixes) {  		if (peek == 'f' || peek == 'F') {  			// float value  			ReaderRead ();  			suffix += "f";  			isFloat = true;  			subFmt |= LiteralSubformat.Float;  			peek = (char)ReaderPeek ();  		} else if (peek == 'L') {  			// real value  			ReaderRead ();  			//isLong = true;  			suffix += 'L';  			subFmt |= LiteralSubformat.Real;  			peek = (char)ReaderPeek ();  		}  	}  	if (peek == 'i') {  		// imaginary value  		ReaderRead ();  		suffix += "i";  		subFmt |= LiteralSubformat.Imaginary;  		isImaginary = true;  	}  	#endregion  	#region Parse the digit string  	var num = ParseFloatValue (sb' NumBase);  	if (exponent != 0) {  		try {  			num *= (decimal)Math.Pow (NumBase == 16 ? 2 : 10' exponent);  		} catch (OverflowException) {  			num = decimal.MaxValue;  			//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  			//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  		}  	}  	#endregion  	var token = Token (DTokens.Literal' x' y' Col - x/*stringValue.Length*/' num' /* stringValue'*/HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar' subFmt);  	if (token != null)  		token.next = nextToken;  	return token;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked {  	// prevent exception when ReaderPeek() = -1 is cast to char  	int y = Line;  	sb.Length = 0;  	sb.Append (ch);  	//string prefix = null;  	string expSuffix = "";  	string suffix = null;  	int exponent = 0;  	bool HasDot = false;  	LiteralSubformat subFmt = 0;  	bool isFloat = false;  	bool isImaginary = false;  	//bool isUnsigned = false;  	//bool isLong = false;  	int NumBase = 0;  	// Set it to 0 initially - it'll be set to another value later for sure  	char peek = (char)ReaderPeek ();  	// At first' check pre-comma values  	if (ch == '0') {  		if (peek == 'x' || peek == 'X')// Hex values  		 {  			//prefix = "0x";  			ReaderRead ();  			// skip 'x'  			sb.Length = 0;  			// Remove '0' from 0x prefix from the stringvalue  			NumBase = 16;  			peek = (char)ReaderPeek ();  			while (IsHex (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} else if (peek == 'b' || peek == 'B')// Bin values  		 {  			//prefix = "0b";  			ReaderRead ();  			// skip 'b'  			sb.Length = 0;  			NumBase = 2;  			peek = (char)ReaderPeek ();  			while (IsBin (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} // Oct values have been removed in dmd 2.053  		/*else if (IsOct(peek) || peek == '_') // Oct values 					{ 						NumBase = 8; 						prefix = "0"; 						sb.Length = 0;  						while (IsOct(peek) || peek == '_') 						{ 							if (peek != '_') 								sb.Append((char)ReaderRead()); 							else ReaderRead(); 							peek = (char)ReaderPeek(); 						} 					}*/else  			NumBase = 10;  		// Enables pre-comma parsing .. in this case we'd 000 literals or something like that  	}  	if (NumBase == 10 || (ch != '.' && NumBase == 0))// Only allow further digits for 10-based integers' not for binary or hex values  	 {  		NumBase = 10;  		while (IsDigit (peek) || peek == '_') {  			if (peek != '_')  				sb.Append ((char)ReaderRead ());  			else  				ReaderRead ();  			peek = (char)ReaderPeek ();  		}  	}  	#region Read digits that occur after a comma  	DToken nextToken = null;  	// if we accidently read a 'dot'  	bool AllowSuffixes = true;  	if ((NumBase == 0 && ch == '.') || peek == '.') {  		if (ch != '.')  			ReaderRead ();  		else {  			NumBase = 10;  			sb.Length = 0;  			sb.Append ('0');  		}  		peek = (char)ReaderPeek ();  		if (!IsLegalDigit (peek' NumBase)) {  			if (peek == '.') {  				ReaderRead ();  				nextToken = Token (DTokens.DoubleDot' Col - 1' Line' 2);  			} else if (IsIdentifierPart (peek))  				nextToken = Token (DTokens.Dot' Col - 1' Line' 1);  			AllowSuffixes = false;  		} else {  			HasDot = true;  			sb.Append ('.');  			do {  				if (peek == '_')  					ReaderRead ();  				else  					sb.Append ((char)ReaderRead ());  				peek = (char)ReaderPeek ();  			} while (IsLegalDigit (peek' NumBase));  		}  	}  	#endregion  	#region Exponents  	if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E')) {  		// read exponent  		string suff = peek.ToString ();  		ReaderRead ();  		peek = (char)ReaderPeek ();  		if (peek == '-' || peek == '+')  			expSuffix += (char)ReaderRead ();  		peek = (char)ReaderPeek ();  		while ((peek >= '0' && peek <= '9') || peek == '_') {  			// read exponent value  			if (peek == '_')  				ReaderRead ();  			else  				expSuffix += (char)ReaderRead ();  			peek = (char)ReaderPeek ();  		}  		// Exponents just can be decimal integers  		int.TryParse (expSuffix' out exponent);  		expSuffix = suff + expSuffix;  		peek = (char)ReaderPeek ();  	}  	#endregion  	#region Suffixes  	if (!HasDot) {  		unsigned:  		if (peek == 'u' || peek == 'U') {  			ReaderRead ();  			suffix += "u";  			subFmt |= LiteralSubformat.Unsigned;  			//isUnsigned = true;  			peek = (char)ReaderPeek ();  		}  		if (peek == 'L') {  			subFmt |= LiteralSubformat.Long;  			ReaderRead ();  			suffix += "L";  			//isLong = true;  			peek = (char)ReaderPeek ();  			if (!subFmt.HasFlag (LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  				goto unsigned;  		}  	}  	if (HasDot || AllowSuffixes) {  		if (peek == 'f' || peek == 'F') {  			// float value  			ReaderRead ();  			suffix += "f";  			isFloat = true;  			subFmt |= LiteralSubformat.Float;  			peek = (char)ReaderPeek ();  		} else if (peek == 'L') {  			// real value  			ReaderRead ();  			//isLong = true;  			suffix += 'L';  			subFmt |= LiteralSubformat.Real;  			peek = (char)ReaderPeek ();  		}  	}  	if (peek == 'i') {  		// imaginary value  		ReaderRead ();  		suffix += "i";  		subFmt |= LiteralSubformat.Imaginary;  		isImaginary = true;  	}  	#endregion  	#region Parse the digit string  	var num = ParseFloatValue (sb' NumBase);  	if (exponent != 0) {  		try {  			num *= (decimal)Math.Pow (NumBase == 16 ? 2 : 10' exponent);  		} catch (OverflowException) {  			num = decimal.MaxValue;  			//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  			//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  		}  	}  	#endregion  	var token = Token (DTokens.Literal' x' y' Col - x/*stringValue.Length*/' num' /* stringValue'*/HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar' subFmt);  	if (token != null)  		token.next = nextToken;  	return token;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked {  	// prevent exception when ReaderPeek() = -1 is cast to char  	int y = Line;  	sb.Length = 0;  	sb.Append (ch);  	//string prefix = null;  	string expSuffix = "";  	string suffix = null;  	int exponent = 0;  	bool HasDot = false;  	LiteralSubformat subFmt = 0;  	bool isFloat = false;  	bool isImaginary = false;  	//bool isUnsigned = false;  	//bool isLong = false;  	int NumBase = 0;  	// Set it to 0 initially - it'll be set to another value later for sure  	char peek = (char)ReaderPeek ();  	// At first' check pre-comma values  	if (ch == '0') {  		if (peek == 'x' || peek == 'X')// Hex values  		 {  			//prefix = "0x";  			ReaderRead ();  			// skip 'x'  			sb.Length = 0;  			// Remove '0' from 0x prefix from the stringvalue  			NumBase = 16;  			peek = (char)ReaderPeek ();  			while (IsHex (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} else if (peek == 'b' || peek == 'B')// Bin values  		 {  			//prefix = "0b";  			ReaderRead ();  			// skip 'b'  			sb.Length = 0;  			NumBase = 2;  			peek = (char)ReaderPeek ();  			while (IsBin (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} // Oct values have been removed in dmd 2.053  		/*else if (IsOct(peek) || peek == '_') // Oct values 					{ 						NumBase = 8; 						prefix = "0"; 						sb.Length = 0;  						while (IsOct(peek) || peek == '_') 						{ 							if (peek != '_') 								sb.Append((char)ReaderRead()); 							else ReaderRead(); 							peek = (char)ReaderPeek(); 						} 					}*/else  			NumBase = 10;  		// Enables pre-comma parsing .. in this case we'd 000 literals or something like that  	}  	if (NumBase == 10 || (ch != '.' && NumBase == 0))// Only allow further digits for 10-based integers' not for binary or hex values  	 {  		NumBase = 10;  		while (IsDigit (peek) || peek == '_') {  			if (peek != '_')  				sb.Append ((char)ReaderRead ());  			else  				ReaderRead ();  			peek = (char)ReaderPeek ();  		}  	}  	#region Read digits that occur after a comma  	DToken nextToken = null;  	// if we accidently read a 'dot'  	bool AllowSuffixes = true;  	if ((NumBase == 0 && ch == '.') || peek == '.') {  		if (ch != '.')  			ReaderRead ();  		else {  			NumBase = 10;  			sb.Length = 0;  			sb.Append ('0');  		}  		peek = (char)ReaderPeek ();  		if (!IsLegalDigit (peek' NumBase)) {  			if (peek == '.') {  				ReaderRead ();  				nextToken = Token (DTokens.DoubleDot' Col - 1' Line' 2);  			} else if (IsIdentifierPart (peek))  				nextToken = Token (DTokens.Dot' Col - 1' Line' 1);  			AllowSuffixes = false;  		} else {  			HasDot = true;  			sb.Append ('.');  			do {  				if (peek == '_')  					ReaderRead ();  				else  					sb.Append ((char)ReaderRead ());  				peek = (char)ReaderPeek ();  			} while (IsLegalDigit (peek' NumBase));  		}  	}  	#endregion  	#region Exponents  	if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E')) {  		// read exponent  		string suff = peek.ToString ();  		ReaderRead ();  		peek = (char)ReaderPeek ();  		if (peek == '-' || peek == '+')  			expSuffix += (char)ReaderRead ();  		peek = (char)ReaderPeek ();  		while ((peek >= '0' && peek <= '9') || peek == '_') {  			// read exponent value  			if (peek == '_')  				ReaderRead ();  			else  				expSuffix += (char)ReaderRead ();  			peek = (char)ReaderPeek ();  		}  		// Exponents just can be decimal integers  		int.TryParse (expSuffix' out exponent);  		expSuffix = suff + expSuffix;  		peek = (char)ReaderPeek ();  	}  	#endregion  	#region Suffixes  	if (!HasDot) {  		unsigned:  		if (peek == 'u' || peek == 'U') {  			ReaderRead ();  			suffix += "u";  			subFmt |= LiteralSubformat.Unsigned;  			//isUnsigned = true;  			peek = (char)ReaderPeek ();  		}  		if (peek == 'L') {  			subFmt |= LiteralSubformat.Long;  			ReaderRead ();  			suffix += "L";  			//isLong = true;  			peek = (char)ReaderPeek ();  			if (!subFmt.HasFlag (LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  				goto unsigned;  		}  	}  	if (HasDot || AllowSuffixes) {  		if (peek == 'f' || peek == 'F') {  			// float value  			ReaderRead ();  			suffix += "f";  			isFloat = true;  			subFmt |= LiteralSubformat.Float;  			peek = (char)ReaderPeek ();  		} else if (peek == 'L') {  			// real value  			ReaderRead ();  			//isLong = true;  			suffix += 'L';  			subFmt |= LiteralSubformat.Real;  			peek = (char)ReaderPeek ();  		}  	}  	if (peek == 'i') {  		// imaginary value  		ReaderRead ();  		suffix += "i";  		subFmt |= LiteralSubformat.Imaginary;  		isImaginary = true;  	}  	#endregion  	#region Parse the digit string  	var num = ParseFloatValue (sb' NumBase);  	if (exponent != 0) {  		try {  			num *= (decimal)Math.Pow (NumBase == 16 ? 2 : 10' exponent);  		} catch (OverflowException) {  			num = decimal.MaxValue;  			//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  			//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  		}  	}  	#endregion  	var token = Token (DTokens.Literal' x' y' Col - x/*stringValue.Length*/' num' /* stringValue'*/HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar' subFmt);  	if (token != null)  		token.next = nextToken;  	return token;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked {  	// prevent exception when ReaderPeek() = -1 is cast to char  	int y = Line;  	sb.Length = 0;  	sb.Append (ch);  	//string prefix = null;  	string expSuffix = "";  	string suffix = null;  	int exponent = 0;  	bool HasDot = false;  	LiteralSubformat subFmt = 0;  	bool isFloat = false;  	bool isImaginary = false;  	//bool isUnsigned = false;  	//bool isLong = false;  	int NumBase = 0;  	// Set it to 0 initially - it'll be set to another value later for sure  	char peek = (char)ReaderPeek ();  	// At first' check pre-comma values  	if (ch == '0') {  		if (peek == 'x' || peek == 'X')// Hex values  		 {  			//prefix = "0x";  			ReaderRead ();  			// skip 'x'  			sb.Length = 0;  			// Remove '0' from 0x prefix from the stringvalue  			NumBase = 16;  			peek = (char)ReaderPeek ();  			while (IsHex (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} else if (peek == 'b' || peek == 'B')// Bin values  		 {  			//prefix = "0b";  			ReaderRead ();  			// skip 'b'  			sb.Length = 0;  			NumBase = 2;  			peek = (char)ReaderPeek ();  			while (IsBin (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} // Oct values have been removed in dmd 2.053  		/*else if (IsOct(peek) || peek == '_') // Oct values 					{ 						NumBase = 8; 						prefix = "0"; 						sb.Length = 0;  						while (IsOct(peek) || peek == '_') 						{ 							if (peek != '_') 								sb.Append((char)ReaderRead()); 							else ReaderRead(); 							peek = (char)ReaderPeek(); 						} 					}*/else  			NumBase = 10;  		// Enables pre-comma parsing .. in this case we'd 000 literals or something like that  	}  	if (NumBase == 10 || (ch != '.' && NumBase == 0))// Only allow further digits for 10-based integers' not for binary or hex values  	 {  		NumBase = 10;  		while (IsDigit (peek) || peek == '_') {  			if (peek != '_')  				sb.Append ((char)ReaderRead ());  			else  				ReaderRead ();  			peek = (char)ReaderPeek ();  		}  	}  	#region Read digits that occur after a comma  	DToken nextToken = null;  	// if we accidently read a 'dot'  	bool AllowSuffixes = true;  	if ((NumBase == 0 && ch == '.') || peek == '.') {  		if (ch != '.')  			ReaderRead ();  		else {  			NumBase = 10;  			sb.Length = 0;  			sb.Append ('0');  		}  		peek = (char)ReaderPeek ();  		if (!IsLegalDigit (peek' NumBase)) {  			if (peek == '.') {  				ReaderRead ();  				nextToken = Token (DTokens.DoubleDot' Col - 1' Line' 2);  			} else if (IsIdentifierPart (peek))  				nextToken = Token (DTokens.Dot' Col - 1' Line' 1);  			AllowSuffixes = false;  		} else {  			HasDot = true;  			sb.Append ('.');  			do {  				if (peek == '_')  					ReaderRead ();  				else  					sb.Append ((char)ReaderRead ());  				peek = (char)ReaderPeek ();  			} while (IsLegalDigit (peek' NumBase));  		}  	}  	#endregion  	#region Exponents  	if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E')) {  		// read exponent  		string suff = peek.ToString ();  		ReaderRead ();  		peek = (char)ReaderPeek ();  		if (peek == '-' || peek == '+')  			expSuffix += (char)ReaderRead ();  		peek = (char)ReaderPeek ();  		while ((peek >= '0' && peek <= '9') || peek == '_') {  			// read exponent value  			if (peek == '_')  				ReaderRead ();  			else  				expSuffix += (char)ReaderRead ();  			peek = (char)ReaderPeek ();  		}  		// Exponents just can be decimal integers  		int.TryParse (expSuffix' out exponent);  		expSuffix = suff + expSuffix;  		peek = (char)ReaderPeek ();  	}  	#endregion  	#region Suffixes  	if (!HasDot) {  		unsigned:  		if (peek == 'u' || peek == 'U') {  			ReaderRead ();  			suffix += "u";  			subFmt |= LiteralSubformat.Unsigned;  			//isUnsigned = true;  			peek = (char)ReaderPeek ();  		}  		if (peek == 'L') {  			subFmt |= LiteralSubformat.Long;  			ReaderRead ();  			suffix += "L";  			//isLong = true;  			peek = (char)ReaderPeek ();  			if (!subFmt.HasFlag (LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  				goto unsigned;  		}  	}  	if (HasDot || AllowSuffixes) {  		if (peek == 'f' || peek == 'F') {  			// float value  			ReaderRead ();  			suffix += "f";  			isFloat = true;  			subFmt |= LiteralSubformat.Float;  			peek = (char)ReaderPeek ();  		} else if (peek == 'L') {  			// real value  			ReaderRead ();  			//isLong = true;  			suffix += 'L';  			subFmt |= LiteralSubformat.Real;  			peek = (char)ReaderPeek ();  		}  	}  	if (peek == 'i') {  		// imaginary value  		ReaderRead ();  		suffix += "i";  		subFmt |= LiteralSubformat.Imaginary;  		isImaginary = true;  	}  	#endregion  	#region Parse the digit string  	var num = ParseFloatValue (sb' NumBase);  	if (exponent != 0) {  		try {  			num *= (decimal)Math.Pow (NumBase == 16 ? 2 : 10' exponent);  		} catch (OverflowException) {  			num = decimal.MaxValue;  			//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  			//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  		}  	}  	#endregion  	var token = Token (DTokens.Literal' x' y' Col - x/*stringValue.Length*/' num' /* stringValue'*/HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar' subFmt);  	if (token != null)  		token.next = nextToken;  	return token;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked {  	// prevent exception when ReaderPeek() = -1 is cast to char  	int y = Line;  	sb.Length = 0;  	sb.Append (ch);  	//string prefix = null;  	string expSuffix = "";  	string suffix = null;  	int exponent = 0;  	bool HasDot = false;  	LiteralSubformat subFmt = 0;  	bool isFloat = false;  	bool isImaginary = false;  	//bool isUnsigned = false;  	//bool isLong = false;  	int NumBase = 0;  	// Set it to 0 initially - it'll be set to another value later for sure  	char peek = (char)ReaderPeek ();  	// At first' check pre-comma values  	if (ch == '0') {  		if (peek == 'x' || peek == 'X')// Hex values  		 {  			//prefix = "0x";  			ReaderRead ();  			// skip 'x'  			sb.Length = 0;  			// Remove '0' from 0x prefix from the stringvalue  			NumBase = 16;  			peek = (char)ReaderPeek ();  			while (IsHex (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} else if (peek == 'b' || peek == 'B')// Bin values  		 {  			//prefix = "0b";  			ReaderRead ();  			// skip 'b'  			sb.Length = 0;  			NumBase = 2;  			peek = (char)ReaderPeek ();  			while (IsBin (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} // Oct values have been removed in dmd 2.053  		/*else if (IsOct(peek) || peek == '_') // Oct values 					{ 						NumBase = 8; 						prefix = "0"; 						sb.Length = 0;  						while (IsOct(peek) || peek == '_') 						{ 							if (peek != '_') 								sb.Append((char)ReaderRead()); 							else ReaderRead(); 							peek = (char)ReaderPeek(); 						} 					}*/else  			NumBase = 10;  		// Enables pre-comma parsing .. in this case we'd 000 literals or something like that  	}  	if (NumBase == 10 || (ch != '.' && NumBase == 0))// Only allow further digits for 10-based integers' not for binary or hex values  	 {  		NumBase = 10;  		while (IsDigit (peek) || peek == '_') {  			if (peek != '_')  				sb.Append ((char)ReaderRead ());  			else  				ReaderRead ();  			peek = (char)ReaderPeek ();  		}  	}  	#region Read digits that occur after a comma  	DToken nextToken = null;  	// if we accidently read a 'dot'  	bool AllowSuffixes = true;  	if ((NumBase == 0 && ch == '.') || peek == '.') {  		if (ch != '.')  			ReaderRead ();  		else {  			NumBase = 10;  			sb.Length = 0;  			sb.Append ('0');  		}  		peek = (char)ReaderPeek ();  		if (!IsLegalDigit (peek' NumBase)) {  			if (peek == '.') {  				ReaderRead ();  				nextToken = Token (DTokens.DoubleDot' Col - 1' Line' 2);  			} else if (IsIdentifierPart (peek))  				nextToken = Token (DTokens.Dot' Col - 1' Line' 1);  			AllowSuffixes = false;  		} else {  			HasDot = true;  			sb.Append ('.');  			do {  				if (peek == '_')  					ReaderRead ();  				else  					sb.Append ((char)ReaderRead ());  				peek = (char)ReaderPeek ();  			} while (IsLegalDigit (peek' NumBase));  		}  	}  	#endregion  	#region Exponents  	if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E')) {  		// read exponent  		string suff = peek.ToString ();  		ReaderRead ();  		peek = (char)ReaderPeek ();  		if (peek == '-' || peek == '+')  			expSuffix += (char)ReaderRead ();  		peek = (char)ReaderPeek ();  		while ((peek >= '0' && peek <= '9') || peek == '_') {  			// read exponent value  			if (peek == '_')  				ReaderRead ();  			else  				expSuffix += (char)ReaderRead ();  			peek = (char)ReaderPeek ();  		}  		// Exponents just can be decimal integers  		int.TryParse (expSuffix' out exponent);  		expSuffix = suff + expSuffix;  		peek = (char)ReaderPeek ();  	}  	#endregion  	#region Suffixes  	if (!HasDot) {  		unsigned:  		if (peek == 'u' || peek == 'U') {  			ReaderRead ();  			suffix += "u";  			subFmt |= LiteralSubformat.Unsigned;  			//isUnsigned = true;  			peek = (char)ReaderPeek ();  		}  		if (peek == 'L') {  			subFmt |= LiteralSubformat.Long;  			ReaderRead ();  			suffix += "L";  			//isLong = true;  			peek = (char)ReaderPeek ();  			if (!subFmt.HasFlag (LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  				goto unsigned;  		}  	}  	if (HasDot || AllowSuffixes) {  		if (peek == 'f' || peek == 'F') {  			// float value  			ReaderRead ();  			suffix += "f";  			isFloat = true;  			subFmt |= LiteralSubformat.Float;  			peek = (char)ReaderPeek ();  		} else if (peek == 'L') {  			// real value  			ReaderRead ();  			//isLong = true;  			suffix += 'L';  			subFmt |= LiteralSubformat.Real;  			peek = (char)ReaderPeek ();  		}  	}  	if (peek == 'i') {  		// imaginary value  		ReaderRead ();  		suffix += "i";  		subFmt |= LiteralSubformat.Imaginary;  		isImaginary = true;  	}  	#endregion  	#region Parse the digit string  	var num = ParseFloatValue (sb' NumBase);  	if (exponent != 0) {  		try {  			num *= (decimal)Math.Pow (NumBase == 16 ? 2 : 10' exponent);  		} catch (OverflowException) {  			num = decimal.MaxValue;  			//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  			//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  		}  	}  	#endregion  	var token = Token (DTokens.Literal' x' y' Col - x/*stringValue.Length*/' num' /* stringValue'*/HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar' subFmt);  	if (token != null)  		token.next = nextToken;  	return token;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked {  	// prevent exception when ReaderPeek() = -1 is cast to char  	int y = Line;  	sb.Length = 0;  	sb.Append (ch);  	//string prefix = null;  	string expSuffix = "";  	string suffix = null;  	int exponent = 0;  	bool HasDot = false;  	LiteralSubformat subFmt = 0;  	bool isFloat = false;  	bool isImaginary = false;  	//bool isUnsigned = false;  	//bool isLong = false;  	int NumBase = 0;  	// Set it to 0 initially - it'll be set to another value later for sure  	char peek = (char)ReaderPeek ();  	// At first' check pre-comma values  	if (ch == '0') {  		if (peek == 'x' || peek == 'X')// Hex values  		 {  			//prefix = "0x";  			ReaderRead ();  			// skip 'x'  			sb.Length = 0;  			// Remove '0' from 0x prefix from the stringvalue  			NumBase = 16;  			peek = (char)ReaderPeek ();  			while (IsHex (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} else if (peek == 'b' || peek == 'B')// Bin values  		 {  			//prefix = "0b";  			ReaderRead ();  			// skip 'b'  			sb.Length = 0;  			NumBase = 2;  			peek = (char)ReaderPeek ();  			while (IsBin (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} // Oct values have been removed in dmd 2.053  		/*else if (IsOct(peek) || peek == '_') // Oct values 					{ 						NumBase = 8; 						prefix = "0"; 						sb.Length = 0;  						while (IsOct(peek) || peek == '_') 						{ 							if (peek != '_') 								sb.Append((char)ReaderRead()); 							else ReaderRead(); 							peek = (char)ReaderPeek(); 						} 					}*/else  			NumBase = 10;  		// Enables pre-comma parsing .. in this case we'd 000 literals or something like that  	}  	if (NumBase == 10 || (ch != '.' && NumBase == 0))// Only allow further digits for 10-based integers' not for binary or hex values  	 {  		NumBase = 10;  		while (IsDigit (peek) || peek == '_') {  			if (peek != '_')  				sb.Append ((char)ReaderRead ());  			else  				ReaderRead ();  			peek = (char)ReaderPeek ();  		}  	}  	#region Read digits that occur after a comma  	DToken nextToken = null;  	// if we accidently read a 'dot'  	bool AllowSuffixes = true;  	if ((NumBase == 0 && ch == '.') || peek == '.') {  		if (ch != '.')  			ReaderRead ();  		else {  			NumBase = 10;  			sb.Length = 0;  			sb.Append ('0');  		}  		peek = (char)ReaderPeek ();  		if (!IsLegalDigit (peek' NumBase)) {  			if (peek == '.') {  				ReaderRead ();  				nextToken = Token (DTokens.DoubleDot' Col - 1' Line' 2);  			} else if (IsIdentifierPart (peek))  				nextToken = Token (DTokens.Dot' Col - 1' Line' 1);  			AllowSuffixes = false;  		} else {  			HasDot = true;  			sb.Append ('.');  			do {  				if (peek == '_')  					ReaderRead ();  				else  					sb.Append ((char)ReaderRead ());  				peek = (char)ReaderPeek ();  			} while (IsLegalDigit (peek' NumBase));  		}  	}  	#endregion  	#region Exponents  	if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E')) {  		// read exponent  		string suff = peek.ToString ();  		ReaderRead ();  		peek = (char)ReaderPeek ();  		if (peek == '-' || peek == '+')  			expSuffix += (char)ReaderRead ();  		peek = (char)ReaderPeek ();  		while ((peek >= '0' && peek <= '9') || peek == '_') {  			// read exponent value  			if (peek == '_')  				ReaderRead ();  			else  				expSuffix += (char)ReaderRead ();  			peek = (char)ReaderPeek ();  		}  		// Exponents just can be decimal integers  		int.TryParse (expSuffix' out exponent);  		expSuffix = suff + expSuffix;  		peek = (char)ReaderPeek ();  	}  	#endregion  	#region Suffixes  	if (!HasDot) {  		unsigned:  		if (peek == 'u' || peek == 'U') {  			ReaderRead ();  			suffix += "u";  			subFmt |= LiteralSubformat.Unsigned;  			//isUnsigned = true;  			peek = (char)ReaderPeek ();  		}  		if (peek == 'L') {  			subFmt |= LiteralSubformat.Long;  			ReaderRead ();  			suffix += "L";  			//isLong = true;  			peek = (char)ReaderPeek ();  			if (!subFmt.HasFlag (LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  				goto unsigned;  		}  	}  	if (HasDot || AllowSuffixes) {  		if (peek == 'f' || peek == 'F') {  			// float value  			ReaderRead ();  			suffix += "f";  			isFloat = true;  			subFmt |= LiteralSubformat.Float;  			peek = (char)ReaderPeek ();  		} else if (peek == 'L') {  			// real value  			ReaderRead ();  			//isLong = true;  			suffix += 'L';  			subFmt |= LiteralSubformat.Real;  			peek = (char)ReaderPeek ();  		}  	}  	if (peek == 'i') {  		// imaginary value  		ReaderRead ();  		suffix += "i";  		subFmt |= LiteralSubformat.Imaginary;  		isImaginary = true;  	}  	#endregion  	#region Parse the digit string  	var num = ParseFloatValue (sb' NumBase);  	if (exponent != 0) {  		try {  			num *= (decimal)Math.Pow (NumBase == 16 ? 2 : 10' exponent);  		} catch (OverflowException) {  			num = decimal.MaxValue;  			//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  			//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  		}  	}  	#endregion  	var token = Token (DTokens.Literal' x' y' Col - x/*stringValue.Length*/' num' /* stringValue'*/HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar' subFmt);  	if (token != null)  		token.next = nextToken;  	return token;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked {  	// prevent exception when ReaderPeek() = -1 is cast to char  	int y = Line;  	sb.Length = 0;  	sb.Append (ch);  	//string prefix = null;  	string expSuffix = "";  	string suffix = null;  	int exponent = 0;  	bool HasDot = false;  	LiteralSubformat subFmt = 0;  	bool isFloat = false;  	bool isImaginary = false;  	//bool isUnsigned = false;  	//bool isLong = false;  	int NumBase = 0;  	// Set it to 0 initially - it'll be set to another value later for sure  	char peek = (char)ReaderPeek ();  	// At first' check pre-comma values  	if (ch == '0') {  		if (peek == 'x' || peek == 'X')// Hex values  		 {  			//prefix = "0x";  			ReaderRead ();  			// skip 'x'  			sb.Length = 0;  			// Remove '0' from 0x prefix from the stringvalue  			NumBase = 16;  			peek = (char)ReaderPeek ();  			while (IsHex (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} else if (peek == 'b' || peek == 'B')// Bin values  		 {  			//prefix = "0b";  			ReaderRead ();  			// skip 'b'  			sb.Length = 0;  			NumBase = 2;  			peek = (char)ReaderPeek ();  			while (IsBin (peek) || peek == '_') {  				if (peek != '_')  					sb.Append ((char)ReaderRead ());  				else  					ReaderRead ();  				peek = (char)ReaderPeek ();  			}  		} // Oct values have been removed in dmd 2.053  		/*else if (IsOct(peek) || peek == '_') // Oct values 					{ 						NumBase = 8; 						prefix = "0"; 						sb.Length = 0;  						while (IsOct(peek) || peek == '_') 						{ 							if (peek != '_') 								sb.Append((char)ReaderRead()); 							else ReaderRead(); 							peek = (char)ReaderPeek(); 						} 					}*/else  			NumBase = 10;  		// Enables pre-comma parsing .. in this case we'd 000 literals or something like that  	}  	if (NumBase == 10 || (ch != '.' && NumBase == 0))// Only allow further digits for 10-based integers' not for binary or hex values  	 {  		NumBase = 10;  		while (IsDigit (peek) || peek == '_') {  			if (peek != '_')  				sb.Append ((char)ReaderRead ());  			else  				ReaderRead ();  			peek = (char)ReaderPeek ();  		}  	}  	#region Read digits that occur after a comma  	DToken nextToken = null;  	// if we accidently read a 'dot'  	bool AllowSuffixes = true;  	if ((NumBase == 0 && ch == '.') || peek == '.') {  		if (ch != '.')  			ReaderRead ();  		else {  			NumBase = 10;  			sb.Length = 0;  			sb.Append ('0');  		}  		peek = (char)ReaderPeek ();  		if (!IsLegalDigit (peek' NumBase)) {  			if (peek == '.') {  				ReaderRead ();  				nextToken = Token (DTokens.DoubleDot' Col - 1' Line' 2);  			} else if (IsIdentifierPart (peek))  				nextToken = Token (DTokens.Dot' Col - 1' Line' 1);  			AllowSuffixes = false;  		} else {  			HasDot = true;  			sb.Append ('.');  			do {  				if (peek == '_')  					ReaderRead ();  				else  					sb.Append ((char)ReaderRead ());  				peek = (char)ReaderPeek ();  			} while (IsLegalDigit (peek' NumBase));  		}  	}  	#endregion  	#region Exponents  	if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E')) {  		// read exponent  		string suff = peek.ToString ();  		ReaderRead ();  		peek = (char)ReaderPeek ();  		if (peek == '-' || peek == '+')  			expSuffix += (char)ReaderRead ();  		peek = (char)ReaderPeek ();  		while ((peek >= '0' && peek <= '9') || peek == '_') {  			// read exponent value  			if (peek == '_')  				ReaderRead ();  			else  				expSuffix += (char)ReaderRead ();  			peek = (char)ReaderPeek ();  		}  		// Exponents just can be decimal integers  		int.TryParse (expSuffix' out exponent);  		expSuffix = suff + expSuffix;  		peek = (char)ReaderPeek ();  	}  	#endregion  	#region Suffixes  	if (!HasDot) {  		unsigned:  		if (peek == 'u' || peek == 'U') {  			ReaderRead ();  			suffix += "u";  			subFmt |= LiteralSubformat.Unsigned;  			//isUnsigned = true;  			peek = (char)ReaderPeek ();  		}  		if (peek == 'L') {  			subFmt |= LiteralSubformat.Long;  			ReaderRead ();  			suffix += "L";  			//isLong = true;  			peek = (char)ReaderPeek ();  			if (!subFmt.HasFlag (LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  				goto unsigned;  		}  	}  	if (HasDot || AllowSuffixes) {  		if (peek == 'f' || peek == 'F') {  			// float value  			ReaderRead ();  			suffix += "f";  			isFloat = true;  			subFmt |= LiteralSubformat.Float;  			peek = (char)ReaderPeek ();  		} else if (peek == 'L') {  			// real value  			ReaderRead ();  			//isLong = true;  			suffix += 'L';  			subFmt |= LiteralSubformat.Real;  			peek = (char)ReaderPeek ();  		}  	}  	if (peek == 'i') {  		// imaginary value  		ReaderRead ();  		suffix += "i";  		subFmt |= LiteralSubformat.Imaginary;  		isImaginary = true;  	}  	#endregion  	#region Parse the digit string  	var num = ParseFloatValue (sb' NumBase);  	if (exponent != 0) {  		try {  			num *= (decimal)Math.Pow (NumBase == 16 ? 2 : 10' exponent);  		} catch (OverflowException) {  			num = decimal.MaxValue;  			//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  			//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  		}  	}  	#endregion  	var token = Token (DTokens.Literal' x' y' Col - x/*stringValue.Length*/' num' /* stringValue'*/HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar' subFmt);  	if (token != null)  		token.next = nextToken;  	return token;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: if (ch == '0') {  	if (peek == 'x' || peek == 'X')// Hex values  	 {  		//prefix = "0x";  		ReaderRead ();  		// skip 'x'  		sb.Length = 0;  		// Remove '0' from 0x prefix from the stringvalue  		NumBase = 16;  		peek = (char)ReaderPeek ();  		while (IsHex (peek) || peek == '_') {  			if (peek != '_')  				sb.Append ((char)ReaderRead ());  			else  				ReaderRead ();  			peek = (char)ReaderPeek ();  		}  	} else if (peek == 'b' || peek == 'B')// Bin values  	 {  		//prefix = "0b";  		ReaderRead ();  		// skip 'b'  		sb.Length = 0;  		NumBase = 2;  		peek = (char)ReaderPeek ();  		while (IsBin (peek) || peek == '_') {  			if (peek != '_')  				sb.Append ((char)ReaderRead ());  			else  				ReaderRead ();  			peek = (char)ReaderPeek ();  		}  	} // Oct values have been removed in dmd 2.053  	/*else if (IsOct(peek) || peek == '_') // Oct values 					{ 						NumBase = 8; 						prefix = "0"; 						sb.Length = 0;  						while (IsOct(peek) || peek == '_') 						{ 							if (peek != '_') 								sb.Append((char)ReaderRead()); 							else ReaderRead(); 							peek = (char)ReaderPeek(); 						} 					}*/else  		NumBase = 10;  	// Enables pre-comma parsing .. in this case we'd 000 literals or something like that  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: if (ch == '0') {  	if (peek == 'x' || peek == 'X')// Hex values  	 {  		//prefix = "0x";  		ReaderRead ();  		// skip 'x'  		sb.Length = 0;  		// Remove '0' from 0x prefix from the stringvalue  		NumBase = 16;  		peek = (char)ReaderPeek ();  		while (IsHex (peek) || peek == '_') {  			if (peek != '_')  				sb.Append ((char)ReaderRead ());  			else  				ReaderRead ();  			peek = (char)ReaderPeek ();  		}  	} else if (peek == 'b' || peek == 'B')// Bin values  	 {  		//prefix = "0b";  		ReaderRead ();  		// skip 'b'  		sb.Length = 0;  		NumBase = 2;  		peek = (char)ReaderPeek ();  		while (IsBin (peek) || peek == '_') {  			if (peek != '_')  				sb.Append ((char)ReaderRead ());  			else  				ReaderRead ();  			peek = (char)ReaderPeek ();  		}  	} // Oct values have been removed in dmd 2.053  	/*else if (IsOct(peek) || peek == '_') // Oct values 					{ 						NumBase = 8; 						prefix = "0"; 						sb.Length = 0;  						while (IsOct(peek) || peek == '_') 						{ 							if (peek != '_') 								sb.Append((char)ReaderRead()); 							else ReaderRead(); 							peek = (char)ReaderPeek(); 						} 					}*/else  		NumBase = 10;  	// Enables pre-comma parsing .. in this case we'd 000 literals or something like that  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: if (ch == '0') {  	if (peek == 'x' || peek == 'X')// Hex values  	 {  		//prefix = "0x";  		ReaderRead ();  		// skip 'x'  		sb.Length = 0;  		// Remove '0' from 0x prefix from the stringvalue  		NumBase = 16;  		peek = (char)ReaderPeek ();  		while (IsHex (peek) || peek == '_') {  			if (peek != '_')  				sb.Append ((char)ReaderRead ());  			else  				ReaderRead ();  			peek = (char)ReaderPeek ();  		}  	} else if (peek == 'b' || peek == 'B')// Bin values  	 {  		//prefix = "0b";  		ReaderRead ();  		// skip 'b'  		sb.Length = 0;  		NumBase = 2;  		peek = (char)ReaderPeek ();  		while (IsBin (peek) || peek == '_') {  			if (peek != '_')  				sb.Append ((char)ReaderRead ());  			else  				ReaderRead ();  			peek = (char)ReaderPeek ();  		}  	} // Oct values have been removed in dmd 2.053  	/*else if (IsOct(peek) || peek == '_') // Oct values 					{ 						NumBase = 8; 						prefix = "0"; 						sb.Length = 0;  						while (IsOct(peek) || peek == '_') 						{ 							if (peek != '_') 								sb.Append((char)ReaderRead()); 							else ReaderRead(); 							peek = (char)ReaderPeek(); 						} 					}*/else  		NumBase = 10;  	// Enables pre-comma parsing .. in this case we'd 000 literals or something like that  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: if (peek == 'x' || peek == 'X')// Hex values   {  	//prefix = "0x";  	ReaderRead ();  	// skip 'x'  	sb.Length = 0;  	// Remove '0' from 0x prefix from the stringvalue  	NumBase = 16;  	peek = (char)ReaderPeek ();  	while (IsHex (peek) || peek == '_') {  		if (peek != '_')  			sb.Append ((char)ReaderRead ());  		else  			ReaderRead ();  		peek = (char)ReaderPeek ();  	}  } else if (peek == 'b' || peek == 'B')// Bin values   {  	//prefix = "0b";  	ReaderRead ();  	// skip 'b'  	sb.Length = 0;  	NumBase = 2;  	peek = (char)ReaderPeek ();  	while (IsBin (peek) || peek == '_') {  		if (peek != '_')  			sb.Append ((char)ReaderRead ());  		else  			ReaderRead ();  		peek = (char)ReaderPeek ();  	}  } // Oct values have been removed in dmd 2.053  /*else if (IsOct(peek) || peek == '_') // Oct values 					{ 						NumBase = 8; 						prefix = "0"; 						sb.Length = 0;  						while (IsOct(peek) || peek == '_') 						{ 							if (peek != '_') 								sb.Append((char)ReaderRead()); 							else ReaderRead(); 							peek = (char)ReaderPeek(); 						} 					}*/else  	NumBase = 10;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: if (peek == 'x' || peek == 'X')// Hex values   {  	//prefix = "0x";  	ReaderRead ();  	// skip 'x'  	sb.Length = 0;  	// Remove '0' from 0x prefix from the stringvalue  	NumBase = 16;  	peek = (char)ReaderPeek ();  	while (IsHex (peek) || peek == '_') {  		if (peek != '_')  			sb.Append ((char)ReaderRead ());  		else  			ReaderRead ();  		peek = (char)ReaderPeek ();  	}  } else if (peek == 'b' || peek == 'B')// Bin values   {  	//prefix = "0b";  	ReaderRead ();  	// skip 'b'  	sb.Length = 0;  	NumBase = 2;  	peek = (char)ReaderPeek ();  	while (IsBin (peek) || peek == '_') {  		if (peek != '_')  			sb.Append ((char)ReaderRead ());  		else  			ReaderRead ();  		peek = (char)ReaderPeek ();  	}  } // Oct values have been removed in dmd 2.053  /*else if (IsOct(peek) || peek == '_') // Oct values 					{ 						NumBase = 8; 						prefix = "0"; 						sb.Length = 0;  						while (IsOct(peek) || peek == '_') 						{ 							if (peek != '_') 								sb.Append((char)ReaderRead()); 							else ReaderRead(); 							peek = (char)ReaderPeek(); 						} 					}*/else  	NumBase = 10;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: if (peek == 'x' || peek == 'X')// Hex values   {  	//prefix = "0x";  	ReaderRead ();  	// skip 'x'  	sb.Length = 0;  	// Remove '0' from 0x prefix from the stringvalue  	NumBase = 16;  	peek = (char)ReaderPeek ();  	while (IsHex (peek) || peek == '_') {  		if (peek != '_')  			sb.Append ((char)ReaderRead ());  		else  			ReaderRead ();  		peek = (char)ReaderPeek ();  	}  } else if (peek == 'b' || peek == 'B')// Bin values   {  	//prefix = "0b";  	ReaderRead ();  	// skip 'b'  	sb.Length = 0;  	NumBase = 2;  	peek = (char)ReaderPeek ();  	while (IsBin (peek) || peek == '_') {  		if (peek != '_')  			sb.Append ((char)ReaderRead ());  		else  			ReaderRead ();  		peek = (char)ReaderPeek ();  	}  } // Oct values have been removed in dmd 2.053  /*else if (IsOct(peek) || peek == '_') // Oct values 					{ 						NumBase = 8; 						prefix = "0"; 						sb.Length = 0;  						while (IsOct(peek) || peek == '_') 						{ 							if (peek != '_') 								sb.Append((char)ReaderRead()); 							else ReaderRead(); 							peek = (char)ReaderPeek(); 						} 					}*/else  	NumBase = 10;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: NumBase = 16;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: if (peek == 'b' || peek == 'B')// Bin values   {  	//prefix = "0b";  	ReaderRead ();  	// skip 'b'  	sb.Length = 0;  	NumBase = 2;  	peek = (char)ReaderPeek ();  	while (IsBin (peek) || peek == '_') {  		if (peek != '_')  			sb.Append ((char)ReaderRead ());  		else  			ReaderRead ();  		peek = (char)ReaderPeek ();  	}  } // Oct values have been removed in dmd 2.053  /*else if (IsOct(peek) || peek == '_') // Oct values 					{ 						NumBase = 8; 						prefix = "0"; 						sb.Length = 0;  						while (IsOct(peek) || peek == '_') 						{ 							if (peek != '_') 								sb.Append((char)ReaderRead()); 							else ReaderRead(); 							peek = (char)ReaderPeek(); 						} 					}*/else  	NumBase = 10;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: if (peek == 'b' || peek == 'B')// Bin values   {  	//prefix = "0b";  	ReaderRead ();  	// skip 'b'  	sb.Length = 0;  	NumBase = 2;  	peek = (char)ReaderPeek ();  	while (IsBin (peek) || peek == '_') {  		if (peek != '_')  			sb.Append ((char)ReaderRead ());  		else  			ReaderRead ();  		peek = (char)ReaderPeek ();  	}  } // Oct values have been removed in dmd 2.053  /*else if (IsOct(peek) || peek == '_') // Oct values 					{ 						NumBase = 8; 						prefix = "0"; 						sb.Length = 0;  						while (IsOct(peek) || peek == '_') 						{ 							if (peek != '_') 								sb.Append((char)ReaderRead()); 							else ReaderRead(); 							peek = (char)ReaderPeek(); 						} 					}*/else  	NumBase = 10;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: NumBase = 2;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: NumBase = 10;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: if (NumBase == 10 || (ch != '.' && NumBase == 0))// Only allow further digits for 10-based integers' not for binary or hex values   {  	NumBase = 10;  	while (IsDigit (peek) || peek == '_') {  		if (peek != '_')  			sb.Append ((char)ReaderRead ());  		else  			ReaderRead ();  		peek = (char)ReaderPeek ();  	}  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: if (NumBase == 10 || (ch != '.' && NumBase == 0))// Only allow further digits for 10-based integers' not for binary or hex values   {  	NumBase = 10;  	while (IsDigit (peek) || peek == '_') {  		if (peek != '_')  			sb.Append ((char)ReaderRead ());  		else  			ReaderRead ();  		peek = (char)ReaderPeek ();  	}  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: NumBase = 10;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: if ((NumBase == 0 && ch == '.') || peek == '.') {  	if (ch != '.')  		ReaderRead ();  	else {  		NumBase = 10;  		sb.Length = 0;  		sb.Append ('0');  	}  	peek = (char)ReaderPeek ();  	if (!IsLegalDigit (peek' NumBase)) {  		if (peek == '.') {  			ReaderRead ();  			nextToken = Token (DTokens.DoubleDot' Col - 1' Line' 2);  		} else if (IsIdentifierPart (peek))  			nextToken = Token (DTokens.Dot' Col - 1' Line' 1);  		AllowSuffixes = false;  	} else {  		HasDot = true;  		sb.Append ('.');  		do {  			if (peek == '_')  				ReaderRead ();  			else  				sb.Append ((char)ReaderRead ());  			peek = (char)ReaderPeek ();  		} while (IsLegalDigit (peek' NumBase));  	}  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: if ((NumBase == 0 && ch == '.') || peek == '.') {  	if (ch != '.')  		ReaderRead ();  	else {  		NumBase = 10;  		sb.Length = 0;  		sb.Append ('0');  	}  	peek = (char)ReaderPeek ();  	if (!IsLegalDigit (peek' NumBase)) {  		if (peek == '.') {  			ReaderRead ();  			nextToken = Token (DTokens.DoubleDot' Col - 1' Line' 2);  		} else if (IsIdentifierPart (peek))  			nextToken = Token (DTokens.Dot' Col - 1' Line' 1);  		AllowSuffixes = false;  	} else {  		HasDot = true;  		sb.Append ('.');  		do {  			if (peek == '_')  				ReaderRead ();  			else  				sb.Append ((char)ReaderRead ());  			peek = (char)ReaderPeek ();  		} while (IsLegalDigit (peek' NumBase));  	}  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: if (ch != '.')  	ReaderRead ();  else {  	NumBase = 10;  	sb.Length = 0;  	sb.Append ('0');  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: NumBase = 10;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: if (!IsLegalDigit (peek' NumBase)) {  	if (peek == '.') {  		ReaderRead ();  		nextToken = Token (DTokens.DoubleDot' Col - 1' Line' 2);  	} else if (IsIdentifierPart (peek))  		nextToken = Token (DTokens.Dot' Col - 1' Line' 1);  	AllowSuffixes = false;  } else {  	HasDot = true;  	sb.Append ('.');  	do {  		if (peek == '_')  			ReaderRead ();  		else  			sb.Append ((char)ReaderRead ());  		peek = (char)ReaderPeek ();  	} while (IsLegalDigit (peek' NumBase));  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: if (peek == '.') {  	ReaderRead ();  	nextToken = Token (DTokens.DoubleDot' Col - 1' Line' 2);  } else if (IsIdentifierPart (peek))  	nextToken = Token (DTokens.Dot' Col - 1' Line' 1);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: nextToken = Token (DTokens.DoubleDot' Col - 1' Line' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E')) {  	// read exponent  	string suff = peek.ToString ();  	ReaderRead ();  	peek = (char)ReaderPeek ();  	if (peek == '-' || peek == '+')  		expSuffix += (char)ReaderRead ();  	peek = (char)ReaderPeek ();  	while ((peek >= '0' && peek <= '9') || peek == '_') {  		// read exponent value  		if (peek == '_')  			ReaderRead ();  		else  			expSuffix += (char)ReaderRead ();  		peek = (char)ReaderPeek ();  	}  	// Exponents just can be decimal integers  	int.TryParse (expSuffix' out exponent);  	expSuffix = suff + expSuffix;  	peek = (char)ReaderPeek ();  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: if (exponent != 0) {  	try {  		num *= (decimal)Math.Pow (NumBase == 16 ? 2 : 10' exponent);  	} catch (OverflowException) {  		num = decimal.MaxValue;  		//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  		//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  	}  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: if (exponent != 0) {  	try {  		num *= (decimal)Math.Pow (NumBase == 16 ? 2 : 10' exponent);  	} catch (OverflowException) {  		num = decimal.MaxValue;  		//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  		//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  	}  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: if (exponent != 0) {  	try {  		num *= (decimal)Math.Pow (NumBase == 16 ? 2 : 10' exponent);  	} catch (OverflowException) {  		num = decimal.MaxValue;  		//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  		//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  	}  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: try {  	num *= (decimal)Math.Pow (NumBase == 16 ? 2 : 10' exponent);  } catch (OverflowException) {  	num = decimal.MaxValue;  	//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  	//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: try {  	num *= (decimal)Math.Pow (NumBase == 16 ? 2 : 10' exponent);  } catch (OverflowException) {  	num = decimal.MaxValue;  	//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  	//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: try {  	num *= (decimal)Math.Pow (NumBase == 16 ? 2 : 10' exponent);  } catch (OverflowException) {  	num = decimal.MaxValue;  	//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  	//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: num *= (decimal)Math.Pow (NumBase == 16 ? 2 : 10' exponent);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: num *= (decimal)Math.Pow (NumBase == 16 ? 2 : 10' exponent);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: num *= (decimal)Math.Pow (NumBase == 16 ? 2 : 10' exponent);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: switch (c) {  case '\'':  	ch = '\'';  	break;  case '\"':  	ch = '\"';  	break;  case '?':  	ch = '?';  	return "\\?";  // Literal question mark  case '\\':  	ch = '\\';  	break;  /*case '0': 					ch = '\0'; 					break;*/case 'a':  	ch = '\a';  	// Bell (alert)  	break;  case 'b':  	ch = '\b';  	// Backspace  	break;  case 'f':  	ch = '\f';  	// Formfeed  	break;  case 'n':  	ch = '\n';  	break;  case 'r':  	ch = '\r';  	break;  case 't':  	ch = '\t';  	break;  case 'v':  	ch = '\v';  	// Vertical tab  	break;  case 'u':  case 'x':  	// 16 bit unicode character  	c = (char)ReaderRead ();  	number = GetHexNumber (c);  	escapeSequenceBuffer [curPos++] = c;  	if (number < 0) {  		OnError (Line' Col - 1' String.Format ("Invalid char in literal : {0}"' c));  	}  	for (int i = 0; i < 3; ++i) {  		if (IsHex ((char)ReaderPeek ())) {  			c = (char)ReaderRead ();  			int idx = GetHexNumber (c);  			escapeSequenceBuffer [curPos++] = c;  			number = 16 * number + idx;  		} else {  			break;  		}  	}  	ch = (char)number;  	break;  case 'U':  	// 32 bit unicode character  	number = 0;  	for (int i = 0; i < 8; ++i) {  		if (IsHex ((char)ReaderPeek ())) {  			c = (char)ReaderRead ();  			int idx = GetHexNumber (c);  			escapeSequenceBuffer [curPos++] = c;  			number = 16 * number + idx;  		} else {  			OnError (Line' Col - 1' String.Format ("Invalid char in literal : {0}"' (char)ReaderPeek ()));  			break;  		}  	}  	if (number > 0xffff) {  		ch = '\0';  		surrogatePair = char.ConvertFromUtf32 (number);  	} else {  		ch = (char)number;  	}  	break;  // NamedCharacterEntities  case '&':  	string charEntity = "";  	while (true) {  		nextChar = ReaderRead ();  		if (nextChar < 0) {  			OnError (Line' Col - 1' "EOF reached within named char entity");  			ch = '\0';  			return string.Empty;  		}  		c = (char)nextChar;  		if (c == ';')  			break;  		if (IsIdentifierPart (c))  			charEntity += c;  		else {  			OnError (Line' Col - 1' "Unexpected character found in named char entity: " + c);  			ch = '\0';  			return string.Empty;  		}  	}  	if (string.IsNullOrEmpty (charEntity)) {  		OnError (Line' Col - 1' "Empty named character entities not allowed");  		ch = '\0';  		return string.Empty;  	}  	//TODO: Performance improvement  	//var ret=System.Web.HttpUtility.HtmlDecode("&"+charEntity+";");  	ch = '#';  	//ret[0];  	return "&" + charEntity + ";";  default:  	// Max 3 following octal digits  	if (IsOct (c)) {  		// Parse+Convert oct to dec integer  		int oct = GetHexNumber (c);  		for (int i = 0; i < 2; ++i) {  			if (IsOct ((char)ReaderPeek ())) {  				c = (char)ReaderRead ();  				escapeSequenceBuffer [curPos++] = c;  				int idx = GetHexNumber (c);  				oct = 8 * oct + idx;  			} else  				break;  		}  		// Convert integer to character  		if (oct > 0xffff) {  			ch = '\0';  			surrogatePair = char.ConvertFromUtf32 (oct);  		} else {  			ch = (char)oct;  		}  	} else {  		OnError (Line' Col' String.Format ("Unexpected escape sequence : {0}"' c));  		ch = '\0';  	}  	break;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: switch (c) {  case '\'':  	ch = '\'';  	break;  case '\"':  	ch = '\"';  	break;  case '?':  	ch = '?';  	return "\\?";  // Literal question mark  case '\\':  	ch = '\\';  	break;  /*case '0': 					ch = '\0'; 					break;*/case 'a':  	ch = '\a';  	// Bell (alert)  	break;  case 'b':  	ch = '\b';  	// Backspace  	break;  case 'f':  	ch = '\f';  	// Formfeed  	break;  case 'n':  	ch = '\n';  	break;  case 'r':  	ch = '\r';  	break;  case 't':  	ch = '\t';  	break;  case 'v':  	ch = '\v';  	// Vertical tab  	break;  case 'u':  case 'x':  	// 16 bit unicode character  	c = (char)ReaderRead ();  	number = GetHexNumber (c);  	escapeSequenceBuffer [curPos++] = c;  	if (number < 0) {  		OnError (Line' Col - 1' String.Format ("Invalid char in literal : {0}"' c));  	}  	for (int i = 0; i < 3; ++i) {  		if (IsHex ((char)ReaderPeek ())) {  			c = (char)ReaderRead ();  			int idx = GetHexNumber (c);  			escapeSequenceBuffer [curPos++] = c;  			number = 16 * number + idx;  		} else {  			break;  		}  	}  	ch = (char)number;  	break;  case 'U':  	// 32 bit unicode character  	number = 0;  	for (int i = 0; i < 8; ++i) {  		if (IsHex ((char)ReaderPeek ())) {  			c = (char)ReaderRead ();  			int idx = GetHexNumber (c);  			escapeSequenceBuffer [curPos++] = c;  			number = 16 * number + idx;  		} else {  			OnError (Line' Col - 1' String.Format ("Invalid char in literal : {0}"' (char)ReaderPeek ()));  			break;  		}  	}  	if (number > 0xffff) {  		ch = '\0';  		surrogatePair = char.ConvertFromUtf32 (number);  	} else {  		ch = (char)number;  	}  	break;  // NamedCharacterEntities  case '&':  	string charEntity = "";  	while (true) {  		nextChar = ReaderRead ();  		if (nextChar < 0) {  			OnError (Line' Col - 1' "EOF reached within named char entity");  			ch = '\0';  			return string.Empty;  		}  		c = (char)nextChar;  		if (c == ';')  			break;  		if (IsIdentifierPart (c))  			charEntity += c;  		else {  			OnError (Line' Col - 1' "Unexpected character found in named char entity: " + c);  			ch = '\0';  			return string.Empty;  		}  	}  	if (string.IsNullOrEmpty (charEntity)) {  		OnError (Line' Col - 1' "Empty named character entities not allowed");  		ch = '\0';  		return string.Empty;  	}  	//TODO: Performance improvement  	//var ret=System.Web.HttpUtility.HtmlDecode("&"+charEntity+";");  	ch = '#';  	//ret[0];  	return "&" + charEntity + ";";  default:  	// Max 3 following octal digits  	if (IsOct (c)) {  		// Parse+Convert oct to dec integer  		int oct = GetHexNumber (c);  		for (int i = 0; i < 2; ++i) {  			if (IsOct ((char)ReaderPeek ())) {  				c = (char)ReaderRead ();  				escapeSequenceBuffer [curPos++] = c;  				int idx = GetHexNumber (c);  				oct = 8 * oct + idx;  			} else  				break;  		}  		// Convert integer to character  		if (oct > 0xffff) {  			ch = '\0';  			surrogatePair = char.ConvertFromUtf32 (oct);  		} else {  			ch = (char)oct;  		}  	} else {  		OnError (Line' Col' String.Format ("Unexpected escape sequence : {0}"' c));  		ch = '\0';  	}  	break;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: switch (c) {  case '\'':  	ch = '\'';  	break;  case '\"':  	ch = '\"';  	break;  case '?':  	ch = '?';  	return "\\?";  // Literal question mark  case '\\':  	ch = '\\';  	break;  /*case '0': 					ch = '\0'; 					break;*/case 'a':  	ch = '\a';  	// Bell (alert)  	break;  case 'b':  	ch = '\b';  	// Backspace  	break;  case 'f':  	ch = '\f';  	// Formfeed  	break;  case 'n':  	ch = '\n';  	break;  case 'r':  	ch = '\r';  	break;  case 't':  	ch = '\t';  	break;  case 'v':  	ch = '\v';  	// Vertical tab  	break;  case 'u':  case 'x':  	// 16 bit unicode character  	c = (char)ReaderRead ();  	number = GetHexNumber (c);  	escapeSequenceBuffer [curPos++] = c;  	if (number < 0) {  		OnError (Line' Col - 1' String.Format ("Invalid char in literal : {0}"' c));  	}  	for (int i = 0; i < 3; ++i) {  		if (IsHex ((char)ReaderPeek ())) {  			c = (char)ReaderRead ();  			int idx = GetHexNumber (c);  			escapeSequenceBuffer [curPos++] = c;  			number = 16 * number + idx;  		} else {  			break;  		}  	}  	ch = (char)number;  	break;  case 'U':  	// 32 bit unicode character  	number = 0;  	for (int i = 0; i < 8; ++i) {  		if (IsHex ((char)ReaderPeek ())) {  			c = (char)ReaderRead ();  			int idx = GetHexNumber (c);  			escapeSequenceBuffer [curPos++] = c;  			number = 16 * number + idx;  		} else {  			OnError (Line' Col - 1' String.Format ("Invalid char in literal : {0}"' (char)ReaderPeek ()));  			break;  		}  	}  	if (number > 0xffff) {  		ch = '\0';  		surrogatePair = char.ConvertFromUtf32 (number);  	} else {  		ch = (char)number;  	}  	break;  // NamedCharacterEntities  case '&':  	string charEntity = "";  	while (true) {  		nextChar = ReaderRead ();  		if (nextChar < 0) {  			OnError (Line' Col - 1' "EOF reached within named char entity");  			ch = '\0';  			return string.Empty;  		}  		c = (char)nextChar;  		if (c == ';')  			break;  		if (IsIdentifierPart (c))  			charEntity += c;  		else {  			OnError (Line' Col - 1' "Unexpected character found in named char entity: " + c);  			ch = '\0';  			return string.Empty;  		}  	}  	if (string.IsNullOrEmpty (charEntity)) {  		OnError (Line' Col - 1' "Empty named character entities not allowed");  		ch = '\0';  		return string.Empty;  	}  	//TODO: Performance improvement  	//var ret=System.Web.HttpUtility.HtmlDecode("&"+charEntity+";");  	ch = '#';  	//ret[0];  	return "&" + charEntity + ";";  default:  	// Max 3 following octal digits  	if (IsOct (c)) {  		// Parse+Convert oct to dec integer  		int oct = GetHexNumber (c);  		for (int i = 0; i < 2; ++i) {  			if (IsOct ((char)ReaderPeek ())) {  				c = (char)ReaderRead ();  				escapeSequenceBuffer [curPos++] = c;  				int idx = GetHexNumber (c);  				oct = 8 * oct + idx;  			} else  				break;  		}  		// Convert integer to character  		if (oct > 0xffff) {  			ch = '\0';  			surrogatePair = char.ConvertFromUtf32 (oct);  		} else {  			ch = (char)oct;  		}  	} else {  		OnError (Line' Col' String.Format ("Unexpected escape sequence : {0}"' c));  		ch = '\0';  	}  	break;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: switch (c) {  case '\'':  	ch = '\'';  	break;  case '\"':  	ch = '\"';  	break;  case '?':  	ch = '?';  	return "\\?";  // Literal question mark  case '\\':  	ch = '\\';  	break;  /*case '0': 					ch = '\0'; 					break;*/case 'a':  	ch = '\a';  	// Bell (alert)  	break;  case 'b':  	ch = '\b';  	// Backspace  	break;  case 'f':  	ch = '\f';  	// Formfeed  	break;  case 'n':  	ch = '\n';  	break;  case 'r':  	ch = '\r';  	break;  case 't':  	ch = '\t';  	break;  case 'v':  	ch = '\v';  	// Vertical tab  	break;  case 'u':  case 'x':  	// 16 bit unicode character  	c = (char)ReaderRead ();  	number = GetHexNumber (c);  	escapeSequenceBuffer [curPos++] = c;  	if (number < 0) {  		OnError (Line' Col - 1' String.Format ("Invalid char in literal : {0}"' c));  	}  	for (int i = 0; i < 3; ++i) {  		if (IsHex ((char)ReaderPeek ())) {  			c = (char)ReaderRead ();  			int idx = GetHexNumber (c);  			escapeSequenceBuffer [curPos++] = c;  			number = 16 * number + idx;  		} else {  			break;  		}  	}  	ch = (char)number;  	break;  case 'U':  	// 32 bit unicode character  	number = 0;  	for (int i = 0; i < 8; ++i) {  		if (IsHex ((char)ReaderPeek ())) {  			c = (char)ReaderRead ();  			int idx = GetHexNumber (c);  			escapeSequenceBuffer [curPos++] = c;  			number = 16 * number + idx;  		} else {  			OnError (Line' Col - 1' String.Format ("Invalid char in literal : {0}"' (char)ReaderPeek ()));  			break;  		}  	}  	if (number > 0xffff) {  		ch = '\0';  		surrogatePair = char.ConvertFromUtf32 (number);  	} else {  		ch = (char)number;  	}  	break;  // NamedCharacterEntities  case '&':  	string charEntity = "";  	while (true) {  		nextChar = ReaderRead ();  		if (nextChar < 0) {  			OnError (Line' Col - 1' "EOF reached within named char entity");  			ch = '\0';  			return string.Empty;  		}  		c = (char)nextChar;  		if (c == ';')  			break;  		if (IsIdentifierPart (c))  			charEntity += c;  		else {  			OnError (Line' Col - 1' "Unexpected character found in named char entity: " + c);  			ch = '\0';  			return string.Empty;  		}  	}  	if (string.IsNullOrEmpty (charEntity)) {  		OnError (Line' Col - 1' "Empty named character entities not allowed");  		ch = '\0';  		return string.Empty;  	}  	//TODO: Performance improvement  	//var ret=System.Web.HttpUtility.HtmlDecode("&"+charEntity+";");  	ch = '#';  	//ret[0];  	return "&" + charEntity + ";";  default:  	// Max 3 following octal digits  	if (IsOct (c)) {  		// Parse+Convert oct to dec integer  		int oct = GetHexNumber (c);  		for (int i = 0; i < 2; ++i) {  			if (IsOct ((char)ReaderPeek ())) {  				c = (char)ReaderRead ();  				escapeSequenceBuffer [curPos++] = c;  				int idx = GetHexNumber (c);  				oct = 8 * oct + idx;  			} else  				break;  		}  		// Convert integer to character  		if (oct > 0xffff) {  			ch = '\0';  			surrogatePair = char.ConvertFromUtf32 (oct);  		} else {  			ch = (char)oct;  		}  	} else {  		OnError (Line' Col' String.Format ("Unexpected escape sequence : {0}"' c));  		ch = '\0';  	}  	break;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: switch (c) {  case '\'':  	ch = '\'';  	break;  case '\"':  	ch = '\"';  	break;  case '?':  	ch = '?';  	return "\\?";  // Literal question mark  case '\\':  	ch = '\\';  	break;  /*case '0': 					ch = '\0'; 					break;*/case 'a':  	ch = '\a';  	// Bell (alert)  	break;  case 'b':  	ch = '\b';  	// Backspace  	break;  case 'f':  	ch = '\f';  	// Formfeed  	break;  case 'n':  	ch = '\n';  	break;  case 'r':  	ch = '\r';  	break;  case 't':  	ch = '\t';  	break;  case 'v':  	ch = '\v';  	// Vertical tab  	break;  case 'u':  case 'x':  	// 16 bit unicode character  	c = (char)ReaderRead ();  	number = GetHexNumber (c);  	escapeSequenceBuffer [curPos++] = c;  	if (number < 0) {  		OnError (Line' Col - 1' String.Format ("Invalid char in literal : {0}"' c));  	}  	for (int i = 0; i < 3; ++i) {  		if (IsHex ((char)ReaderPeek ())) {  			c = (char)ReaderRead ();  			int idx = GetHexNumber (c);  			escapeSequenceBuffer [curPos++] = c;  			number = 16 * number + idx;  		} else {  			break;  		}  	}  	ch = (char)number;  	break;  case 'U':  	// 32 bit unicode character  	number = 0;  	for (int i = 0; i < 8; ++i) {  		if (IsHex ((char)ReaderPeek ())) {  			c = (char)ReaderRead ();  			int idx = GetHexNumber (c);  			escapeSequenceBuffer [curPos++] = c;  			number = 16 * number + idx;  		} else {  			OnError (Line' Col - 1' String.Format ("Invalid char in literal : {0}"' (char)ReaderPeek ()));  			break;  		}  	}  	if (number > 0xffff) {  		ch = '\0';  		surrogatePair = char.ConvertFromUtf32 (number);  	} else {  		ch = (char)number;  	}  	break;  // NamedCharacterEntities  case '&':  	string charEntity = "";  	while (true) {  		nextChar = ReaderRead ();  		if (nextChar < 0) {  			OnError (Line' Col - 1' "EOF reached within named char entity");  			ch = '\0';  			return string.Empty;  		}  		c = (char)nextChar;  		if (c == ';')  			break;  		if (IsIdentifierPart (c))  			charEntity += c;  		else {  			OnError (Line' Col - 1' "Unexpected character found in named char entity: " + c);  			ch = '\0';  			return string.Empty;  		}  	}  	if (string.IsNullOrEmpty (charEntity)) {  		OnError (Line' Col - 1' "Empty named character entities not allowed");  		ch = '\0';  		return string.Empty;  	}  	//TODO: Performance improvement  	//var ret=System.Web.HttpUtility.HtmlDecode("&"+charEntity+";");  	ch = '#';  	//ret[0];  	return "&" + charEntity + ";";  default:  	// Max 3 following octal digits  	if (IsOct (c)) {  		// Parse+Convert oct to dec integer  		int oct = GetHexNumber (c);  		for (int i = 0; i < 2; ++i) {  			if (IsOct ((char)ReaderPeek ())) {  				c = (char)ReaderRead ();  				escapeSequenceBuffer [curPos++] = c;  				int idx = GetHexNumber (c);  				oct = 8 * oct + idx;  			} else  				break;  		}  		// Convert integer to character  		if (oct > 0xffff) {  			ch = '\0';  			surrogatePair = char.ConvertFromUtf32 (oct);  		} else {  			ch = (char)oct;  		}  	} else {  		OnError (Line' Col' String.Format ("Unexpected escape sequence : {0}"' c));  		ch = '\0';  	}  	break;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: switch (c) {  case '\'':  	ch = '\'';  	break;  case '\"':  	ch = '\"';  	break;  case '?':  	ch = '?';  	return "\\?";  // Literal question mark  case '\\':  	ch = '\\';  	break;  /*case '0': 					ch = '\0'; 					break;*/case 'a':  	ch = '\a';  	// Bell (alert)  	break;  case 'b':  	ch = '\b';  	// Backspace  	break;  case 'f':  	ch = '\f';  	// Formfeed  	break;  case 'n':  	ch = '\n';  	break;  case 'r':  	ch = '\r';  	break;  case 't':  	ch = '\t';  	break;  case 'v':  	ch = '\v';  	// Vertical tab  	break;  case 'u':  case 'x':  	// 16 bit unicode character  	c = (char)ReaderRead ();  	number = GetHexNumber (c);  	escapeSequenceBuffer [curPos++] = c;  	if (number < 0) {  		OnError (Line' Col - 1' String.Format ("Invalid char in literal : {0}"' c));  	}  	for (int i = 0; i < 3; ++i) {  		if (IsHex ((char)ReaderPeek ())) {  			c = (char)ReaderRead ();  			int idx = GetHexNumber (c);  			escapeSequenceBuffer [curPos++] = c;  			number = 16 * number + idx;  		} else {  			break;  		}  	}  	ch = (char)number;  	break;  case 'U':  	// 32 bit unicode character  	number = 0;  	for (int i = 0; i < 8; ++i) {  		if (IsHex ((char)ReaderPeek ())) {  			c = (char)ReaderRead ();  			int idx = GetHexNumber (c);  			escapeSequenceBuffer [curPos++] = c;  			number = 16 * number + idx;  		} else {  			OnError (Line' Col - 1' String.Format ("Invalid char in literal : {0}"' (char)ReaderPeek ()));  			break;  		}  	}  	if (number > 0xffff) {  		ch = '\0';  		surrogatePair = char.ConvertFromUtf32 (number);  	} else {  		ch = (char)number;  	}  	break;  // NamedCharacterEntities  case '&':  	string charEntity = "";  	while (true) {  		nextChar = ReaderRead ();  		if (nextChar < 0) {  			OnError (Line' Col - 1' "EOF reached within named char entity");  			ch = '\0';  			return string.Empty;  		}  		c = (char)nextChar;  		if (c == ';')  			break;  		if (IsIdentifierPart (c))  			charEntity += c;  		else {  			OnError (Line' Col - 1' "Unexpected character found in named char entity: " + c);  			ch = '\0';  			return string.Empty;  		}  	}  	if (string.IsNullOrEmpty (charEntity)) {  		OnError (Line' Col - 1' "Empty named character entities not allowed");  		ch = '\0';  		return string.Empty;  	}  	//TODO: Performance improvement  	//var ret=System.Web.HttpUtility.HtmlDecode("&"+charEntity+";");  	ch = '#';  	//ret[0];  	return "&" + charEntity + ";";  default:  	// Max 3 following octal digits  	if (IsOct (c)) {  		// Parse+Convert oct to dec integer  		int oct = GetHexNumber (c);  		for (int i = 0; i < 2; ++i) {  			if (IsOct ((char)ReaderPeek ())) {  				c = (char)ReaderRead ();  				escapeSequenceBuffer [curPos++] = c;  				int idx = GetHexNumber (c);  				oct = 8 * oct + idx;  			} else  				break;  		}  		// Convert integer to character  		if (oct > 0xffff) {  			ch = '\0';  			surrogatePair = char.ConvertFromUtf32 (oct);  		} else {  			ch = (char)oct;  		}  	} else {  		OnError (Line' Col' String.Format ("Unexpected escape sequence : {0}"' c));  		ch = '\0';  	}  	break;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: for (int i = 0; i < 3; ++i) {  	if (IsHex ((char)ReaderPeek ())) {  		c = (char)ReaderRead ();  		int idx = GetHexNumber (c);  		escapeSequenceBuffer [curPos++] = c;  		number = 16 * number + idx;  	} else {  		break;  	}  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: for (int i = 0; i < 3; ++i) {  	if (IsHex ((char)ReaderPeek ())) {  		c = (char)ReaderRead ();  		int idx = GetHexNumber (c);  		escapeSequenceBuffer [curPos++] = c;  		number = 16 * number + idx;  	} else {  		break;  	}  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: if (IsHex ((char)ReaderPeek ())) {  	c = (char)ReaderRead ();  	int idx = GetHexNumber (c);  	escapeSequenceBuffer [curPos++] = c;  	number = 16 * number + idx;  } else {  	break;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: number = 16 * number + idx;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {  	if (IsHex ((char)ReaderPeek ())) {  		c = (char)ReaderRead ();  		int idx = GetHexNumber (c);  		escapeSequenceBuffer [curPos++] = c;  		number = 16 * number + idx;  	} else {  		OnError (Line' Col - 1' String.Format ("Invalid char in literal : {0}"' (char)ReaderPeek ()));  		break;  	}  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {  	if (IsHex ((char)ReaderPeek ())) {  		c = (char)ReaderRead ();  		int idx = GetHexNumber (c);  		escapeSequenceBuffer [curPos++] = c;  		number = 16 * number + idx;  	} else {  		OnError (Line' Col - 1' String.Format ("Invalid char in literal : {0}"' (char)ReaderPeek ()));  		break;  	}  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: if (IsHex ((char)ReaderPeek ())) {  	c = (char)ReaderRead ();  	int idx = GetHexNumber (c);  	escapeSequenceBuffer [curPos++] = c;  	number = 16 * number + idx;  } else {  	OnError (Line' Col - 1' String.Format ("Invalid char in literal : {0}"' (char)ReaderPeek ()));  	break;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: number = 16 * number + idx;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: if (IsOct (c)) {  	// Parse+Convert oct to dec integer  	int oct = GetHexNumber (c);  	for (int i = 0; i < 2; ++i) {  		if (IsOct ((char)ReaderPeek ())) {  			c = (char)ReaderRead ();  			escapeSequenceBuffer [curPos++] = c;  			int idx = GetHexNumber (c);  			oct = 8 * oct + idx;  		} else  			break;  	}  	// Convert integer to character  	if (oct > 0xffff) {  		ch = '\0';  		surrogatePair = char.ConvertFromUtf32 (oct);  	} else {  		ch = (char)oct;  	}  } else {  	OnError (Line' Col' String.Format ("Unexpected escape sequence : {0}"' c));  	ch = '\0';  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: if (IsOct (c)) {  	// Parse+Convert oct to dec integer  	int oct = GetHexNumber (c);  	for (int i = 0; i < 2; ++i) {  		if (IsOct ((char)ReaderPeek ())) {  			c = (char)ReaderRead ();  			escapeSequenceBuffer [curPos++] = c;  			int idx = GetHexNumber (c);  			oct = 8 * oct + idx;  		} else  			break;  	}  	// Convert integer to character  	if (oct > 0xffff) {  		ch = '\0';  		surrogatePair = char.ConvertFromUtf32 (oct);  	} else {  		ch = (char)oct;  	}  } else {  	OnError (Line' Col' String.Format ("Unexpected escape sequence : {0}"' c));  	ch = '\0';  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: for (int i = 0; i < 2; ++i) {  	if (IsOct ((char)ReaderPeek ())) {  		c = (char)ReaderRead ();  		escapeSequenceBuffer [curPos++] = c;  		int idx = GetHexNumber (c);  		oct = 8 * oct + idx;  	} else  		break;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: for (int i = 0; i < 2; ++i) {  	if (IsOct ((char)ReaderPeek ())) {  		c = (char)ReaderRead ();  		escapeSequenceBuffer [curPos++] = c;  		int idx = GetHexNumber (c);  		oct = 8 * oct + idx;  	} else  		break;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: if (IsOct ((char)ReaderPeek ())) {  	c = (char)ReaderRead ();  	escapeSequenceBuffer [curPos++] = c;  	int idx = GetHexNumber (c);  	oct = 8 * oct + idx;  } else  	break;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: oct = 8 * oct + idx;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadChar,The following statement contains a magic number: if (ch == '\\') {  	escapeSequence = ReadEscapeSequence (out chValue' out surrogatePair);  	if (surrogatePair != null) {  		// Although we'll pass back a string as literal value' it's originally handled as char literal!  	}  } else if (ch == '\'') {  	return Token (DTokens.Literal' x' y' 2' char.MinValue' "''"' LiteralFormat.CharLiteral);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadChar,The following statement contains a magic number: if (ch == '\'') {  	return Token (DTokens.Literal' x' y' 2' char.MinValue' "''"' LiteralFormat.CharLiteral);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadChar,The following statement contains a magic number: return Token (DTokens.Literal' x' y' 2' char.MinValue' "''"' LiteralFormat.CharLiteral);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) {  case '+':  	switch (ReaderPeek ()) {  	case '+':  		ReaderRead ();  		return Token (DTokens.Increment' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.PlusAssign' x' y);  	}  	return Token (DTokens.Plus' x' y);  case '-':  	switch (ReaderPeek ()) {  	case '-':  		ReaderRead ();  		return Token (DTokens.Decrement' x' y);  	case '=':  		ReaderRead ();  		return Token (DTokens.MinusAssign' x' y);  	case '>':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y);  	}  	return Token (DTokens.Minus' x' y);  case '*':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TimesAssign' x' y' 2);  	default:  		break;  	}  	return Token (DTokens.Times' x' y);  case '/':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.DivAssign' x' y' 2);  	}  	return Token (DTokens.Div' x' y);  case '%':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ModAssign' x' y' 2);  	}  	return Token (DTokens.Mod' x' y);  case '&':  	switch (ReaderPeek ()) {  	case '&':  		ReaderRead ();  		return Token (DTokens.LogicalAnd' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseAndAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseAnd' x' y);  case '|':  	switch (ReaderPeek ()) {  	case '|':  		ReaderRead ();  		return Token (DTokens.LogicalOr' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.BitwiseOrAssign' x' y' 2);  	}  	return Token (DTokens.BitwiseOr' x' y);  case '^':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.XorAssign' x' y' 2);  	case '^':  		ReaderRead ();  		if (ReaderPeek () == '=') {  			ReaderRead ();  			return Token (DTokens.PowAssign' x' y' 3);  		}  		return Token (DTokens.Pow' x' y' 2);  	}  	return Token (DTokens.Xor' x' y);  case '!':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.NotEqual' x' y' 2);  	// !=  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrGreater' x' y' 3);  		// !<=  		case '>':  			ReaderRead ();  			switch (ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.Unordered' x' y' 4);  			// !<>=  			}  			return Token (DTokens.UnorderedOrEqual' x' y' 3);  		// !<>  		}  		return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  	// !<  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.UnorderedOrLess' x' y' 3);  		// !>=  		default:  			break;  		}  		return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  	// !>  	}  	return Token (DTokens.Not' x' y);  case '~':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TildeAssign' x' y' 2);  	}  	return Token (DTokens.Tilde' x' y);  case '=':  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Equal' x' y' 2);  	case '>':  		ReaderRead ();  		return Token (DTokens.GoesTo' x' y' 2);  	}  	return Token (DTokens.Assign' x' y);  case '<':  	switch (ReaderPeek ()) {  	case '<':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftLeftAssign' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.ShiftLeft' x' y' 2);  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.LessEqualOrGreater' x' y' 3);  		default:  			break;  		}  		return Token (DTokens.LessOrGreater' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqual' x' y' 2);  	}  	return Token (DTokens.LessThan' x' y);  case '>':  	switch (ReaderPeek ()) {  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.ShiftRightAssign' x' y' 3);  			case '>':  				ReaderRead ();  				if (ReaderPeek () != -1) {  					switch ((char)ReaderPeek ()) {  					case '=':  						ReaderRead ();  						return Token (DTokens.TripleRightShiftAssign' x' y' 4);  					}  					return Token (DTokens.ShiftRightUnsigned' x' y' 3);  					// >>>  				}  				break;  			}  		}  		return Token (DTokens.ShiftRight' x' y' 2);  	case '=':  		ReaderRead ();  		return Token (DTokens.GreaterEqual' x' y' 2);  	}  	return Token (DTokens.GreaterThan' x' y);  case '?':  	return Token (DTokens.Question' x' y);  case '$':  	return Token (DTokens.Dollar' x' y);  case ';':  	return Token (DTokens.Semicolon' x' y);  case ':':  	return Token (DTokens.Colon' x' y);  case ''':  	return Token (DTokens.Comma' x' y);  case '.':  	// Prevent OverflowException when ReaderPeek returns -1  	int tmp = ReaderPeek ();  	if (tmp > 0 && IsDigit ((char)tmp))  		return ReadDigit ('.'' Col - 1);  	else if (tmp == (int)'.') {  		ReaderRead ();  		if ((char)ReaderPeek () == '.')// Triple dot  		 {  			ReaderRead ();  			return Token (DTokens.TripleDot' x' y' 3);  		}  		return Token (DTokens.DoubleDot' x' y' 2);  	}  	return Token (DTokens.Dot' x' y);  case ')':  	return Token (DTokens.CloseParenthesis' x' y);  case '(':  	return Token (DTokens.OpenParenthesis' x' y);  case ']':  	return Token (DTokens.CloseSquareBracket' x' y);  case '[':  	return Token (DTokens.OpenSquareBracket' x' y);  case '}':  	return Token (DTokens.CloseCurlyBrace' x' y);  case '{':  	return Token (DTokens.OpenCurlyBrace' x' y);  default:  	return null;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.TimesAssign' x' y' 2);  default:  	break;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.TimesAssign' x' y' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.DivAssign' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.DivAssign' x' y' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.ModAssign' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.ModAssign' x' y' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '&':  	ReaderRead ();  	return Token (DTokens.LogicalAnd' x' y' 2);  case '=':  	ReaderRead ();  	return Token (DTokens.BitwiseAndAssign' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '&':  	ReaderRead ();  	return Token (DTokens.LogicalAnd' x' y' 2);  case '=':  	ReaderRead ();  	return Token (DTokens.BitwiseAndAssign' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.LogicalAnd' x' y' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.BitwiseAndAssign' x' y' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '|':  	ReaderRead ();  	return Token (DTokens.LogicalOr' x' y' 2);  case '=':  	ReaderRead ();  	return Token (DTokens.BitwiseOrAssign' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '|':  	ReaderRead ();  	return Token (DTokens.LogicalOr' x' y' 2);  case '=':  	ReaderRead ();  	return Token (DTokens.BitwiseOrAssign' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.LogicalOr' x' y' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.BitwiseOrAssign' x' y' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.XorAssign' x' y' 2);  case '^':  	ReaderRead ();  	if (ReaderPeek () == '=') {  		ReaderRead ();  		return Token (DTokens.PowAssign' x' y' 3);  	}  	return Token (DTokens.Pow' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.XorAssign' x' y' 2);  case '^':  	ReaderRead ();  	if (ReaderPeek () == '=') {  		ReaderRead ();  		return Token (DTokens.PowAssign' x' y' 3);  	}  	return Token (DTokens.Pow' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.XorAssign' x' y' 2);  case '^':  	ReaderRead ();  	if (ReaderPeek () == '=') {  		ReaderRead ();  		return Token (DTokens.PowAssign' x' y' 3);  	}  	return Token (DTokens.Pow' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.XorAssign' x' y' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: if (ReaderPeek () == '=') {  	ReaderRead ();  	return Token (DTokens.PowAssign' x' y' 3);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.PowAssign' x' y' 3);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.Pow' x' y' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.NotEqual' x' y' 2);  // !=  case '<':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.UnorderedOrGreater' x' y' 3);  	// !<=  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.Unordered' x' y' 4);  		// !<>=  		}  		return Token (DTokens.UnorderedOrEqual' x' y' 3);  	// !<>  	}  	return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  // !<  case '>':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.UnorderedOrLess' x' y' 3);  	// !>=  	default:  		break;  	}  	return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  // !>  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.NotEqual' x' y' 2);  // !=  case '<':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.UnorderedOrGreater' x' y' 3);  	// !<=  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.Unordered' x' y' 4);  		// !<>=  		}  		return Token (DTokens.UnorderedOrEqual' x' y' 3);  	// !<>  	}  	return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  // !<  case '>':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.UnorderedOrLess' x' y' 3);  	// !>=  	default:  		break;  	}  	return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  // !>  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.NotEqual' x' y' 2);  // !=  case '<':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.UnorderedOrGreater' x' y' 3);  	// !<=  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.Unordered' x' y' 4);  		// !<>=  		}  		return Token (DTokens.UnorderedOrEqual' x' y' 3);  	// !<>  	}  	return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  // !<  case '>':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.UnorderedOrLess' x' y' 3);  	// !>=  	default:  		break;  	}  	return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  // !>  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.NotEqual' x' y' 2);  // !=  case '<':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.UnorderedOrGreater' x' y' 3);  	// !<=  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.Unordered' x' y' 4);  		// !<>=  		}  		return Token (DTokens.UnorderedOrEqual' x' y' 3);  	// !<>  	}  	return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  // !<  case '>':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.UnorderedOrLess' x' y' 3);  	// !>=  	default:  		break;  	}  	return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  // !>  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.NotEqual' x' y' 2);  // !=  case '<':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.UnorderedOrGreater' x' y' 3);  	// !<=  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.Unordered' x' y' 4);  		// !<>=  		}  		return Token (DTokens.UnorderedOrEqual' x' y' 3);  	// !<>  	}  	return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  // !<  case '>':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.UnorderedOrLess' x' y' 3);  	// !>=  	default:  		break;  	}  	return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  // !>  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.NotEqual' x' y' 2);  // !=  case '<':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.UnorderedOrGreater' x' y' 3);  	// !<=  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.Unordered' x' y' 4);  		// !<>=  		}  		return Token (DTokens.UnorderedOrEqual' x' y' 3);  	// !<>  	}  	return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  // !<  case '>':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.UnorderedOrLess' x' y' 3);  	// !>=  	default:  		break;  	}  	return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  // !>  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.NotEqual' x' y' 2);  // !=  case '<':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.UnorderedOrGreater' x' y' 3);  	// !<=  	case '>':  		ReaderRead ();  		switch (ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.Unordered' x' y' 4);  		// !<>=  		}  		return Token (DTokens.UnorderedOrEqual' x' y' 3);  	// !<>  	}  	return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  // !<  case '>':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.UnorderedOrLess' x' y' 3);  	// !>=  	default:  		break;  	}  	return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  // !>  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.NotEqual' x' y' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.UnorderedOrGreater' x' y' 3);  // !<=  case '>':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Unordered' x' y' 4);  	// !<>=  	}  	return Token (DTokens.UnorderedOrEqual' x' y' 3);  // !<>  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.UnorderedOrGreater' x' y' 3);  // !<=  case '>':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Unordered' x' y' 4);  	// !<>=  	}  	return Token (DTokens.UnorderedOrEqual' x' y' 3);  // !<>  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.UnorderedOrGreater' x' y' 3);  // !<=  case '>':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Unordered' x' y' 4);  	// !<>=  	}  	return Token (DTokens.UnorderedOrEqual' x' y' 3);  // !<>  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.UnorderedOrGreater' x' y' 3);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.Unordered' x' y' 4);  // !<>=  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.Unordered' x' y' 4);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.UnorderedOrEqual' x' y' 3);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.UnorderedGreaterOrEqual' x' y' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.UnorderedOrLess' x' y' 3);  // !>=  default:  	break;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.UnorderedOrLess' x' y' 3);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.UnorderedLessOrEqual' x' y' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.TildeAssign' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.TildeAssign' x' y' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.Equal' x' y' 2);  case '>':  	ReaderRead ();  	return Token (DTokens.GoesTo' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.Equal' x' y' 2);  case '>':  	ReaderRead ();  	return Token (DTokens.GoesTo' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.Equal' x' y' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.GoesTo' x' y' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '<':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ShiftLeftAssign' x' y' 3);  	default:  		break;  	}  	return Token (DTokens.ShiftLeft' x' y' 2);  case '>':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqualOrGreater' x' y' 3);  	default:  		break;  	}  	return Token (DTokens.LessOrGreater' x' y' 2);  case '=':  	ReaderRead ();  	return Token (DTokens.LessEqual' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '<':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ShiftLeftAssign' x' y' 3);  	default:  		break;  	}  	return Token (DTokens.ShiftLeft' x' y' 2);  case '>':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqualOrGreater' x' y' 3);  	default:  		break;  	}  	return Token (DTokens.LessOrGreater' x' y' 2);  case '=':  	ReaderRead ();  	return Token (DTokens.LessEqual' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '<':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ShiftLeftAssign' x' y' 3);  	default:  		break;  	}  	return Token (DTokens.ShiftLeft' x' y' 2);  case '>':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqualOrGreater' x' y' 3);  	default:  		break;  	}  	return Token (DTokens.LessOrGreater' x' y' 2);  case '=':  	ReaderRead ();  	return Token (DTokens.LessEqual' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '<':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ShiftLeftAssign' x' y' 3);  	default:  		break;  	}  	return Token (DTokens.ShiftLeft' x' y' 2);  case '>':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqualOrGreater' x' y' 3);  	default:  		break;  	}  	return Token (DTokens.LessOrGreater' x' y' 2);  case '=':  	ReaderRead ();  	return Token (DTokens.LessEqual' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '<':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ShiftLeftAssign' x' y' 3);  	default:  		break;  	}  	return Token (DTokens.ShiftLeft' x' y' 2);  case '>':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.LessEqualOrGreater' x' y' 3);  	default:  		break;  	}  	return Token (DTokens.LessOrGreater' x' y' 2);  case '=':  	ReaderRead ();  	return Token (DTokens.LessEqual' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.ShiftLeftAssign' x' y' 3);  default:  	break;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.ShiftLeftAssign' x' y' 3);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.ShiftLeft' x' y' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.LessEqualOrGreater' x' y' 3);  default:  	break;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.LessEqualOrGreater' x' y' 3);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.LessOrGreater' x' y' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.LessEqual' x' y' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '>':  	ReaderRead ();  	if (ReaderPeek () != -1) {  		switch ((char)ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftRightAssign' x' y' 3);  		case '>':  			ReaderRead ();  			if (ReaderPeek () != -1) {  				switch ((char)ReaderPeek ()) {  				case '=':  					ReaderRead ();  					return Token (DTokens.TripleRightShiftAssign' x' y' 4);  				}  				return Token (DTokens.ShiftRightUnsigned' x' y' 3);  				// >>>  			}  			break;  		}  	}  	return Token (DTokens.ShiftRight' x' y' 2);  case '=':  	ReaderRead ();  	return Token (DTokens.GreaterEqual' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '>':  	ReaderRead ();  	if (ReaderPeek () != -1) {  		switch ((char)ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftRightAssign' x' y' 3);  		case '>':  			ReaderRead ();  			if (ReaderPeek () != -1) {  				switch ((char)ReaderPeek ()) {  				case '=':  					ReaderRead ();  					return Token (DTokens.TripleRightShiftAssign' x' y' 4);  				}  				return Token (DTokens.ShiftRightUnsigned' x' y' 3);  				// >>>  			}  			break;  		}  	}  	return Token (DTokens.ShiftRight' x' y' 2);  case '=':  	ReaderRead ();  	return Token (DTokens.GreaterEqual' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '>':  	ReaderRead ();  	if (ReaderPeek () != -1) {  		switch ((char)ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftRightAssign' x' y' 3);  		case '>':  			ReaderRead ();  			if (ReaderPeek () != -1) {  				switch ((char)ReaderPeek ()) {  				case '=':  					ReaderRead ();  					return Token (DTokens.TripleRightShiftAssign' x' y' 4);  				}  				return Token (DTokens.ShiftRightUnsigned' x' y' 3);  				// >>>  			}  			break;  		}  	}  	return Token (DTokens.ShiftRight' x' y' 2);  case '=':  	ReaderRead ();  	return Token (DTokens.GreaterEqual' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '>':  	ReaderRead ();  	if (ReaderPeek () != -1) {  		switch ((char)ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftRightAssign' x' y' 3);  		case '>':  			ReaderRead ();  			if (ReaderPeek () != -1) {  				switch ((char)ReaderPeek ()) {  				case '=':  					ReaderRead ();  					return Token (DTokens.TripleRightShiftAssign' x' y' 4);  				}  				return Token (DTokens.ShiftRightUnsigned' x' y' 3);  				// >>>  			}  			break;  		}  	}  	return Token (DTokens.ShiftRight' x' y' 2);  case '=':  	ReaderRead ();  	return Token (DTokens.GreaterEqual' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ReaderPeek ()) {  case '>':  	ReaderRead ();  	if (ReaderPeek () != -1) {  		switch ((char)ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftRightAssign' x' y' 3);  		case '>':  			ReaderRead ();  			if (ReaderPeek () != -1) {  				switch ((char)ReaderPeek ()) {  				case '=':  					ReaderRead ();  					return Token (DTokens.TripleRightShiftAssign' x' y' 4);  				}  				return Token (DTokens.ShiftRightUnsigned' x' y' 3);  				// >>>  			}  			break;  		}  	}  	return Token (DTokens.ShiftRight' x' y' 2);  case '=':  	ReaderRead ();  	return Token (DTokens.GreaterEqual' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: if (ReaderPeek () != -1) {  	switch ((char)ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ShiftRightAssign' x' y' 3);  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.TripleRightShiftAssign' x' y' 4);  			}  			return Token (DTokens.ShiftRightUnsigned' x' y' 3);  			// >>>  		}  		break;  	}  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: if (ReaderPeek () != -1) {  	switch ((char)ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ShiftRightAssign' x' y' 3);  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.TripleRightShiftAssign' x' y' 4);  			}  			return Token (DTokens.ShiftRightUnsigned' x' y' 3);  			// >>>  		}  		break;  	}  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: if (ReaderPeek () != -1) {  	switch ((char)ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.ShiftRightAssign' x' y' 3);  	case '>':  		ReaderRead ();  		if (ReaderPeek () != -1) {  			switch ((char)ReaderPeek ()) {  			case '=':  				ReaderRead ();  				return Token (DTokens.TripleRightShiftAssign' x' y' 4);  			}  			return Token (DTokens.ShiftRightUnsigned' x' y' 3);  			// >>>  		}  		break;  	}  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch ((char)ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.ShiftRightAssign' x' y' 3);  case '>':  	ReaderRead ();  	if (ReaderPeek () != -1) {  		switch ((char)ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.TripleRightShiftAssign' x' y' 4);  		}  		return Token (DTokens.ShiftRightUnsigned' x' y' 3);  		// >>>  	}  	break;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch ((char)ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.ShiftRightAssign' x' y' 3);  case '>':  	ReaderRead ();  	if (ReaderPeek () != -1) {  		switch ((char)ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.TripleRightShiftAssign' x' y' 4);  		}  		return Token (DTokens.ShiftRightUnsigned' x' y' 3);  		// >>>  	}  	break;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch ((char)ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.ShiftRightAssign' x' y' 3);  case '>':  	ReaderRead ();  	if (ReaderPeek () != -1) {  		switch ((char)ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.TripleRightShiftAssign' x' y' 4);  		}  		return Token (DTokens.ShiftRightUnsigned' x' y' 3);  		// >>>  	}  	break;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.ShiftRightAssign' x' y' 3);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: if (ReaderPeek () != -1) {  	switch ((char)ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TripleRightShiftAssign' x' y' 4);  	}  	return Token (DTokens.ShiftRightUnsigned' x' y' 3);  	// >>>  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: if (ReaderPeek () != -1) {  	switch ((char)ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.TripleRightShiftAssign' x' y' 4);  	}  	return Token (DTokens.ShiftRightUnsigned' x' y' 3);  	// >>>  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch ((char)ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.TripleRightShiftAssign' x' y' 4);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.TripleRightShiftAssign' x' y' 4);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.ShiftRightUnsigned' x' y' 3);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.ShiftRight' x' y' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.GreaterEqual' x' y' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: if (tmp > 0 && IsDigit ((char)tmp))  	return ReadDigit ('.'' Col - 1);  else if (tmp == (int)'.') {  	ReaderRead ();  	if ((char)ReaderPeek () == '.')// Triple dot  	 {  		ReaderRead ();  		return Token (DTokens.TripleDot' x' y' 3);  	}  	return Token (DTokens.DoubleDot' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: if (tmp > 0 && IsDigit ((char)tmp))  	return ReadDigit ('.'' Col - 1);  else if (tmp == (int)'.') {  	ReaderRead ();  	if ((char)ReaderPeek () == '.')// Triple dot  	 {  		ReaderRead ();  		return Token (DTokens.TripleDot' x' y' 3);  	}  	return Token (DTokens.DoubleDot' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: if (tmp == (int)'.') {  	ReaderRead ();  	if ((char)ReaderPeek () == '.')// Triple dot  	 {  		ReaderRead ();  		return Token (DTokens.TripleDot' x' y' 3);  	}  	return Token (DTokens.DoubleDot' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: if (tmp == (int)'.') {  	ReaderRead ();  	if ((char)ReaderPeek () == '.')// Triple dot  	 {  		ReaderRead ();  		return Token (DTokens.TripleDot' x' y' 3);  	}  	return Token (DTokens.DoubleDot' x' y' 2);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: if ((char)ReaderPeek () == '.')// Triple dot   {  	ReaderRead ();  	return Token (DTokens.TripleDot' x' y' 3);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.TripleDot' x' y' 3);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: return Token (DTokens.DoubleDot' x' y' 2);  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadSingleLineComment,The following statement contains a magic number: if ((commentType & Comment.Type.Documentation) != 0 || !OnlyEnlistDDocComments)  	Comments.Add (new Comment (commentType' comm.TrimStart ('/'' ' '' '\t')' st.Column < 2' st' end));  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadSingleLineComment,The following statement contains a magic number: Comments.Add (new Comment (commentType' comm.TrimStart ('/'' ' '' '\t')' st.Column < 2' st' end));  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadMultiLineComment,The following statement contains a magic number: while ((nextChar = ReaderRead ()) != -1) {  	char ch = (char)nextChar;  	// Catch deeper-nesting comments  	if (isNestingComment && ch == '/' && ReaderPeek () == '+') {  		nestedCommentDepth++;  		ReaderRead ();  	}  	// End of multiline comment reached ?  	if ((isNestingComment ? ch == '+' : ch == '*') && ReaderPeek () == '/') {  		ReaderRead ();  		// Skip "*" or "+"  		if (nestedCommentDepth > 1)  			nestedCommentDepth--;  		else {  			if (commentType.HasFlag (Comment.Type.Documentation) || !OnlyEnlistDDocComments)  				Comments.Add (new Comment (commentType' scCurWord.ToString ().Trim (ch' ' '' '\t'' '\r'' '\n'' isNestingComment ? '+' : '*')' st.Column < 2' st' new CodeLocation (Col' Line)));  			return;  		}  	}  	if (HandleLineEnd (ch)) {  		scCurWord.AppendLine ();  		hadLineEnd = true;  	} // Skip intial white spaces' leading + as well as *  	else if (hadLineEnd) {  		if (char.IsWhiteSpace (ch) || (isNestingComment ? ch == '+' : ch == '*')) {  		} else {  			scCurWord.Append (ch);  			hadLineEnd = false;  		}  	} else  		scCurWord.Append (ch);  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadMultiLineComment,The following statement contains a magic number: if ((isNestingComment ? ch == '+' : ch == '*') && ReaderPeek () == '/') {  	ReaderRead ();  	// Skip "*" or "+"  	if (nestedCommentDepth > 1)  		nestedCommentDepth--;  	else {  		if (commentType.HasFlag (Comment.Type.Documentation) || !OnlyEnlistDDocComments)  			Comments.Add (new Comment (commentType' scCurWord.ToString ().Trim (ch' ' '' '\t'' '\r'' '\n'' isNestingComment ? '+' : '*')' st.Column < 2' st' new CodeLocation (Col' Line)));  		return;  	}  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadMultiLineComment,The following statement contains a magic number: if (nestedCommentDepth > 1)  	nestedCommentDepth--;  else {  	if (commentType.HasFlag (Comment.Type.Documentation) || !OnlyEnlistDDocComments)  		Comments.Add (new Comment (commentType' scCurWord.ToString ().Trim (ch' ' '' '\t'' '\r'' '\n'' isNestingComment ? '+' : '*')' st.Column < 2' st' new CodeLocation (Col' Line)));  	return;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadMultiLineComment,The following statement contains a magic number: if (commentType.HasFlag (Comment.Type.Documentation) || !OnlyEnlistDDocComments)  	Comments.Add (new Comment (commentType' scCurWord.ToString ().Trim (ch' ' '' '\t'' '\r'' '\n'' isNestingComment ? '+' : '*')' st.Column < 2' st' new CodeLocation (Col' Line)));  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadMultiLineComment,The following statement contains a magic number: Comments.Add (new Comment (commentType' scCurWord.ToString ().Trim (ch' ' '' '\t'' '\r'' '\n'' isNestingComment ? '+' : '*')' st.Column < 2' st' new CodeLocation (Col' Line)));  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadMultiLineComment,The following statement contains a magic number: if (commentType.HasFlag (Comment.Type.Documentation) || !OnlyEnlistDDocComments)  	Comments.Add (new Comment (commentType' scCurWord.ToString ().Trim ()' st.Column < 2' st' new CodeLocation (Col' Line)));  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadMultiLineComment,The following statement contains a magic number: Comments.Add (new Comment (commentType' scCurWord.ToString ().Trim ()' st.Column < 2' st' new CodeLocation (Col' Line)));  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,IsLegalDigit,The following statement contains a magic number: switch (NumBase) {  case 2:  	return IsBin (d);  case 10:  	return IsDigit (d);  case 16:  	return IsHex (d);  default:  	return false;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,IsLegalDigit,The following statement contains a magic number: switch (NumBase) {  case 2:  	return IsBin (d);  case 10:  	return IsDigit (d);  case 16:  	return IsHex (d);  default:  	return false;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,IsLegalDigit,The following statement contains a magic number: switch (NumBase) {  case 2:  	return IsBin (d);  case 10:  	return IsDigit (d);  case 16:  	return IsHex (d);  default:  	return false;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) {  case '0':  	return 0;  case '1':  	return 1;  case '2':  	return 2;  case '3':  	return 3;  case '4':  	return 4;  case '5':  	return 5;  case '6':  	return 6;  case '7':  	return 7;  case '8':  	return 8;  case '9':  	return 9;  case 'a':  case 'A':  	return 10;  case 'b':  case 'B':  	return 11;  case 'c':  case 'C':  	return 12;  case 'd':  case 'D':  	return 13;  case 'e':  case 'E':  	return 14;  case 'f':  case 'F':  	return 15;  default:  	//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  	return 0;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) {  case '0':  	return 0;  case '1':  	return 1;  case '2':  	return 2;  case '3':  	return 3;  case '4':  	return 4;  case '5':  	return 5;  case '6':  	return 6;  case '7':  	return 7;  case '8':  	return 8;  case '9':  	return 9;  case 'a':  case 'A':  	return 10;  case 'b':  case 'B':  	return 11;  case 'c':  case 'C':  	return 12;  case 'd':  case 'D':  	return 13;  case 'e':  case 'E':  	return 14;  case 'f':  case 'F':  	return 15;  default:  	//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  	return 0;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) {  case '0':  	return 0;  case '1':  	return 1;  case '2':  	return 2;  case '3':  	return 3;  case '4':  	return 4;  case '5':  	return 5;  case '6':  	return 6;  case '7':  	return 7;  case '8':  	return 8;  case '9':  	return 9;  case 'a':  case 'A':  	return 10;  case 'b':  case 'B':  	return 11;  case 'c':  case 'C':  	return 12;  case 'd':  case 'D':  	return 13;  case 'e':  case 'E':  	return 14;  case 'f':  case 'F':  	return 15;  default:  	//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  	return 0;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) {  case '0':  	return 0;  case '1':  	return 1;  case '2':  	return 2;  case '3':  	return 3;  case '4':  	return 4;  case '5':  	return 5;  case '6':  	return 6;  case '7':  	return 7;  case '8':  	return 8;  case '9':  	return 9;  case 'a':  case 'A':  	return 10;  case 'b':  case 'B':  	return 11;  case 'c':  case 'C':  	return 12;  case 'd':  case 'D':  	return 13;  case 'e':  case 'E':  	return 14;  case 'f':  case 'F':  	return 15;  default:  	//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  	return 0;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) {  case '0':  	return 0;  case '1':  	return 1;  case '2':  	return 2;  case '3':  	return 3;  case '4':  	return 4;  case '5':  	return 5;  case '6':  	return 6;  case '7':  	return 7;  case '8':  	return 8;  case '9':  	return 9;  case 'a':  case 'A':  	return 10;  case 'b':  case 'B':  	return 11;  case 'c':  case 'C':  	return 12;  case 'd':  case 'D':  	return 13;  case 'e':  case 'E':  	return 14;  case 'f':  case 'F':  	return 15;  default:  	//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  	return 0;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) {  case '0':  	return 0;  case '1':  	return 1;  case '2':  	return 2;  case '3':  	return 3;  case '4':  	return 4;  case '5':  	return 5;  case '6':  	return 6;  case '7':  	return 7;  case '8':  	return 8;  case '9':  	return 9;  case 'a':  case 'A':  	return 10;  case 'b':  case 'B':  	return 11;  case 'c':  case 'C':  	return 12;  case 'd':  case 'D':  	return 13;  case 'e':  case 'E':  	return 14;  case 'f':  case 'F':  	return 15;  default:  	//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  	return 0;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) {  case '0':  	return 0;  case '1':  	return 1;  case '2':  	return 2;  case '3':  	return 3;  case '4':  	return 4;  case '5':  	return 5;  case '6':  	return 6;  case '7':  	return 7;  case '8':  	return 8;  case '9':  	return 9;  case 'a':  case 'A':  	return 10;  case 'b':  case 'B':  	return 11;  case 'c':  case 'C':  	return 12;  case 'd':  case 'D':  	return 13;  case 'e':  case 'E':  	return 14;  case 'f':  case 'F':  	return 15;  default:  	//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  	return 0;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) {  case '0':  	return 0;  case '1':  	return 1;  case '2':  	return 2;  case '3':  	return 3;  case '4':  	return 4;  case '5':  	return 5;  case '6':  	return 6;  case '7':  	return 7;  case '8':  	return 8;  case '9':  	return 9;  case 'a':  case 'A':  	return 10;  case 'b':  case 'B':  	return 11;  case 'c':  case 'C':  	return 12;  case 'd':  case 'D':  	return 13;  case 'e':  case 'E':  	return 14;  case 'f':  case 'F':  	return 15;  default:  	//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  	return 0;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) {  case '0':  	return 0;  case '1':  	return 1;  case '2':  	return 2;  case '3':  	return 3;  case '4':  	return 4;  case '5':  	return 5;  case '6':  	return 6;  case '7':  	return 7;  case '8':  	return 8;  case '9':  	return 9;  case 'a':  case 'A':  	return 10;  case 'b':  case 'B':  	return 11;  case 'c':  case 'C':  	return 12;  case 'd':  case 'D':  	return 13;  case 'e':  case 'E':  	return 14;  case 'f':  case 'F':  	return 15;  default:  	//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  	return 0;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) {  case '0':  	return 0;  case '1':  	return 1;  case '2':  	return 2;  case '3':  	return 3;  case '4':  	return 4;  case '5':  	return 5;  case '6':  	return 6;  case '7':  	return 7;  case '8':  	return 8;  case '9':  	return 9;  case 'a':  case 'A':  	return 10;  case 'b':  case 'B':  	return 11;  case 'c':  case 'C':  	return 12;  case 'd':  case 'D':  	return 13;  case 'e':  case 'E':  	return 14;  case 'f':  case 'F':  	return 15;  default:  	//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  	return 0;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) {  case '0':  	return 0;  case '1':  	return 1;  case '2':  	return 2;  case '3':  	return 3;  case '4':  	return 4;  case '5':  	return 5;  case '6':  	return 6;  case '7':  	return 7;  case '8':  	return 8;  case '9':  	return 9;  case 'a':  case 'A':  	return 10;  case 'b':  case 'B':  	return 11;  case 'c':  case 'C':  	return 12;  case 'd':  case 'D':  	return 13;  case 'e':  case 'E':  	return 14;  case 'f':  case 'F':  	return 15;  default:  	//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  	return 0;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) {  case '0':  	return 0;  case '1':  	return 1;  case '2':  	return 2;  case '3':  	return 3;  case '4':  	return 4;  case '5':  	return 5;  case '6':  	return 6;  case '7':  	return 7;  case '8':  	return 8;  case '9':  	return 9;  case 'a':  case 'A':  	return 10;  case 'b':  case 'B':  	return 11;  case 'c':  case 'C':  	return 12;  case 'd':  case 'D':  	return 13;  case 'e':  case 'E':  	return 14;  case 'f':  case 'F':  	return 15;  default:  	//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  	return 0;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) {  case '0':  	return 0;  case '1':  	return 1;  case '2':  	return 2;  case '3':  	return 3;  case '4':  	return 4;  case '5':  	return 5;  case '6':  	return 6;  case '7':  	return 7;  case '8':  	return 8;  case '9':  	return 9;  case 'a':  case 'A':  	return 10;  case 'b':  case 'B':  	return 11;  case 'c':  case 'C':  	return 12;  case 'd':  case 'D':  	return 13;  case 'e':  case 'E':  	return 14;  case 'f':  case 'F':  	return 15;  default:  	//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  	return 0;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) {  case '0':  	return 0;  case '1':  	return 1;  case '2':  	return 2;  case '3':  	return 3;  case '4':  	return 4;  case '5':  	return 5;  case '6':  	return 6;  case '7':  	return 7;  case '8':  	return 8;  case '9':  	return 9;  case 'a':  case 'A':  	return 10;  case 'b':  case 'B':  	return 11;  case 'c':  case 'C':  	return 12;  case 'd':  case 'D':  	return 13;  case 'e':  case 'E':  	return 14;  case 'f':  case 'F':  	return 15;  default:  	//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  	return 0;  }  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: return 2;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: return 3;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: return 4;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: return 5;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: return 6;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: return 7;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: return 8;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: return 9;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: return 10;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: return 11;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: return 12;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: return 13;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: return 14;  
Magic Number,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: return 15;  
Magic Number,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,GetComments,The following statement contains a magic number: if (sb.Length != 5 || sb.ToString ().ToLowerInvariant () != "ditto")  	PreviousComment = sb;  
Magic Number,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,CheckForPostSemicolonComment,The following statement contains a magic number: if (ret.Length == 5 && ret.ToString ().ToLowerInvariant () == "ditto")  	return PreviousComment.ToString ();  
Magic Number,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmStatement,The following statement contains a magic number: while (!IsEOF && laKind != (CloseCurlyBrace)) {  	bool retrying = false;  	Retry:  	bool noStatement = false;  	switch (laKind) {  	case Align:  		als = new AsmStatement.AlignStatement () {  			Location = la.Location'  			Parent = s  		};  		Step ();  		als.ValueExpression = Expression (Scope);  		l.Add (als);  		Step ();  		break;  	case DTokens.Identifier:  		var opCode = AsmStatement.InstructionStatement.OpCode.__UNKNOWN__;  		var dataType = AsmStatement.RawDataStatement.DataType.__UNKNOWN__;  		if (Peek (1).Kind == Colon) {  			l.Add (new LabeledStatement () {  				Location = la.Location'  				Parent = s'  				Identifier = la.Value'  				EndLocation = Peek (1).EndLocation  			});  			Step ();  			Step ();  			if (laKind == Semicolon)  				Step ();  			continue;  		}  		if (AsmStatement.RawDataStatement.TryParseDataType (la.Value' out dataType))  			l.Add (new AsmStatement.RawDataStatement () {  				Location = la.Location'  				Parent = s'  				TypeOfData = dataType  			});  		else if (AsmStatement.InstructionStatement.TryParseOpCode (la.Value' out opCode))  			l.Add (new AsmStatement.InstructionStatement () {  				Location = la.Location'  				Parent = s'  				Operation = opCode  			});  		else  			switch (la.Value.ToLower ()) {  			case "pause":  				SynErr (Identifier' "Pause is not supported by dmd's assembler. Use `rep; nop;` instead to achieve the same effect.");  				break;  			case "even":  				als = new AsmStatement.AlignStatement () {  					Location = la.Location'  					Parent = s  				};  				als.ValueExpression = new IdentifierExpression (2) {  					Location = la.Location'  					EndLocation = la.EndLocation  				};  				l.Add (als);  				break;  			case "naked":  				noStatement = true;  				break;  			default:  				SynErr (Identifier' "Unknown op-code!");  				l.Add (new AsmStatement.InstructionStatement () {  					Location = la.Location'  					Parent = s'  					Operation = AsmStatement.InstructionStatement.OpCode.__UNKNOWN__  				});  				break;  			}  		Step ();  		if (noStatement && laKind != Semicolon)  			SynErr (Semicolon);  		var parentStatement = noStatement ? s : l [l.Count - 1];  		var args = new List<IExpression> ();  		if (IsEOF)  			args.Add (new TokenExpression (Incomplete));  		else if (laKind != Semicolon) {  			while (true) {  				if (laKind == CloseCurlyBrace) {  					// This is required as a custom error message because  					// it would complain about finding an identifier instead.  					SynErr (Semicolon' "; expected' } found");  					break;  				}  				var e = ParseAsmExpression (Scope' parentStatement);  				if (e != null)  					args.Add (e);  				if (laKind == Comma) {  					Step ();  					continue;  				}  				if (IsEOF)  					args.Add (new TokenExpression (Incomplete));  				if (!Expect (Semicolon)) {  					while (laKind != Semicolon && laKind != CloseCurlyBrace && !IsEOF)  						Step ();  					if (laKind == Semicolon)  						Step ();  				}  				break;  			}  		} else  			Step ();  		if (parentStatement is AsmStatement.InstructionStatement)  			((AsmStatement.InstructionStatement)parentStatement).Arguments = args.ToArray ();  		else if (parentStatement is AsmStatement.RawDataStatement)  			((AsmStatement.RawDataStatement)parentStatement).Data = args.ToArray ();  		break;  	case DTokens.Semicolon:  		Step ();  		break;  	case DTokens.Literal:  		l.Add (new AsmStatement.RawDataStatement {  			Location = la.Location'  			Data = new[] {  				ParseAsmPrimaryExpression (Scope' Parent)  			}'  			EndLocation = t.EndLocation'  			Parent = Parent  		});  		Expect (DTokens.Semicolon);  		break;  	default:  		string val;  		if (!retrying && Keywords.TryGetValue (laKind' out val)) {  			la.LiteralValue = val;  			la.Kind = Identifier;  			Lexer.laKind = Identifier;  			retrying = true;  			goto Retry;  		} else {  			noStatement = true;  			SynErr (Identifier);  			Step ();  		}  		break;  	}  	if (!noStatement)  		l [l.Count - 1].EndLocation = t.Location;  }  
Magic Number,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmStatement,The following statement contains a magic number: switch (laKind) {  case Align:  	als = new AsmStatement.AlignStatement () {  		Location = la.Location'  		Parent = s  	};  	Step ();  	als.ValueExpression = Expression (Scope);  	l.Add (als);  	Step ();  	break;  case DTokens.Identifier:  	var opCode = AsmStatement.InstructionStatement.OpCode.__UNKNOWN__;  	var dataType = AsmStatement.RawDataStatement.DataType.__UNKNOWN__;  	if (Peek (1).Kind == Colon) {  		l.Add (new LabeledStatement () {  			Location = la.Location'  			Parent = s'  			Identifier = la.Value'  			EndLocation = Peek (1).EndLocation  		});  		Step ();  		Step ();  		if (laKind == Semicolon)  			Step ();  		continue;  	}  	if (AsmStatement.RawDataStatement.TryParseDataType (la.Value' out dataType))  		l.Add (new AsmStatement.RawDataStatement () {  			Location = la.Location'  			Parent = s'  			TypeOfData = dataType  		});  	else if (AsmStatement.InstructionStatement.TryParseOpCode (la.Value' out opCode))  		l.Add (new AsmStatement.InstructionStatement () {  			Location = la.Location'  			Parent = s'  			Operation = opCode  		});  	else  		switch (la.Value.ToLower ()) {  		case "pause":  			SynErr (Identifier' "Pause is not supported by dmd's assembler. Use `rep; nop;` instead to achieve the same effect.");  			break;  		case "even":  			als = new AsmStatement.AlignStatement () {  				Location = la.Location'  				Parent = s  			};  			als.ValueExpression = new IdentifierExpression (2) {  				Location = la.Location'  				EndLocation = la.EndLocation  			};  			l.Add (als);  			break;  		case "naked":  			noStatement = true;  			break;  		default:  			SynErr (Identifier' "Unknown op-code!");  			l.Add (new AsmStatement.InstructionStatement () {  				Location = la.Location'  				Parent = s'  				Operation = AsmStatement.InstructionStatement.OpCode.__UNKNOWN__  			});  			break;  		}  	Step ();  	if (noStatement && laKind != Semicolon)  		SynErr (Semicolon);  	var parentStatement = noStatement ? s : l [l.Count - 1];  	var args = new List<IExpression> ();  	if (IsEOF)  		args.Add (new TokenExpression (Incomplete));  	else if (laKind != Semicolon) {  		while (true) {  			if (laKind == CloseCurlyBrace) {  				// This is required as a custom error message because  				// it would complain about finding an identifier instead.  				SynErr (Semicolon' "; expected' } found");  				break;  			}  			var e = ParseAsmExpression (Scope' parentStatement);  			if (e != null)  				args.Add (e);  			if (laKind == Comma) {  				Step ();  				continue;  			}  			if (IsEOF)  				args.Add (new TokenExpression (Incomplete));  			if (!Expect (Semicolon)) {  				while (laKind != Semicolon && laKind != CloseCurlyBrace && !IsEOF)  					Step ();  				if (laKind == Semicolon)  					Step ();  			}  			break;  		}  	} else  		Step ();  	if (parentStatement is AsmStatement.InstructionStatement)  		((AsmStatement.InstructionStatement)parentStatement).Arguments = args.ToArray ();  	else if (parentStatement is AsmStatement.RawDataStatement)  		((AsmStatement.RawDataStatement)parentStatement).Data = args.ToArray ();  	break;  case DTokens.Semicolon:  	Step ();  	break;  case DTokens.Literal:  	l.Add (new AsmStatement.RawDataStatement {  		Location = la.Location'  		Data = new[] {  			ParseAsmPrimaryExpression (Scope' Parent)  		}'  		EndLocation = t.EndLocation'  		Parent = Parent  	});  	Expect (DTokens.Semicolon);  	break;  default:  	string val;  	if (!retrying && Keywords.TryGetValue (laKind' out val)) {  		la.LiteralValue = val;  		la.Kind = Identifier;  		Lexer.laKind = Identifier;  		retrying = true;  		goto Retry;  	} else {  		noStatement = true;  		SynErr (Identifier);  		Step ();  	}  	break;  }  
Magic Number,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmStatement,The following statement contains a magic number: if (AsmStatement.RawDataStatement.TryParseDataType (la.Value' out dataType))  	l.Add (new AsmStatement.RawDataStatement () {  		Location = la.Location'  		Parent = s'  		TypeOfData = dataType  	});  else if (AsmStatement.InstructionStatement.TryParseOpCode (la.Value' out opCode))  	l.Add (new AsmStatement.InstructionStatement () {  		Location = la.Location'  		Parent = s'  		Operation = opCode  	});  else  	switch (la.Value.ToLower ()) {  	case "pause":  		SynErr (Identifier' "Pause is not supported by dmd's assembler. Use `rep; nop;` instead to achieve the same effect.");  		break;  	case "even":  		als = new AsmStatement.AlignStatement () {  			Location = la.Location'  			Parent = s  		};  		als.ValueExpression = new IdentifierExpression (2) {  			Location = la.Location'  			EndLocation = la.EndLocation  		};  		l.Add (als);  		break;  	case "naked":  		noStatement = true;  		break;  	default:  		SynErr (Identifier' "Unknown op-code!");  		l.Add (new AsmStatement.InstructionStatement () {  			Location = la.Location'  			Parent = s'  			Operation = AsmStatement.InstructionStatement.OpCode.__UNKNOWN__  		});  		break;  	}  
Magic Number,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmStatement,The following statement contains a magic number: if (AsmStatement.InstructionStatement.TryParseOpCode (la.Value' out opCode))  	l.Add (new AsmStatement.InstructionStatement () {  		Location = la.Location'  		Parent = s'  		Operation = opCode  	});  else  	switch (la.Value.ToLower ()) {  	case "pause":  		SynErr (Identifier' "Pause is not supported by dmd's assembler. Use `rep; nop;` instead to achieve the same effect.");  		break;  	case "even":  		als = new AsmStatement.AlignStatement () {  			Location = la.Location'  			Parent = s  		};  		als.ValueExpression = new IdentifierExpression (2) {  			Location = la.Location'  			EndLocation = la.EndLocation  		};  		l.Add (als);  		break;  	case "naked":  		noStatement = true;  		break;  	default:  		SynErr (Identifier' "Unknown op-code!");  		l.Add (new AsmStatement.InstructionStatement () {  			Location = la.Location'  			Parent = s'  			Operation = AsmStatement.InstructionStatement.OpCode.__UNKNOWN__  		});  		break;  	}  
Magic Number,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmStatement,The following statement contains a magic number: switch (la.Value.ToLower ()) {  case "pause":  	SynErr (Identifier' "Pause is not supported by dmd's assembler. Use `rep; nop;` instead to achieve the same effect.");  	break;  case "even":  	als = new AsmStatement.AlignStatement () {  		Location = la.Location'  		Parent = s  	};  	als.ValueExpression = new IdentifierExpression (2) {  		Location = la.Location'  		EndLocation = la.EndLocation  	};  	l.Add (als);  	break;  case "naked":  	noStatement = true;  	break;  default:  	SynErr (Identifier' "Unknown op-code!");  	l.Add (new AsmStatement.InstructionStatement () {  		Location = la.Location'  		Parent = s'  		Operation = AsmStatement.InstructionStatement.OpCode.__UNKNOWN__  	});  	break;  }  
Magic Number,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmStatement,The following statement contains a magic number: als.ValueExpression = new IdentifierExpression (2) {  	Location = la.Location'  	EndLocation = la.EndLocation  };  
Magic Number,D_Parser.Parser,DDocParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,Parameters,The following statement contains a magic number: while (!Finished) {  	switch (Peek ()) {  	case ''':  		if (curParam > 9) {  			Step ();  			break;  		}  		l ["$" + curParam.ToString ()] = text.Substring (paramBegin' nextOffset - paramBegin);  		Step ();  		if (curParam == 1)  			// Second parameter begins now -- will be $+ then  			secondParamBegin = nextOffset;  		paramBegin = nextOffset;  		curParam++;  		break;  	default:  		SkipParameterText ();  		break;  	}  }  
Magic Number,D_Parser.Parser,DDocParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,Parameters,The following statement contains a magic number: switch (Peek ()) {  case ''':  	if (curParam > 9) {  		Step ();  		break;  	}  	l ["$" + curParam.ToString ()] = text.Substring (paramBegin' nextOffset - paramBegin);  	Step ();  	if (curParam == 1)  		// Second parameter begins now -- will be $+ then  		secondParamBegin = nextOffset;  	paramBegin = nextOffset;  	curParam++;  	break;  default:  	SkipParameterText ();  	break;  }  
Magic Number,D_Parser.Parser,DDocParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,Parameters,The following statement contains a magic number: if (curParam > 9) {  	Step ();  	break;  }  
Magic Number,D_Parser.Parser,DDocParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,Parameters,The following statement contains a magic number: if (curParam > 1 && curParam < 9)  	l ["$" + curParam.ToString ()] = text.Substring (paramBegin' nextOffset - paramBegin);  
Magic Number,D_Parser.Parser,DDocParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,SkipParameterText,The following statement contains a magic number: switch (Peek ()) {  case '(':  	SkipParentheses ();  	break;  case '"':  case '\'':  	SkipString ();  	break;  case '<':  	Read ();  	if (Peek () == '!' && nextOffset + 2 < text.Length && text [nextOffset + 1] == '-' && text [nextOffset + 2] == '-') {  		Step ();  		// !  		Step ();  		// -  		Step ();  		// -  		SkipHtmlComment ();  	} else  		SkipParameterText ();  	break;  case '\0':  case ')':  	break;  default:  	Step ();  	break;  }  
Magic Number,D_Parser.Parser,DDocParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,SkipParameterText,The following statement contains a magic number: switch (Peek ()) {  case '(':  	SkipParentheses ();  	break;  case '"':  case '\'':  	SkipString ();  	break;  case '<':  	Read ();  	if (Peek () == '!' && nextOffset + 2 < text.Length && text [nextOffset + 1] == '-' && text [nextOffset + 2] == '-') {  		Step ();  		// !  		Step ();  		// -  		Step ();  		// -  		SkipHtmlComment ();  	} else  		SkipParameterText ();  	break;  case '\0':  case ')':  	break;  default:  	Step ();  	break;  }  
Magic Number,D_Parser.Parser,DDocParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,SkipParameterText,The following statement contains a magic number: if (Peek () == '!' && nextOffset + 2 < text.Length && text [nextOffset + 1] == '-' && text [nextOffset + 2] == '-') {  	Step ();  	// !  	Step ();  	// -  	Step ();  	// -  	SkipHtmlComment ();  } else  	SkipParameterText ();  
Magic Number,D_Parser.Parser,DDocParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,SkipParameterText,The following statement contains a magic number: if (Peek () == '!' && nextOffset + 2 < text.Length && text [nextOffset + 1] == '-' && text [nextOffset + 2] == '-') {  	Step ();  	// !  	Step ();  	// -  	Step ();  	// -  	SkipHtmlComment ();  } else  	SkipParameterText ();  
Magic Number,D_Parser.Dom.Expressions,ArrayLiteralExpression,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Expressions\ArrayLiteralExpression.cs,ToString,The following statement contains a magic number: if (Elements != null)  	for (int i = 0; i < Elements.Count; i++) {  		s += Elements [i].ToString () + "' ";  		if (i == 100) {  			s += "...";  			break;  		}  	}  
Magic Number,D_Parser.Dom.Expressions,ArrayLiteralExpression,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Expressions\ArrayLiteralExpression.cs,ToString,The following statement contains a magic number: for (int i = 0; i < Elements.Count; i++) {  	s += Elements [i].ToString () + "' ";  	if (i == 100) {  		s += "...";  		break;  	}  }  
Magic Number,D_Parser.Dom.Expressions,ArrayLiteralExpression,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Expressions\ArrayLiteralExpression.cs,ToString,The following statement contains a magic number: if (i == 100) {  	s += "...";  	break;  }  
Missing Default,D_Parser.Dom,BuiltInAtAttribute,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Attribute.cs,ToString,The following switch statement is missing a default case: switch (Kind) {  case BuiltInAttributes.Disable:  	return "@disable";  case BuiltInAttributes.Property:  	return "@property";  case BuiltInAttributes.Safe:  	return "@safe";  case BuiltInAttributes.System:  	return "@system";  case BuiltInAttributes.Trusted:  	return "@trusted";  }  
Missing Default,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,EnforceBraceStyle,The following switch statement is missing a default case: switch (braceStyle) {  case BraceStyle.DoNotChange:  	startIndent = endIndent = null;  	break;  case BraceStyle.EndOfLineWithoutSpace:  	startIndent = "";  	endIndent = IsLineIsEmptyUpToEol (rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString;  	break;  case BraceStyle.EndOfLine:  	int lastNonWs;  	var lastComments = GetCommentsBefore (lBrace' out lastNonWs);  	if (lastComments.Count != 0) {  		// delete old bracket  		AddChange (whitespaceStart' lbraceOffset - whitespaceStart + 1' "");  		lbraceOffset = whitespaceStart = lastNonWs + 1;  		startIndent = " {";  	} else {  		startIndent = " ";  	}  	endIndent = IsLineIsEmptyUpToEol (rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString;  	break;  case BraceStyle.NextLine:  	startIndent = this.options.EolMarker + curIndent.IndentString;  	endIndent = IsLineIsEmptyUpToEol (rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString;  	break;  case BraceStyle.NextLineShifted2:  case BraceStyle.NextLineShifted:  	curIndent.Push (IndentType.Block);  	startIndent = this.options.EolMarker + curIndent.IndentString;  	endIndent = IsLineIsEmptyUpToEol (rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString;  	curIndent.Pop ();  	break;  }  
Missing Default,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,Visit,The following switch statement is missing a default case: switch (n.SpecialType) {  case DMethod.MethodType.Destructor:  case DMethod.MethodType.Constructor:  	nameLength = 4;  	// this  	break;  case DMethod.MethodType.Normal:  	nameLength = n.Name.Length;  	break;  }  
Missing Default,D_Parser.Formatting,DFormattingVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,Visit,The following switch statement is missing a default case: switch (policy.MultiVariableDeclPlacement) {  case NewLinePlacement.NewLine:  	curIndent.Push (IndentType.Continuation);  	FixIndentationForceNewLine (n.NameLocation);  	curIndent.Pop ();  	break;  case NewLinePlacement.SameLine:  	ForceSpacesBeforeRemoveNewLines (n.NameLocation' true);  	break;  }  
Missing Default,D_Parser.Misc,CompletionOptions,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\CompletionOptions.cs,Load,The following switch statement is missing a default case: switch (x.LocalName) {  case "EnableResolutionCache":  	EnableResolutionCache = x.ReadString ().ToLower () == "true";  	break;  case "CompletionTimeout":  	int.TryParse (x.ReadString ()' out CompletionTimeout);  	break;  case "EnableUFCSCompletion":  	ShowUFCSItems = x.ReadString ().ToLower () == "true";  	break;  case "EnableDeclarationConstraints":  	EnableDeclarationConstraints = x.ReadString ().ToLower () == "true";  	break;  case "MixinAnalysis":  	DisableMixinAnalysis = x.ReadString ().ToLower () != "true";  	break;  case "CompletionSuggestionMode":  	EnableSuggestionMode = x.ReadString ().ToLower () == "true";  	break;  case "HideDeprecatedNodes":  	HideDeprecatedNodes = x.ReadString ().ToLower () == "true";  	break;  case "HideDisabledNodes":  	HideDisabledNodes = x.ReadString ().ToLower () == "true";  	break;  case "ShowStructMembersInStructInitOnly":  	ShowStructMembersInStructInitOnly = x.ReadString ().ToLower () == "true";  	break;  }  
Missing Default,D_Parser.Misc,VersionIdEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\VersionIdEvaluation.cs,GetOSAndCPUVersions,The following switch statement is missing a default case: switch (OS) {  case Platform.Windows:  	l.Add ("Windows");  	l.Add (is64BitOS ? "Win64" : "Win32");  	break;  case Platform.Linux:  	l.Add ("Posix");  	l.Add ("linux");  	break;  case Platform.Mac:  	l.Add ("OSX");  	l.Add ("darwin");  	l.Add ("Posix");  	break;  }  
Missing Default,D_Parser.Misc,ConsoleLogger,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Logger.cs,Log,The following switch statement is missing a default case: switch (lvl) {  case LogLevel.Debug:  	Console.Write ("Debug: ");  	break;  case LogLevel.Error:  	Console.Write ("Error: ");  	break;  case LogLevel.Fatal:  	Console.Write ("Fatal error: ");  	break;  case LogLevel.Info:  	Console.Write ("Info: ");  	break;  case LogLevel.Warn:  	Console.Write ("Warning: ");  	break;  }  
Missing Default,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,TemplateArg,The following switch statement is missing a default case: switch ((char)r.Read ()) {  case 'T':  	return new TypeDeclarationExpression (DTypeToTypeDeclVisitor.GenerateTypeDecl (Type ()));  case 'V':  	var t = Type ();  	// Where should the explicit type be used when there's already a value?  	return Value ();  case 'S':  	return new IdentifierExpression (LName ()' LiteralFormat.StringLiteral);  }  
Missing Default,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Type,The following switch statement is missing a default case: switch (type) {  case 'O':  	var t = Type ();  	t.Modifier = DTokens.Shared;  	return t;  case 'x':  	t = Type ();  	t.Modifier = DTokens.Const;  	return t;  case 'y':  	t = Type ();  	t.Modifier = DTokens.Immutable;  	return t;  case 'N':  	switch (r.Read ()) {  	case 'g':  		t = Type ();  		t.Modifier = DTokens.InOut;  		return t;  	case 'e':  		// TypeNewArray ?  		Type ();  		return null;  	}  	break;  case 'A':  	return new ArrayType (Type ());  case 'G':  	var len = (int)Number ();  	return new ArrayType (Type ()' len);  case 'H':  	var keyType = Type ();  	t = Type ();  	return new AssocArrayType (t' keyType);  case 'P':  	return new PointerType (Type ());  case 'F':  case 'U':  case 'W':  case 'V':  case 'R':  	AbstractType ret;  	List<DAttribute> attrs;  	Dictionary<INode' AbstractType> pars;  	Function (out ret' out attrs' out pars' type);  	var dm = new DMethod {  		Attributes = attrs  	};  	dm.Parameters.AddRange (pars.Keys);  	return new MemberSymbol (dm' ret' null);  case 'C':  case 'S':  case 'E':  case 'T':  case 'I':  	return TypeDeclarationResolver.ResolveSingle (QualifiedName ()' ctxt);  /* 					return new MemberSymbol(null'null' QualifiedName()); 				case 'C': 					return new ClassType(new DClassLike(DTokens.Class)' QualifiedName()' null); 				case 'S': 					return new StructType(new DClassLike(DTokens.Struct)' QualifiedName()); 				case 'E': 					return new EnumType(new DEnum()' null' QualifiedName()); 				case 'T': 					return new AliasedType(null' null' QualifiedName()); 				*/case 'D':  	Function (out ret' out attrs' out pars' type);  	var dgArgs = new List<AbstractType> ();  	foreach (var kv in pars)  		dgArgs.Add (new MemberSymbol (kv.Key as DNode' kv.Value' null));  	return new DelegateType (ret' new DelegateDeclaration {  		Parameters = pars.Keys.ToList ()  	}' dgArgs);  case 'v':  	return new PrimitiveType (DTokens.Void);  case 'g':  	return new PrimitiveType (DTokens.Byte);  case 'h':  	return new PrimitiveType (DTokens.Ubyte);  case 's':  	return new PrimitiveType (DTokens.Short);  case 't':  	return new PrimitiveType (DTokens.Ushort);  case 'i':  	return new PrimitiveType (DTokens.Int);  case 'k':  	return new PrimitiveType (DTokens.Uint);  case 'l':  	return new PrimitiveType (DTokens.Long);  case 'm':  	return new PrimitiveType (DTokens.Ulong);  case 'f':  	return new PrimitiveType (DTokens.Float);  case 'd':  	return new PrimitiveType (DTokens.Double);  case 'e':  	return new PrimitiveType (DTokens.Real);  case 'o':  	return new PrimitiveType (DTokens.Ifloat);  case 'p':  	return new PrimitiveType (DTokens.Idouble);  case 'j':  	return new PrimitiveType (DTokens.Ireal);  case 'q':  	return new PrimitiveType (DTokens.Cfloat);  case 'r':  	return new PrimitiveType (DTokens.Cdouble);  case 'c':  	return new PrimitiveType (DTokens.Creal);  case 'b':  	return new PrimitiveType (DTokens.Bool);  case 'a':  	return new PrimitiveType (DTokens.Char);  case 'u':  	return new PrimitiveType (DTokens.Wchar);  case 'w':  	return new PrimitiveType (DTokens.Dchar);  case 'n':  	return null;  case 'B':  	len = (int)Number ();  	var items = new AbstractType[len];  	var c = (char)r.Read ();  	for (int i = 0; i < len; i++) {  		Argument (ref c' out items [i]);  	}  	return new DTuple (items);  }  
Missing Default,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Type,The following switch statement is missing a default case: switch (r.Read ()) {  case 'g':  	t = Type ();  	t.Modifier = DTokens.InOut;  	return t;  case 'e':  	// TypeNewArray ?  	Type ();  	return null;  }  
Missing Default,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Function,The following switch statement is missing a default case: switch (callConvention) {  case 'U':  	conv = "C";  	break;  case 'W':  	conv = "Windows";  	break;  case 'V':  	conv = "Pascal";  	break;  case 'R':  	conv = "C++";  	break;  }  
Missing Default,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Function,The following switch statement is missing a default case: switch (r.Peek ()) {  case 'a':  	r.Read ();  	nextChar = (char)r.Read ();  	attributes.Add (new Modifier (DTokens.Pure));  	continue;  case 'b':  	r.Read ();  	nextChar = (char)r.Read ();  	attributes.Add (new Modifier (DTokens.Nothrow));  	continue;  case 'c':  	r.Read ();  	nextChar = (char)r.Read ();  	attributes.Add (new Modifier (DTokens.Ref));  	continue;  case 'd':  	r.Read ();  	nextChar = (char)r.Read ();  	attributes.Add (new BuiltInAtAttribute (BuiltInAtAttribute.BuiltInAttributes.Property));  	continue;  case 'e':  	r.Read ();  	nextChar = (char)r.Read ();  	attributes.Add (new BuiltInAtAttribute (BuiltInAtAttribute.BuiltInAttributes.Trusted));  	continue;  case 'f':  	r.Read ();  	nextChar = (char)r.Read ();  	attributes.Add (new BuiltInAtAttribute (BuiltInAtAttribute.BuiltInAttributes.Safe));  	continue;  }  
Missing Default,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Argument,The following switch statement is missing a default case: switch (c) {  case 'J':  	par.Attributes.Add (new Modifier (DTokens.Out));  	break;  case 'K':  	par.Attributes.Add (new Modifier (DTokens.Ref));  	break;  case 'L':  	par.Attributes.Add (new Modifier (DTokens.Lazy));  	break;  }  
Missing Default,D_Parser.Misc.Mangling,Demangler,D:\newReposJune17\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The following switch statement is missing a default case: switch (p) {  case 'n':  	r.Read ();  	return new TokenExpression (DTokens.Null);  case 'N':  	r.Read ();  	return new IdentifierExpression (-Number ()' LiteralFormat.Scalar' LiteralSubformat.Integer);  case 'i':  	r.Read ();  	return new IdentifierExpression (-Number ()' LiteralFormat.Scalar' LiteralSubformat.Integer | LiteralSubformat.Imaginary);  case 'e':  	// HexFloat  	r.Read ();  	return HexFloat ();  case 'c':  	// Complex  	r.Read ();  	var re = HexFloat ();  	r.Read ();  	// Skip further c  	var im = HexFloat ();  	//TODO  	return re;  case 'H':  case 'A':  case 'S':  	r.Read ();  	var n = (int)Number ();  	var xx = new List<IExpression> ();  	for (int i = n; i > 0; i--)  		xx.Add (Value ());  	if (p == 'S') {  		var inits = new List<StructMemberInitializer> (xx.Count);  		for (int i = n - 1; i >= 0; i--)  			inits.Add (new StructMemberInitializer {  				Value = xx [i]  			});  		return new StructInitializer {  			MemberInitializers = inits.ToArray ()  		};  	}  	if (p == 'H' || PeekIsValue)// We've got an AA  	 {  		for (int i = n; i > 0; i--)  			xx.Add (Value ());  		var kv = new List<KeyValuePair<IExpression' IExpression>> (n);  		for (int i = (n * 2) - 1; i > 0; i -= 2)  			kv.Add (new KeyValuePair<IExpression' IExpression> (xx [i - 1]' xx [i]));  		return new AssocArrayExpression {  			Elements = kv  		};  	}  	return new ArrayLiteralExpression (xx);  case 'a':  case 'w':  case 'd':  	r.Read ();  	var len = (int)Number ();  	sb.Clear ();  	for (; len > 0; len--)  		sb.Append ((char)(Lexer.GetHexNumber ((char)r.Read ()) << 4 + Lexer.GetHexNumber ((char)r.Read ())));  	return new IdentifierExpression (sb.ToString ()' LiteralFormat.StringLiteral' p == 'a' ? LiteralSubformat.Utf8 : (p == 'w' ? LiteralSubformat.Utf16 : LiteralSubformat.Utf32));  }  
Missing Default,D_Parser.Refactoring,TypeReferenceFinder,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,Visit,The following switch statement is missing a default case: switch (CheckCondition (s.Condition)) {  case 1:  	if (s.ElseStatement != null)  		invalidConditionalCodeRegions.Add (s.ElseStatement);  	if (s.ScopedStatement != null)  		s.ScopedStatement.Accept (this);  	return;  case -1:  	if (s.ScopedStatement != null)  		invalidConditionalCodeRegions.Add (s.ScopedStatement);  	if (s.ElseStatement != null)  		s.ElseStatement.Accept (this);  	return;  }  
Missing Default,D_Parser.Refactoring,TypeReferenceFinder,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,VisitAttributeMetaDeclarationBlock,The following switch statement is missing a default case: switch (CheckCondition (a.AttributeOrCondition)) {  case 1:  	if (a.OptionalElseBlock != null)  		invalidConditionalCodeRegions.Add (a.OptionalElseBlock);  	break;  case -1:  	invalidConditionalCodeRegions.Add (a);  	break;  }  
Missing Default,D_Parser.Refactoring,TypeReferenceFinder,D:\newReposJune17\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,CheckNode,The following switch statement is missing a default case: switch (CheckCondition (n.Attributes)) {  case -1:  	invalidConditionalCodeRegions.Add (n);  	return false;  }  
Missing Default,D_Parser.Resolver,StaticProperties,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,help_ReflectNonComplexType,The following switch statement is missing a default case: switch (pt.TypeToken) {  case DTokens.Cfloat:  	return new DTokenDeclaration (DTokens.Float);  case DTokens.Cdouble:  	return new DTokenDeclaration (DTokens.Double);  case DTokens.Creal:  	return new DTokenDeclaration (DTokens.Real);  }  
Missing Default,D_Parser.Resolver,StaticProperties,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,help_ReflectResolvedNonComplexType,The following switch statement is missing a default case: switch (pt.TypeToken) {  case DTokens.Cfloat:  	return new PrimitiveType (DTokens.Float);  case DTokens.Cdouble:  	return new PrimitiveType (DTokens.Double);  case DTokens.Creal:  	return new PrimitiveType (DTokens.Real);  }  
Missing Default,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_BoolOp,The following switch statement is missing a default case: switch (x.OperatorToken) {  case DTokens.GreaterThan:  	// greater' >  	relationIsTrue = a.Value > b.Value && (!cmpIm || a.ImaginaryPart > b.ImaginaryPart);  	break;  case DTokens.GreaterEqual:  	// greater or equal' >=  	relationIsTrue = a.Value >= b.Value && a.ImaginaryPart >= b.ImaginaryPart;  	break;  case DTokens.LessThan:  	// less' <  	relationIsTrue = a.Value < b.Value && (!cmpIm || a.ImaginaryPart < b.ImaginaryPart);  	break;  case DTokens.LessEqual:  	// less or equal' <=  	relationIsTrue = a.Value <= b.Value && a.ImaginaryPart <= b.ImaginaryPart;  	break;  case DTokens.Unordered:  	// unordered' !<>=  	relationIsTrue = unordered;  	break;  case DTokens.LessOrGreater:  	// less or greater' <>  	relationIsTrue = (a.Value < b.Value || a.Value > b.Value) && (!cmpIm || (a.ImaginaryPart < b.ImaginaryPart || a.ImaginaryPart > b.ImaginaryPart));  	break;  case DTokens.LessEqualOrGreater:  	// less' equal' or greater' <>=  	relationIsTrue = (a.Value < b.Value || a.Value >= b.Value) && (!cmpIm || (a.ImaginaryPart < b.ImaginaryPart || a.ImaginaryPart >= b.ImaginaryPart));  	break;  case DTokens.UnorderedOrGreater:  	// unordered or greater' !<=  	relationIsTrue = unordered || (a.Value > b.Value && (!cmpIm || a.ImaginaryPart > b.ImaginaryPart));  	break;  case DTokens.UnorderedGreaterOrEqual:  	// unordered' greater' or equal' !<  	relationIsTrue = unordered || (a.Value >= b.Value && a.ImaginaryPart >= b.ImaginaryPart);  	break;  case DTokens.UnorderedOrLess:  	// unordered or less' !>=  	relationIsTrue = unordered || (a.Value < b.Value && (!cmpIm || a.ImaginaryPart < b.ImaginaryPart));  	break;  case DTokens.UnorderedLessOrEqual:  	// unordered' less' or equal' !>  	relationIsTrue = unordered || (a.Value <= b.Value && a.ImaginaryPart <= b.ImaginaryPart);  	break;  case DTokens.UnorderedOrEqual:  	// unordered or equal' !<>  	relationIsTrue = unordered || (a.Value == b.Value && a.ImaginaryPart == b.ImaginaryPart);  	break;  }  
Missing Default,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The following switch statement is missing a default case: switch (x.OperatorToken) {  case DTokens.ShiftLeft:  	return (long)a.Value << (int)b.Value;  // TODO: Handle the imaginary part  case DTokens.ShiftRight:  	return (long)a.Value >> (int)b.Value;  case DTokens.ShiftRightUnsigned:  	//TODO: Find out where's the difference between >> and >>>  	return (ulong)a.Value >> (int)(uint)b.Value;  }  
Missing Default,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The following switch statement is missing a default case: switch (op.OperatorToken) {  case DTokens.Plus:  	return new PrimitiveValue (a.BaseTypeToken' a.Value + b.Value' a.ImaginaryPart + b.ImaginaryPart' a.Modifier);  case DTokens.Minus:  	return new PrimitiveValue (a.BaseTypeToken' a.Value - b.Value' a.ImaginaryPart - b.ImaginaryPart' a.Modifier);  }  
Missing Default,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_EvalSpecToken,The following switch statement is missing a default case: switch (isExpression.TypeSpecializationToken) {  /* 				 * To handle semantic tokens like "return" or "super" it's just needed to  				 * look into the current resolver context - 				 * then' we'll be able to gather either the parent method or the currently scoped class definition. 				 */case DTokens.Struct:  case DTokens.Union:  case DTokens.Class:  case DTokens.Interface:  	if (r = typeToCheck is UserDefinedType && ((TemplateIntermediateType)typeToCheck).Definition.ClassType == isExpression.TypeSpecializationToken)  		res = typeToCheck;  	break;  case DTokens.Enum:  	if (!(typeToCheck is EnumType))  		break;  	{  		var tr = (UserDefinedType)typeToCheck;  		r = true;  		res = tr.Base;  	}  	break;  case DTokens.Function:  case DTokens.Delegate:  	if (typeToCheck is DelegateType) {  		var isFun = false;  		var dgr = (DelegateType)typeToCheck;  		if (!dgr.IsFunctionLiteral)  			r = isExpression.TypeSpecializationToken == ((isFun = dgr.IsFunction) ? DTokens.Function : DTokens.Delegate);  		// Must be a delegate otherwise  		else  			isFun = !(r = isExpression.TypeSpecializationToken == DTokens.Delegate);  		if (r) {  			//TODO  			if (isFun) {  				// TypeTuple of the function parameter types. For C- and D-style variadic functions' only the non-variadic parameters are included.   				// For typesafe variadic functions' the ... is ignored.  			} else {  				// the function type of the delegate  			}  		}  	} else// Normal functions are also accepted as delegates  	 {  		r = isExpression.TypeSpecializationToken == DTokens.Delegate && typeToCheck is MemberSymbol && ((DSymbol)typeToCheck).Definition is DMethod;  		//TODO: Alias handling' same as couple of lines above  	}  	break;  case DTokens.Super:  	//TODO: Test this  	var dc = DResolver.SearchClassLikeAt (ctxt.ScopedBlock' isExpression.Location) as DClassLike;  	if (dc != null) {  		var udt = DResolver.ResolveClassOrInterface (dc' ctxt' null' true) as ClassType;  		if (r = udt.Base != null && ResultComparer.IsEqual (typeToCheck' udt.Base)) {  			var l = new List<AbstractType> ();  			if (udt.Base != null)  				l.Add (udt.Base);  			if (udt.BaseInterfaces != null && udt.BaseInterfaces.Length != 0)  				l.AddRange (udt.BaseInterfaces);  			res = new DTuple (l);  		}  	}  	break;  case DTokens.Const:  case DTokens.Immutable:  case DTokens.InOut:  // TODO?  case DTokens.Shared:  	if (r = typeToCheck.Modifier == isExpression.TypeSpecializationToken)  		res = typeToCheck;  	break;  case DTokens.Return:  	// TODO: Test  	var dm = DResolver.SearchBlockAt (ctxt.ScopedBlock' isExpression.Location) as DMethod;  	if (dm != null) {  		var retType_ = TypeDeclarationResolver.GetMethodReturnType (dm' ctxt);  		if (r = retType_ != null && ResultComparer.IsEqual (typeToCheck' retType_))  			res = retType_;  	}  	break;  }  
Missing Default,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The following switch statement is missing a default case: switch (te.Keyword) {  case "":  case null:  	return null;  case "hasMember":  	bool ret = false;  	var optionsBackup = ctxt.ContextIndependentOptions;  	ctxt.ContextIndependentOptions = ResolutionOptions.IgnoreAllProtectionAttributes;  	AbstractType t;  	var pfa = ExpressionTypeEvaluation.prepareMemberTraitExpression (ctxt' te' out t' ValueProvider);  	if (pfa != null && t != null) {  		t.NonStaticAccess = true;  		ignoreErrors = true;  		var res = ExpressionTypeEvaluation.EvaluateType (pfa' ctxt' false);  		ret = res != null;  		ignoreErrors = false;  	}  	ctxt.ContextIndependentOptions = optionsBackup;  	return new PrimitiveValue (ret);  case "identifier":  	if (te.Arguments != null && te.Arguments.Length == 1)  		return new ArrayValue (GetStringType ()' te.Arguments [0].ToString ());  	break;  case "getMember":  	pfa = ExpressionTypeEvaluation.prepareMemberTraitExpression (ctxt' te' out t' ValueProvider);  	if (pfa == null || t == null)  		break;  	var vs = EvalPostfixAccessExpression (this' ctxt' pfa' t' ValueProvider: ValueProvider);  	if (vs == null || vs.Length == 0)  		return null;  	return vs [0];  case "getOverloads":  	optionsBackup = ctxt.ContextIndependentOptions;  	ctxt.ContextIndependentOptions = ResolutionOptions.IgnoreAllProtectionAttributes;  	pfa = ExpressionTypeEvaluation.prepareMemberTraitExpression (ctxt' te' out t' ValueProvider);  	if (pfa != null && t != null)  		vs = EvalPostfixAccessExpression (this' ctxt' pfa' t);  	else  		vs = null;  	ctxt.ContextIndependentOptions = optionsBackup;  	return new TypeValue (new DTuple (vs));  case "getProtection":  	optionsBackup = ctxt.ContextIndependentOptions;  	ctxt.ContextIndependentOptions = ResolutionOptions.IgnoreAllProtectionAttributes;  	var prot = "public";  	if (te.Arguments == null || te.Arguments.Length != 1 || te.Arguments [0] == null)  		EvalError (te' "First trait argument must be a symbol identifier");  	else {  		t = ExpressionTypeEvaluation.ResolveTraitArgument (ctxt' te.Arguments [0]);  		if (t is DSymbol) {  			var dn = (t as DSymbol).Definition;  			if (dn.ContainsAttribute (DTokens.Private))  				prot = "private";  			else if (dn.ContainsAttribute (DTokens.Protected))  				prot = "protected";  			else if (dn.ContainsAttribute (DTokens.Package))  				prot = "package";  			else if (dn.ContainsAttribute (DTokens.Export))  				prot = "export";  		} else  			EvalError (te' "First argument must evaluate to an existing code symbol");  	}  	ctxt.ContextIndependentOptions = optionsBackup;  	return new ArrayValue (GetStringType ()' prot);  case "getVirtualFunctions":  	break;  case "getVirtualMethods":  	break;  case "parent":  	break;  case "classInstanceSize":  	break;  case "allMembers":  	break;  case "derivedMembers":  	break;  case "isSame":  	ret = false;  	if (te.Arguments == null || te.Arguments.Length < 2) {  		EvalError (te' "isSame requires two arguments to compare");  	} else {  		t = ExpressionTypeEvaluation.ResolveTraitArgument (ctxt' te.Arguments [0]);  		if (t != null) {  			var t2 = ExpressionTypeEvaluation.ResolveTraitArgument (ctxt' te.Arguments [1]);  			if (t2 != null)  				ret = Resolver.ResultComparer.IsEqual (t' t2);  		}  	}  	return new PrimitiveValue (ret);  case "compiles":  	ret = false;  	if (te.Arguments != null) {  		foreach (var arg in te.Arguments) {  			ret = arg == null || ExpressionTypeEvaluation.ResolveTraitArgument (ctxt' arg) != null;  			if (!ret)  				break;  		}  	}  	return new PrimitiveValue (ret);  }  
Missing Default,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The following switch statement is missing a default case: switch (te.Keyword) {  case "isArithmetic":  	var pt = t as PrimitiveType;  	ret = pt != null && (DTokens.IsBasicType_Integral (pt.TypeToken) || DTokens.IsBasicType_FloatingPoint (pt.TypeToken));  	break;  case "isFloating":  	pt = t as PrimitiveType;  	ret = pt != null && DTokens.IsBasicType_FloatingPoint (pt.TypeToken);  	break;  case "isIntegral":  	pt = t as PrimitiveType;  	ret = pt != null && DTokens.IsBasicType_Integral (pt.TypeToken);  	break;  case "isScalar":  	pt = t as PrimitiveType;  	ret = pt != null && DTokens.IsBasicType (pt.TypeToken);  	break;  case "isUnsigned":  	pt = t as PrimitiveType;  	ret = pt != null && DTokens.IsBasicType_Unsigned (pt.TypeToken);  	break;  case "isAbstractClass":  	ret = t is ClassType && (t as ClassType).Definition.ContainsAttribute (DTokens.Abstract);  	break;  case "isFinalClass":  	ret = t is ClassType && (t as ClassType).Definition.ContainsAttribute (DTokens.Final);  	break;  case "isAssociativeArray":  	ret = t is AssocArrayType && !(t is ArrayType);  	break;  case "isStaticArray":  	ret = t is ArrayType && (t as ArrayType).IsStaticArray;  	break;  }  
Missing Default,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,The following switch statement is missing a default case: switch (mod.Token) {  case DTokens.Const:  case DTokens.Immutable:  case DTokens.Shared:  case DTokens.Nothrow:  	// ?  	// not DTokens.Pure due to some mystical reasons  	skip = true;  	break;  }  
Missing Default,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,The following switch statement is missing a default case: switch (te.Keyword) {  case "":  case null:  	return null;  case "identifier":  	return GetStringType ();  case "getMember":  	pfa = prepareMemberTraitExpression (te' out t);  	if (pfa == null || t == null)  		break;  	var vs = Evaluation.EvalPostfixAccessExpression (this' ctxt' pfa' t);  	if (vs == null || vs.Length == 0)  		return null;  	return vs [0];  case "getOverloads":  	optionsBackup = ctxt.ContextIndependentOptions;  	ctxt.ContextIndependentOptions = ResolutionOptions.IgnoreAllProtectionAttributes;  	pfa = prepareMemberTraitExpression (te' out t);  	if (pfa != null && t != null)  		vs = Evaluation.EvalPostfixAccessExpression (this' ctxt' pfa' t);  	else  		vs = null;  	ctxt.ContextIndependentOptions = optionsBackup;  	return new DTuple (vs);  case "getProtection":  	return GetStringType ();  case "getVirtualFunctions":  	break;  case "getVirtualMethods":  	break;  case "parent":  	break;  case "classInstanceSize":  	break;  case "allMembers":  	break;  case "derivedMembers":  	break;  case "compiles":  	return new PrimitiveType (DTokens.Bool);  }  
Missing Default,D_Parser.Resolver.ExpressionSemantics,MathOperationEvaluation,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MathOperationEvaluation.cs,TryCalc,The following switch statement is missing a default case: switch (op) {  case MathOp.Add:  	x = i1 + i2;  	break;  case MathOp.Sub:  	x = i1 - i2;  	break;  case MathOp.Mul:  	x = i1 * i2;  	break;  case MathOp.Div:  	x = i1 / i2;  	break;  case MathOp.Xor:  	x = i1 ^ i2;  	break;  case MathOp.Or:  	x = i1 | i2;  	break;  case MathOp.And:  	x = i1 & i2;  	break;  case MathOp.AndAnd:  	break;  case MathOp.OrOr:  	break;  }  
Missing Default,D_Parser.Resolver.ExpressionSemantics,PrimitiveValue,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,The following switch statement is missing a default case: switch (BaseTypeToken) {  case DTokens.Void:  	return "void";  case DTokens.Bool:  	return Value == 1M ? "true" : "false";  case DTokens.Char:  case DTokens.Wchar:  case DTokens.Dchar:  	return Char.ConvertFromUtf32 ((int)Value);  }  
Missing Default,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\newReposJune17\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,CanAddMemberOfType,The following switch statement is missing a default case: switch (dc.ClassType) {  case DTokens.Class:  	return (vis & MemberFilter.Classes) != 0;  case DTokens.Interface:  	return (vis & MemberFilter.Interfaces) != 0;  case DTokens.Template:  	return (vis & MemberFilter.Templates) != 0;  case DTokens.Struct:  case DTokens.Union:  	return dc.IsAnonymous ? (vis & MemberFilter.Variables) != 0 : (vis & MemberFilter.StructsAndUnions) != 0;  }  
Missing Default,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,SkipCurrentBlock,The following switch statement is missing a default case: switch (nextChar) {  // Handle line ends  case '\r':  case '\n':  	HandleLineEnd ((char)nextChar);  	break;  // Handle comments  case '/':  	int peek = ReaderPeek ();  	if (peek == '/' || peek == '*' || peek == '+') {  		ReadComment ();  		continue;  	}  	break;  // handle string literals  case 'r':  	int pk = ReaderPeek ();  	if (pk == '"') {  		ReaderRead ();  		ReadVerbatimString ('"');  	}  	break;  case '`':  	ReadVerbatimString (nextChar);  	break;  case '"':  	ReadString (nextChar);  	break;  case '\'':  	ReadChar ();  	break;  case '{':  	braceCount++;  	continue;  case '}':  	braceCount--;  	if (braceCount < 0) {  		lookaheadToken = Token (laKind = DTokens.CloseCurlyBrace' Col - 1' Line);  		StartPeek ();  		Peek ();  		return;  	}  	break;  }  
Missing Default,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following switch statement is missing a default case: switch (ReaderPeek ()) {  case '{':  	return ReadTokenStringLiteral_CurlyInit ();  case '"'/* q"{{ ...}}   }}"*/:  	return ReadTokenStringLiteral_IdentInit ();  }  
Missing Default,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadTokenStringLiteral_IdentInit,The following switch statement is missing a default case: switch (ReaderPeek ()) {  case '\'':  case '"':  case '`':  	// TODO r" " missing  	tokenString.Append ((char)ReaderRead ());  	goto next;  }  
Missing Default,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadTokenStringLiteral_CurlyInit,The following switch statement is missing a default case: switch (tk.Kind) {  case DTokens.OpenCurlyBrace:  	bracketLevel++;  	break;  case DTokens.CloseCurlyBrace:  	if (--bracketLevel < 1)  		continue;  	break;  }  
Missing Default,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,TokenStringParsing_AppendToken,The following switch statement is missing a default case: switch (tk.LiteralFormat) {  case LiteralFormat.CharLiteral:  	tokenString.Append ('\'').Append (tk.LiteralValue).Append ('\'');  	break;  case LiteralFormat.None:  case LiteralFormat.Scalar:  case LiteralFormat.FloatingPoint:  	tokenString.Append (tk.LiteralValue);  	break;  case LiteralFormat.StringLiteral:  	tokenString.Append ('\"').Append (tk.LiteralValue).Append ('\"');  	break;  case LiteralFormat.VerbatimStringLiteral:  	//TODO: More specific distinguishment between verbatim string types  	tokenString.Append ('`').Append (tk.LiteralValue).Append ('`');  	break;  }  
Missing Default,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,TokenStringParsing_AppendLiteralSubFormat,The following switch statement is missing a default case: switch (tk.Subformat) {  case LiteralSubformat.Utf8:  	break;  case LiteralSubformat.Utf16:  	sb.Append ('w');  	break;  case LiteralSubformat.Utf32:  	sb.Append ('d');  	break;  //TODO  }  
Missing Default,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,TryReadExplicitStringFormat,The following switch statement is missing a default case: switch ((char)this.ReaderPeek ()) {  case 'c':  	ReaderRead ();  	break;  case 'd':  	subFmt = LiteralSubformat.Utf32;  	ReaderRead ();  	return;  case 'w':  	subFmt = LiteralSubformat.Utf16;  	ReaderRead ();  	return;  }  
Missing Default,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek ()) {  case '+':  	ReaderRead ();  	return Token (DTokens.Increment' x' y);  case '=':  	ReaderRead ();  	return Token (DTokens.PlusAssign' x' y);  }  
Missing Default,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek ()) {  case '-':  	ReaderRead ();  	return Token (DTokens.Decrement' x' y);  case '=':  	ReaderRead ();  	return Token (DTokens.MinusAssign' x' y);  case '>':  	ReaderRead ();  	return Token (DTokens.TildeAssign' x' y);  }  
Missing Default,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.DivAssign' x' y' 2);  }  
Missing Default,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.ModAssign' x' y' 2);  }  
Missing Default,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek ()) {  case '&':  	ReaderRead ();  	return Token (DTokens.LogicalAnd' x' y' 2);  case '=':  	ReaderRead ();  	return Token (DTokens.BitwiseAndAssign' x' y' 2);  }  
Missing Default,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek ()) {  case '|':  	ReaderRead ();  	return Token (DTokens.LogicalOr' x' y' 2);  case '=':  	ReaderRead ();  	return Token (DTokens.BitwiseOrAssign' x' y' 2);  }  
Missing Default,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.XorAssign' x' y' 2);  case '^':  	ReaderRead ();  	if (ReaderPeek () == '=') {  		ReaderRead ();  		return Token (DTokens.PowAssign' x' y' 3);  	}  	return Token (DTokens.Pow' x' y' 2);  }  
Missing Default,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.UnorderedOrGreater' x' y' 3);  // !<=  case '>':  	ReaderRead ();  	switch (ReaderPeek ()) {  	case '=':  		ReaderRead ();  		return Token (DTokens.Unordered' x' y' 4);  	// !<>=  	}  	return Token (DTokens.UnorderedOrEqual' x' y' 3);  // !<>  }  
Missing Default,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.Unordered' x' y' 4);  // !<>=  }  
Missing Default,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.TildeAssign' x' y' 2);  }  
Missing Default,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.Equal' x' y' 2);  case '>':  	ReaderRead ();  	return Token (DTokens.GoesTo' x' y' 2);  }  
Missing Default,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek ()) {  case '>':  	ReaderRead ();  	if (ReaderPeek () != -1) {  		switch ((char)ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.ShiftRightAssign' x' y' 3);  		case '>':  			ReaderRead ();  			if (ReaderPeek () != -1) {  				switch ((char)ReaderPeek ()) {  				case '=':  					ReaderRead ();  					return Token (DTokens.TripleRightShiftAssign' x' y' 4);  				}  				return Token (DTokens.ShiftRightUnsigned' x' y' 3);  				// >>>  			}  			break;  		}  	}  	return Token (DTokens.ShiftRight' x' y' 2);  case '=':  	ReaderRead ();  	return Token (DTokens.GreaterEqual' x' y' 2);  }  
Missing Default,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch ((char)ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.ShiftRightAssign' x' y' 3);  case '>':  	ReaderRead ();  	if (ReaderPeek () != -1) {  		switch ((char)ReaderPeek ()) {  		case '=':  			ReaderRead ();  			return Token (DTokens.TripleRightShiftAssign' x' y' 4);  		}  		return Token (DTokens.ShiftRightUnsigned' x' y' 3);  		// >>>  	}  	break;  }  
Missing Default,D_Parser.Parser,Lexer,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch ((char)ReaderPeek ()) {  case '=':  	ReaderRead ();  	return Token (DTokens.TripleRightShiftAssign' x' y' 4);  }  
Missing Default,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,AttributeBlock,The following switch statement is missing a default case: switch ((attr as Modifier).Token) {  case DTokens.Virtual:  case DTokens.Final:  	continue;  }  
Missing Default,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,AttributeBlock,The following switch statement is missing a default case: switch ((attr as BuiltInAtAttribute).Kind) {  case BuiltInAtAttribute.BuiltInAttributes.Safe:  case BuiltInAtAttribute.BuiltInAttributes.System:  case BuiltInAtAttribute.BuiltInAttributes.Trusted:  	continue;  }  
Missing Default,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Declaration,The following switch statement is missing a default case: switch (laKind) {  case Identifier:  	switch (Lexer.CurrentPeekToken.Kind) {  	case __EOF__:  	case EOF:  	case DTokens.Semicolon:  	// enum E;  	case DTokens.Colon:  	// enum E : int {...}  	case DTokens.OpenCurlyBrace:  		// enum E {...}  		yield return EnumDeclaration (Scope);  		yield break;  	}  	break;  case __EOF__:  case EOF:  case DTokens.Semicolon:  // enum;  case DTokens.Colon:  // enum : int {...}  case DTokens.OpenCurlyBrace:  	// enum {...}  	yield return EnumDeclaration (Scope);  	yield break;  }  
Missing Default,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,Declaration,The following switch statement is missing a default case: switch (Lexer.CurrentPeekToken.Kind) {  case __EOF__:  case EOF:  case DTokens.Semicolon:  // enum E;  case DTokens.Colon:  // enum E : int {...}  case DTokens.OpenCurlyBrace:  	// enum E {...}  	yield return EnumDeclaration (Scope);  	yield break;  }  
Missing Default,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,IdentifierList,The following switch statement is missing a default case: switch (laKind) {  case DTokens.This:  case DTokens.Super:  	Step ();  	td = new DTokenDeclaration (t.Kind) {  		Location = t.Location'  		EndLocation = t.EndLocation  	};  	if (!Expect (DTokens.Dot))  		return td;  	break;  }  
Missing Default,D_Parser.Parser,DParser,D:\newReposJune17\aBothe_D_Parser\DParser2\Parser\Parser.cs,AtAttribute,The following switch statement is missing a default case: switch (la.Value) {  case "safe":  	att = BuiltInAtAttribute.BuiltInAttributes.Safe;  	break;  case "system":  	att = BuiltInAtAttribute.BuiltInAttributes.System;  	break;  case "trusted":  	att = BuiltInAtAttribute.BuiltInAttributes.Trusted;  	break;  case "property":  	att = BuiltInAtAttribute.BuiltInAttributes.Property;  	break;  case "disable":  	att = BuiltInAtAttribute.BuiltInAttributes.Disable;  	break;  }  
Missing Default,D_Parser.Dom.Statements,GotoStatement,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Statements\GotoStatement.cs,ToCode,The following switch statement is missing a default case: switch (StmtType) {  case GotoStmtType.Identifier:  	return "goto " + LabelIdentifier + ';';  case GotoStmtType.Default:  	return "goto default;";  case GotoStmtType.Case:  	return "goto" + (CaseExpression == null ? "" : (' ' + CaseExpression.ToString ())) + ';';  }  
Missing Default,D_Parser.Dom.Expressions,IdentifierExpression,D:\newReposJune17\aBothe_D_Parser\DParser2\Dom\Expressions\IdentifierExpression.cs,ToString,The following switch statement is missing a default case: switch (Format) {  case Parser.LiteralFormat.CharLiteral:  	return "'" + (EscapeStringHash != 0 ? ("\\" + Strings.TryGet (EscapeStringHash)) : Value ?? "") + "'";  case Parser.LiteralFormat.StringLiteral:  	return "\"" + StringValue + "\"";  case Parser.LiteralFormat.VerbatimStringLiteral:  	return "r\"" + StringValue + "\"";  }  
