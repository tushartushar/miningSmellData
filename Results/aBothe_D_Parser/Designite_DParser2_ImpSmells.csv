Implementation smell,Namespace,Class,File,Method,Description
Long Method,D_Parser.Formatting,DFormattingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,VisitChildren,The method has 111 lines of code.
Long Method,D_Parser.Formatting.Indent,IndentEngine,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushNewLine,The method has 137 lines of code.
Long Method,D_Parser.Formatting.Indent,IndentEngine,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,Push,The method has 193 lines of code.
Long Method,D_Parser.Formatting.Indent,IndentStack,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,The method has 132 lines of code.
Long Method,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Type,The method has 115 lines of code.
Long Method,D_Parser.Parser.Implementations,DAsmStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DAsmStatementParser.cs,ParseAsmStatement,The method has 141 lines of code.
Long Method,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,Decl,The method has 152 lines of code.
Long Method,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,IsAssignExpression,The method has 155 lines of code.
Long Method,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,NewExpression,The method has 145 lines of code.
Long Method,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,PostfixExpression,The method has 163 lines of code.
Long Method,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,PrimaryExpression,The method has 382 lines of code.
Long Method,D_Parser.Parser.Implementations,DModulesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DModulesParser.cs,DeclDef,The method has 189 lines of code.
Long Method,D_Parser.Parser.Implementations,DModulesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DModulesParser.cs,Condition,The method has 124 lines of code.
Long Method,D_Parser.Parser.Implementations,DStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DStatementParser.cs,Statement,The method has 399 lines of code.
Long Method,D_Parser.Parser.Implementations,DTemplatesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DTemplatesParser.cs,TemplateParameter,The method has 117 lines of code.
Long Method,D_Parser.Parser.Implementations,DTemplatesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DTemplatesParser.cs,TemplateInstance,The method has 124 lines of code.
Long Method,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The method has 176 lines of code.
Long Method,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadTokenStringLiteral_IdentInit,The method has 102 lines of code.
Long Method,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The method has 241 lines of code.
Long Method,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The method has 188 lines of code.
Long Method,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The method has 255 lines of code.
Long Method,D_Parser.Resolver,StaticProperties,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,StaticProperties,The method has 168 lines of code.
Long Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The method has 120 lines of code.
Long Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalConcatenation,The method has 112 lines of code.
Long Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_EvalSpecToken,The method has 125 lines of code.
Long Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The method has 264 lines of code.
Complex Method,D_Parser.Completion.Providers,CtrlSpaceCompletionProvider,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\CtrlSpaceCompletionProvider.cs,BuildCompletionDataInternal,Cyclomatic complexity of the method is 21
Complex Method,D_Parser.Completion.Providers,ImportStatementCompletionProvider,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\ImportStatementCompletionProvider.cs,BuildCompletionDataInternal,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Completion.Providers,MemberCompletionProvider,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\MemberCompletionProvider.cs,VisitModuleSymbol,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Completion.Providers,MethodOverrideCompletionProvider,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\MethodOverrideCompletionProvider.cs,GenerateOverridingMethodStub,Cyclomatic complexity of the method is 26
Complex Method,D_Parser.Completion.Providers,InlineAsmCompletionProvider,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\InlineAsmCompletionProvider.cs,InlineAsmCompletionProvider,Cyclomatic complexity of the method is 13
Complex Method,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\ToolTips\NodeTooltipRepresentationGen.cs,DDocToMarkup,Cyclomatic complexity of the method is 18
Complex Method,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\ToolTips\NodeTooltipRepresentationGen.cs,GenTooltipSignature,Cyclomatic complexity of the method is 13
Complex Method,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\ToolTips\NodeTooltipRepresentationGen.cs,GenDelegateSignature,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\ToolTips\NodeTooltipRepresentationGen.cs,AppendParameters,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Dom,DClassLike,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Nodes\OtherNodeDefinitions.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Dom,DNode,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Nodes\DNode.cs,ContainsPropertyAttribute,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Dom,DelegateDeclaration,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\DDeclarations.cs,ToString,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Dom,DefaultDepthFirstVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\DefaultDepthFirstVisitor.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Dom.Expressions,TemplateInstanceExpression,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Expressions\TemplateInstanceExpression.cs,ToString,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Dom.Statements,AsmRawDataStatement,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Statements\AsmRawDataStatement.cs,TryParseDataType,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Dom.Statements,AsmRawDataStatement,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Statements\AsmRawDataStatement.cs,ToCode,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Dom.Statements,AsmInstructionStatement,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Statements\AsmInstructionStatement.cs,AsmInstructionStatement,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Formatting,DFormattingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,EnforceBraceStyle,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Formatting,DFormattingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,GetCommentsBefore,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Formatting,DFormattingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,SearchLastNonWsChar,Cyclomatic complexity of the method is 13
Complex Method,D_Parser.Formatting,DFormattingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,VisitChildren,Cyclomatic complexity of the method is 17
Complex Method,D_Parser.Formatting,DFormattingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,Visit,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Formatting,DFormattingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,Visit,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Formatting,TextDocument,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DocumentAdapter.cs,ToLocation,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Formatting.Indent,IndentEngineWrapper,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CorrectIndent,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Formatting.Indent,IndentEngine,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushSlash,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Formatting.Indent,IndentEngine,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushColon,Cyclomatic complexity of the method is 13
Complex Method,D_Parser.Formatting.Indent,IndentEngine,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushOpenSq,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Formatting.Indent,IndentEngine,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushOpenBrace,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Formatting.Indent,IndentEngine,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushCloseBrace,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Formatting.Indent,IndentEngine,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,Push,Cyclomatic complexity of the method is 43
Complex Method,D_Parser.Formatting.Indent,IndentStack,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,Cyclomatic complexity of the method is 31
Complex Method,D_Parser.Misc,CompletionOptions,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\CompletionOptions.cs,Load,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Misc,VersionIdEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\VersionIdEvaluation.cs,GetOSAndCPUVersions,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Misc,VersionIdEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\VersionIdEvaluation.cs,GetVersionIds,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Misc,GlobalParseCache,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\GlobalParseCache.cs,preparationTh,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,QualifiedName,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,RemoveNestedTemplateRefsFromQualifier,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Type,Cyclomatic complexity of the method is 39
Complex Method,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,Cyclomatic complexity of the method is 17
Complex Method,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,HexFloat,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser.Implementations,DAsmStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DAsmStatementParser.cs,ParseAsmStatement,Cyclomatic complexity of the method is 29
Complex Method,D_Parser.Parser.Implementations,DAsmStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DAsmStatementParser.cs,ParseAsmUnaryExpression,Cyclomatic complexity of the method is 18
Complex Method,D_Parser.Parser.Implementations,DAsmStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DAsmStatementParser.cs,ParseAsmPrimaryExpression,Cyclomatic complexity of the method is 18
Complex Method,D_Parser.Parser.Implementations,DAttributesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DAttributesParser.cs,AttributeSpecifier,Cyclomatic complexity of the method is 17
Complex Method,D_Parser.Parser.Implementations,DAttributesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DAttributesParser.cs,AtAttribute,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Parser.Implementations,DBodiedSymbolsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DBodiedSymbolsParser.cs,InterfaceDeclaration,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser.Implementations,DBodiedSymbolsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DBodiedSymbolsParser.cs,FunctionBody,Cyclomatic complexity of the method is 13
Complex Method,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,Declaration,Cyclomatic complexity of the method is 18
Complex Method,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,Decl,Cyclomatic complexity of the method is 25
Complex Method,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,BasicType,Cyclomatic complexity of the method is 19
Complex Method,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,BasicType2,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,Declarator,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,DeclaratorSuffixes,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,Parameters,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,Parameter,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,GetCurrentAttributeSet,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,IsAssignExpression,Cyclomatic complexity of the method is 28
Complex Method,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,CmpExpression,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,UnaryExpression,Cyclomatic complexity of the method is 15
Complex Method,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,NewExpression,Cyclomatic complexity of the method is 18
Complex Method,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,PostfixExpression,Cyclomatic complexity of the method is 19
Complex Method,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,PrimaryExpression,Cyclomatic complexity of the method is 59
Complex Method,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,ArrayLiteral,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Parser.Implementations,DModulesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DModulesParser.cs,DeclDef,Cyclomatic complexity of the method is 39
Complex Method,D_Parser.Parser.Implementations,DModulesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DModulesParser.cs,Condition,Cyclomatic complexity of the method is 20
Complex Method,D_Parser.Parser.Implementations,DParserImplementationPart,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DParserImplementationPart.cs,CheckForPostSemicolonComment,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Parser.Implementations,DStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DStatementParser.cs,Statement,Cyclomatic complexity of the method is 87
Complex Method,D_Parser.Parser.Implementations,DStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DStatementParser.cs,ForeachStatement,Cyclomatic complexity of the method is 13
Complex Method,D_Parser.Parser.Implementations,DStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DStatementParser.cs,BlockStatement,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser.Implementations,DTemplatesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DTemplatesParser.cs,TemplateMixin,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Parser.Implementations,DTemplatesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DTemplatesParser.cs,TemplateParameter,Cyclomatic complexity of the method is 17
Complex Method,D_Parser.Parser.Implementations,DTemplatesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DTemplatesParser.cs,TemplateInstance,Cyclomatic complexity of the method is 16
Complex Method,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,SkipCurrentBlock,Cyclomatic complexity of the method is 16
Complex Method,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,Cyclomatic complexity of the method is 33
Complex Method,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadTokenStringLiteral_IdentInit,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadIdent,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,Cyclomatic complexity of the method is 31
Complex Method,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,Cyclomatic complexity of the method is 50
Complex Method,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadMultiLineComment,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,Cyclomatic complexity of the method is 17
Complex Method,D_Parser.Parser,IncrementalParsingBase<T>,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\IncrementalParsing.cs,ParseIncrementally,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Refactoring,SortImportsRefactoring,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Refactoring\SortImportsRefactoring.cs,ResortImports,Cyclomatic complexity of the method is 15
Complex Method,D_Parser.Refactoring,SortImportsRefactoring,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Refactoring\SortImportsRefactoring.cs,CalculateImportsToSort,Cyclomatic complexity of the method is 16
Complex Method,D_Parser.Refactoring,ImportDictComparer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Refactoring\SortImportsRefactoring.cs,Compare,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Refactoring,TypeReferenceFinder,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,VisitImport,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Refactoring,NodeTypeDeterminer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,VisitDVariable,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Refactoring,ClassInterfaceDerivativeFinder,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Refactoring\ClassInterfaceDerivativeFinder.cs,HandleItem,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Refactoring,ImportStmtCreation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Refactoring\ImportStmtCreation.cs,FindLastImportStatementEndLocation,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,DeepScanClass,Cyclomatic complexity of the method is 13
Complex Method,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,scanChildren,Cyclomatic complexity of the method is 14
Complex Method,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,HandleAliasThisDeclarations,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,MatchesCompilationConditions,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,SearchAttributesForIsExprDecls,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,CanHandleNode,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,CanAddMemberOfType,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Resolver.ASTScanner,StatementHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,VisitImport,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver.ASTScanner,StatementHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,VisitMixinStatement,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver.ASTScanner,StatementHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.ASTScanner,StatementHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,DetermineForeachKeyValuePairs,Cyclomatic complexity of the method is 13
Complex Method,D_Parser.Resolver.ASTScanner,StatementHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,Visit,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Resolver.ASTScanner,ConditionsFrame,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\ConditionsFrame.cs,GetNextMetaBlockOrStatStmt,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver,ConditionVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ConditionalCompilation.cs,VisitAttributeMetaDeclaration,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver,MixinAnalysis,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\MixinAnalysis.cs,CheckAndPushAnalysisStack,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver,MixinAnalysis,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\MixinAnalysis.cs,GetMixinContent,Cyclomatic complexity of the method is 14
Complex Method,D_Parser.Resolver,ResultComparer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ResultComparer.cs,IsEqual,Cyclomatic complexity of the method is 19
Complex Method,D_Parser.Resolver,ResultComparer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ResultComparer.cs,IsImplicitlyConvertible,Cyclomatic complexity of the method is 18
Complex Method,D_Parser.Resolver,ResultComparer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ResultComparer.cs,IsImplicitlyConvertible,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver,StaticProperties,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,GetOwnerType,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Resolver,ConditionalCompilationFlags,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ConditionalCompilationFlags.cs,IsMatching,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver,MutableConditionFlagSet,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ConditionalCompilationFlags.cs,Add,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver,LooseResolution,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,SearchNodesByName,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Resolver,LooseResolution,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,LookupIdRawly,Cyclomatic complexity of the method is 14
Complex Method,D_Parser.Resolver.ExpressionSemantics.CTFE,FunctionEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\CTFE\FunctionEvaluation.cs,AssignCallArgumentsToIC,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,VisitScalarConstantExpression,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalConcatenation,Cyclomatic complexity of the method is 21
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,mult,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_WithAliases,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_EvalSpecToken,Cyclomatic complexity of the method is 24
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,Cyclomatic complexity of the method is 17
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalPostfixAccessExpression,Cyclomatic complexity of the method is 14
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,AccessArrayAtIndex,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,SliceArray,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,Cyclomatic complexity of the method is 54
Complex Method,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetConstructors,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,Cyclomatic complexity of the method is 19
Complex Method,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,AccessArrayAtIndex,Cyclomatic complexity of the method is 17
Complex Method,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,FilterOutByResultPriority,Cyclomatic complexity of the method is 14
Complex Method,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,Cyclomatic complexity of the method is 16
Complex Method,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,Cyclomatic complexity of the method is 16
Complex Method,D_Parser.Resolver.ExpressionSemantics,MathOperationEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MathOperationEvaluation.cs,TryCalc,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver.ExpressionSemantics,ArrayValue,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.ExpressionSemantics,SymbolValueComparer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\SymbolValueComparer.cs,IsEqual,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Resolver.ExpressionSemantics,OverloadFilterVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MethodOverloadsByParameterTypeComparisonFilter.cs,VisitMemberSymbol,Cyclomatic complexity of the method is 19
Complex Method,D_Parser.Resolver.ExpressionSemantics,OverloadFilterVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MethodOverloadsByParameterTypeComparisonFilter.cs,TryHandleMethodArgumentTuple,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Resolver.ResolutionHooks,bitfields,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\bitfields.cs,TryDeduce,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Resolver.ResolutionHooks,TupleHook,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\Tuple.cs,TryDeduce,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver.Templates,SpecializationOrdering,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\SpecializationOrdering.cs,IsMoreSpecialized,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.Templates,TemplateParameterDeductionVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateParameterDeductionVisitor.cs,Set,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.Templates,TemplateParameterDeductionVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateParameterDeductionVisitor.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.Templates,TemplateParameterDeductionVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateParameterDeductionVisitor.cs,Visit,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,Visit,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,Visit,Cyclomatic complexity of the method is 15
Complex Method,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,Visit,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver.Templates,TemplateInstanceHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,PreResolveTemplateArgs,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Resolver.Templates,TemplateInstanceHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParamsAndFilterOverloads,Cyclomatic complexity of the method is 13
Complex Method,D_Parser.Resolver.Templates,TemplateInstanceHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceOverloads,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Resolver.Templates,TemplateInstanceHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParam,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver.TypeResolution,DSymbolBaseTypeResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\DSymbolBaseTypeResolver.cs,GetMethodReturnType,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Resolver.TypeResolution,DSymbolBaseTypeResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\DSymbolBaseTypeResolver.cs,ResolveDVariableBaseType,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver.TypeResolution,DSymbolBaseTypeResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\DSymbolBaseTypeResolver.cs,GetForeachStatmentIteratorType,Cyclomatic complexity of the method is 13
Complex Method,D_Parser.Resolver.TypeResolution,ClassInterfaceResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\ClassInterfaceResolver.cs,ResolveClassOrInterface,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver.TypeResolution,ClassInterfaceResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\ClassInterfaceResolver.cs,ResolveBaseClassOrInterface,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver.TypeResolution,SingleResolverVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\SingleResolverVisitor.cs,Visit,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,ResolveFurtherTypeIdentifier,Cyclomatic complexity of the method is 17
Complex Method,D_Parser.Resolver.TypeResolution,DResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,StripMemberSymbols,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.TypeResolution,UFCSResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\UFCSResolver.cs,HandleItem,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Completion,ParameterInsightResolution,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\ParameterInsightResolution.cs,Visit,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Completion,CodeCompletion,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\CodeCompletion.cs,GenerateCompletionData,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Completion,CodeCompletion,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\CodeCompletion.cs,FindCurrentCaretContext,Cyclomatic complexity of the method is 9
Complex Method,D_Parser,DocumentHelper,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\DocumentHelper.cs,GetOffsetByRelativeLocation,Cyclomatic complexity of the method is 14
Long Parameter List,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\ToolTips\NodeTooltipRepresentationGen.cs,AppendFormat,The method has 6 parameters. Parameters: content' sb' flags' r' g' b
Long Parameter List,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\ToolTips\NodeTooltipRepresentationGen.cs,GenTooltipSignature,The method has 5 parameters. Parameters: dn' templateParamCompletion' currentMethodParam' baseType' deducedTypes
Long Parameter List,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\ToolTips\NodeTooltipRepresentationGen.cs,AppendMethod,The method has 6 parameters. Parameters: dm' sb' templArgs' curArg' baseType' deducedTypes
Long Parameter List,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\ToolTips\NodeTooltipRepresentationGen.cs,AttributesTypeAndName,The method has 5 parameters. Parameters: dn' sb' baseType' highlightTemplateParam' deducedTypes
Long Parameter List,D_Parser.Dom.Statements,OpCodeDescriptor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Statements\AsmInstructionStatement.cs,OpCodeDescriptor,The method has 8 parameters. Parameters: opcode' name' description' validForms' incomplete' insSet' is32BitOnly' is64BitOnly
Long Parameter List,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,HashEnum,The method has 5 parameters. Parameters: h' prime' l' visPred' mindOrder
Long Parameter List,D_Parser.Formatting,Formatter,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Formatter.cs,FormatCode,The method has 5 parameters. Parameters: code' ast' document' options' textStyle
Long Parameter List,D_Parser.Formatting.Indent,IndentEngineWrapper,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CorrectIndent,The method has 7 parameters. Parameters: code' startOffset' endOffset' documentReplace' options' textStyle' formatLastLine
Long Parameter List,D_Parser.Formatting.Indent,IndentStack,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,The method has 5 parameters. Parameters: inside' keyword' lineNr' nSpaces' indent
Long Parameter List,D_Parser.Misc,ParsingFinishedEventArgs,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\GlobalParseCache.cs,ParsingFinishedEventArgs,The method has 5 parameters. Parameters: dir' pack' duration' parseDuration' fileCount
Long Parameter List,D_Parser.Misc,GlobalParseCache,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\GlobalParseCache.cs,BeginAddOrUpdatePaths,The method has 5 parameters. Parameters: basePaths' skipFunctionBodies' finishedHandler' taskTokens' cancellationToken
Long Parameter List,D_Parser.Parser,Comment,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Tokens\Comment.cs,Comment,The method has 5 parameters. Parameters: commentType' comment' commentStartsLine' startPosition' endPosition
Long Parameter List,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Token,The method has 7 parameters. Parameters: kind' startLocation_Col' startLocation_Line' tokenLength' literalValue' literalFormat' literalSubFormat
Long Parameter List,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Token,The method has 9 parameters. Parameters: kind' startLocation_Col' startLocation_Line' endLocation_Col' endLocation_Line' literalValue' literalFormat' literalSubFormat' rawCode
Long Parameter List,D_Parser.Parser,IncrementalParsing,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\IncrementalParsing.cs,UpdateBlockPartly,The method has 5 parameters. Parameters: bs' code' caretOffset' caretLocation' isInsideNonCodeSegment
Long Parameter List,D_Parser.Parser,IncrementalParsing,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\IncrementalParsing.cs,UpdateBlockPartly,The method has 5 parameters. Parameters: bn' code' caretOffset' caretLocation' isInsideNonCodeSegment
Long Parameter List,D_Parser.Parser,IncrementalParsingBase<T>,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\IncrementalParsing.cs,ParseIncrementally,The method has 5 parameters. Parameters: sr' code' caretOffset' caretLocation' isInsideNonCodeSegment
Long Parameter List,D_Parser.Parser,DDocParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,FindNextMacro,The method has 6 parameters. Parameters: text' startOffset' macroStart' length' macroName' macroParameters
Long Parameter List,D_Parser.Resolver.ASTScanner,StatementHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,StatementHandler,The method has 5 parameters. Parameters: parentNodeOfVisitedStmt' v' parms' caret' pushResolvedCurScope
Long Parameter List,D_Parser.Resolver,StaticProperties,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,ListProperties,The method has 5 parameters. Parameters: gen' ctxt' vis' t' isVariableInstance
Long Parameter List,D_Parser.Resolver,ConditionalCompilationFlags,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ConditionalCompilationFlags.cs,ConditionalCompilationFlags,The method has 5 parameters. Parameters: definedVersionIdentifiers' versionNumber' debug' definedDebugIdentifiers' debugLevel
Long Parameter List,D_Parser.Resolver,LooseResolution,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,SearchNodesByName,The method has 5 parameters. Parameters: idToFind' parseCacheContext' pcw' foundPackages' foundItems
Long Parameter List,D_Parser.Resolver.ExpressionSemantics.CTFE,FunctionEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\CTFE\FunctionEvaluation.cs,AssignCallArgumentsToIC,The method has 5 parameters. Parameters: mr' callArguments' baseValueProvider' targetArgs' ctxt
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,HandleSingleMathOp,The method has 5 parameters. Parameters: x' l' r' m' UnorderedCheck
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalMethodCall,The method has 7 parameters. Parameters: baseExpression' tix' ctxt' call' callArguments' returnBaseTypeOnly' ValueProvider
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalPostfixAccessExpression,The method has 7 parameters. Parameters: vis' ctxt' acc' resultBase' EvalAndFilterOverloads' ResolveImmediateBaseType' ValueProvider
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetUnfilteredMethodOverloads_Helper,The method has 6 parameters. Parameters: foreExpression' ctxt' supExpression' l' staticOnly' ov
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,MethodOverloadCandidateSearchVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MethodOverloadCandidateSearchVisitor.cs,SearchCandidates,The method has 6 parameters. Parameters: baseExpression' ctxt' valueProvider' call' returnBaseTypeOnly' returnInstantly
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,MethodOverloadsByParameterTypeComparisonFilter,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MethodOverloadsByParameterTypeComparisonFilter.cs,FilterOverloads,The method has 6 parameters. Parameters: call' methodOverloads' ctxt' valueProvider' returnBaseTypeOnly' callArguments
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,OverloadFilterVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MethodOverloadsByParameterTypeComparisonFilter.cs,OverloadFilterVisitor,The method has 5 parameters. Parameters: call' ctxt' valueProvider' returnBaseTypeOnly' callArguments
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,OverloadFilterVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MethodOverloadsByParameterTypeComparisonFilter.cs,TryHandleMethodArgumentTuple,The method has 7 parameters. Parameters: ctxt' add' callArguments' dm' deducedTypeDict' currentParameter' currentArg
Long Parameter List,D_Parser.Resolver.Templates,TemplateParameterDeductionVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateParameterDeductionVisitor.cs,Set,The method has 5 parameters. Parameters: ctxt' TargetDictionary' p' r' nameHash
Long Parameter List,D_Parser.Resolver.Templates,TemplateTypeParameterTypeMatcher,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,TryMatchTypeDeclAgainstResolvedResult,The method has 5 parameters. Parameters: td' rr' ctxt' TargetDictionary' enforceTypeEqualityWhenDeducing
Long Parameter List,D_Parser.Resolver.Templates,TemplateTypeParameterTypeMatcher,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,TryMatchTypeDeclAgainstResolvedResult,The method has 6 parameters. Parameters: p' td' rr' ctxt' TargetDictionary' enforceTypeEqualityWhenDeducing
Long Parameter List,D_Parser.Resolver.Templates,TemplateInstanceHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParams,The method has 6 parameters. Parameters: givenTemplateArguments' isMethodCall' ctxt' overload' tplNode' deducedTypes
Long Parameter List,D_Parser.Resolver.Templates,TemplateInstanceHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParam,The method has 5 parameters. Parameters: ctxt' overload' deducedTypes' argEnum' expectedParam
Long Parameter List,D_Parser.Resolver.TypeResolution,ClassInterfaceResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\ClassInterfaceResolver.cs,ResolveClassOrInterface,The method has 5 parameters. Parameters: dc' ctxt' instanceDeclaration' ResolveFirstBaseIdOnly' extraDeducedTemplateParams
Long Parameter List,D_Parser.Resolver.TypeResolution,ClassInterfaceResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\ClassInterfaceResolver.cs,ResolveBaseClasses,The method has 7 parameters. Parameters: dc' ctxt' instanceDeclaration' ResolveFirstBaseIdOnly' deducedTypes' baseClass' interfaces
Long Parameter List,D_Parser.Resolver.TypeResolution,ClassInterfaceResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\ClassInterfaceResolver.cs,ResolveBaseClassOrInterface,The method has 6 parameters. Parameters: type' isFirstBase' dc' ctxt' baseClass' interfaces
Long Parameter List,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,ResolveFurtherTypeIdentifier,The method has 5 parameters. Parameters: nextIdentifierHash' resultBases' ctxt' typeIdObject' ufcsItem
Long Parameter List,D_Parser.Resolver.TypeResolution,UFCSResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\UFCSResolver.cs,TryResolveUFCS,The method has 5 parameters. Parameters: firstArgument' nameHash' nameLoc' ctxt' nameSr
Long Parameter List,D_Parser.Completion,ParameterInsightResolution,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\ParameterInsightResolution.cs,CalculateCurrentArgument,The method has 5 parameters. Parameters: nex' res' caretLocation' ctxt' resultBases
Long Parameter List,D_Parser.Completion,CtorScan,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\ParameterInsightResolution.cs,ScanForConstructors,The method has 5 parameters. Parameters: sr' scope' udt' _ctors' explicitCtorFound
Long Parameter List,D_Parser.Completion,MemberCompletionEnumeration,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\MemberCompletionEnumeration.cs,EnumAllAvailableMembers,The method has 7 parameters. Parameters: cdgen' ScopedBlock' Caret' CodeCache' VisibleMembers' cancelToken' compilationEnvironment
Long Parameter List,D_Parser.Completion,MemberCompletionEnumeration,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\MemberCompletionEnumeration.cs,EnumChildren,The method has 6 parameters. Parameters: cdgen' ctxt' block' isVarInstance' vis' publicImports
Long Identifier,D_Parser.Completion.Providers,PragmaCompletionProvider,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\AttributeCompletionProvider.cs,,The length of the parameter PragmaAttributeCompletionItems is 30.
Long Identifier,D_Parser.Completion.Providers,AttributeCompletionProvider,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\AttributeCompletionProvider.cs,,The length of the parameter ExternAttributeCompletionItems is 30.
Long Identifier,D_Parser.Completion.Providers,TraitsExpressionCompletionProvider,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\AttributeCompletionProvider.cs,,The length of the parameter TraitsExpressionCompletionItems is 31.
Long Identifier,D_Parser.Completion.Providers,CtrlSpaceCompletionProvider,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\CtrlSpaceCompletionProvider.cs,,The length of the parameter PropertyAttributeCompletionItems is 32.
Long Identifier,D_Parser.Completion.Providers,MethodOverrideCompletionProvider,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\MethodOverrideCompletionProvider.cs,GenerateOverridingMethodStub,The length of the parameter generateExecuteSuperFunctionStmt is 32.
Long Identifier,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\ToolTips\NodeTooltipRepresentationGen.cs,,The length of the parameter MaxTemplateConstraintExprLength is 31.
Long Identifier,D_Parser.Dom,DNode,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Nodes\DNode.cs,ContainsPropertyAttribute,The length of the parameter userDefinedAttributeExpression is 30.
Long Identifier,D_Parser.Formatting,DFormattingOptions,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingOptions.cs,,The length of the parameter KeepArgumentIndentOnSquareBracketOpen is 37.
Long Identifier,D_Parser.Misc,CompletionOptions,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\CompletionOptions.cs,,The length of the parameter ShowStructMembersInStructInitOnly is 33.
Long Identifier,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,,The length of the parameter endedWhileBeingInNonCodeSequence is 32.
Long Identifier,D_Parser.Resolver.ASTScanner,ItemCheckParameters,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\ItemCheckParameters.cs,,The length of the parameter dontHandleTemplateParamsInNodeScan is 34.
Long Identifier,D_Parser.Resolver,StorageClassImplicitCastCheck,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\StorageClassImplicitCastCheck.cs,,The length of the parameter allowedImplicitConversions_RawTable is 35.
Long Identifier,D_Parser.Resolver,StorageClassImplicitCastCheck,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\StorageClassImplicitCastCheck.cs,,The length of the parameter allowedImplicitConversions_Lookup is 33.
Long Identifier,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalMethodCall,The length of the parameter templateMatchedMethodOverloads is 30.
Long Identifier,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The length of the parameter includeFinalNonOverridingMethods is 32.
Long Identifier,D_Parser.Resolver.Templates,SpecializationOrdering,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\SpecializationOrdering.cs,FilterFromMostToLeastSpecialized,The length of the parameter lastEquallySpecializedOverloads is 31.
Long Identifier,D_Parser.Resolver.Templates,TemplateTypeParameterTypeMatcher,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,TryMatchTypeDeclAgainstResolvedResult,The length of the parameter enforceTypeEqualityWhenDeducing is 31.
Long Identifier,D_Parser.Resolver.Templates,TemplateTypeParameterTypeMatcher,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,TryMatchTypeDeclAgainstResolvedResult,The length of the parameter enforceTypeEqualityWhenDeducing is 31.
Long Identifier,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,TemplateTypeParamDeclVisitor,The length of the parameter enforceTypeEqualityWhenDeducing is 31.
Long Identifier,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,Visit,The length of the parameter paramTix_TemplateMatchPossibilities is 35.
Long Identifier,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,,The length of the parameter enforceTypeEqualityWhenDeducing is 31.
Long Identifier,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,,The length of the parameter originallyReferredTemplateTypeParam is 35.
Long Identifier,D_Parser.Resolver.Templates,TemplateInstanceHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParamsAndFilterOverloads,The length of the parameter templateConstraintFilteredOverloads is 35.
Long Identifier,D_Parser.Resolver.Templates,TemplateInstanceHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParamsAndFilterOverloads,The length of the parameter implicitPropertiesOrEponymousTemplatesOrOther is 45.
Long Identifier,D_Parser.Completion,CodeCompletion,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\CodeCompletion.cs,GenerateCompletionData,The length of the parameter alreadyCheckedCompletionContext is 31.
Long Statement,D_Parser.Completion.Providers,CtrlSpaceCompletionProvider,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\CtrlSpaceCompletionProvider.cs,BuildCompletionDataInternal,The length of the statement  "				CompletionDataGenerator.AddTextItem("seg"'"The seg means load the segment number that the symbol is in. This is not relevant for flat model code. Instead' do a move from the relevant segment register."); " is 203.
Long Statement,D_Parser.Completion.Providers,MemberCompletionProvider,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\MemberCompletionProvider.cs,BuildCompletionDataInternal,The length of the statement  "			if (t == null) //TODO: Add after-space list creation when an unbound . (Dot) was entered which means to access the global scope" is 127.
Long Statement,D_Parser.Completion.Providers,MemberCompletionProvider,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\MemberCompletionProvider.cs,VisitTemplateParameterSymbol,The length of the statement  "				var tpp = tps.Parameter is TemplateThisParameter ? (tps.Parameter as TemplateThisParameter).FollowParameter : tps.Parameter;" is 124.
Long Statement,D_Parser.Completion.Providers,MethodOverrideCompletionProvider,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\MethodOverrideCompletionProvider.cs,BuildCompletionDataInternal,The length of the statement  "				classType = ClassInterfaceResolver.ResolveClassOrInterface(dc' ctxt'	null) as TemplateIntermediateType' Editor.CancelToken); " is 124.
Long Statement,D_Parser.Completion.Providers,MethodOverrideCompletionProvider,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\MethodOverrideCompletionProvider.cs,BuildCompletionDataInternal,The length of the statement  "					CompletionDataGenerator.AddCodeGeneratingNodeItem(dm' GenerateOverridingMethodStub(dm' begunNode' !(t is InterfaceType))); " is 122.
Long Statement,D_Parser.Completion.Providers,SelectiveImportCompletionProvider,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\SelectiveImportCompletionProvider.cs,BuildCompletionDataInternal,The length of the statement  "			var module = Editor.ParseCache.LookupModuleName(Editor.SyntaxTree' import.ModuleIdentifier.ToString(true)).FirstOrDefault(); " is 124.
Long Statement,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\ToolTips\NodeTooltipRepresentationGen.cs,GenTooltipSignature,The length of the statement  "				return GenTooltipSignature(ds.Definition' templateParamCompletion' currentMethodParam' typedecl' new DeducedTypeDictionary(ds));" is 128.
Long Statement,D_Parser.Dom,DBlockNode,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Nodes\DBlockNode.cs,GetMetaBlockStack,The length of the statement  "				if (lastSr != null && !(mindAttributeSections && lastSr is AttributeMetaDeclarationSection) && mb.Location < lastSr.Location && mb.EndLocation > lastSr.EndLocation) " is 164.
Long Statement,D_Parser.Dom,DBlockNode,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Nodes\DBlockNode.cs,GetMetaBlockStack,The length of the statement  "				if (((takeBlockStartLocations && mb is IMetaDeclarationBlock) ? ((IMetaDeclarationBlock)mb).BlockStartLocation : mb.Location) <= Where && mb.EndLocation >= Where) { " is 164.
Long Statement,D_Parser.Dom,DVariable,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Nodes\OtherNodeDefinitions.cs,ToString,The length of the statement  "			return (IsAlias ? "alias " : "") + base.ToString(Attributes' IncludePath) + (initializer && Initializer != null ? (" = " + Initializer.ToString()) : "");" is 153.
Long Statement,D_Parser.Dom,TemplateValueParameter,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\TemplateParameters.cs,ToString,The length of the statement  "			return (Type != null ? (Type.ToString() + " ") : "") + Name/*+ (SpecializationExpression!=null?(":"+SpecializationExpression.ToString()):"")+ " is 141.
Long Statement,D_Parser.Dom,IdentifierDeclaration,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\DDeclarations.cs,ToString,The length of the statement  "			return (ModuleScoped ? "." : "") + (IncludesBase && InnerDeclaration != null ? (InnerDeclaration.ToString() + ".") : "") + Id;" is 126.
Long Statement,D_Parser.Dom,DTokenDeclaration,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\DDeclarations.cs,ToString,The length of the statement  "			return (IncludesBase && InnerDeclaration != null ? (InnerDeclaration.ToString() + '.') : "") + DTokens.GetTokenString(Token);" is 125.
Long Statement,D_Parser.Dom,MemberFunctionAttributeDecl,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\DDeclarations.cs,ToString,The length of the statement  "			return (IncludesBase && InnerDeclaration != null ? (InnerDeclaration.ToString() + " ") : "") + DTokens.GetTokenString(Modifier) + "(" + (InnerType != null ? InnerType.ToString() : "") + ")";" is 190.
Long Statement,D_Parser.Dom,TypeOfDeclaration,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\DDeclarations.cs,ToString,The length of the statement  "			return (IncludesBase && InnerDeclaration != null ? (InnerDeclaration.ToString() + " ") : "") + "typeof(" + (Expression != null ? Expression.ToString() : "") + ")";" is 163.
Long Statement,D_Parser.Dom,VectorDeclaration,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\DDeclarations.cs,ToString,The length of the statement  "			return (IncludesBase && InnerDeclaration != null ? (InnerDeclaration.ToString() + " ") : "") + "__vector(" + basetype + ")";" is 124.
Long Statement,D_Parser.Dom.Expressions,SliceArgument,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Expressions\PostfixExpression_ArrayAccess.cs,ToString,The length of the statement  "				return LowerBoundExpression.ToString () + ".." + (UpperBoundExpression != null ? UpperBoundExpression.ToString () : string.Empty); " is 130.
Long Statement,D_Parser.Dom.Statements,CaseStatement,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Statements\SwitchStatement.cs,ToCode,The length of the statement  "				var ret = "case " + ArgumentList.ToString() + ':' + (IsCaseRange ? (" .. case " + LastExpression.ToString() + ':') : "") + Environment.NewLine; " is 143.
Long Statement,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitDTuple,The length of the statement  "				(o) => o is ISymbolValue ? (o as ISymbolValue).Accept(Instance) : o is AbstractType ? (o as AbstractType).Accept(Instance) : 0' true);" is 134.
Long Statement,D_Parser.Formatting,DFormattingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,EnforceBraceStyle,The length of the statement  "					endIndent = IsLineIsEmptyUpToEol(rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString; " is 122.
Long Statement,D_Parser.Formatting,DFormattingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,EnforceBraceStyle,The length of the statement  "					endIndent = IsLineIsEmptyUpToEol(rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString; " is 122.
Long Statement,D_Parser.Formatting,DFormattingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,EnforceBraceStyle,The length of the statement  "					endIndent = IsLineIsEmptyUpToEol(rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString; " is 122.
Long Statement,D_Parser.Formatting,DFormattingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,EnforceBraceStyle,The length of the statement  "					endIndent = IsLineIsEmptyUpToEol(rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString; " is 122.
Long Statement,D_Parser.Formatting,DFormattingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,FixStatementIndentation,The length of the statement  "			string indentString = nextStatementIndent == null ? (isEmpty ? "" : this.options.EolMarker) + this.curIndent.IndentString : nextStatementIndent; " is 144.
Long Statement,D_Parser.Formatting,DFormattingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,VisitBlock,The length of the statement  "			EnforceBraceStyle(policy.TypeBlockBraces' block.BlockStartLocation' block.EndLocation.Line' block.EndLocation.Column-1); " is 120.
Long Statement,D_Parser.Formatting,TextReplaceAction,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,ToString,The length of the statement  "				return string.Format("[TextReplaceAction: Offset={0}' RemovalLength={1}' NewText={2}]"' Offset' RemovalLength' NewText); " is 120.
Long Statement,D_Parser.Formatting,FormattingIndentStack,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\FormattingIndentStack.cs,Update,The length of the statement  "			indentString = new string('\t'' curIndent / options.TabSize) + new string(' '' curIndent % options.TabSize) + new string (' '' ExtraSpaces); " is 140.
Long Statement,D_Parser.Formatting.Indent,IndentEngineWrapper,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CorrectIndent,The length of the statement  "			var eng = new IndentEngine(options ?? DFormattingOptions.CreateDStandard()' textStyle.TabsToSpaces' textStyle.IndentSize' textStyle.KeepAlignmentSpaces); " is 153.
Long Statement,D_Parser.Formatting.Indent,IndentEngineWrapper,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CorrectIndent,The length of the statement  "						replaceActions.Add(new DFormattingVisitor.TextReplaceAction(eng.Position - eng.LineOffset' originalIndent' eng.ThisLineIndent)); " is 128.
Long Statement,D_Parser.Formatting.Indent,IndentEngineWrapper,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CorrectIndent,The length of the statement  "					replaceActions.Add(new DFormattingVisitor.TextReplaceAction(eng.Position - eng.LineOffset' originalIndent' eng.ThisLineIndent)); " is 128.
Long Statement,D_Parser.Formatting.Indent,IndentEngine,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushAccGrave,The length of the statement  "			if ((inside & (Inside.PreProcessor | Inside.Comment | Inside.CharLiteral | Inside.StringLiteral | Inside.VerbatimString)) != 0) " is 127.
Long Statement,D_Parser.Formatting.Indent,IndentStack,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,The length of the statement  "						((inside != Inside.SquareBracketList || ie.Options.KeepArgumentIndentOnSquareBracketOpen) && stack[sp].inside == Inside.ParenList)) { " is 133.
Long Statement,D_Parser.Formatting.Indent,Node,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,ToString,The length of the statement  "				return string.Format ("[Node: inside={0}' keyword={1}' indent={2}' nSpaces={3}' lineNr={4}]"' inside' DTokens.GetTokenString(keyword)' indent' nSpaces' lineNr); " is 160.
Long Statement,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,RemoveNestedTemplateRefsFromQualifier,The length of the statement  "							tix.Arguments[argumentIndex] = TypeDeclarationExpression.TryWrap(RemoveNestedTemplateRefsFromQualifier((arg as TypeDeclarationExpression).Declaration)); " is 152.
Long Statement,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The length of the statement  "					return new ScalarConstantExpression(-Number()' LiteralFormat.Scalar' LiteralSubformat.Integer | LiteralSubformat.Imaginary);" is 124.
Long Statement,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,HexFloat,The length of the statement  "						return new PostfixExpression_Access{ AccessExpression = new IdentifierExpression("nan")' PostfixForeExpression = new TokenExpression(DTokens.Float) };" is 150.
Long Statement,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,HexFloat,The length of the statement  "				var inf = new PostfixExpression_Access{ AccessExpression = new IdentifierExpression("infinity")' PostfixForeExpression = new TokenExpression(DTokens.Float) };" is 158.
Long Statement,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,HexFloat,The length of the statement  "			return new ScalarConstantExpression(n' LiteralFormat.Scalar | ((Math.Truncate(n) == n) ? 0 : LiteralFormat.FloatingPoint)' LiteralSubformat.Double);" is 148.
Long Statement,D_Parser.Parser.Implementations,DAsmStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DAsmStatementParser.cs,ParseAsmStatement,The length of the statement  "							l.Add(new LabeledStatement() { Location = la.Location' Parent = s' Identifier = la.Value' EndLocation = Peek(1).EndLocation }); " is 127.
Long Statement,D_Parser.Parser.Implementations,DAsmStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DAsmStatementParser.cs,ParseAsmStatement,The length of the statement  "									SynErr(DTokens.Identifier' "Pause is not supported by dmd's assembler. Use `rep; nop;` instead to achieve the same effect."); " is 125.
Long Statement,D_Parser.Parser.Implementations,DAsmStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DAsmStatementParser.cs,ParseAsmStatement,The length of the statement  "									als.ValueExpression = new ScalarConstantExpression(2m' LiteralFormat.Scalar) { Location = la.Location' EndLocation = la.EndLocation }; " is 134.
Long Statement,D_Parser.Parser.Implementations,DAsmStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DAsmStatementParser.cs,ParseAsmStatement,The length of the statement  "									l.Add(new AsmInstructionStatement() { Location = la.Location' Parent = s' Operation = AsmInstructionStatement.OpCode.__UNKNOWN__ }); " is 132.
Long Statement,D_Parser.Parser.Implementations,DAsmStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DAsmStatementParser.cs,ParseAsmUnaryExpression,The length of the statement  "							return new PostfixExpression_Access() { PostfixForeExpression = ParseAsmExpression(Scope' Parent)' AccessExpression = new IdentifierExpression("seg") }; " is 152.
Long Statement,D_Parser.Parser.Implementations,DAsmStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DAsmStatementParser.cs,ParseAsmUnaryExpression,The length of the statement  "							return new PostfixExpression_Access() { PostfixForeExpression = ParseAsmExpression(Scope' Parent)' AccessExpression = new IdentifierExpression("offsetof") }; " is 157.
Long Statement,D_Parser.Parser.Implementations,DAsmStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DAsmStatementParser.cs,ParseAsmPrimaryExpression,The length of the statement  "					return new ScalarConstantExpression(t.LiteralValue' t.LiteralFormat' t.Subformat) { Location = t.Location' EndLocation = t.EndLocation }; " is 137.
Long Statement,D_Parser.Parser.Implementations,DAsmStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DAsmStatementParser.cs,ParseAsmPrimaryExpression,The length of the statement  "									var ex = new AsmRegisterExpression() { Location = t.Location' EndLocation = t.EndLocation' Register = string.Intern(reg) }; " is 123.
Long Statement,D_Parser.Parser.Implementations,DAsmStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DAsmStatementParser.cs,ParseAsmPrimaryExpression,The length of the statement  "									return new UnaryExpression_SegmentBase() { RegisterExpression = ex' UnaryExpression = ParseAsmExpression(Scope' Parent) }; " is 122.
Long Statement,D_Parser.Parser.Implementations,DAsmStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DAsmStatementParser.cs,ParseAsmPrimaryExpression,The length of the statement  "									return new AsmRegisterExpression() { Location = t.Location' EndLocation = t.EndLocation' Register = string.Intern(reg) }; " is 121.
Long Statement,D_Parser.Parser.Implementations,DAsmStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DAsmStatementParser.cs,ParseAsmPrimaryExpression,The length of the statement  "								outer = new PostfixExpression_Access() { AccessExpression = new IdentifierExpression(t.Value)' PostfixForeExpression = outer }; " is 127.
Long Statement,D_Parser.Parser.Implementations,DAttributesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DAttributesParser.cs,AttributeSpecifier,The length of the statement  "						m.LiteralContent = parserParts.declarationParser.IdentifierList(scope); // Reassigns a symbol's package/'namespace' or so " is 121.
Long Statement,D_Parser.Parser.Implementations,DBodiedSymbolsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DBodiedSymbolsParser.cs,FunctionBody,The length of the statement  "							contractStmt.OutResultVariable = new IdentifierDeclaration(t.Value) { Location = t.Location' EndLocation = t.EndLocation }; " is 123.
Long Statement,D_Parser.Parser.Implementations,DBodiedSymbolsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DBodiedSymbolsParser.cs,FunctionBody,The length of the statement  "			// Although there can be in&out constraints' there doesn't have to be a direct body definition. Used on abstract class/interface methods." is 137.
Long Statement,D_Parser.Parser.Implementations,DBodiedSymbolsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DBodiedSymbolsParser.cs,FunctionBody,The length of the statement  "			par.EndLocation = IsEOF && t.Kind != DTokens.CloseCurlyBrace ? la.Location : par.Body != null ? par.Body.EndLocation : t.EndLocation;" is 133.
Long Statement,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,AliasDeclaration,The length of the statement  "				(Lexer.CurrentPeekToken.Kind == DTokens.OpenParenthesis && OverPeekBrackets(DTokens.OpenParenthesis) && Lexer.CurrentPeekToken.Kind == DTokens.Assign)))" is 152.
Long Statement,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,AliasDeclaration,The length of the statement  "			foreach (var n in Decl(Scope' laKind != DTokens.Identifier || Lexer.CurrentPeekToken.Kind != DTokens.OpenParenthesis ? null : new Modifier(DTokens.Alias)' true))" is 161.
Long Statement,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,Decl,The length of the statement  "				laKind == DTokens.Identifier && (DeclarationAttributes.Count > 0 || Lexer.CurrentPeekToken.Kind == DTokens.OpenParenthesis)))" is 125.
Long Statement,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,BasicType2,The length of the statement  "							KeyExpression = new PostfixExpression_ArrayAccess(fromExpression' parserParts.expressionsParser.AssignExpression(scope))" is 120.
Long Statement,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,Declarator,The length of the statement  "							(ad == null || !(ad.KeyExpression is TokenExpression) || (ad.KeyExpression as TokenExpression).Token != DTokens.Incomplete)) // 'string[|'" is 138.
Long Statement,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,OldCStyleFunctionPointer,The length of the statement  "			//SynErr(OpenParenthesis'"C-style function pointers are deprecated. Use the function() syntax instead."); // Only deprecated in D2" is 130.
Long Statement,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,Declarator2,The length of the statement  "					|| (t.Kind == DTokens.OpenParenthesis && laKind == DTokens.CloseParenthesis) /* -- means if an argumentless function call has been made' return null because this would be an expression */" is 187.
Long Statement,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,Parameters,The length of the statement  "			// It's not specified in the official D syntax spec' but we treat id-only typed anonymous parameters as non-typed id-full parameters" is 132.
Long Statement,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,Parameter,The length of the statement  "			while ((DTokensSemanticHelpers.IsParamModifier(laKind) && laKind != DTokens.InOut) || (DTokensSemanticHelpers.IsMemberFunctionAttribute(laKind) && Lexer.CurrentPeekToken.Kind != DTokens.OpenParenthesis))" is 203.
Long Statement,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,PushAttribute,The length of the statement  "				// If attr would change the accessability of an item' remove all previously found (so the most near attribute that's next to the item is significant)" is 149.
Long Statement,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,GetCurrentAttributeSet,The length of the statement  "				// ISSUE: Theoretically' when having two identically written but semantically different UDA attributes' the first one will become overridden." is 141.
Long Statement,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,IsAssignExpression,The length of the statement  "							bool isPrimitiveExpr = Lexer.CurrentPeekToken.Kind == DTokens.Dot || Lexer.CurrentPeekToken.Kind == DTokens.OpenParenthesis;" is 124.
Long Statement,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,IsAssignExpression,The length of the statement  "			// Addition: If a times token ('*') follows an identifier list' we can assume that we have a declaration and NOT an expression!" is 127.
Long Statement,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,IsAssignExpression,The length of the statement  "			// Example: *a=b is an expression; a*=b is not possible (and a Multiply-Assign-Expression) - instead something like A* a should be taken..." is 139.
Long Statement,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,AndExpression,The length of the statement  "			// Note: Since we ignored all kinds of CmpExpressions in AndAndExpression()' we have to take CmpExpression instead of ShiftExpression here!" is 139.
Long Statement,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,PostfixExpression,The length of the statement  "						laKind == DTokens.CloseParenthesis && Lexer.CurrentPeekToken == dotToken) // Also take it as a type declaration if there's nothing following (see Expression Resolving)" is 167.
Long Statement,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,PostfixExpression,The length of the statement  "						var peid = t.Kind == DTokens.Increment ? (PostfixExpression)new PostfixExpression_Increment() : new PostfixExpression_Decrement();" is 130.
Long Statement,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,PrimaryExpression,The length of the statement  "					return new PostfixExpression_Access { PostfixForeExpression = dot' AccessExpression = new TokenExpression(DTokens.Incomplete) };" is 128.
Long Statement,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,PrimaryExpression,The length of the statement  "						return new StringLiteralExpression(sb.ToString()' t.LiteralFormat == LiteralFormat.VerbatimStringLiteral' t.Subformat) { Location = startLoc' EndLocation = t.EndLocation };" is 172.
Long Statement,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,PrimaryExpression,The length of the statement  "					//else if (t.LiteralFormat == LiteralFormat.CharLiteral)return new IdentifierExpression(t.LiteralValue) { LiteralFormat=t.LiteralFormat'Location = startLoc' EndLocation = t.EndLocation };" is 187.
Long Statement,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,PrimaryExpression,The length of the statement  "					return new ScalarConstantExpression(t.LiteralValue' t.LiteralFormat' t.Subformat' t.RawCodeRepresentation) { Location = startLoc' EndLocation = t.EndLocation };" is 160.
Long Statement,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,PrimaryExpression,The length of the statement  "					if (Scope != null && !AllowWeakTypeParsing) // HACK -- not only on AllowWeakTypeParsing! But apparently' this stuff may be parsed twice' so force-skip results of the first attempt although this is a rather stupid solution" is 221.
Long Statement,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,ArrayLiteral,The length of the statement  "				return new ArrayLiteralExpression(Enumerable.Empty<IExpression>()) { Location = startLoc' EndLocation = t.EndLocation };" is 120.
Long Statement,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,ArrayLiteral,The length of the statement  "				var ae = nonInitializer ? new AssocArrayExpression { Location = startLoc } : new ArrayInitializer { Location = startLoc };" is 122.
Long Statement,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,IsLambaExpression,The length of the statement  "				return k == DTokens.Comma || k == DTokens.Identifier || k == DTokens.CloseSquareBracket || DTokensSemanticHelpers.IsBasicType(k) || DTokensSemanticHelpers.IsStorageClass(k);" is 173.
Long Statement,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,IsFunctionLiteral,The length of the statement  "			while (DTokensSemanticHelpers.IsStorageClass(Lexer.CurrentPeekToken.Kind) || (at = Lexer.CurrentPeekToken.Kind == DTokens.At))" is 126.
Long Statement,D_Parser.Parser.Implementations,DModulesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DModulesParser.cs,DeclDef,The length of the statement  "					module.Add(parserParts.bodiedSymbolsParser.Constructor(module' module is DClassLike && ((DClassLike)module).ClassType == DTokens.Struct)); " is 138.
Long Statement,D_Parser.Parser.Implementations,DModulesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DModulesParser.cs,AttributeBlock,The length of the statement  "			 * Also' pop them from the declarationAttributes stack on to the block attributes so they will be assigned to all child items later on. " is 134.
Long Statement,D_Parser.Parser.Implementations,DModulesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DModulesParser.cs,AttributeBlock,The length of the statement  "				metaDeclBlock = new AttributeMetaDeclarationBlock(DeclarationAttributes.ToArray()) { BlockStartLocation = la.Location }; " is 120.
Long Statement,D_Parser.Parser.Implementations,DModulesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DModulesParser.cs,Condition,The length of the statement  "										SemErr(DTokens.Version' "Can't handle " + t.LiteralValue.ToString() + " as version constraint; taking ulong.max instead"); " is 122.
Long Statement,D_Parser.Parser.Implementations,DModulesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DModulesParser.cs,ImportBindings,The length of the statement  "						importBindings.SelectedSymbols.Add(new ImportStatement.ImportBinding(new IdentifierDeclaration(DTokens.IncompleteIdHash)' symbolAlias)); " is 136.
Long Statement,D_Parser.Parser.Implementations,DParserImplementationPart,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DParserImplementationPart.cs,SynErr,The length of the statement  "			SynErr(n' DTokens.GetTokenString(n) + " expected" + (t != null ? ("' " + DTokens.GetTokenString(t.Kind) + " found") : "")); " is 123.
Long Statement,D_Parser.Parser.Implementations,DStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DStatementParser.cs,IfCondition,The length of the statement  "				(Peek(1).Kind == DTokens.Assign || Lexer.CurrentPeekToken.Kind == DTokens.CloseParenthesis)) || // if(a * b * c) is an expression' if(a * b = 123) may be a pointer variable " is 172.
Long Statement,D_Parser.Parser.Implementations,DStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DStatementParser.cs,ForeachStatement,The length of the statement  "				else if (laKind == (DTokens.Identifier) && (Lexer.CurrentPeekToken.Kind == (DTokens.Semicolon) || Lexer.CurrentPeekToken.Kind == DTokens.Comma)) " is 144.
Long Statement,D_Parser.Parser.Implementations,DTemplatesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DTemplatesParser.cs,TemplateInstance,The length of the statement  "			td = new TemplateInstanceExpression(mod != DTokens.INVALID ? new MemberFunctionAttributeDecl(mod) { InnerType = td } : td) " is 122.
Long Statement,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The length of the statement  "								return Token(DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue(numString' 16)' /*numString'*/ LiteralFormat.Scalar);" is 136.
Long Statement,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The length of the statement  "										literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString(3) + " by Alexander Bothe";" is 134.
Long Statement,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadTokenStringLiteral_IdentInit,The length of the statement  "			return Token(DTokens.Literal' x' y' Col' Line' tokenString.ToString().Trim()' LiteralFormat.VerbatimStringLiteral' subFmt);" is 123.
Long Statement,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadTokenStringLiteral_CurlyInit,The length of the statement  "			return Token(DTokens.Literal' x' y' Col' Line' tokenString.ToString().Trim()' LiteralFormat.VerbatimStringLiteral' subFmt);" is 123.
Long Statement,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadIdent,The length of the statement  "							OnError(Line' Col' "Unicode escape sequences in identifiers cannot be used to represent characters that are invalid in identifiers");" is 133.
Long Statement,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadIdent,The length of the statement  "							OnError(Line' Col' "Unicode escape sequences in identifiers cannot be used to represent characters that are invalid in identifiers");" is 133.
Long Statement,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The length of the statement  "				if (numBase == 10 || (ch != '.' && numBase == 0)) // Only allow further digits for 10-based integers' not for binary or hex values " is 130.
Long Statement,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadString,The length of the statement  "			return Token(DTokens.Literal' x' y' Col' Line' /*originalValue.ToString()'*/ sb.ToString()' LiteralFormat.StringLiteral' subFmt);" is 129.
Long Statement,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadVerbatimString,The length of the statement  "			return Token(DTokens.Literal' x' y' Col' Line' /*originalValue.ToString()'*/ sb.ToString()' LiteralFormat.VerbatimStringLiteral' subFmt);" is 137.
Long Statement,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadChar,The length of the statement  "			return Token(DTokens.Literal' x' y' Col' Line' string.IsNullOrEmpty(surrogatePair) ? (object)chValue : surrogatePair' LiteralFormat.CharLiteral' surrogatePair == null ? LiteralSubformat.Utf8 : LiteralSubformat.Utf16' escapeSequence);" is 233.
Long Statement,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadMultiLineComment,The length of the statement  "							Comments.Add(new Comment(commentType' scCurWord.ToString().Trim(ch' ' '' '\t'' '\r'' '\n'' isNestingComment ? '+' : '*')' st.Column < 2' st' new CodeLocation(Col' Line)));" is 171.
Long Statement,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadSpecialTokenSequence,The length of the statement  "					nextToken = Next(); //ISSUE: Successive #line tokens will be skipped here - perhaps detect if there's a special token following? " is 128.
Long Statement,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,OnError,The length of the statement  "				LexerErrors.Add(new ParserError(false' message' CurrentToken != null ? CurrentToken.Kind : -1' new CodeLocation(col' line)));" is 125.
Long Statement,D_Parser.Parser,DTokens,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Tokens\DTokens.cs,GetDescription,The length of the statement  "					return "Disables a declaration\nA reference to a declaration marked with the @disable attribute causes a compile time error\n\nThis can be used to explicitly disallow certain operations \nor overloads at compile time \nrather than relying on generating a runtime error.";" is 271.
Long Statement,D_Parser.Parser,DTokens,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Tokens\DTokens.cs,GetDescription,The length of the statement  "					return "Property functions \ncan be called without parentheses (hence acting like properties).\n\nstruct S {\n  int m_x;\n  @property {\n    int x() { return m_x; }\n    int x(int newx) { return m_x = newx; }\n  }\n}\n\nvoid foo() {\n  S s;\n  s.x = 3;   // calls s.x(int)\n  bar(s.x);  // calls bar(s.x())\n}";" is 311.
Long Statement,D_Parser.Parser,DTokens,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Tokens\DTokens.cs,GetDescription,The length of the statement  "					return "Safe functions\n\nThe following operations are not allowed in safe functions:\n\n- No casting from a pointer type to any type other than void*.\n- No casting from any non-pointer type to a pointer type.\n- No modification of pointer values.\n- Cannot access unions that have pointers or references overlapping with other types.\n- Calling any system functions.\n- No catching of exceptions that are not derived from class Exception.\n- No inline assembler.\n- No explicit casting of mutable objects to immutable.\n- No explicit casting of immutable objects to mutable.\n- No explicit casting of thread local objects to shared.\n- No explicit casting of shared objects to thread local.\n- No taking the address of a local variable or function parameter.\n- Cannot access __gshared variables.\n- Functions nested inside safe functions default to being safe functions.\n\nSafe functions are covariant with trusted or system functions.";" is 941.
Long Statement,D_Parser.Parser,DTokens,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Tokens\DTokens.cs,GetDescription,The length of the statement  "					return "System functions \nare functions not marked with @safe or @trusted and are not nested inside @safe functions\n\nSystem functions may be marked with the @system attribute.\n \nA function being system does not mean it actually is unsafe' it just means that the compiler is unable to verify that it cannot exhibit undefined behavior.\n\nSystem functions are not covariant with trusted or safe functions.";" is 410.
Long Statement,D_Parser.Parser,DTokens,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Tokens\DTokens.cs,GetDescription,The length of the statement  "					return "Trusted functions\n\n- Are marked with the @trusted attribute'\n- Are guaranteed by the programmer to not exhibit \n  any undefined behavior if called by a safe function'\n- May call safe' trusted' or system functions'\n- Are covariant with safe or system functions";" is 275.
Long Statement,D_Parser.Parser,DTokens,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Tokens\DTokens.cs,GetDescription,The length of the statement  "					return "No GC functions\nare marked with the @nogc attribute to ensure no GC allocations are done by the function itself or any of the called functions.";" is 154.
Long Statement,D_Parser.Parser,DTokens,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Tokens\DTokens.cs,GetDescription,The length of the statement  "					return "switch(a)\n{\n   case 1:\n      foo();\n      break;\n   case 2:\n      bar();\n      break;\n   default:\n      break;\n}";" is 132.
Long Statement,D_Parser.Parser,IncrementalParsingBase<T>,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\IncrementalParsing.cs,ParseIncrementally,The length of the statement  "				var startOff = startLoc.Line > 1 ? DocumentHelper.GetOffsetByRelativeLocation(code' caretLocation' caretOffset' startLoc) : 0; " is 126.
Long Statement,D_Parser.Parser,IncrementalParsingBase<T>,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\IncrementalParsing.cs,ParseIncrementally,The length of the statement  "					// Update the actual tempBlock as well as methods/other blocks' end location that just appeared while parsing the code incrementally' " is 133.
Long Statement,D_Parser.Parser,BlockStmtIncrParsing,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\IncrementalParsing.cs,PrepareParsing,The length of the statement  "				tempParentBlock.Attributes = finalParentMethod.Attributes; // assign given attributes to the temporary block for allowing the completion to check whether static or non-static items may be shown " is 193.
Long Statement,D_Parser.Refactoring,ReferencesFinder,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Refactoring\ReferencesFinder.cs,Visit,The length of the statement  "			var id = acc.AccessExpression is NewExpression ? (acc.AccessExpression as NewExpression).Type as IntermediateIdType : acc.AccessExpression as IntermediateIdType; " is 161.
Long Statement,D_Parser.Refactoring,TypeReferenceFinder,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,OnScopedBlockChanged,The length of the statement  "			var filter = MemberFilter.Types | MemberFilter.Enums | MemberFilter.TypeParameters | MemberFilter.Variables | MemberFilter.Methods; " is 131.
Long Statement,D_Parser.Refactoring,TypeReferenceFinder,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,Visit,The length of the statement  "			//TODO: If there is a type result' try to resolve x (or postfix-access expressions etc.) to find out whether it's overwritten by some local non-type " is 148.
Long Statement,D_Parser.Refactoring,ClassInterfaceDerivativeFinder,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Refactoring\ClassInterfaceDerivativeFinder.cs,SearchForClassDerivatives,The length of the statement  "				throw new ArgumentException ("t is expected to be a class or an interface' not " + (t != null ? t.ToString () : "null")); " is 121.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,DeepScanClass,The length of the statement  "				takeStaticChildrenOnly = (udt == null || !udt.NonStaticAccess) && ctxt.ScopedBlock is DMethod && (ctxt.ScopedBlock as DMethod).IsStatic" is 135.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,VisitStatementHierarchy,The length of the statement  "			return dm != null && (s = dm.GetSubBlockAt (caret)) != null && s.Accept (new StatementHandler (dm' this' parms' caret));" is 120.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,HandleAliasThisDeclarations,The length of the statement  "			if (aliasThisDefsBeingParsed.TryGetValue (tit.Definition' out alreadyParsedAliasThis) && alreadyParsedAliasThis == aliasDef)" is 124.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,HandleAliasThisDeclarations,The length of the statement  "				aliasedSymbolOverloads = DResolver.StripMemberSymbols(DResolver.StripMemberSymbols(TypeDeclarationResolver.ResolveSingle(aliasDef.Type' ctxt)));" is 144.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,MatchesCompilationConditions,The length of the statement  "						res = neg != null ? !ctxt.CurrentContext.MatchesDeclarationEnvironment(neg) : ctxt.CurrentContext.MatchesDeclarationEnvironment(cond);" is 134.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,CanHandleNode,The length of the statement  "			if((ctxt.Options & ResolutionOptions.IgnoreAllProtectionAttributes) != ResolutionOptions.IgnoreAllProtectionAttributes){" is 120.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,CanHandleNode,The length of the statement  "				if((CanShowMember(dn' ctxt.ScopedBlock) || (parms.isBaseClass && !parms.isMixinAst)) && ((!parms.takeStaticChildrenOnly && (!parms.publicImportsOnly || !parms.isBaseClass)) || IsConstOrStatic(dn)))" is 197.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,CanHandleNode,The length of the statement  "			if (dm3 != null && !(dm3.SpecialType == DMethod.MethodType.Normal || dm3.SpecialType == DMethod.MethodType.Delegate || dm3.NameHash != 0))" is 138.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,IsConstOrStatic,The length of the statement  "			return dn != null && (dn.IsStatic || (dv != null && (dv.IsConst || dv.IsAlias))); // Aliases are always static - it only depends on their base types then" is 153.
Long Statement,D_Parser.Resolver.ASTScanner,StatementHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,VisitImport,The length of the statement  "				var thisModuleName = (ctxt.ScopedBlock != null && (mod = ctxt.ScopedBlock.NodeRoot as DModule) != null) ? mod.NameHash : 0;" is 123.
Long Statement,D_Parser.Resolver.ASTScanner,StatementHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,VisitImport,The length of the statement  "				foreach (var module in ctxt.ParseCache.LookupModuleName(scopedModule' moduleName)) //TODO: Only take the first module? Notify the user about ambigous module names?" is 163.
Long Statement,D_Parser.Resolver.ASTScanner,StatementHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,Visit,The length of the statement  "					var pseudoValueTemplateParameter = new TemplateValueParameter(valueHoldingIterator.NameHash' valueHoldingIterator.NameLocation' valueHoldingIterator.Parent as DNode).Representation; " is 181.
Long Statement,D_Parser.Resolver.ASTScanner,StatementHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,Visit,The length of the statement  "					var pseudoKeyTemplateParameter = keyHoldingIterator != null ? new TemplateValueParameter(keyHoldingIterator.NameHash' keyHoldingIterator.NameLocation' keyHoldingIterator.Parent as DNode).Representation : null; " is 209.
Long Statement,D_Parser.Resolver.ASTScanner,StatementHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,Visit,The length of the statement  "						deducedTypes[pseudoValueTemplateParameter.TemplateParameter] = new TemplateParameterSymbol(pseudoValueTemplateParameter' kv.Value); " is 131.
Long Statement,D_Parser.Resolver.ASTScanner,StatementHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,Visit,The length of the statement  "							deducedTypes[pseudoKeyTemplateParameter.TemplateParameter] = new TemplateParameterSymbol(pseudoKeyTemplateParameter' kv.Key); " is 125.
Long Statement,D_Parser.Resolver,DTypeToCodeVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\DTypeToCodeVisitor.cs,VisitTemplateParameterSymbol,The length of the statement  "				AcceptType(t.Base); //FIXME: It's not actually code but currently needed for correct ToString() representation in e.g. parameter insight" is 136.
Long Statement,D_Parser.Resolver,TemplateParameterSymbol,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Model\DType.cs,ToString,The length of the statement  "			return "<"+(Parameter == null ? "(unknown)" : Parameter.Name)+">"+(ParameterValue!=null ? ParameterValue.ToString() : (Base==null ? "" : Base.ToString())); " is 155.
Long Statement,D_Parser.Resolver,StaticProperties,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,GetLookedUpType,The length of the statement  "				(tps.Parameter is TemplateThisParameter parameter ? parameter.FollowParameter : tps.Parameter) is TemplateTupleParameter) " is 121.
Long Statement,D_Parser.Resolver,StaticProperties,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,TryEvalPropertyType,The length of the statement  "			if (props.TryGetValue(propName' out prop) || (Properties.TryGetValue(GetOwnerType(t)' out props) && props.TryGetValue(propName' out prop))) " is 139.
Long Statement,D_Parser.Resolver,ResolvedTypeCloner,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ResolvedTypeCloner.cs,Clone,The length of the statement  "			return Clone<AbstractTypeT>(t' new CloneOptions() { newBase = newBase' templateParameterSymbols = templateParameterSymbols }); " is 126.
Long Statement,D_Parser.Resolver,ResolvedTypeCloner,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ResolvedTypeCloner.cs,VisitAliasedType,The length of the statement  "			return new AliasedType(t.Definition' TryCloneBase(t)' t.declaration' TryMergeDeducedTypes(t)) { Modifiers = t.Modifiers }; " is 122.
Long Statement,D_Parser.Resolver,ResolvedTypeCloner,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ResolvedTypeCloner.cs,VisitClassType,The length of the statement  "			return new ClassType(t.Definition' TryCloneBase(t) as TemplateIntermediateType' t.BaseInterfaces' TryMergeDeducedTypes(t)) " is 122.
Long Statement,D_Parser.Resolver,ResolvedTypeCloner,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ResolvedTypeCloner.cs,VisitDelegateCallSymbol,The length of the statement  "			return new DelegateCallSymbol(/*cloneBase && t.Delegate != null ? t.Delegate.Accept(this) as DelegateType :*/ t.Delegate' t.callExpression); " is 140.
Long Statement,D_Parser.Resolver,ResolvedTypeCloner,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ResolvedTypeCloner.cs,VisitTemplateParameterSymbol,The length of the statement  "			return new TemplateParameterSymbol(t.Parameter' t.ParameterValue ?? TryCloneBase(t) as ISemantic) { Modifiers = t.Modifiers }; " is 126.
Long Statement,D_Parser.Resolver,ResolutionContext,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ResolutionContext.cs,Push,The length of the statement  "			return Push(ASTSearchHelper.SearchBlockAt(editor.SyntaxTree' editor.CaretLocation) ?? editor.SyntaxTree' editor.CaretLocation); " is 127.
Long Statement,D_Parser.Resolver,ConditionalCompilationFlags,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ConditionalCompilationFlags.cs,IsMatching,The length of the statement  "			return !Evaluation.IsFalsy(v); //TODO: Just because the expression evaluation isn't working properly currently' let it return true to have it e.g. in the completion list " is 169.
Long Statement,D_Parser.Resolver,CacheEntryDict,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Caching\ResolutionCache.cs,GetTemplateParamHash,The length of the statement  "				var h = ctxt.ScopedBlock == null ? 1 : ASTSearchHelper.SearchBlockAt(ctxt.ScopedBlock' ctxt.CurrentContext.Caret).Accept(hashVis); " is 130.
Long Statement,D_Parser.Resolver,LooseResolution,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,ResolveTypeLoosely,The length of the statement  "					ctxt.CurrentContext.ContextDependentOptions |= ResolutionOptions.ReturnMethodReferencesOnly | ResolutionOptions.DontResolveAliases;" is 131.
Long Statement,D_Parser.Resolver,LooseResolution,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,ResolveTypeLoosely,The length of the statement  "					ctxt.CurrentContext.ContextDependentOptions |= ResolutionOptions.ReturnMethodReferencesOnly | ResolutionOptions.DontResolveAliases;" is 131.
Long Statement,D_Parser.Resolver,LooseResolution,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,ResolveTypeLoosely,The length of the statement  "						ret = AmbiguousType.Get(ExpressionTypeEvaluation.GetOverloads(o as IdentifierExpression' ctxt' deduceParameters: false));" is 121.
Long Statement,D_Parser.Resolver,LooseResolution,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,SearchNodesByName,The length of the statement  "			ctxt.ContextIndependentOptions = ResolutionOptions.DontResolveBaseTypes | ResolutionOptions.NoTemplateParameterDeduction;" is 121.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_BoolOp,The length of the statement  "							relationIsTrue = (a.Value < b.Value || a.Value > b.Value) && (!cmpIm || (a.ImaginaryPart < b.ImaginaryPart || a.ImaginaryPart > b.ImaginaryPart)); " is 146.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_BoolOp,The length of the statement  "							relationIsTrue = (a.Value < b.Value || a.Value >= b.Value) && (!cmpIm || (a.ImaginaryPart < b.ImaginaryPart || a.ImaginaryPart >= b.ImaginaryPart)); " is 148.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The length of the statement  "				EvalError(x' "Left value must evaluate to a constant scalar value. Operator overloads aren't supported yet"' new[]{lValue}); " is 124.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The length of the statement  "				if (x.RightOperand is OperatorBasedExpression && !(x.RightOperand is AssignExpression)) //TODO: This must be true only if it's a math expression' so not an assign expression etc. " is 178.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The length of the statement  "				return HandleSingleMathOp(x' l' TryGetValue(rValue ?? (x.RightOperand != null ? x.RightOperand.Accept(this) : null))' mult); " is 124.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalConcatenation,The length of the statement  "			// Notable: If one element is of the value type of the array' the element is added (either at the front or at the back) to the array " is 132.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalConcatenation,The length of the statement  "				EvalError(x' "At least one operand must be an (non-associative) array. If so' the other operand must be of the array's element type."' catQueue.ToArray()); " is 155.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalConcatenation,The length of the statement  "					EvalError(x' "Element with type " + (e.RepresentedType != null ? e.RepresentedType.ToCode() : "") + " doesn't fit into array with type "+lastArrayType.ToCode()' catQueue.ToArray()); " is 181.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,HandleSingleMathOp,The length of the statement  "					return PrimitiveValue.CreateNaNValue(pl.IsNaN ? pl.BaseTypeToken : pr.BaseTypeToken' pl.IsNaN ? pl.Modifiers : pr.Modifiers); " is 125.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,HandleSingleMathOp,The length of the statement  "					return PrimitiveValue.CreateNaNValue(pl.IsNaN ? pl.BaseTypeToken : pr.BaseTypeToken' pl.IsNaN ? pl.Modifiers : pr.Modifiers); " is 125.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_WithAliases,The length of the statement  "			var expectedTemplateParams = new TemplateParameter[isExpression.TemplateParameterList == null  ? 1 : (isExpression.TemplateParameterList.Length + 1)];" is 150.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_WithAliases,The length of the statement  "					tpl_params[isExpression.ArtificialFirstSpecParam] = new TemplateParameterSymbol(isExpression.ArtificialFirstSpecParam' r.Item2);" is 128.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_EvalSpecToken,The length of the statement  "								// TypeTuple of the function parameter types. For C- and D-style variadic functions' only the non-variadic parameters are included. " is 131.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The length of the statement  "			var assertVal = x.AssignExpressions.Count > 0 && x.AssignExpressions[0] != null ? x.AssignExpressions[0].Accept(this) as ISymbolValue : null; " is 141.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The length of the statement  "			return new AssociativeArrayValue(new AssocArrayType(elements[0].Value.RepresentedType' elements[0].Key.RepresentedType)' elements); " is 131.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,GetRawCallOverloads,The length of the statement  "				// Explicitly don't resolve the methods' return types - it'll be done after filtering to e.g. resolve template types to the deduced one " is 135.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,GetRawCallOverloads,The length of the statement  "					baseExpression = ExpressionTypeEvaluation.GetResolvedConstructorOverloads((TokenExpression)call.PostfixForeExpression' ctxt); " is 125.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalPostfixAccessExpression,The length of the statement  "				// Do not deduce and filter if superior expression is a method call since call arguments' types also count as template arguments! " is 129.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,SliceArray,The length of the statement  "				EvalError(lower != -1 ? sl.LowerBoundExpression : sl.UpperBoundExpression' "Boundary expression must base an integral type"); " is 125.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,SliceArray,The length of the statement  "				EvalError(sl.LowerBoundExpression' "Lower boundary must be smaller than " + len); return new NullValue(ar.RepresentedType); " is 123.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,SliceArray,The length of the statement  "				EvalError(sl.UpperBoundExpression' "Upper boundary must be greater than " + lower); return new NullValue(ar.RepresentedType); " is 125.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,SliceArray,The length of the statement  "				EvalError(sl.UpperBoundExpression' "Upper boundary must be smaller than " + len); return new NullValue(ar.RepresentedType); " is 123.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,EvaluateType,The length of the statement  "			if (!(t is TemplateParameterSymbol) || !ctxt.ContainsDeducedTemplateParameter((t as TemplateParameterSymbol).Parameter)) // Don't allow caching parameters that affect the caching context. " is 187.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetRawCallOverloads,The length of the statement  "				// Explicitly don't resolve the methods' return types - it'll be done after filtering to e.g. resolve template types to the deduced one " is 135.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetAccessedOverloads,The length of the statement  "			return Evaluation.EvalPostfixAccessExpression<AbstractType>(new ExpressionTypeEvaluation(ctxt)' ctxt' acc' resultBase' DeducePostfixTemplateParams); " is 148.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetResolvedConstructorOverloads,The length of the statement  "					return D_Parser.Resolver.TypeResolution.TypeDeclarationResolver.HandleNodeMatches(GetConstructors(classRef)' ctxt' classRef' tk); " is 129.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetConstructors,The length of the statement  "					yield return new DMethod(DMethod.MethodType.Constructor) { Name = DMethod.ConstructorIdentifier' Parent = ct.Definition' Description = "Default constructor for " + ct.Name }; " is 174.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,The length of the statement  "			return x.TrueCaseExpression != null ? x.TrueCaseExpression.Accept(this) : (x.FalseCaseExpression != null ? x.FalseCaseExpression.Accept(this) : null); " is 150.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,The length of the statement  "			return TypeDeclarationResolver.ResolveSingle(new IdentifierDeclaration(uat.AccessIdentifierHash) { EndLocation = uat.EndLocation' InnerDeclaration = uat.Type }' ctxt); " is 167.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,AccessArrayAtIndex,The length of the statement  "						foreExpression = DResolver.StripMemberSymbols(TypeDeclarationResolver.HandleNodeMatch(aliasThis' ctxt' foreExpression)); " is 120.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,AccessArrayAtIndex,The length of the statement  "					arg_i += indexArgs.Count; //TODO: Only increment by the amount of actually used args for filtering out the respective method overload. " is 134.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetOverloads,The length of the statement  "					$"Finished resolving base type {((ITypeDeclaration) id).InnerDeclaration} => {resultBases}. {sw.ElapsedMilliseconds} ms."); " is 123.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,The length of the statement  "			return TypeDeclarationResolver.ResolveSingle(new IdentifierDeclaration("TypeInfo") { InnerDeclaration = new IdentifierDeclaration("object") }' ctxt); " is 149.
Long Statement,D_Parser.Resolver.ExpressionSemantics,OverloadFilterVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MethodOverloadsByParameterTypeComparisonFilter.cs,VisitMemberSymbol,The length of the statement  "				else if (!isUfcs && hasHandledUfcsResultBefore) // In the rare case of having a ufcs result occuring _after_ a normal member result' remove the initial arg again " is 161.
Long Statement,D_Parser.Resolver.ExpressionSemantics,OverloadFilterVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MethodOverloadsByParameterTypeComparisonFilter.cs,VisitMemberSymbol,The length of the statement  "								if (!TemplateTypeParameterTypeMatcher.TryMatchTypeDeclAgainstResolvedResult(paramType' callArguments[currentArg++]' ctxt' deducedTypeDict' false)) " is 146.
Long Statement,D_Parser.Resolver.ExpressionSemantics,OverloadFilterVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MethodOverloadsByParameterTypeComparisonFilter.cs,TryHandleMethodArgumentTuple,The length of the statement  "					var nextExpectedParameter = DResolver.StripMemberSymbols(TypeDeclarationResolver.ResolveSingle(dm.Parameters[currentParameter + 1].Type' ctxt)); " is 144.
Long Statement,D_Parser.Resolver.ExpressionSemantics,OverloadFilterVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MethodOverloadsByParameterTypeComparisonFilter.cs,TryHandleMethodArgumentTuple,The length of the statement  "							if (currentArg >= callArguments.Count || !ResultComparer.IsImplicitlyConvertible(callArguments[currentArg++]' AbstractType.Get(item)' ctxt)) " is 140.
Long Statement,D_Parser.Resolver.ResolutionHooks,bitfields,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\bitfields.cs,TryDeduce,The length of the statement  "								sb.Append("@property @safe ").Append(templateParamName).Append(' ').Append(name).AppendLine("() pure nothrow const {}"); " is 120.
Long Statement,D_Parser.Resolver.ResolutionHooks,bitfields,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\bitfields.cs,TryDeduce,The length of the statement  "								sb.Append("@property @safe void ").Append(name).AppendLine("(").Append(templateParamName).AppendLine(" v) pure nothrow {}"); " is 124.
Long Statement,D_Parser.Resolver.ResolutionHooks,bitfields,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\bitfields.cs,TryDeduce,The length of the statement  "								sb.Append("enum ").Append(templateParamName).Append(" ").Append(name).Append("_min = cast(").Append(templateParamName).AppendLine(") 0;"); " is 138.
Long Statement,D_Parser.Resolver.ResolutionHooks,bitfields,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\bitfields.cs,TryDeduce,The length of the statement  "								sb.Append("enum ").Append(templateParamName).Append(" ").Append(name).Append("_max = cast(").Append(templateParamName).AppendLine(") 0;"); " is 138.
Long Statement,D_Parser.Resolver.ResolutionHooks,TupleHook,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\Tuple.cs,TryDeduce,The length of the statement  "				tupleStruct.Add(new DVariable { NameHash = DVariable.AliasThisIdentifierHash' IsAlias = true' IsAliasThis = true' Type = new IdentifierDeclaration(tupleName) }); " is 161.
Long Statement,D_Parser.Resolver.ResolutionHooks,autoimplement,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\autoimplement.cs,TryDeduce,The length of the statement  "			return new ClassType(cls.Definition' baseClass as ClassType' baseClass is InterfaceType ? new[] {baseClass as InterfaceType} : null' ds.DeducedTypes); " is 150.
Long Statement,D_Parser.Resolver.Templates,SpecializationOrdering,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\SpecializationOrdering.cs,IsMoreSpecialized,The length of the statement  "				IsMoreSpecialized(((TemplateThisParameter)t1).FollowParameter' ((TemplateThisParameter)t2).FollowParameter' t1_dummyParameterList)) " is 131.
Long Statement,D_Parser.Resolver.Templates,SpecializationOrdering,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\SpecializationOrdering.cs,IsMoreSpecialized,The length of the statement  "				// It's not needed to test both expressions for equality because they actually were equal to the given template instance argument " is 129.
Long Statement,D_Parser.Resolver.Templates,SpecializationOrdering,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\SpecializationOrdering.cs,IsMoreSpecialized,The length of the statement  "			else if (t1.Specialization == null) // Return false if t2 is more specialized or if t1 as well as t2 are not specialized " is 120.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateParameterDeduction.cs,Handle,The length of the statement  "			//TODO: Handle __FILE__ and __LINE__ correctly - so don't evaluate them at the template declaration but at the point of instantiation " is 133.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeductionVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateParameterDeductionVisitor.cs,Visit,The length of the statement  "			if(!TemplateTypeParameterTypeMatcher.TryMatchTypeDeclAgainstResolvedResult(p.Specialization' arg' ctxt' TargetDictionary' EnforceTypeEqualityWhenDeducing)) " is 155.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeductionVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateParameterDeductionVisitor.cs,TryAssignDefaultType,The length of the statement  "			using (ctxt.Push(ASTSearchHelper.SearchBlockAt(ctxt.ScopedBlock.NodeRoot as IBlockNode' p.Default.Location)' p.Default.Location)) " is 129.
Long Statement,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,Visit,The length of the statement  "					return TemplateParameterDeductionVisitor.Set(ctxt' TargetDictionary' (originallyReferredTemplateTypeParam != null && id.IdHash == originallyReferredTemplateTypeParam.NameHash) ? originallyReferredTemplateTypeParam : null' r' id.IdHash);" is 236.
Long Statement,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,Visit,The length of the statement  "						// If an expression (the usual case) has been passed as argument' evaluate its value' otherwise is its type already resolved." is 125.
Long Statement,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,Visit,The length of the statement  "						var finalArg = argumentArrayType is ArrayType ? (ISemantic)new PrimitiveValue((argumentArrayType as ArrayType).FixedLength) : argumentArrayType.KeyType;" is 152.
Long Statement,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,Visit,The length of the statement  "						result = TemplateParameterDeductionVisitor.Set(ctxt' TargetDictionary' originallyReferredTemplateTypeParam' finalArg' id.IdHash);" is 129.
Long Statement,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,Visit,The length of the statement  "						// Just test for equality of the argument and parameter expression' e.g. if both param and arg are 123' the result will be true." is 128.
Long Statement,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,Visit,The length of the statement  "						result = SymbolValueComparer.IsEqual(Evaluation.EvaluateValue(arrayDeclToCheckAgainst.KeyExpression' ctxt)' new PrimitiveValue((argumentArrayType as ArrayType).FixedLength));" is 174.
Long Statement,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,Visit,The length of the statement  "				 * Therefore' it's needed to manually resolve the identifier' and look out for aliases or such unprecise aliases..confusing as s**t!" is 131.
Long Statement,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,Visit,The length of the statement  "				 * If the param tix id is part of the template param list' the behaviour is currently undefined! - so instantly return false' I'll leave it as TODO/FIXME" is 152.
Long Statement,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,Visit,The length of the statement  "					if (tixBasedArgumentType != null && CheckForTixIdentifierEquality(paramTix_TemplateMatchPossibilities' tixBasedArgumentType.Definition))" is 136.
Long Statement,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,Visit,The length of the statement  "					var argEnum_given = (tixBasedArgumentType.Definition.TemplateParameters ?? Enumerable.Empty<TemplateParameter>()).GetEnumerator();" is 130.
Long Statement,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,ResolveTemplateInstanceId,The length of the statement  "				 * When having a cascaded tix as parameter' it uses the left-most part (i.e. the inner most) of the typedeclaration construct." is 125.
Long Statement,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,ResolveTemplateInstanceId,The length of the statement  "				ctxt.CurrentContext.ContextDependentOptions = ResolutionOptions.DontResolveBaseClasses | ResolutionOptions.DontResolveBaseTypes;" is 128.
Long Statement,D_Parser.Resolver.Templates,TemplateInstanceHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceEponymousTemplate,The length of the statement  "				ExpressionTypeEvaluation.EvaluateType(def.Initializer' ctxt)' ept.DeducedTypes); //ept; //ExpressionTypeEvaluation.EvaluateType (ept.Definition.Initializer' ctxt); " is 163.
Long Statement,D_Parser.Resolver.Templates,TemplateInstanceHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceOverloads,The length of the statement  "				var hook = D_Parser.Resolver.ResolutionHooks.HookRegistry.TryDeduce(overload' givenTemplateArguments' out ignoreOtherOverloads); " is 128.
Long Statement,D_Parser.Resolver.Templates,TemplateInstanceHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParam,The length of the statement  "				return CheckAndDeduceTypeTuple(expectedParam as TemplateTupleParameter' Enumerable.Empty<ISemantic>()' deducedTypes' ctxt); " is 123.
Long Statement,D_Parser.Resolver.Templates,TemplateInstanceHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParam,The length of the statement  "			// There might be too few args - but that doesn't mean that it's not correct - it's only required that all parameters got satisfied with a type " is 143.
Long Statement,D_Parser.Resolver.Templates,TemplateInstanceHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceOrInduceSingleTemplateParameter,The length of the statement  "				var probablyInducableParameter = DSymbolBaseTypeResolver.ResolveTemplateParameter(ctxt' new TemplateParameter.Node(parameter)); " is 127.
Long Statement,D_Parser.Resolver.TypeResolution,ASTSearchHelper,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\ASTSearchHelper.cs,SearchBlockAt,The length of the statement  "					return SearchBlockAt(subItem' Where); // For e.g. nested nested methods inside anonymous class declarations that occur furtherly inside a method. " is 145.
Long Statement,D_Parser.Resolver.TypeResolution,DSymbolBaseTypeResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\DSymbolBaseTypeResolver.cs,CanResolveBase,The length of the statement  "					|| (m.Type as IdentifierDeclaration).IdHash != m.NameHash || m.Type.InnerDeclaration != null); // pretty rough and incomplete SO prevention hack " is 144.
Long Statement,D_Parser.Resolver.TypeResolution,DSymbolBaseTypeResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\DSymbolBaseTypeResolver.cs,ResolveDVariableBaseType,The length of the statement  "				var variableModifiers = variable.Attributes.FindAll((DAttribute obj) => obj is Modifier).Select((arg) => ((Modifier)arg).Token).ToArray(); " is 138.
Long Statement,D_Parser.Resolver.TypeResolution,DSymbolBaseTypeResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\DSymbolBaseTypeResolver.cs,GetForeachIteratorType,The length of the statement  "			loc = new CodeLocation(loc.Column - 1' loc.Line); // SearchStmtDeeplyAt only checks '<' EndLocation' we may need to have '<=' though due to completion offsets. " is 159.
Long Statement,D_Parser.Resolver.TypeResolution,DSymbolBaseTypeResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\DSymbolBaseTypeResolver.cs,GetForeachIteratorType,The length of the statement  "			var curStmt = curMethod != null ? ASTSearchHelper.SearchStatementDeeplyAt(curMethod.GetSubBlockAt(ctxt.CurrentContext.Caret)' loc) : null; " is 138.
Long Statement,D_Parser.Resolver.TypeResolution,ClassInterfaceResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\ClassInterfaceResolver.cs,ResolveObjectClass,The length of the statement  "			using (ctxt.Push(ctxt.ScopedBlock == null ? null : ctxt.ScopedBlock.NodeRoot)) //TODO: understand why we're passing null " is 120.
Long Statement,D_Parser.Resolver.TypeResolution,ClassInterfaceResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\ClassInterfaceResolver.cs,ResolveInstantiationTemplateArguments,The length of the statement  "				// Pop a context frame as we still need to resolve the template instance expression args in the place where the expression occurs' not the instantiated class' location " is 167.
Long Statement,D_Parser.Resolver.TypeResolution,ClassInterfaceResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\ClassInterfaceResolver.cs,ResolveBaseClassOrInterface,The length of the statement  "			if (type == null || (type is IdentifierDeclaration && (type as IdentifierDeclaration).IdHash == dc.NameHash) || dc.NodeRoot == dc) " is 130.
Long Statement,D_Parser.Resolver.TypeResolution,ClassInterfaceResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\ClassInterfaceResolver.cs,ResolveBaseClassOrInterface,The length of the statement  "					ctxt.LogError(new ResolutionError(dc' "The base " + (r is ClassType ? "class" : "template") + " name must preceed base interfaces")); " is 133.
Long Statement,D_Parser.Resolver.TypeResolution,SingleResolverVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\SingleResolverVisitor.cs,Visit,The length of the statement  "					// D Magic: One might access tuple items directly in the pseudo array declaration - so stuff like Tup[0] i; becomes e.g. int i; " is 127.
Long Statement,D_Parser.Resolver.TypeResolution,SingleResolverVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\SingleResolverVisitor.cs,Visit,The length of the statement  "						ctxt.LogError (ad' "TypeTuple only consists of " + (dtup.Items != null ? dtup.Items.Length : 0) + " items. Can't access item at index " + fixedArrayLength); " is 156.
Long Statement,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,ResolveFurtherTypeIdentifier,The length of the statement  "							r.AddRange(UFCSResolver.TryResolveUFCS(b' nextIdentifierHash' ctxt.ScopedBlock != udt.Definition && typeIdObject != null ? typeIdObject.Location : ctxt.ScopedBlock.BlockStartLocation' ctxt' typeIdObject));" is 205.
Long Statement,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,ResolveFurtherTypeIdentifier,The length of the statement  "						r.AddRange(UFCSResolver.TryResolveUFCS (b' nextIdentifierHash' typeIdObject != null ? typeIdObject.Location : ctxt.ScopedBlock.BlockStartLocation' ctxt' typeIdObject));" is 168.
Long Statement,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,TryPostDeduceAliasDefinition,The length of the statement  "						bases = TemplateInstanceHandler.DeduceParamsAndFilterOverloads(aliasBase' typeBase as TemplateInstanceExpression' ctxt' false);" is 127.
Long Statement,D_Parser.Resolver.TypeResolution,DResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,StripMemberSymbols,The length of the statement  "				// auto o = new Class(); -- o will be MemberSymbol and its base type will be a MemberSymbol either (i.e. the constructor reference)" is 131.
Long Statement,D_Parser.Resolver.TypeResolution,DResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,StripMemberSymbols,The length of the statement  "				if(ds is MemberSymbol && (ds as DSymbol).Definition is DMethod && (ds as DSymbol).NameHash == DMethod.ConstructorIdentifierHash)" is 128.
Long Statement,D_Parser.Resolver.TypeResolution,OpDispatchResolution,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\OpDispatchResolution.cs,TryResolveFurtherIdViaOpDispatch,The length of the statement  "				ctxt.CurrentContext.ContextDependentOptions = opt; // Mainly required for not resolving opDispatch's return type' as this will be performed later on in higher levels" is 165.
Long Statement,D_Parser.Completion,ParameterInsightResolution,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\ParameterInsightResolution.cs,Visit,The length of the statement  "			res.ResolvedTypesOrMethods = ExpressionTypeEvaluation.GetUnfilteredMethodOverloads(call.PostfixForeExpression' ctxt' call);" is 123.
Long Statement,D_Parser.Completion,ParameterInsightResolution,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\ParameterInsightResolution.cs,Visit,The length of the statement  "			var ov = TypeDeclarationResolver.ResolveFurtherTypeIdentifier(ExpressionTypeEvaluation.OpSliceIdHash' b' ctxt' x' false);" is 121.
Long Statement,D_Parser.Completion,MemberCompletionEnumeration,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\MemberCompletionEnumeration.cs,PreCheckItem,The length of the statement  "			return isVarInst || !(n is DMethod || dv != null || n is TemplateParameter.Node) ||	(n as DNode).IsStatic || n is DEnumValue ||	(dv != null && (dv.IsConst || dv.IsAlias)); " is 171.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The length of the statement  "				(n.ContainsAnyAttribute (DTokens.Auto) || DTokensSemanticHelpers.ContainsStorageClass(n.Attributes) != Modifier.Empty)) { " is 121.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,VisitAttribute,The length of the statement  "			if (a.ContentHash == DTokens.IncompleteIdHash || ((c = a.LiteralContent as string) != null && c.EndsWith(DTokens.IncompleteId))) { " is 130.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The length of the statement  "				const MemberFilter BaseAsmFlags = MemberFilter.Classes | MemberFilter.StructsAndUnions | MemberFilter.Enums | MemberFilter.Methods | MemberFilter.TypeParameters | MemberFilter.Types | MemberFilter.Variables; " is 207.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The length of the statement  "					prv = new CtrlSpaceCompletionProvider(cdgen' scopedBlock' BaseAsmFlags | MemberFilter.x86Registers | MemberFilter.x64Registers | MemberFilter.Labels); " is 150.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The length of the statement  "					prv = new CtrlSpaceCompletionProvider (cdgen' scopedBlock' shownKeywords.Count == 0 ? MemberFilter.All | MemberFilter.ExpressionKeywords : shownKeywords.Peek()); " is 161.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The length of the statement  "					// When typing a dot without anything following' trigger completion and show types' methods and vars that are located in the module & import scope " is 146.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The length of the statement  "					prv = new CtrlSpaceCompletionProvider (cdgen' scopedBlock' MemberFilter.Methods | MemberFilter.Types | MemberFilter.Variables | MemberFilter.TypeParameters ); " is 158.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The length of the statement  "				prv = new CtrlSpaceCompletionProvider(cdgen' scopedBlock' MemberFilter.Types | MemberFilter.ExpressionKeywords | MemberFilter.StatementBlockKeywords); " is 150.
Complex Conditional,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\ToolTips\NodeTooltipRepresentationGen.cs,GenTooltipSignature,The conditional expression  "currentMethodParam >= 0 && !templateParamCompletion && ds.Definition is DVariable && ds.Base != null"  is complex.
Complex Conditional,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\ToolTips\NodeTooltipRepresentationGen.cs,GenTooltipSignature,The conditional expression  "dvar.IsConst || dvar.IsAlias || dvar is DEnumValue || dvar.ContainsAnyAttribute(DTokens.Immutable)"  is complex.
Complex Conditional,D_Parser.Dom,DBlockNode,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Nodes\DBlockNode.cs,GetMetaBlockStack,The conditional expression  "lastSr != null && !(mindAttributeSections && lastSr is AttributeMetaDeclarationSection) && mb.Location < lastSr.Location && mb.EndLocation > lastSr.EndLocation"  is complex.
Complex Conditional,D_Parser.Formatting,DFormattingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,GetCommentsBefore,The conditional expression  "c == ' ' || c == '\t' || c=='\r' || c == '\n'"  is complex.
Complex Conditional,D_Parser.Formatting,DFormattingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,ForceSpacesAfterRemoveLines,The conditional expression  "i < document.TextLength && (IsSpacing (c = document[i]) || c == '\r' || c == '\n')"  is complex.
Complex Conditional,D_Parser.Formatting,DFormattingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,VisitChildren,The conditional expression  "mbStack.Count == 0 || (mb.Location > (peekMb = mbStack.Peek()).Location &&   					                          mb.EndLocation < peekMb.EndLocation &&   					                          !(peekMb is AttributeMetaDeclarationSection))"  is complex.
Complex Conditional,D_Parser.Formatting.Indent,IndentEngineWrapper,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CorrectIndent,The conditional expression  "code.Peek() == -1 || (formatLastLine && n != '\r' && n != '\n')"  is complex.
Complex Conditional,D_Parser.Formatting.Indent,IndentEngine,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushNewLine,The conditional expression  "keyword == DTokens.Case || keyword == DTokens.Default || !canBeLabel || inside == Inside.Empty"  is complex.
Complex Conditional,D_Parser.Formatting.Indent,IndentEngine,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushNewLine,The conditional expression  "(stack.PeekInside(0) == Inside.Block && stack.PeekKeyword == DTokens.Enum)   						||(inside == Inside.FoldedStatement || inside == Inside.SquareBracketList)"  is complex.
Complex Conditional,D_Parser.Formatting.Indent,IndentStack,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,The conditional expression  "(stack [sp].inside & Inside.FoldedBlockOrCase) != 0 ||  						// If there's myFoo( \n { \n' keep the ( indent + 1 tab  						// If there's myFoo( \n [ \n' keep the ( indent only if ie.Options.KeepArgumentIndentOnSquareBracketOpen says so.  						((inside != Inside.SquareBracketList || ie.Options.KeepArgumentIndentOnSquareBracketOpen) && stack[sp].inside == Inside.ParenList)"  is complex.
Complex Conditional,D_Parser.Parser.Implementations,DAsmStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DAsmStatementParser.cs,ParseAsmStatement,The conditional expression  "!Expect(DTokens.CloseCurlyBrace) && (t.Kind == DTokens.OpenCurlyBrace || t.Kind == DTokens.Semicolon) && IsEOF"  is complex.
Complex Conditional,D_Parser.Parser.Implementations,DBodiedSymbolsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DBodiedSymbolsParser.cs,EnumValue,The conditional expression  "laKind == DTokens.Identifier && ( 				Lexer.CurrentPeekToken.Kind == DTokens.Assign || 				Lexer.CurrentPeekToken.Kind == DTokens.Comma || 				Lexer.CurrentPeekToken.Kind == DTokens.CloseCurlyBrace)"  is complex.
Complex Conditional,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,AliasDeclaration,The conditional expression  "(laKind == DTokens.Identifier && Lexer.CurrentPeekToken.Kind == DTokens.This) || 				(laKind == DTokens.This && Lexer.CurrentPeekToken.Kind == DTokens.Assign)"  is complex.
Complex Conditional,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,AliasDeclaration,The conditional expression  "laKind == DTokens.Identifier && (Lexer.CurrentPeekToken.Kind == DTokens.Assign || 				(Lexer.CurrentPeekToken.Kind == DTokens.OpenParenthesis && OverPeekBrackets(DTokens.OpenParenthesis) && Lexer.CurrentPeekToken.Kind == DTokens.Assign))"  is complex.
Complex Conditional,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,Decl,The conditional expression  "(StorageClass != Modifier.Empty && 				laKind == DTokens.Identifier && (DeclarationAttributes.Count > 0 || Lexer.CurrentPeekToken.Kind == DTokens.OpenParenthesis))"  is complex.
Complex Conditional,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,Decl,The conditional expression  "isAlias && (laKind == DTokens.This || laKind == DTokens.Super) && Lexer.CurrentPeekToken.Kind != DTokens.Dot"  is complex.
Complex Conditional,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,Decl,The conditional expression  "tix.Arguments == null || tix.Arguments.Length == 0 || 						(tix.Arguments[tix.Arguments.Length - 1] is TokenExpression && 						(tix.Arguments[tix.Arguments.Length - 1] as TokenExpression).Token == DTokens.INVALID)"  is complex.
Complex Conditional,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,Declarator,The conditional expression  "(tokDecl == null || tokDecl.Token != DTokens.Incomplete) && // 'T!|' or similar 							(ad == null || !(ad.KeyExpression is TokenExpression) || (ad.KeyExpression as TokenExpression).Token != DTokens.Incomplete)"  is complex.
Complex Conditional,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,Declarator2,The conditional expression  "AllowWeakTypeParsing && (td == null 					|| (t.Kind == DTokens.OpenParenthesis && laKind == DTokens.CloseParenthesis) /* -- means if an argumentless function call has been made' return null because this would be an expression */ 					|| laKind != DTokens.CloseParenthesis)"  is complex.
Complex Conditional,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,Parameter,The conditional expression  "(DTokensSemanticHelpers.IsParamModifier(laKind) && laKind != DTokens.InOut) || (DTokensSemanticHelpers.IsMemberFunctionAttribute(laKind) && Lexer.CurrentPeekToken.Kind != DTokens.OpenParenthesis)"  is complex.
Complex Conditional,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,PostfixExpression,The conditional expression  "(laKind == DTokens.Identifier && Peek(1).Kind != DTokens.Not && Peek(1).Kind != DTokens.OpenParenthesis) || IsEOF"  is complex.
Complex Conditional,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,PrimaryExpression,The conditional expression  "laKind == DTokens.Identifier && (Lexer.CurrentPeekToken.Kind == DTokens.CloseParenthesis 							|| Lexer.CurrentPeekToken.Kind == DTokens.Equal 							|| Lexer.CurrentPeekToken.Kind == DTokens.Colon)"  is complex.
Complex Conditional,D_Parser.Parser.Implementations,DExpressionsParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DExpressionsParser.cs,TraitsExpression,The conditional expression  "td != null && (laKind == DTokens.Comma || laKind == DTokens.CloseParenthesis || IsEOF)"  is complex.
Complex Conditional,D_Parser.Parser.Implementations,DStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DStatementParser.cs,IfCondition,The conditional expression  "tp != null && ((laKind == DTokens.Identifier &&  				(Peek(1).Kind == DTokens.Assign || Lexer.CurrentPeekToken.Kind == DTokens.CloseParenthesis)) || // if(a * b * c) is an expression' if(a * b = 123) may be a pointer variable  				(IsEOF && tp.InnerDeclaration == null))"  is complex.
Complex Conditional,D_Parser.Parser.Implementations,DStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DStatementParser.cs,Statement,The conditional expression  "laKind != DTokens.Case && laKind != DTokens.Default && laKind != DTokens.CloseCurlyBrace && !IsEOF"  is complex.
Complex Conditional,D_Parser.Parser.Implementations,DStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DStatementParser.cs,Statement,The conditional expression  "laKind != DTokens.Case && laKind != DTokens.Default && laKind != DTokens.CloseCurlyBrace && !IsEOF"  is complex.
Complex Conditional,D_Parser.Parser.Implementations,DStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DStatementParser.cs,Statement,The conditional expression  "ds.Declarations != null &&  						ds.Declarations.Length == 1 &&  						!(ds.Declarations[0] is DVariable) &&  						!AllowWeakTypeParsing"  is complex.
Complex Conditional,D_Parser.Parser.Implementations,DStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DStatementParser.cs,Statement,The conditional expression  "DTokensSemanticHelpers.IsClassLike(laKind)  						|| (DTokensSemanticHelpers.IsBasicType(laKind) && Lexer.CurrentPeekToken.Kind != DTokens.Dot)  						|| DTokensSemanticHelpers.IsModifier(laKind)"  is complex.
Complex Conditional,D_Parser.Parser.Implementations,DTemplatesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DTemplatesParser.cs,TemplateParameter,The conditional expression  "laKind == (DTokens.Identifier) && (  				Lexer.CurrentPeekToken.Kind == (DTokens.Colon)  				|| Lexer.CurrentPeekToken.Kind == (DTokens.Assign)  				|| Lexer.CurrentPeekToken.Kind == (DTokens.Comma)  				|| Lexer.CurrentPeekToken.Kind == (DTokens.CloseParenthesis))"  is complex.
Complex Conditional,D_Parser.Parser,DDocParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,SkipParameterText,The conditional expression  "Peek () == '!' &&  					    nextOffset + 2 < text.Length &&  					    text [nextOffset + 1] == '-' && text [nextOffset + 2] == '-'"  is complex.
Complex Conditional,D_Parser.Refactoring,TypeReferenceFinder,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,CheckCondition,The conditional expression  "c == null || 				c is StaticIfCondition ||  				(c is NegatedDeclarationCondition && (c as NegatedDeclarationCondition).FirstCondition is NegatedDeclarationCondition)"  is complex.
Complex Conditional,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,DeepScanClass,The conditional expression  "resolveBaseClassIfRequired && udt.Base == null &&  						(type == DTokens.Class ||type == DTokens.Interface)"  is complex.
Complex Conditional,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,CanHandleNode,The conditional expression  "(CanShowMember(dn' ctxt.ScopedBlock) || (parms.isBaseClass && !parms.isMixinAst)) && ((!parms.takeStaticChildrenOnly && (!parms.publicImportsOnly || !parms.isBaseClass)) || IsConstOrStatic(dn))"  is complex.
Complex Conditional,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,CanHandleNode,The conditional expression  "dm3 != null && !(dm3.SpecialType == DMethod.MethodType.Normal || dm3.SpecialType == DMethod.MethodType.Delegate || dm3.NameHash != 0)"  is complex.
Complex Conditional,D_Parser.Resolver.ASTScanner,StatementHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,VisitDVariable,The conditional expression  "dv.Initializer != null && 					(caretInsensitive || (dv.Initializer.Location > Caret && dv.Initializer.EndLocation < Caret))"  is complex.
Complex Conditional,D_Parser.Resolver.ASTScanner,StatementHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,VisitSubStatements,The conditional expression  "!(ignoreBounds || caretInsensitive) && 					(stmtContainer.Location > Caret || stmtContainer.EndLocation < Caret)"  is complex.
Complex Conditional,D_Parser.Resolver.ASTScanner,StatementHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,Visit,The conditional expression  "s.Location < Caret && 					(s.ScopedStatement == null || s.ScopedStatement.EndLocation >= Caret) && 					s.ForeachTypeList != null"  is complex.
Complex Conditional,D_Parser.Resolver,DTypeToTypeDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\DTypeToTypeDeclVisitor.cs,VisitDSymbol,The conditional expression  "def != null && def != (def = def.Parent as DNode) && 				def != null && !(def is DModule)"  is complex.
Complex Conditional,D_Parser.Resolver,ResultComparer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ResultComparer.cs,IsImplicitlyConvertible,The conditional expression  "!isVariable && 				resToCheck is ArrayType && 				targetType is PointerType && ((targetType = (targetType as PointerType).Base) is PrimitiveType) && 				DTokensSemanticHelpers.IsBasicType_Character((targetType as PrimitiveType).TypeToken)"  is complex.
Complex Conditional,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,mult,The conditional expression  "(a.Value!=0 && b.Value == 0) || (a.ImaginaryPart!=0 && b.ImaginaryPart==0)"  is complex.
Complex Conditional,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,mult,The conditional expression  "(a.Value!=0 && b.Value == 0) || (a.ImaginaryPart!=0 && b.ImaginaryPart==0)"  is complex.
Complex Conditional,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetConstructors,The conditional expression  "dv != null &&  							!dv.IsStatic &&  							!dv.IsAlias &&  							!dv.IsConst"  is complex.
Complex Conditional,D_Parser.Resolver.Templates,SpecializationOrdering,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\SpecializationOrdering.cs,IsMoreSpecialized,The conditional expression  "dn1 == null || dn1.TemplateParameters == null || dn2 == null || dn2.TemplateParameters == null"  is complex.
Complex Conditional,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,Visit,The conditional expression  "(arrayDeclToCheckAgainst.ClampsEmpty == (at == null)) && 					(at == null || !at.IsStaticArray || arrayDeclToCheckAgainst.KeyExpression == null)"  is complex.
Complex Conditional,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,Visit,The conditional expression  "(d.Parameters == null || d.Parameters.Count == 0) && 						dr_decl.Parameters == null || dr_decl.Parameters.Count == 0"  is complex.
Complex Conditional,D_Parser.Resolver.Templates,TemplateTypeParamDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateTypeParameterTypeMatcher.cs,Visit,The conditional expression  "(dn.Attributes == null || dn.Attributes.Count == 0) && 								(dn_arg.Attributes == null || dn_arg.Attributes.Count == 0)"  is complex.
Complex Conditional,D_Parser.Resolver.TypeResolution,ClassInterfaceResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\ClassInterfaceResolver.cs,ResolveBaseClassOrInterface,The conditional expression  "type == null || (type is IdentifierDeclaration && (type as IdentifierDeclaration).IdHash == dc.NameHash) || dc.NodeRoot == dc"  is complex.
Complex Conditional,D_Parser.Resolver.TypeResolution,ScopedObjectVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\ScopedObjectVisitor.cs,VisitTemplateParameter,The conditional expression  "tp.NameHash != 0 &&  				caret.Line == nl.Line &&  				caret.Column >= nl.Column &&  				(name = tp.Name) != null &&  				caret.Column <= nl.Column + name.Length"  is complex.
Complex Conditional,D_Parser.Resolver.TypeResolution,ScopedObjectVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\ScopedObjectVisitor.cs,VisitDNode,The conditional expression  "n.NameHash != 0 &&  				caret.Line == nl.Line &&  				caret.Column >= nl.Column &&  				(name = n.Name) != null &&  				caret.Column <= nl.Column + name.Length"  is complex.
Complex Conditional,D_Parser.Resolver.TypeResolution,UFCSResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\UFCSResolver.cs,PreCheckItem,The conditional expression  "(nameFilterHash != 0 && n.NameHash != nameFilterHash) || (!(n is ImportSymbolNode) && !(n.Parent is DModule))"  is complex.
Complex Conditional,D_Parser.Completion,CompletionProviderVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The conditional expression  "!halt && n.NameHash == 0 &&   				(n.ContainsAnyAttribute (DTokens.Auto) || DTokensSemanticHelpers.ContainsStorageClass(n.Attributes) != Modifier.Empty)"  is complex.
Virtual Method Call from Constructor,D_Parser.Resolver,StaticProperties,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,StaticProperties,The constructor "StaticProperties" calls a virtual method "Accept".
Empty Catch Block,D_Parser.Parser.Implementations,DModulesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DModulesParser.cs,DeclDef,The method has an empty catch block.
Empty Catch Block,D_Parser.Refactoring,TypeReferenceFinder,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,Visit,The method has an empty catch block.
Empty Catch Block,D_Parser.Resolver.ExpressionSemantics,MathOperationEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MathOperationEvaluation.cs,ToBool,The method has an empty catch block.
Empty Catch Block,D_Parser.Resolver.ExpressionSemantics,MathOperationEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MathOperationEvaluation.cs,ToDouble,The method has an empty catch block.
Empty Catch Block,D_Parser.Resolver.ExpressionSemantics,MathOperationEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MathOperationEvaluation.cs,ToLong,The method has an empty catch block.
Empty Catch Block,D_Parser.Resolver.Templates,TemplateInstanceHandler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParamsAndFilterOverloads,The method has an empty catch block.
Magic Number,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\ToolTips\NodeTooltipRepresentationGen.cs,AppendFormat,The following statement contains a magic number: sb.Append($" color='#{(int) (r * 255.0):x2}{(int) (g * 255.0):x2}{(int) (b * 255.0):x2}'");
Magic Number,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\ToolTips\NodeTooltipRepresentationGen.cs,AppendFormat,The following statement contains a magic number: sb.Append($" color='#{(int) (r * 255.0):x2}{(int) (g * 255.0):x2}{(int) (b * 255.0):x2}'");
Magic Number,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\ToolTips\NodeTooltipRepresentationGen.cs,AppendFormat,The following statement contains a magic number: sb.Append($" color='#{(int) (r * 255.0):x2}{(int) (g * 255.0):x2}{(int) (b * 255.0):x2}'");
Magic Number,D_Parser.Dom,DClassLike,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Nodes\OtherNodeDefinitions.cs,ToString,The following statement contains a magic number: sb.Remove(sb.Length - 2' 2);
Magic Number,D_Parser.Dom,DClassLike,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Nodes\OtherNodeDefinitions.cs,ToString,The following statement contains a magic number: sb.Remove(sb.Length - 2' 2);
Magic Number,D_Parser.Dom,CodeLocation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\CodeLocation.cs,GetHashCode,The following statement contains a magic number: return unchecked(87 * Column.GetHashCode() ^ Line.GetHashCode());
Magic Number,D_Parser.Dom.Expressions,ArrayLiteralExpression,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Expressions\ArrayLiteralExpression.cs,ToString,The following statement contains a magic number: ++i == 100
Magic Number,D_Parser.Dom.Statements,AsmRawDataStatement,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Statements\AsmRawDataStatement.cs,ToCode,The following statement contains a magic number: var sb = new StringBuilder(Data.Length * 4);
Magic Number,D_Parser.Dom.Statements,AsmInstructionStatement,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Statements\AsmInstructionStatement.cs,AsmInstructionStatement,The following statement contains a magic number: var argumentForms = new List<AT[]>(16);
Magic Number,D_Parser.Dom.Statements,AsmAlignStatement,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Statements\AsmAlignStatement.cs,ToCode,The following statement contains a magic number: ie != null && ie.Value.Equals(2m)
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Hash,The following statement contains a magic number: Hash (ref h' prime' o ? 3L : 0);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return unchecked(100003 * VisitDVariable(n as DVariable));
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitDVariable,The following statement contains a magic number: long h = 100019 * VisitDNode (n);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1000037;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitBlockNode,The following statement contains a magic number: const long prime = 1000117;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1000039;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return unchecked(1000081 * VisitBlockNode(n));
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1000099;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return unchecked(1000133 * n.Mixin.Accept(this));
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return unchecked(1000231 * VisitDVariable((DVariable)ep));
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1000249;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1000253;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1000273;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: const long prime = 1000151;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: return 1000159;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: return unchecked(1000171 * VisitAttribute((Modifier)attr));
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: return 1000183 * (long)a.Kind;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: const long prime = 1000187;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: return 1000193 * ((long)a.VersionNumber + (long)a.VersionIdHash);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: return 1000199 * ((long)a.DebugLevel + (long)a.DebugIdHash);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: const long prime = 1000211;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: return unchecked(1000213 * a.FirstCondition.Accept(this));
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000289;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000291;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitImport,The following statement contains a magic number: return 1000303;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitImport,The following statement contains a magic number: return 1000313;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitImport,The following statement contains a magic number: return 1000333;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000357;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000367;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000381;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000393;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000397;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000403;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000409;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000423;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000427;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000429;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000453;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000457;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000507;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000537;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000541;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000547;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000577;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000579;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000589;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000609;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAsmStatement,The following statement contains a magic number: return 1000619;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAsmInstructionStatement,The following statement contains a magic number: return 1000621;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAsmRawDataStatement,The following statement contains a magic number: return 1000639;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAsmAlignStatement,The following statement contains a magic number: return 1000651;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000667;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000679;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000691;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000697;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000699;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000721;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000723;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000763;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000777;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000793;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1002341;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitMixinStatement,The following statement contains a magic number: return 1000829;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1000847;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression (x' 1000849);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1000859;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1000861);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1000889);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1000907);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1000919);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1000921);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1000931);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1000969;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1000973);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1000981;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: Hash (ref h' prime' x.Not ? 2 : 1);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1000999);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1001003);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1001017);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1001023);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1001027);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression(x' 1001041);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression(x' 1001069);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression(x' 1001081);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression(x' 1001087);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression(x' 1001089);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression(x' 1001093);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression(x' 1001107);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression(x' 1001123);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001153;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001159;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001173;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression(x' 1001177);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001191;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001197;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitPostfixExpression(x' 1001219);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitPostfixExpression(x' 1001237);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitPostfixExpression_Methodcall,The following statement contains a magic number: const long prime = 1001267;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001279;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001303;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitScalarConstantExpression,The following statement contains a magic number: const long prime = 1002341;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitStringLiteralExpression,The following statement contains a magic number: const long prime = 1002343;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001311;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001321 + (long)x.Token >> 8;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001321 + (long)x.Token >> 8;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001323 + x.Declaration.Accept(this);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001327;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001347;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001353;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001369;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001381;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001387;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001389;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001401;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001411;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001431;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001447;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001459;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001467;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001491;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001501 * x.Register.GetHashCode();
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001527;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001531;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001549;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001551;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001563;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitTypeDeclaration(td' 1001569);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001587;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001593;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001639;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001621;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitTypeDeclaration(td' 1001629);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitPrimitiveType,The following statement contains a magic number: const long prime = 1001659;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitPointerType,The following statement contains a magic number: return VisitDerivedType (t' 1001669);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitArrayType,The following statement contains a magic number: const long prime = 1001683;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAssocArrayType,The following statement contains a magic number: const long prime = 1001687;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitDelegateCallSymbol,The following statement contains a magic number: const long prime = 1001713;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitDelegateType,The following statement contains a magic number: const long prime = 1001723;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAliasedType,The following statement contains a magic number: return VisitDSymbol(t' 1001743);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitEnumType,The following statement contains a magic number: return VisitUserDefinedType (t' 1001783);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitStructType,The following statement contains a magic number: return VisitTemplateIntermediaryType (t' 1001797);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitUnionType,The following statement contains a magic number: return VisitTemplateIntermediaryType (t' 1001801);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitClassType,The following statement contains a magic number: return VisitTemplateIntermediaryType (t' 1001807);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitInterfaceType,The following statement contains a magic number: return VisitTemplateIntermediaryType (t' 1001809);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitTemplateType,The following statement contains a magic number: return VisitTemplateIntermediaryType (t' 1001821);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitMixinTemplateType,The following statement contains a magic number: return VisitTemplateIntermediaryType (t' 1001831);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitEponymousTemplateType,The following statement contains a magic number: return VisitUserDefinedType (t' 1001839);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitStaticProperty,The following statement contains a magic number: return VisitMemberSymbol(t' 1001911);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitMemberSymbol,The following statement contains a magic number: return VisitDSymbol (t' 1001933);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitTemplateParameterSymbol,The following statement contains a magic number: const long prime = 1001941;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitArrayAccessSymbol,The following statement contains a magic number: return VisitDerivedType(t' 1001947);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitModuleSymbol,The following statement contains a magic number: return VisitDSymbol(t' 1001953);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitPackageSymbol,The following statement contains a magic number: const long prime = 1001977;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitDTuple,The following statement contains a magic number: const long prime = 1001981;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitUnknownType,The following statement contains a magic number: return VisitAbstractType(t' 1001983);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAmbigousType,The following statement contains a magic number: const long prime = 1001989;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitMetaDeclarationBlock,The following statement contains a magic number: return 1002017;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttributeMetaDeclarationBlock,The following statement contains a magic number: return 1002049;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttributeMetaDeclarationSection,The following statement contains a magic number: return 1002061;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitElseMetaDeclarationBlock,The following statement contains a magic number: return 1002073;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitElseMetaDeclarationSection,The following statement contains a magic number: return 1002151;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitElseMetaDeclaration,The following statement contains a magic number: return 1002077;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttributeMetaDeclaration,The following statement contains a magic number: return 1002083;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitTemplateParameter,The following statement contains a magic number: const long prime = 1002091;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1002101;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1002109;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1002121;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1002143;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1002149 * VisitTemplateParameter(tp);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitErrorValue,The following statement contains a magic number: const long prime = 1002173;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitPrimitiveValue,The following statement contains a magic number: const long prime = 1002191;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitVoidValue,The following statement contains a magic number: return VisitExpressionValue (v' 1002227);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitArrayValue,The following statement contains a magic number: const long prime = 1002241;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAssociativeArrayValue,The following statement contains a magic number: const long prime = 1002247;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitDelegateValue,The following statement contains a magic number: const long prime = 1002257;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitNullValue,The following statement contains a magic number: return VisitExpressionValue (v' 1002259);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitTypeOverloadValue,The following statement contains a magic number: const long prime = 1002263;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitVariableValue,The following statement contains a magic number: return VisitReferenceValue(v' 1002289);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitTypeValue,The following statement contains a magic number: return VisitExpressionValue (v' 1002299);
Magic Number,D_Parser.Formatting,DFormattingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,Visit,The following statement contains a magic number: switch(n.SpecialType)  			{  				case DMethod.MethodType.Destructor:  				case DMethod.MethodType.Constructor:  					nameLength = 4; // this  					break;  				case DMethod.MethodType.Normal:  					nameLength = n.Name.Length;  					break;  			}
Magic Number,D_Parser.Formatting,TextDocument,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DocumentAdapter.cs,ToLocation,The following statement contains a magic number: offset < text.Length/2
Magic Number,D_Parser.Formatting.Indent,IndentEngineWrapper,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CalculateIndent,The following statement contains a magic number: line < 2
Magic Number,D_Parser.Formatting.Indent,IndentEngine,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,WordIsKeyword,The following statement contains a magic number: var kw = DTokens.GetTokenID(linebuf.ToString (wordStart' Math.Min (linebuf.Length - wordStart' 15)));
Magic Number,D_Parser.Formatting.Indent,IndentEngine,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,Push,The following statement contains a magic number: switch (c) {  			case '#':  				PushHash (inside);  				lastChar = '#';  				break;  			case '/':  				PushSlash (inside);  				break;  			case '\\':  				PushBackSlash (inside);  				break;  			case '+':  			case '*':  				PushStar (inside'c);  				break;  			case '`':  				PushAccGrave(inside);  				break;  			case '"':  				PushQuote (inside);  				break;  			case '\'':  				PushSQuote (inside);  				break;  			case ':':  				PushColon (inside);  				break;  			case ';':  				PushSemicolon (inside);  				break;  			case '[':  				PushOpenSq (inside);  				break;  			case ']':  				PushCloseSq (inside);  				break;  			case '(':  				PushOpenParen (inside);  				break;  			case ')':  				PushCloseParen (inside);  				break;  			case '{':  				PushOpenBrace (inside);  				break;  			case '}':  				PushCloseBrace (inside);  				break;  			case '\r':  				CheckForParentList ();  				PushNewLine (inside);  				lastChar = c;  				return;  			case '\n':  				CheckForParentList ();  				  				if (lastChar == '\r') {  					cursor++;  				} else {  					PushNewLine (inside);  				}  				lastChar = c;  				return;  				case 'e': // If there's an 'else'' look if there has been a if-else backup stack prepared  					//KNOWN ISSUE: Reset this backup stack if there's anything else than an 'else' following the recently closed if-stmt;   					// Anyway this shouldn't be noticed that often as there can't be a stand-alone 'else' dangling around somewhere.   					if (linebuf.Length > 2 && linebuf.ToString (linebuf.Length - 3' 3) == "els") {  						var backup = stack.PeekIfElseBackupStack;  						stack.PeekIfElseBackupStack = null;  						if (backup != null && backup.Count > 0) {  							keyword = DTokens.Else;  							inside = Inside.FoldedStatement;  							stack = backup;  							stack.Pop ();  							var newIndent = stack.PeekIndent (0);				  							if (curIndent != newIndent) {  								curIndent = newIndent;  								needsReindent = true;  							}  						}  					}  					break;  			default:  				break;  			}
Magic Number,D_Parser.Formatting.Indent,IndentEngine,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,Push,The following statement contains a magic number: switch (c) {  			case '#':  				PushHash (inside);  				lastChar = '#';  				break;  			case '/':  				PushSlash (inside);  				break;  			case '\\':  				PushBackSlash (inside);  				break;  			case '+':  			case '*':  				PushStar (inside'c);  				break;  			case '`':  				PushAccGrave(inside);  				break;  			case '"':  				PushQuote (inside);  				break;  			case '\'':  				PushSQuote (inside);  				break;  			case ':':  				PushColon (inside);  				break;  			case ';':  				PushSemicolon (inside);  				break;  			case '[':  				PushOpenSq (inside);  				break;  			case ']':  				PushCloseSq (inside);  				break;  			case '(':  				PushOpenParen (inside);  				break;  			case ')':  				PushCloseParen (inside);  				break;  			case '{':  				PushOpenBrace (inside);  				break;  			case '}':  				PushCloseBrace (inside);  				break;  			case '\r':  				CheckForParentList ();  				PushNewLine (inside);  				lastChar = c;  				return;  			case '\n':  				CheckForParentList ();  				  				if (lastChar == '\r') {  					cursor++;  				} else {  					PushNewLine (inside);  				}  				lastChar = c;  				return;  				case 'e': // If there's an 'else'' look if there has been a if-else backup stack prepared  					//KNOWN ISSUE: Reset this backup stack if there's anything else than an 'else' following the recently closed if-stmt;   					// Anyway this shouldn't be noticed that often as there can't be a stand-alone 'else' dangling around somewhere.   					if (linebuf.Length > 2 && linebuf.ToString (linebuf.Length - 3' 3) == "els") {  						var backup = stack.PeekIfElseBackupStack;  						stack.PeekIfElseBackupStack = null;  						if (backup != null && backup.Count > 0) {  							keyword = DTokens.Else;  							inside = Inside.FoldedStatement;  							stack = backup;  							stack.Pop ();  							var newIndent = stack.PeekIndent (0);				  							if (curIndent != newIndent) {  								curIndent = newIndent;  								needsReindent = true;  							}  						}  					}  					break;  			default:  				break;  			}
Magic Number,D_Parser.Formatting.Indent,IndentEngine,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,Push,The following statement contains a magic number: switch (c) {  			case '#':  				PushHash (inside);  				lastChar = '#';  				break;  			case '/':  				PushSlash (inside);  				break;  			case '\\':  				PushBackSlash (inside);  				break;  			case '+':  			case '*':  				PushStar (inside'c);  				break;  			case '`':  				PushAccGrave(inside);  				break;  			case '"':  				PushQuote (inside);  				break;  			case '\'':  				PushSQuote (inside);  				break;  			case ':':  				PushColon (inside);  				break;  			case ';':  				PushSemicolon (inside);  				break;  			case '[':  				PushOpenSq (inside);  				break;  			case ']':  				PushCloseSq (inside);  				break;  			case '(':  				PushOpenParen (inside);  				break;  			case ')':  				PushCloseParen (inside);  				break;  			case '{':  				PushOpenBrace (inside);  				break;  			case '}':  				PushCloseBrace (inside);  				break;  			case '\r':  				CheckForParentList ();  				PushNewLine (inside);  				lastChar = c;  				return;  			case '\n':  				CheckForParentList ();  				  				if (lastChar == '\r') {  					cursor++;  				} else {  					PushNewLine (inside);  				}  				lastChar = c;  				return;  				case 'e': // If there's an 'else'' look if there has been a if-else backup stack prepared  					//KNOWN ISSUE: Reset this backup stack if there's anything else than an 'else' following the recently closed if-stmt;   					// Anyway this shouldn't be noticed that often as there can't be a stand-alone 'else' dangling around somewhere.   					if (linebuf.Length > 2 && linebuf.ToString (linebuf.Length - 3' 3) == "els") {  						var backup = stack.PeekIfElseBackupStack;  						stack.PeekIfElseBackupStack = null;  						if (backup != null && backup.Count > 0) {  							keyword = DTokens.Else;  							inside = Inside.FoldedStatement;  							stack = backup;  							stack.Pop ();  							var newIndent = stack.PeekIndent (0);				  							if (curIndent != newIndent) {  								curIndent = newIndent;  								needsReindent = true;  							}  						}  					}  					break;  			default:  				break;  			}
Magic Number,D_Parser.Formatting.Indent,IndentStack,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,The following statement contains a magic number: Array.Resize <Node> (ref stack' 2 * size);
Magic Number,D_Parser.Formatting.Indent,IndentStack,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,The following statement contains a magic number: Array.Resize <Node> (ref stack' 2 * size);
Magic Number,D_Parser.Misc,GlobalParseCache,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\GlobalParseCache.cs,parseTh,The following statement contains a magic number: var someFileParseEntries = new FileParseQueueEntry[5];
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The following statement contains a magic number: switch(p) 			{ 				case 'n': 					r.Read(); 					return new TokenExpression(DTokens.Null); 				case 'N': 					r.Read(); 					return new ScalarConstantExpression(-Number()' LiteralFormat.Scalar' LiteralSubformat.Integer); 				case 'i': 					r.Read(); 					return new ScalarConstantExpression(-Number()' LiteralFormat.Scalar' LiteralSubformat.Integer | LiteralSubformat.Imaginary); 				case 'e': // HexFloat 					r.Read(); 					return HexFloat(); 				case 'c': // Complex 					r.Read(); 					var re = HexFloat(); 					r.Read(); // Skip further c 					var im = HexFloat(); 					//TODO 					return re; 				case 'H': 				case 'A': 				case 'S': 					r.Read(); 					var n = (int)Number(); 					var xx = new List<IExpression>(); 					for(int i = n; i > 0; i--) 						xx.Add(Value()); 					 					if(p == 'S') 					{ 						var inits = new List<StructMemberInitializer>(xx.Count); 						 						for(int i = n-1; i >= 0; i--) 							inits.Add(new StructMemberInitializer{Value = xx[i]}); 						 						return new StructInitializer{MemberInitializers = inits.ToArray()}; 					} 					 					if(p == 'H' || PeekIsValue) // We've got an AA 					{ 						for(int i = n; i > 0; i--) 							xx.Add(Value()); 						 						var kv = new List<KeyValuePair<IExpression'IExpression>>(n); 						 						for(int i = (n*2) - 1; i > 0; i-=2) 							kv.Add(new KeyValuePair<IExpression'IExpression>(xx[i-1]'xx[i])); 						 						return new AssocArrayExpression{ Elements = kv }; 					} 					return new ArrayLiteralExpression(xx); 				case 'a': 				case 'w': 				case 'd': 					r.Read(); 					var len = (int)Number(); 					sb.Clear(); 					 					for(;len > 0; len--) 						sb.Append((char)(Lexer.GetHexNumber((char)r.Read()) << 4 + Lexer.GetHexNumber((char)r.Read())));    					LiteralSubformat encoding; 					switch (p)  					{  						default:  						case 'a':  							encoding = LiteralSubformat.Utf8;  							break;  						case 'w':  							encoding = LiteralSubformat.Utf16;  							break;  						case 'd':  							encoding = LiteralSubformat.Utf32;  							break;  					}  					return new StringLiteralExpression(sb.ToString()' false' encoding); 			}
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The following statement contains a magic number: switch(p) 			{ 				case 'n': 					r.Read(); 					return new TokenExpression(DTokens.Null); 				case 'N': 					r.Read(); 					return new ScalarConstantExpression(-Number()' LiteralFormat.Scalar' LiteralSubformat.Integer); 				case 'i': 					r.Read(); 					return new ScalarConstantExpression(-Number()' LiteralFormat.Scalar' LiteralSubformat.Integer | LiteralSubformat.Imaginary); 				case 'e': // HexFloat 					r.Read(); 					return HexFloat(); 				case 'c': // Complex 					r.Read(); 					var re = HexFloat(); 					r.Read(); // Skip further c 					var im = HexFloat(); 					//TODO 					return re; 				case 'H': 				case 'A': 				case 'S': 					r.Read(); 					var n = (int)Number(); 					var xx = new List<IExpression>(); 					for(int i = n; i > 0; i--) 						xx.Add(Value()); 					 					if(p == 'S') 					{ 						var inits = new List<StructMemberInitializer>(xx.Count); 						 						for(int i = n-1; i >= 0; i--) 							inits.Add(new StructMemberInitializer{Value = xx[i]}); 						 						return new StructInitializer{MemberInitializers = inits.ToArray()}; 					} 					 					if(p == 'H' || PeekIsValue) // We've got an AA 					{ 						for(int i = n; i > 0; i--) 							xx.Add(Value()); 						 						var kv = new List<KeyValuePair<IExpression'IExpression>>(n); 						 						for(int i = (n*2) - 1; i > 0; i-=2) 							kv.Add(new KeyValuePair<IExpression'IExpression>(xx[i-1]'xx[i])); 						 						return new AssocArrayExpression{ Elements = kv }; 					} 					return new ArrayLiteralExpression(xx); 				case 'a': 				case 'w': 				case 'd': 					r.Read(); 					var len = (int)Number(); 					sb.Clear(); 					 					for(;len > 0; len--) 						sb.Append((char)(Lexer.GetHexNumber((char)r.Read()) << 4 + Lexer.GetHexNumber((char)r.Read())));    					LiteralSubformat encoding; 					switch (p)  					{  						default:  						case 'a':  							encoding = LiteralSubformat.Utf8;  							break;  						case 'w':  							encoding = LiteralSubformat.Utf16;  							break;  						case 'd':  							encoding = LiteralSubformat.Utf32;  							break;  					}  					return new StringLiteralExpression(sb.ToString()' false' encoding); 			}
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The following statement contains a magic number: switch(p) 			{ 				case 'n': 					r.Read(); 					return new TokenExpression(DTokens.Null); 				case 'N': 					r.Read(); 					return new ScalarConstantExpression(-Number()' LiteralFormat.Scalar' LiteralSubformat.Integer); 				case 'i': 					r.Read(); 					return new ScalarConstantExpression(-Number()' LiteralFormat.Scalar' LiteralSubformat.Integer | LiteralSubformat.Imaginary); 				case 'e': // HexFloat 					r.Read(); 					return HexFloat(); 				case 'c': // Complex 					r.Read(); 					var re = HexFloat(); 					r.Read(); // Skip further c 					var im = HexFloat(); 					//TODO 					return re; 				case 'H': 				case 'A': 				case 'S': 					r.Read(); 					var n = (int)Number(); 					var xx = new List<IExpression>(); 					for(int i = n; i > 0; i--) 						xx.Add(Value()); 					 					if(p == 'S') 					{ 						var inits = new List<StructMemberInitializer>(xx.Count); 						 						for(int i = n-1; i >= 0; i--) 							inits.Add(new StructMemberInitializer{Value = xx[i]}); 						 						return new StructInitializer{MemberInitializers = inits.ToArray()}; 					} 					 					if(p == 'H' || PeekIsValue) // We've got an AA 					{ 						for(int i = n; i > 0; i--) 							xx.Add(Value()); 						 						var kv = new List<KeyValuePair<IExpression'IExpression>>(n); 						 						for(int i = (n*2) - 1; i > 0; i-=2) 							kv.Add(new KeyValuePair<IExpression'IExpression>(xx[i-1]'xx[i])); 						 						return new AssocArrayExpression{ Elements = kv }; 					} 					return new ArrayLiteralExpression(xx); 				case 'a': 				case 'w': 				case 'd': 					r.Read(); 					var len = (int)Number(); 					sb.Clear(); 					 					for(;len > 0; len--) 						sb.Append((char)(Lexer.GetHexNumber((char)r.Read()) << 4 + Lexer.GetHexNumber((char)r.Read())));    					LiteralSubformat encoding; 					switch (p)  					{  						default:  						case 'a':  							encoding = LiteralSubformat.Utf8;  							break;  						case 'w':  							encoding = LiteralSubformat.Utf16;  							break;  						case 'd':  							encoding = LiteralSubformat.Utf32;  							break;  					}  					return new StringLiteralExpression(sb.ToString()' false' encoding); 			}
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The following statement contains a magic number: Lexer.IsLegalDigit(p' 10)
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,HexFloat,The following statement contains a magic number: n *= (decimal)Math.Pow(10' exp);
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,HexDigits,The following statement contains a magic number: return Lexer.ParseFloatValue(sb' 16);
Magic Number,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Number,The following statement contains a magic number: return Lexer.ParseFloatValue(sb' 10);
Magic Number,D_Parser.Parser.Implementations,DAsmStatementParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DAsmStatementParser.cs,ParseAsmStatement,The following statement contains a magic number: switch (laKind)  				{  					case DTokens.Align:  						als = new AsmAlignStatement() { Location = la.Location' Parent = s };  						Step();  						als.ValueExpression = parserParts.expressionsParser.Expression(Scope);  						l.Add(als);  						Step();  						break;  					case DTokens.Identifier:  						var opCode = AsmInstructionStatement.OpCode.__UNKNOWN__;  						var dataType = AsmRawDataStatement.DataType.__UNKNOWN__;  						if (Peek(1).Kind == DTokens.Colon)  						{  							l.Add(new LabeledStatement() { Location = la.Location' Parent = s' Identifier = la.Value' EndLocation = Peek(1).EndLocation });  							Step();  							Step();  							if (laKind == DTokens.Semicolon)  								Step();  							continue;  						}    						if (AsmRawDataStatement.TryParseDataType(la.Value' out dataType))  							l.Add(new AsmRawDataStatement() { Location = la.Location' Parent = s' TypeOfData = dataType });  						else if (AsmInstructionStatement.TryParseOpCode(la.Value' out opCode))  							l.Add(new AsmInstructionStatement() { Location = la.Location' Parent = s' Operation = opCode });  						else switch (la.Value.ToLower())  							{  								case "pause":  									SynErr(DTokens.Identifier' "Pause is not supported by dmd's assembler. Use `rep; nop;` instead to achieve the same effect.");  									break;  								case "even":  									als = new AsmAlignStatement() { Location = la.Location' Parent = s };  									als.ValueExpression = new ScalarConstantExpression(2m' LiteralFormat.Scalar) { Location = la.Location' EndLocation = la.EndLocation };  									l.Add(als);  									break;  								case "naked":  									noStatement = true;  									break;  								default:  									SynErr(DTokens.Identifier' "Unknown op-code!");  									l.Add(new AsmInstructionStatement() { Location = la.Location' Parent = s' Operation = AsmInstructionStatement.OpCode.__UNKNOWN__ });  									break;  							}  						Step();    						if (noStatement && laKind != DTokens.Semicolon)  							SynErr(DTokens.Semicolon);  						var parentStatement = noStatement ? s : l[l.Count - 1];  						var args = new List<IExpression>();  						if (IsEOF)  							args.Add(new TokenExpression(DTokens.Incomplete));  						else if (laKind != DTokens.Semicolon)  						{  							while (true)  							{  								if (laKind == DTokens.CloseCurlyBrace)  								{  									// This is required as a custom error message because  									// it would complain about finding an identifier instead.  									SynErr(DTokens.Semicolon' "; expected' } found");  									break;  								}  								var e = ParseAsmExpression(Scope' parentStatement);  								if (e != null)  									args.Add(e);  								if (laKind == DTokens.Comma)  								{  									Step();  									continue;  								}  								if (IsEOF)  									args.Add(new TokenExpression(DTokens.Incomplete));  								if (!Expect(DTokens.Semicolon))  								{  									while (laKind != DTokens.Semicolon && laKind != DTokens.CloseCurlyBrace && !IsEOF)  										Step();  									if (laKind == DTokens.Semicolon)  										Step();  								}    								break;  							}  						}  						else  							Step();  						if (parentStatement is AsmInstructionStatement)  							((AsmInstructionStatement)parentStatement).Arguments = args.ToArray();  						else if (parentStatement is AsmRawDataStatement)  							((AsmRawDataStatement)parentStatement).Data = args.ToArray();  						break;  					case DTokens.Semicolon:  						Step();  						break;  					case DTokens.Literal:  						l.Add(new AsmRawDataStatement  						{  							Location = la.Location'  							Data = new[] { ParseAsmPrimaryExpression(Scope' Parent) }'  							EndLocation = t.EndLocation'  							Parent = Parent  						});    						Expect(DTokens.Semicolon);  						break;  					default:  						string val;  						if (!retrying && DTokens.TryGetKeywordString(laKind' out val))  						{  							la.LiteralValue = val;  							la.Kind = DTokens.Identifier;  							Lexer.laKind = DTokens.Identifier;  							retrying = true;  							goto Retry;  						}  						else  						{  							noStatement = true;  							SynErr(DTokens.Identifier);  							Step();  						}  						break;  				}
Magic Number,D_Parser.Parser.Implementations,DParserImplementationPart,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DParserImplementationPart.cs,GetComments,The following statement contains a magic number: sb.Length != 5 || sb.ToString().ToLowerInvariant() != "ditto"
Magic Number,D_Parser.Parser.Implementations,DParserImplementationPart,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DParserImplementationPart.cs,CheckForPostSemicolonComment,The following statement contains a magic number: ret.Length == 5 && ret.ToString().ToLowerInvariant() == "ditto"
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: switch (nextChar) 				{ 					case ' ': 					case '\t': 						continue; 					case '\r': 					case '\n': 						if (hadLineEnd) 						{  							// second line end before getting to a token  							// -> here was a blank line  							//specialTracker.AddEndOfLine(new Location(Col' Line));  						} 						HandleLineEnd((char)nextChar); 						hadLineEnd = true; 						continue; 					case '/': 						int peek = ReaderPeek(); 						if (peek == '/' || peek == '*' || peek == '+') 						{ 							ReadComment(); 							continue; 						} 						else 						{ 							token = ReadOperator('/'); 						} 						break; 					case 'r': 						peek = ReaderPeek(); 						if (peek == '"') 						{ 							ReaderRead(); 							token = ReadVerbatimString(peek); 							break; 						} 						else 							goto default; 					case '`': 						token = ReadVerbatimString(nextChar); 						break; 					case '"': 						token = ReadString(nextChar); 						break; 					case '\\':  						// http://digitalmars.com/d/1.0/lex.html#EscapeSequence  						// - It's actually deprecated' but parse such literals anyway  						string surr = ""; 						x = Col - 1; 						y = Line; 						var lit = ReadEscapeSequence(out ch' out surr); 						token = Token(DTokens.Literal' x' y' lit.Length + 1' lit/*' ch.ToString()*/' LiteralFormat.StringLiteral); 						token.RawCodeRepresentation = ch.ToString(); 						OnError(y' x' "Escape sequence strings are deprecated!"); 						break; 					case '\'': 						token = ReadChar(); 						break; 					case '@': 						token = Token(DTokens.At' Col - 1' Line' 1); 						break; 					case '#': 						if ((token = ReadSpecialTokenSequence()) != null) 							break; 						continue; 					default: 						ch = (char)nextChar;  						if (ch == 'x') 						{ 							peek = ReaderPeek(); 							if (peek == '"') // HexString  							{ 								ReaderRead(); // Skip the "    								var numString = new StringBuilder();  								while ((next = ReaderRead()) != -1) 								{ 									ch = (char)next;  									if (IsHex(ch)) 										numString.Append(ch); 									else if (!Char.IsWhiteSpace(ch)) 										break; 								}  								return Token(DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue(numString' 16)' /*numString'*/ LiteralFormat.Scalar); 							} 						} 						else if (ch == 'q') // Token strings  						{ 							switch (ReaderPeek()) 							{ 								case '{': 									return ReadTokenStringLiteral_CurlyInit(); 								case '"'/* q"{{ ...}}   }}"*/: 									return ReadTokenStringLiteral_IdentInit(); 							} 						}  						if (IsLetter(ch) || ch == '\\') 						{ 							x = Col - 1; // Col was incremented above' but we want the start of the identifier  							y = Line; 							bool canBeKeyword; 							var s = ReadIdent(ch' out canBeKeyword); 							if (canBeKeyword) 							{  								// A micro-optimization..  								if (s.Length >= 8 && s[0] == '_' && s[1] == '_') 								{ 									LiteralFormat literalFormat = 0; 									var subFormat = LiteralSubformat.Utf8; 									object literalValue = null;    									// Fill in static string surrogates directly  									if (s == "__VENDOR__") 									{ 										literalFormat = LiteralFormat.StringLiteral; 										literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString(3) + " by Alexander Bothe"; 									} 									else if (s == "__VERSION__") 									{ 										subFormat = LiteralSubformat.Integer; 										var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly().GetName().Version; 										literalFormat = LiteralFormat.Scalar; 										literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor; 									}  									if (literalFormat != 0) 										return Token(DTokens.Literal' x' y' s.Length' 											literalValue'  											//literalValue is string ? (string)literalValue : literalValue.ToString()'  											literalFormat' 											subFormat); 								}  								byte key; 								if (DTokens.Keywords_Lookup.TryGetValue(s' out key)) 									return Token(key' x' y' s.Length); 							} 							return Token(DTokens.Identifier' x' y' s); 						} 						else if (IsDigit(ch)) 							token = ReadDigit(ch' Col - 1); 						else 							token = ReadOperator(ch); 						break; 				}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: switch (nextChar) 				{ 					case ' ': 					case '\t': 						continue; 					case '\r': 					case '\n': 						if (hadLineEnd) 						{  							// second line end before getting to a token  							// -> here was a blank line  							//specialTracker.AddEndOfLine(new Location(Col' Line));  						} 						HandleLineEnd((char)nextChar); 						hadLineEnd = true; 						continue; 					case '/': 						int peek = ReaderPeek(); 						if (peek == '/' || peek == '*' || peek == '+') 						{ 							ReadComment(); 							continue; 						} 						else 						{ 							token = ReadOperator('/'); 						} 						break; 					case 'r': 						peek = ReaderPeek(); 						if (peek == '"') 						{ 							ReaderRead(); 							token = ReadVerbatimString(peek); 							break; 						} 						else 							goto default; 					case '`': 						token = ReadVerbatimString(nextChar); 						break; 					case '"': 						token = ReadString(nextChar); 						break; 					case '\\':  						// http://digitalmars.com/d/1.0/lex.html#EscapeSequence  						// - It's actually deprecated' but parse such literals anyway  						string surr = ""; 						x = Col - 1; 						y = Line; 						var lit = ReadEscapeSequence(out ch' out surr); 						token = Token(DTokens.Literal' x' y' lit.Length + 1' lit/*' ch.ToString()*/' LiteralFormat.StringLiteral); 						token.RawCodeRepresentation = ch.ToString(); 						OnError(y' x' "Escape sequence strings are deprecated!"); 						break; 					case '\'': 						token = ReadChar(); 						break; 					case '@': 						token = Token(DTokens.At' Col - 1' Line' 1); 						break; 					case '#': 						if ((token = ReadSpecialTokenSequence()) != null) 							break; 						continue; 					default: 						ch = (char)nextChar;  						if (ch == 'x') 						{ 							peek = ReaderPeek(); 							if (peek == '"') // HexString  							{ 								ReaderRead(); // Skip the "    								var numString = new StringBuilder();  								while ((next = ReaderRead()) != -1) 								{ 									ch = (char)next;  									if (IsHex(ch)) 										numString.Append(ch); 									else if (!Char.IsWhiteSpace(ch)) 										break; 								}  								return Token(DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue(numString' 16)' /*numString'*/ LiteralFormat.Scalar); 							} 						} 						else if (ch == 'q') // Token strings  						{ 							switch (ReaderPeek()) 							{ 								case '{': 									return ReadTokenStringLiteral_CurlyInit(); 								case '"'/* q"{{ ...}}   }}"*/: 									return ReadTokenStringLiteral_IdentInit(); 							} 						}  						if (IsLetter(ch) || ch == '\\') 						{ 							x = Col - 1; // Col was incremented above' but we want the start of the identifier  							y = Line; 							bool canBeKeyword; 							var s = ReadIdent(ch' out canBeKeyword); 							if (canBeKeyword) 							{  								// A micro-optimization..  								if (s.Length >= 8 && s[0] == '_' && s[1] == '_') 								{ 									LiteralFormat literalFormat = 0; 									var subFormat = LiteralSubformat.Utf8; 									object literalValue = null;    									// Fill in static string surrogates directly  									if (s == "__VENDOR__") 									{ 										literalFormat = LiteralFormat.StringLiteral; 										literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString(3) + " by Alexander Bothe"; 									} 									else if (s == "__VERSION__") 									{ 										subFormat = LiteralSubformat.Integer; 										var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly().GetName().Version; 										literalFormat = LiteralFormat.Scalar; 										literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor; 									}  									if (literalFormat != 0) 										return Token(DTokens.Literal' x' y' s.Length' 											literalValue'  											//literalValue is string ? (string)literalValue : literalValue.ToString()'  											literalFormat' 											subFormat); 								}  								byte key; 								if (DTokens.Keywords_Lookup.TryGetValue(s' out key)) 									return Token(key' x' y' s.Length); 							} 							return Token(DTokens.Identifier' x' y' s); 						} 						else if (IsDigit(ch)) 							token = ReadDigit(ch' Col - 1); 						else 							token = ReadOperator(ch); 						break; 				}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: switch (nextChar) 				{ 					case ' ': 					case '\t': 						continue; 					case '\r': 					case '\n': 						if (hadLineEnd) 						{  							// second line end before getting to a token  							// -> here was a blank line  							//specialTracker.AddEndOfLine(new Location(Col' Line));  						} 						HandleLineEnd((char)nextChar); 						hadLineEnd = true; 						continue; 					case '/': 						int peek = ReaderPeek(); 						if (peek == '/' || peek == '*' || peek == '+') 						{ 							ReadComment(); 							continue; 						} 						else 						{ 							token = ReadOperator('/'); 						} 						break; 					case 'r': 						peek = ReaderPeek(); 						if (peek == '"') 						{ 							ReaderRead(); 							token = ReadVerbatimString(peek); 							break; 						} 						else 							goto default; 					case '`': 						token = ReadVerbatimString(nextChar); 						break; 					case '"': 						token = ReadString(nextChar); 						break; 					case '\\':  						// http://digitalmars.com/d/1.0/lex.html#EscapeSequence  						// - It's actually deprecated' but parse such literals anyway  						string surr = ""; 						x = Col - 1; 						y = Line; 						var lit = ReadEscapeSequence(out ch' out surr); 						token = Token(DTokens.Literal' x' y' lit.Length + 1' lit/*' ch.ToString()*/' LiteralFormat.StringLiteral); 						token.RawCodeRepresentation = ch.ToString(); 						OnError(y' x' "Escape sequence strings are deprecated!"); 						break; 					case '\'': 						token = ReadChar(); 						break; 					case '@': 						token = Token(DTokens.At' Col - 1' Line' 1); 						break; 					case '#': 						if ((token = ReadSpecialTokenSequence()) != null) 							break; 						continue; 					default: 						ch = (char)nextChar;  						if (ch == 'x') 						{ 							peek = ReaderPeek(); 							if (peek == '"') // HexString  							{ 								ReaderRead(); // Skip the "    								var numString = new StringBuilder();  								while ((next = ReaderRead()) != -1) 								{ 									ch = (char)next;  									if (IsHex(ch)) 										numString.Append(ch); 									else if (!Char.IsWhiteSpace(ch)) 										break; 								}  								return Token(DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue(numString' 16)' /*numString'*/ LiteralFormat.Scalar); 							} 						} 						else if (ch == 'q') // Token strings  						{ 							switch (ReaderPeek()) 							{ 								case '{': 									return ReadTokenStringLiteral_CurlyInit(); 								case '"'/* q"{{ ...}}   }}"*/: 									return ReadTokenStringLiteral_IdentInit(); 							} 						}  						if (IsLetter(ch) || ch == '\\') 						{ 							x = Col - 1; // Col was incremented above' but we want the start of the identifier  							y = Line; 							bool canBeKeyword; 							var s = ReadIdent(ch' out canBeKeyword); 							if (canBeKeyword) 							{  								// A micro-optimization..  								if (s.Length >= 8 && s[0] == '_' && s[1] == '_') 								{ 									LiteralFormat literalFormat = 0; 									var subFormat = LiteralSubformat.Utf8; 									object literalValue = null;    									// Fill in static string surrogates directly  									if (s == "__VENDOR__") 									{ 										literalFormat = LiteralFormat.StringLiteral; 										literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString(3) + " by Alexander Bothe"; 									} 									else if (s == "__VERSION__") 									{ 										subFormat = LiteralSubformat.Integer; 										var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly().GetName().Version; 										literalFormat = LiteralFormat.Scalar; 										literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor; 									}  									if (literalFormat != 0) 										return Token(DTokens.Literal' x' y' s.Length' 											literalValue'  											//literalValue is string ? (string)literalValue : literalValue.ToString()'  											literalFormat' 											subFormat); 								}  								byte key; 								if (DTokens.Keywords_Lookup.TryGetValue(s' out key)) 									return Token(key' x' y' s.Length); 							} 							return Token(DTokens.Identifier' x' y' s); 						} 						else if (IsDigit(ch)) 							token = ReadDigit(ch' Col - 1); 						else 							token = ReadOperator(ch); 						break; 				}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: switch (nextChar) 				{ 					case ' ': 					case '\t': 						continue; 					case '\r': 					case '\n': 						if (hadLineEnd) 						{  							// second line end before getting to a token  							// -> here was a blank line  							//specialTracker.AddEndOfLine(new Location(Col' Line));  						} 						HandleLineEnd((char)nextChar); 						hadLineEnd = true; 						continue; 					case '/': 						int peek = ReaderPeek(); 						if (peek == '/' || peek == '*' || peek == '+') 						{ 							ReadComment(); 							continue; 						} 						else 						{ 							token = ReadOperator('/'); 						} 						break; 					case 'r': 						peek = ReaderPeek(); 						if (peek == '"') 						{ 							ReaderRead(); 							token = ReadVerbatimString(peek); 							break; 						} 						else 							goto default; 					case '`': 						token = ReadVerbatimString(nextChar); 						break; 					case '"': 						token = ReadString(nextChar); 						break; 					case '\\':  						// http://digitalmars.com/d/1.0/lex.html#EscapeSequence  						// - It's actually deprecated' but parse such literals anyway  						string surr = ""; 						x = Col - 1; 						y = Line; 						var lit = ReadEscapeSequence(out ch' out surr); 						token = Token(DTokens.Literal' x' y' lit.Length + 1' lit/*' ch.ToString()*/' LiteralFormat.StringLiteral); 						token.RawCodeRepresentation = ch.ToString(); 						OnError(y' x' "Escape sequence strings are deprecated!"); 						break; 					case '\'': 						token = ReadChar(); 						break; 					case '@': 						token = Token(DTokens.At' Col - 1' Line' 1); 						break; 					case '#': 						if ((token = ReadSpecialTokenSequence()) != null) 							break; 						continue; 					default: 						ch = (char)nextChar;  						if (ch == 'x') 						{ 							peek = ReaderPeek(); 							if (peek == '"') // HexString  							{ 								ReaderRead(); // Skip the "    								var numString = new StringBuilder();  								while ((next = ReaderRead()) != -1) 								{ 									ch = (char)next;  									if (IsHex(ch)) 										numString.Append(ch); 									else if (!Char.IsWhiteSpace(ch)) 										break; 								}  								return Token(DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue(numString' 16)' /*numString'*/ LiteralFormat.Scalar); 							} 						} 						else if (ch == 'q') // Token strings  						{ 							switch (ReaderPeek()) 							{ 								case '{': 									return ReadTokenStringLiteral_CurlyInit(); 								case '"'/* q"{{ ...}}   }}"*/: 									return ReadTokenStringLiteral_IdentInit(); 							} 						}  						if (IsLetter(ch) || ch == '\\') 						{ 							x = Col - 1; // Col was incremented above' but we want the start of the identifier  							y = Line; 							bool canBeKeyword; 							var s = ReadIdent(ch' out canBeKeyword); 							if (canBeKeyword) 							{  								// A micro-optimization..  								if (s.Length >= 8 && s[0] == '_' && s[1] == '_') 								{ 									LiteralFormat literalFormat = 0; 									var subFormat = LiteralSubformat.Utf8; 									object literalValue = null;    									// Fill in static string surrogates directly  									if (s == "__VENDOR__") 									{ 										literalFormat = LiteralFormat.StringLiteral; 										literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString(3) + " by Alexander Bothe"; 									} 									else if (s == "__VERSION__") 									{ 										subFormat = LiteralSubformat.Integer; 										var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly().GetName().Version; 										literalFormat = LiteralFormat.Scalar; 										literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor; 									}  									if (literalFormat != 0) 										return Token(DTokens.Literal' x' y' s.Length' 											literalValue'  											//literalValue is string ? (string)literalValue : literalValue.ToString()'  											literalFormat' 											subFormat); 								}  								byte key; 								if (DTokens.Keywords_Lookup.TryGetValue(s' out key)) 									return Token(key' x' y' s.Length); 							} 							return Token(DTokens.Identifier' x' y' s); 						} 						else if (IsDigit(ch)) 							token = ReadDigit(ch' Col - 1); 						else 							token = ReadOperator(ch); 						break; 				}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: numBase = 16;
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: numBase = 10;
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: numBase == 10 || (ch != '.' && numBase == 0)
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: nextToken = Token(DTokens.DoubleDot' Col - 1' Line' 2);
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: (numBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E')
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: num *= (decimal)Math.Pow(numBase == 16 ? 2 : 10' exponent);
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: num *= (decimal)Math.Pow(numBase == 16 ? 2 : 10' exponent);
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: num *= (decimal)Math.Pow(numBase == 16 ? 2 : 10' exponent);
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadVerbatimString,The following statement contains a magic number: int x = Col - 2;
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: switch (c) 			{ 				case '\'': 					ch = '\''; 					break; 				case '\"': 					ch = '\"'; 					break; 				case '?': 					ch = '?'; 					return "\\?"; // Literal question mark  				case '\\': 					ch = '\\'; 					break;  				/*case '0': 					ch = '\0'; 					break;*/  				case 'a': 					ch = '\a'; // Bell (alert)  					break; 				case 'b': 					ch = '\b'; // Backspace  					break; 				case 'f': 					ch = '\f'; // Formfeed  					break; 				case 'n': 					ch = '\n'; 					break; 				case 'r': 					ch = '\r'; 					break; 				case 't': 					ch = '\t'; 					break; 				case 'v': 					ch = '\v'; // Vertical tab  					break; 				case 'u': 				case 'x':  					// 16 bit unicode character  					c = (char)ReaderRead(); 					number = GetHexNumber(c); 					escapeSequenceBuffer[curPos++] = c;  					if (number < 0) 					{ 						OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' c)); 					} 					for (int i = 0; i < 3; ++i) 					{ 						if (IsHex((char)ReaderPeek())) 						{ 							c = (char)ReaderRead(); 							int idx = GetHexNumber(c); 							escapeSequenceBuffer[curPos++] = c; 							number = 16 * number + idx; 						} 						else 						{ 							break; 						} 					} 					ch = (char)number; 					break; 				case 'U':  					// 32 bit unicode character  					number = 0; 					for (int i = 0; i < 8; ++i) 					{ 						if (IsHex((char)ReaderPeek())) 						{ 							c = (char)ReaderRead(); 							int idx = GetHexNumber(c); 							escapeSequenceBuffer[curPos++] = c; 							number = 16 * number + idx; 						} 						else 						{ 							OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' (char)ReaderPeek())); 							break; 						} 					} 					if (number > 0xffff) 					{ 						ch = '\0'; 						surrogatePair = char.ConvertFromUtf32(number); 					} 					else 					{ 						ch = (char)number; 					} 					break;    				// NamedCharacterEntities  				case '&': 					string charEntity = "";  					while (true) 					{ 						nextChar = ReaderRead();  						if (nextChar < 0) 						{ 							OnError(Line' Col - 1' "EOF reached within named char entity"); 							ch = '\0'; 							return string.Empty; 						}  						c = (char)nextChar;  						if (c == ';') 							break;  						if (IsIdentifierPart(c)) 							charEntity += c; 						else 						{ 							OnError(Line' Col - 1' "Unexpected character found in named char entity: " + c); 							ch = '\0'; 							return string.Empty; 						} 					}  					if (string.IsNullOrEmpty(charEntity)) 					{ 						OnError(Line' Col - 1' "Empty named character entities not allowed"); 						ch = '\0'; 						return string.Empty; 					}    					//TODO: Performance improvement  					//var ret=System.Web.HttpUtility.HtmlDecode("&"+charEntity+";");    					ch = '#';//ret[0];    					return "&" + charEntity + ";"; 				default:    					// Max 3 following octal digits  					if (IsOct(c)) 					{  						// Parse+Convert oct to dec integer  						int oct = GetHexNumber(c);  						for (int i = 0; i < 2; ++i) 						{ 							if (IsOct((char)ReaderPeek())) 							{ 								c = (char)ReaderRead(); 								escapeSequenceBuffer[curPos++] = c;  								int idx = GetHexNumber(c); 								oct = 8 * oct + idx; 							} 							else 								break; 						}    						// Convert integer to character  						if (oct > 0xffff) 						{ 							ch = '\0'; 							surrogatePair = char.ConvertFromUtf32(oct); 						} 						else 						{ 							ch = (char)oct; 						}  					} 					else 					{ 						OnError(Line' Col' String.Format("Unexpected escape sequence : {0}"' c)); 						ch = '\0'; 					} 					break; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: switch (c) 			{ 				case '\'': 					ch = '\''; 					break; 				case '\"': 					ch = '\"'; 					break; 				case '?': 					ch = '?'; 					return "\\?"; // Literal question mark  				case '\\': 					ch = '\\'; 					break;  				/*case '0': 					ch = '\0'; 					break;*/  				case 'a': 					ch = '\a'; // Bell (alert)  					break; 				case 'b': 					ch = '\b'; // Backspace  					break; 				case 'f': 					ch = '\f'; // Formfeed  					break; 				case 'n': 					ch = '\n'; 					break; 				case 'r': 					ch = '\r'; 					break; 				case 't': 					ch = '\t'; 					break; 				case 'v': 					ch = '\v'; // Vertical tab  					break; 				case 'u': 				case 'x':  					// 16 bit unicode character  					c = (char)ReaderRead(); 					number = GetHexNumber(c); 					escapeSequenceBuffer[curPos++] = c;  					if (number < 0) 					{ 						OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' c)); 					} 					for (int i = 0; i < 3; ++i) 					{ 						if (IsHex((char)ReaderPeek())) 						{ 							c = (char)ReaderRead(); 							int idx = GetHexNumber(c); 							escapeSequenceBuffer[curPos++] = c; 							number = 16 * number + idx; 						} 						else 						{ 							break; 						} 					} 					ch = (char)number; 					break; 				case 'U':  					// 32 bit unicode character  					number = 0; 					for (int i = 0; i < 8; ++i) 					{ 						if (IsHex((char)ReaderPeek())) 						{ 							c = (char)ReaderRead(); 							int idx = GetHexNumber(c); 							escapeSequenceBuffer[curPos++] = c; 							number = 16 * number + idx; 						} 						else 						{ 							OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' (char)ReaderPeek())); 							break; 						} 					} 					if (number > 0xffff) 					{ 						ch = '\0'; 						surrogatePair = char.ConvertFromUtf32(number); 					} 					else 					{ 						ch = (char)number; 					} 					break;    				// NamedCharacterEntities  				case '&': 					string charEntity = "";  					while (true) 					{ 						nextChar = ReaderRead();  						if (nextChar < 0) 						{ 							OnError(Line' Col - 1' "EOF reached within named char entity"); 							ch = '\0'; 							return string.Empty; 						}  						c = (char)nextChar;  						if (c == ';') 							break;  						if (IsIdentifierPart(c)) 							charEntity += c; 						else 						{ 							OnError(Line' Col - 1' "Unexpected character found in named char entity: " + c); 							ch = '\0'; 							return string.Empty; 						} 					}  					if (string.IsNullOrEmpty(charEntity)) 					{ 						OnError(Line' Col - 1' "Empty named character entities not allowed"); 						ch = '\0'; 						return string.Empty; 					}    					//TODO: Performance improvement  					//var ret=System.Web.HttpUtility.HtmlDecode("&"+charEntity+";");    					ch = '#';//ret[0];    					return "&" + charEntity + ";"; 				default:    					// Max 3 following octal digits  					if (IsOct(c)) 					{  						// Parse+Convert oct to dec integer  						int oct = GetHexNumber(c);  						for (int i = 0; i < 2; ++i) 						{ 							if (IsOct((char)ReaderPeek())) 							{ 								c = (char)ReaderRead(); 								escapeSequenceBuffer[curPos++] = c;  								int idx = GetHexNumber(c); 								oct = 8 * oct + idx; 							} 							else 								break; 						}    						// Convert integer to character  						if (oct > 0xffff) 						{ 							ch = '\0'; 							surrogatePair = char.ConvertFromUtf32(oct); 						} 						else 						{ 							ch = (char)oct; 						}  					} 					else 					{ 						OnError(Line' Col' String.Format("Unexpected escape sequence : {0}"' c)); 						ch = '\0'; 					} 					break; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: switch (c) 			{ 				case '\'': 					ch = '\''; 					break; 				case '\"': 					ch = '\"'; 					break; 				case '?': 					ch = '?'; 					return "\\?"; // Literal question mark  				case '\\': 					ch = '\\'; 					break;  				/*case '0': 					ch = '\0'; 					break;*/  				case 'a': 					ch = '\a'; // Bell (alert)  					break; 				case 'b': 					ch = '\b'; // Backspace  					break; 				case 'f': 					ch = '\f'; // Formfeed  					break; 				case 'n': 					ch = '\n'; 					break; 				case 'r': 					ch = '\r'; 					break; 				case 't': 					ch = '\t'; 					break; 				case 'v': 					ch = '\v'; // Vertical tab  					break; 				case 'u': 				case 'x':  					// 16 bit unicode character  					c = (char)ReaderRead(); 					number = GetHexNumber(c); 					escapeSequenceBuffer[curPos++] = c;  					if (number < 0) 					{ 						OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' c)); 					} 					for (int i = 0; i < 3; ++i) 					{ 						if (IsHex((char)ReaderPeek())) 						{ 							c = (char)ReaderRead(); 							int idx = GetHexNumber(c); 							escapeSequenceBuffer[curPos++] = c; 							number = 16 * number + idx; 						} 						else 						{ 							break; 						} 					} 					ch = (char)number; 					break; 				case 'U':  					// 32 bit unicode character  					number = 0; 					for (int i = 0; i < 8; ++i) 					{ 						if (IsHex((char)ReaderPeek())) 						{ 							c = (char)ReaderRead(); 							int idx = GetHexNumber(c); 							escapeSequenceBuffer[curPos++] = c; 							number = 16 * number + idx; 						} 						else 						{ 							OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' (char)ReaderPeek())); 							break; 						} 					} 					if (number > 0xffff) 					{ 						ch = '\0'; 						surrogatePair = char.ConvertFromUtf32(number); 					} 					else 					{ 						ch = (char)number; 					} 					break;    				// NamedCharacterEntities  				case '&': 					string charEntity = "";  					while (true) 					{ 						nextChar = ReaderRead();  						if (nextChar < 0) 						{ 							OnError(Line' Col - 1' "EOF reached within named char entity"); 							ch = '\0'; 							return string.Empty; 						}  						c = (char)nextChar;  						if (c == ';') 							break;  						if (IsIdentifierPart(c)) 							charEntity += c; 						else 						{ 							OnError(Line' Col - 1' "Unexpected character found in named char entity: " + c); 							ch = '\0'; 							return string.Empty; 						} 					}  					if (string.IsNullOrEmpty(charEntity)) 					{ 						OnError(Line' Col - 1' "Empty named character entities not allowed"); 						ch = '\0'; 						return string.Empty; 					}    					//TODO: Performance improvement  					//var ret=System.Web.HttpUtility.HtmlDecode("&"+charEntity+";");    					ch = '#';//ret[0];    					return "&" + charEntity + ";"; 				default:    					// Max 3 following octal digits  					if (IsOct(c)) 					{  						// Parse+Convert oct to dec integer  						int oct = GetHexNumber(c);  						for (int i = 0; i < 2; ++i) 						{ 							if (IsOct((char)ReaderPeek())) 							{ 								c = (char)ReaderRead(); 								escapeSequenceBuffer[curPos++] = c;  								int idx = GetHexNumber(c); 								oct = 8 * oct + idx; 							} 							else 								break; 						}    						// Convert integer to character  						if (oct > 0xffff) 						{ 							ch = '\0'; 							surrogatePair = char.ConvertFromUtf32(oct); 						} 						else 						{ 							ch = (char)oct; 						}  					} 					else 					{ 						OnError(Line' Col' String.Format("Unexpected escape sequence : {0}"' c)); 						ch = '\0'; 					} 					break; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: switch (c) 			{ 				case '\'': 					ch = '\''; 					break; 				case '\"': 					ch = '\"'; 					break; 				case '?': 					ch = '?'; 					return "\\?"; // Literal question mark  				case '\\': 					ch = '\\'; 					break;  				/*case '0': 					ch = '\0'; 					break;*/  				case 'a': 					ch = '\a'; // Bell (alert)  					break; 				case 'b': 					ch = '\b'; // Backspace  					break; 				case 'f': 					ch = '\f'; // Formfeed  					break; 				case 'n': 					ch = '\n'; 					break; 				case 'r': 					ch = '\r'; 					break; 				case 't': 					ch = '\t'; 					break; 				case 'v': 					ch = '\v'; // Vertical tab  					break; 				case 'u': 				case 'x':  					// 16 bit unicode character  					c = (char)ReaderRead(); 					number = GetHexNumber(c); 					escapeSequenceBuffer[curPos++] = c;  					if (number < 0) 					{ 						OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' c)); 					} 					for (int i = 0; i < 3; ++i) 					{ 						if (IsHex((char)ReaderPeek())) 						{ 							c = (char)ReaderRead(); 							int idx = GetHexNumber(c); 							escapeSequenceBuffer[curPos++] = c; 							number = 16 * number + idx; 						} 						else 						{ 							break; 						} 					} 					ch = (char)number; 					break; 				case 'U':  					// 32 bit unicode character  					number = 0; 					for (int i = 0; i < 8; ++i) 					{ 						if (IsHex((char)ReaderPeek())) 						{ 							c = (char)ReaderRead(); 							int idx = GetHexNumber(c); 							escapeSequenceBuffer[curPos++] = c; 							number = 16 * number + idx; 						} 						else 						{ 							OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' (char)ReaderPeek())); 							break; 						} 					} 					if (number > 0xffff) 					{ 						ch = '\0'; 						surrogatePair = char.ConvertFromUtf32(number); 					} 					else 					{ 						ch = (char)number; 					} 					break;    				// NamedCharacterEntities  				case '&': 					string charEntity = "";  					while (true) 					{ 						nextChar = ReaderRead();  						if (nextChar < 0) 						{ 							OnError(Line' Col - 1' "EOF reached within named char entity"); 							ch = '\0'; 							return string.Empty; 						}  						c = (char)nextChar;  						if (c == ';') 							break;  						if (IsIdentifierPart(c)) 							charEntity += c; 						else 						{ 							OnError(Line' Col - 1' "Unexpected character found in named char entity: " + c); 							ch = '\0'; 							return string.Empty; 						} 					}  					if (string.IsNullOrEmpty(charEntity)) 					{ 						OnError(Line' Col - 1' "Empty named character entities not allowed"); 						ch = '\0'; 						return string.Empty; 					}    					//TODO: Performance improvement  					//var ret=System.Web.HttpUtility.HtmlDecode("&"+charEntity+";");    					ch = '#';//ret[0];    					return "&" + charEntity + ";"; 				default:    					// Max 3 following octal digits  					if (IsOct(c)) 					{  						// Parse+Convert oct to dec integer  						int oct = GetHexNumber(c);  						for (int i = 0; i < 2; ++i) 						{ 							if (IsOct((char)ReaderPeek())) 							{ 								c = (char)ReaderRead(); 								escapeSequenceBuffer[curPos++] = c;  								int idx = GetHexNumber(c); 								oct = 8 * oct + idx; 							} 							else 								break; 						}    						// Convert integer to character  						if (oct > 0xffff) 						{ 							ch = '\0'; 							surrogatePair = char.ConvertFromUtf32(oct); 						} 						else 						{ 							ch = (char)oct; 						}  					} 					else 					{ 						OnError(Line' Col' String.Format("Unexpected escape sequence : {0}"' c)); 						ch = '\0'; 					} 					break; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: switch (c) 			{ 				case '\'': 					ch = '\''; 					break; 				case '\"': 					ch = '\"'; 					break; 				case '?': 					ch = '?'; 					return "\\?"; // Literal question mark  				case '\\': 					ch = '\\'; 					break;  				/*case '0': 					ch = '\0'; 					break;*/  				case 'a': 					ch = '\a'; // Bell (alert)  					break; 				case 'b': 					ch = '\b'; // Backspace  					break; 				case 'f': 					ch = '\f'; // Formfeed  					break; 				case 'n': 					ch = '\n'; 					break; 				case 'r': 					ch = '\r'; 					break; 				case 't': 					ch = '\t'; 					break; 				case 'v': 					ch = '\v'; // Vertical tab  					break; 				case 'u': 				case 'x':  					// 16 bit unicode character  					c = (char)ReaderRead(); 					number = GetHexNumber(c); 					escapeSequenceBuffer[curPos++] = c;  					if (number < 0) 					{ 						OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' c)); 					} 					for (int i = 0; i < 3; ++i) 					{ 						if (IsHex((char)ReaderPeek())) 						{ 							c = (char)ReaderRead(); 							int idx = GetHexNumber(c); 							escapeSequenceBuffer[curPos++] = c; 							number = 16 * number + idx; 						} 						else 						{ 							break; 						} 					} 					ch = (char)number; 					break; 				case 'U':  					// 32 bit unicode character  					number = 0; 					for (int i = 0; i < 8; ++i) 					{ 						if (IsHex((char)ReaderPeek())) 						{ 							c = (char)ReaderRead(); 							int idx = GetHexNumber(c); 							escapeSequenceBuffer[curPos++] = c; 							number = 16 * number + idx; 						} 						else 						{ 							OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' (char)ReaderPeek())); 							break; 						} 					} 					if (number > 0xffff) 					{ 						ch = '\0'; 						surrogatePair = char.ConvertFromUtf32(number); 					} 					else 					{ 						ch = (char)number; 					} 					break;    				// NamedCharacterEntities  				case '&': 					string charEntity = "";  					while (true) 					{ 						nextChar = ReaderRead();  						if (nextChar < 0) 						{ 							OnError(Line' Col - 1' "EOF reached within named char entity"); 							ch = '\0'; 							return string.Empty; 						}  						c = (char)nextChar;  						if (c == ';') 							break;  						if (IsIdentifierPart(c)) 							charEntity += c; 						else 						{ 							OnError(Line' Col - 1' "Unexpected character found in named char entity: " + c); 							ch = '\0'; 							return string.Empty; 						} 					}  					if (string.IsNullOrEmpty(charEntity)) 					{ 						OnError(Line' Col - 1' "Empty named character entities not allowed"); 						ch = '\0'; 						return string.Empty; 					}    					//TODO: Performance improvement  					//var ret=System.Web.HttpUtility.HtmlDecode("&"+charEntity+";");    					ch = '#';//ret[0];    					return "&" + charEntity + ";"; 				default:    					// Max 3 following octal digits  					if (IsOct(c)) 					{  						// Parse+Convert oct to dec integer  						int oct = GetHexNumber(c);  						for (int i = 0; i < 2; ++i) 						{ 							if (IsOct((char)ReaderPeek())) 							{ 								c = (char)ReaderRead(); 								escapeSequenceBuffer[curPos++] = c;  								int idx = GetHexNumber(c); 								oct = 8 * oct + idx; 							} 							else 								break; 						}    						// Convert integer to character  						if (oct > 0xffff) 						{ 							ch = '\0'; 							surrogatePair = char.ConvertFromUtf32(oct); 						} 						else 						{ 							ch = (char)oct; 						}  					} 					else 					{ 						OnError(Line' Col' String.Format("Unexpected escape sequence : {0}"' c)); 						ch = '\0'; 					} 					break; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: switch (c) 			{ 				case '\'': 					ch = '\''; 					break; 				case '\"': 					ch = '\"'; 					break; 				case '?': 					ch = '?'; 					return "\\?"; // Literal question mark  				case '\\': 					ch = '\\'; 					break;  				/*case '0': 					ch = '\0'; 					break;*/  				case 'a': 					ch = '\a'; // Bell (alert)  					break; 				case 'b': 					ch = '\b'; // Backspace  					break; 				case 'f': 					ch = '\f'; // Formfeed  					break; 				case 'n': 					ch = '\n'; 					break; 				case 'r': 					ch = '\r'; 					break; 				case 't': 					ch = '\t'; 					break; 				case 'v': 					ch = '\v'; // Vertical tab  					break; 				case 'u': 				case 'x':  					// 16 bit unicode character  					c = (char)ReaderRead(); 					number = GetHexNumber(c); 					escapeSequenceBuffer[curPos++] = c;  					if (number < 0) 					{ 						OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' c)); 					} 					for (int i = 0; i < 3; ++i) 					{ 						if (IsHex((char)ReaderPeek())) 						{ 							c = (char)ReaderRead(); 							int idx = GetHexNumber(c); 							escapeSequenceBuffer[curPos++] = c; 							number = 16 * number + idx; 						} 						else 						{ 							break; 						} 					} 					ch = (char)number; 					break; 				case 'U':  					// 32 bit unicode character  					number = 0; 					for (int i = 0; i < 8; ++i) 					{ 						if (IsHex((char)ReaderPeek())) 						{ 							c = (char)ReaderRead(); 							int idx = GetHexNumber(c); 							escapeSequenceBuffer[curPos++] = c; 							number = 16 * number + idx; 						} 						else 						{ 							OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' (char)ReaderPeek())); 							break; 						} 					} 					if (number > 0xffff) 					{ 						ch = '\0'; 						surrogatePair = char.ConvertFromUtf32(number); 					} 					else 					{ 						ch = (char)number; 					} 					break;    				// NamedCharacterEntities  				case '&': 					string charEntity = "";  					while (true) 					{ 						nextChar = ReaderRead();  						if (nextChar < 0) 						{ 							OnError(Line' Col - 1' "EOF reached within named char entity"); 							ch = '\0'; 							return string.Empty; 						}  						c = (char)nextChar;  						if (c == ';') 							break;  						if (IsIdentifierPart(c)) 							charEntity += c; 						else 						{ 							OnError(Line' Col - 1' "Unexpected character found in named char entity: " + c); 							ch = '\0'; 							return string.Empty; 						} 					}  					if (string.IsNullOrEmpty(charEntity)) 					{ 						OnError(Line' Col - 1' "Empty named character entities not allowed"); 						ch = '\0'; 						return string.Empty; 					}    					//TODO: Performance improvement  					//var ret=System.Web.HttpUtility.HtmlDecode("&"+charEntity+";");    					ch = '#';//ret[0];    					return "&" + charEntity + ";"; 				default:    					// Max 3 following octal digits  					if (IsOct(c)) 					{  						// Parse+Convert oct to dec integer  						int oct = GetHexNumber(c);  						for (int i = 0; i < 2; ++i) 						{ 							if (IsOct((char)ReaderPeek())) 							{ 								c = (char)ReaderRead(); 								escapeSequenceBuffer[curPos++] = c;  								int idx = GetHexNumber(c); 								oct = 8 * oct + idx; 							} 							else 								break; 						}    						// Convert integer to character  						if (oct > 0xffff) 						{ 							ch = '\0'; 							surrogatePair = char.ConvertFromUtf32(oct); 						} 						else 						{ 							ch = (char)oct; 						}  					} 					else 					{ 						OnError(Line' Col' String.Format("Unexpected escape sequence : {0}"' c)); 						ch = '\0'; 					} 					break; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch) 			{ 				case '+': 					switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					} 					return Token(DTokens.Plus' x' y); 				case '-': 					switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					} 					return Token(DTokens.Minus' x' y); 				case '*': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TimesAssign' x' y' 2); 						default: 							break; 					} 					return Token(DTokens.Times' x' y); 				case '/': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					} 					return Token(DTokens.Div' x' y); 				case '%': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					} 					return Token(DTokens.Mod' x' y); 				case '&': 					switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseAnd' x' y); 				case '|': 					switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					} 					return Token(DTokens.BitwiseOr' x' y); 				case '^': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					} 					return Token(DTokens.Xor' x' y); 				case '!': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							} 							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default: 									break; 							} 							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					} 					return Token(DTokens.Not' x' y); 				case '~': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					} 					return Token(DTokens.Tilde' x' y); 				case '=': 					switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					} 					return Token(DTokens.Assign' x' y); 				case '<': 					switch (ReaderPeek()) 					{ 						case '<': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.ShiftLeftAssign' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.ShiftLeft' x' y' 2); 						case '>': 							ReaderRead(); 							switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.LessEqualOrGreater' x' y' 3); 								default: 									break; 							} 							return Token(DTokens.LessOrGreater' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.LessEqual' x' y' 2); 					} 					return Token(DTokens.LessThan' x' y); 				case '>': 					switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					} 					return Token(DTokens.GreaterThan' x' y); 				case '?': 					return Token(DTokens.Question' x' y); 				case '$': 					return Token(DTokens.Dollar' x' y); 				case ';': 					return Token(DTokens.Semicolon' x' y); 				case ':': 					return Token(DTokens.Colon' x' y); 				case ''': 					return Token(DTokens.Comma' x' y); 				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek(); 					if (tmp > 0 && IsDigit((char)tmp)) 						return ReadDigit('.'' Col - 1); 					else if (tmp == (int)'.') 					{ 						ReaderRead(); 						if ((char)ReaderPeek() == '.') // Triple dot  						{ 							ReaderRead(); 							return Token(DTokens.TripleDot' x' y' 3); 						} 						return Token(DTokens.DoubleDot' x' y' 2); 					} 					return Token(DTokens.Dot' x' y); 				case ')': 					return Token(DTokens.CloseParenthesis' x' y); 				case '(': 					return Token(DTokens.OpenParenthesis' x' y); 				case ']': 					return Token(DTokens.CloseSquareBracket' x' y); 				case '[': 					return Token(DTokens.OpenSquareBracket' x' y); 				case '}': 					return Token(DTokens.CloseCurlyBrace' x' y); 				case '{': 					return Token(DTokens.OpenCurlyBrace' x' y); 				default: 					return null; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadSingleLineComment,The following statement contains a magic number: int tagLen = ((commentType & Comment.Type.Documentation) != 0 ? 3 : 2);
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadSingleLineComment,The following statement contains a magic number: int tagLen = ((commentType & Comment.Type.Documentation) != 0 ? 3 : 2);
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadSingleLineComment,The following statement contains a magic number: Comments.Add(new Comment(commentType' comm.TrimStart('/'' ' '' '\t')' st.Column < 2' st' end));
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadMultiLineComment,The following statement contains a magic number: CodeLocation st = new CodeLocation(Col - ((commentType & Comment.Type.Documentation) != 0 ? 3 : 2)' Line);
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadMultiLineComment,The following statement contains a magic number: CodeLocation st = new CodeLocation(Col - ((commentType & Comment.Type.Documentation) != 0 ? 3 : 2)' Line);
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadMultiLineComment,The following statement contains a magic number: Comments.Add(new Comment(commentType' scCurWord.ToString().Trim()' st.Column < 2' st' new CodeLocation(Col' Line)));
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,IsLegalDigit,The following statement contains a magic number: switch (NumBase) 			{ 				case 2: 					return IsBin(d); 				case 10: 					return IsDigit(d); 				case 16: 					return IsHex(d); 				default: 					return false; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,IsLegalDigit,The following statement contains a magic number: switch (NumBase) 			{ 				case 2: 					return IsBin(d); 				case 10: 					return IsDigit(d); 				case 16: 					return IsHex(d); 				default: 					return false; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,IsLegalDigit,The following statement contains a magic number: switch (NumBase) 			{ 				case 2: 					return IsBin(d); 				case 10: 					return IsDigit(d); 				case 16: 					return IsHex(d); 				default: 					return false; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) 			{ 				case '0': 					return 0; 				case '1': 					return 1; 				case '2': 					return 2; 				case '3': 					return 3; 				case '4': 					return 4; 				case '5': 					return 5; 				case '6': 					return 6; 				case '7': 					return 7; 				case '8': 					return 8; 				case '9': 					return 9; 				case 'a': 				case 'A': 					return 10; 				case 'b': 				case 'B': 					return 11; 				case 'c': 				case 'C': 					return 12; 				case 'd': 				case 'D': 					return 13; 				case 'e': 				case 'E': 					return 14; 				case 'f': 				case 'F': 					return 15; 				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) 			{ 				case '0': 					return 0; 				case '1': 					return 1; 				case '2': 					return 2; 				case '3': 					return 3; 				case '4': 					return 4; 				case '5': 					return 5; 				case '6': 					return 6; 				case '7': 					return 7; 				case '8': 					return 8; 				case '9': 					return 9; 				case 'a': 				case 'A': 					return 10; 				case 'b': 				case 'B': 					return 11; 				case 'c': 				case 'C': 					return 12; 				case 'd': 				case 'D': 					return 13; 				case 'e': 				case 'E': 					return 14; 				case 'f': 				case 'F': 					return 15; 				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) 			{ 				case '0': 					return 0; 				case '1': 					return 1; 				case '2': 					return 2; 				case '3': 					return 3; 				case '4': 					return 4; 				case '5': 					return 5; 				case '6': 					return 6; 				case '7': 					return 7; 				case '8': 					return 8; 				case '9': 					return 9; 				case 'a': 				case 'A': 					return 10; 				case 'b': 				case 'B': 					return 11; 				case 'c': 				case 'C': 					return 12; 				case 'd': 				case 'D': 					return 13; 				case 'e': 				case 'E': 					return 14; 				case 'f': 				case 'F': 					return 15; 				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) 			{ 				case '0': 					return 0; 				case '1': 					return 1; 				case '2': 					return 2; 				case '3': 					return 3; 				case '4': 					return 4; 				case '5': 					return 5; 				case '6': 					return 6; 				case '7': 					return 7; 				case '8': 					return 8; 				case '9': 					return 9; 				case 'a': 				case 'A': 					return 10; 				case 'b': 				case 'B': 					return 11; 				case 'c': 				case 'C': 					return 12; 				case 'd': 				case 'D': 					return 13; 				case 'e': 				case 'E': 					return 14; 				case 'f': 				case 'F': 					return 15; 				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) 			{ 				case '0': 					return 0; 				case '1': 					return 1; 				case '2': 					return 2; 				case '3': 					return 3; 				case '4': 					return 4; 				case '5': 					return 5; 				case '6': 					return 6; 				case '7': 					return 7; 				case '8': 					return 8; 				case '9': 					return 9; 				case 'a': 				case 'A': 					return 10; 				case 'b': 				case 'B': 					return 11; 				case 'c': 				case 'C': 					return 12; 				case 'd': 				case 'D': 					return 13; 				case 'e': 				case 'E': 					return 14; 				case 'f': 				case 'F': 					return 15; 				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) 			{ 				case '0': 					return 0; 				case '1': 					return 1; 				case '2': 					return 2; 				case '3': 					return 3; 				case '4': 					return 4; 				case '5': 					return 5; 				case '6': 					return 6; 				case '7': 					return 7; 				case '8': 					return 8; 				case '9': 					return 9; 				case 'a': 				case 'A': 					return 10; 				case 'b': 				case 'B': 					return 11; 				case 'c': 				case 'C': 					return 12; 				case 'd': 				case 'D': 					return 13; 				case 'e': 				case 'E': 					return 14; 				case 'f': 				case 'F': 					return 15; 				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) 			{ 				case '0': 					return 0; 				case '1': 					return 1; 				case '2': 					return 2; 				case '3': 					return 3; 				case '4': 					return 4; 				case '5': 					return 5; 				case '6': 					return 6; 				case '7': 					return 7; 				case '8': 					return 8; 				case '9': 					return 9; 				case 'a': 				case 'A': 					return 10; 				case 'b': 				case 'B': 					return 11; 				case 'c': 				case 'C': 					return 12; 				case 'd': 				case 'D': 					return 13; 				case 'e': 				case 'E': 					return 14; 				case 'f': 				case 'F': 					return 15; 				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) 			{ 				case '0': 					return 0; 				case '1': 					return 1; 				case '2': 					return 2; 				case '3': 					return 3; 				case '4': 					return 4; 				case '5': 					return 5; 				case '6': 					return 6; 				case '7': 					return 7; 				case '8': 					return 8; 				case '9': 					return 9; 				case 'a': 				case 'A': 					return 10; 				case 'b': 				case 'B': 					return 11; 				case 'c': 				case 'C': 					return 12; 				case 'd': 				case 'D': 					return 13; 				case 'e': 				case 'E': 					return 14; 				case 'f': 				case 'F': 					return 15; 				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) 			{ 				case '0': 					return 0; 				case '1': 					return 1; 				case '2': 					return 2; 				case '3': 					return 3; 				case '4': 					return 4; 				case '5': 					return 5; 				case '6': 					return 6; 				case '7': 					return 7; 				case '8': 					return 8; 				case '9': 					return 9; 				case 'a': 				case 'A': 					return 10; 				case 'b': 				case 'B': 					return 11; 				case 'c': 				case 'C': 					return 12; 				case 'd': 				case 'D': 					return 13; 				case 'e': 				case 'E': 					return 14; 				case 'f': 				case 'F': 					return 15; 				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) 			{ 				case '0': 					return 0; 				case '1': 					return 1; 				case '2': 					return 2; 				case '3': 					return 3; 				case '4': 					return 4; 				case '5': 					return 5; 				case '6': 					return 6; 				case '7': 					return 7; 				case '8': 					return 8; 				case '9': 					return 9; 				case 'a': 				case 'A': 					return 10; 				case 'b': 				case 'B': 					return 11; 				case 'c': 				case 'C': 					return 12; 				case 'd': 				case 'D': 					return 13; 				case 'e': 				case 'E': 					return 14; 				case 'f': 				case 'F': 					return 15; 				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) 			{ 				case '0': 					return 0; 				case '1': 					return 1; 				case '2': 					return 2; 				case '3': 					return 3; 				case '4': 					return 4; 				case '5': 					return 5; 				case '6': 					return 6; 				case '7': 					return 7; 				case '8': 					return 8; 				case '9': 					return 9; 				case 'a': 				case 'A': 					return 10; 				case 'b': 				case 'B': 					return 11; 				case 'c': 				case 'C': 					return 12; 				case 'd': 				case 'D': 					return 13; 				case 'e': 				case 'E': 					return 14; 				case 'f': 				case 'F': 					return 15; 				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) 			{ 				case '0': 					return 0; 				case '1': 					return 1; 				case '2': 					return 2; 				case '3': 					return 3; 				case '4': 					return 4; 				case '5': 					return 5; 				case '6': 					return 6; 				case '7': 					return 7; 				case '8': 					return 8; 				case '9': 					return 9; 				case 'a': 				case 'A': 					return 10; 				case 'b': 				case 'B': 					return 11; 				case 'c': 				case 'C': 					return 12; 				case 'd': 				case 'D': 					return 13; 				case 'e': 				case 'E': 					return 14; 				case 'f': 				case 'F': 					return 15; 				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) 			{ 				case '0': 					return 0; 				case '1': 					return 1; 				case '2': 					return 2; 				case '3': 					return 3; 				case '4': 					return 4; 				case '5': 					return 5; 				case '6': 					return 6; 				case '7': 					return 7; 				case '8': 					return 8; 				case '9': 					return 9; 				case 'a': 				case 'A': 					return 10; 				case 'b': 				case 'B': 					return 11; 				case 'c': 				case 'C': 					return 12; 				case 'd': 				case 'D': 					return 13; 				case 'e': 				case 'E': 					return 14; 				case 'f': 				case 'F': 					return 15; 				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0; 			}
Magic Number,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit) 			{ 				case '0': 					return 0; 				case '1': 					return 1; 				case '2': 					return 2; 				case '3': 					return 3; 				case '4': 					return 4; 				case '5': 					return 5; 				case '6': 					return 6; 				case '7': 					return 7; 				case '8': 					return 8; 				case '9': 					return 9; 				case 'a': 				case 'A': 					return 10; 				case 'b': 				case 'B': 					return 11; 				case 'c': 				case 'C': 					return 12; 				case 'd': 				case 'D': 					return 13; 				case 'e': 				case 'E': 					return 14; 				case 'f': 				case 'F': 					return 15; 				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0; 			}
Magic Number,D_Parser.Parser,DDocParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,FindNextMacro,The following statement contains a magic number: var ddoc = new DDocParser { text = text' nextOffset = macroStart+2 };
Magic Number,D_Parser.Parser,DDocParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,Parameters,The following statement contains a magic number: switch(Peek())  				{  					case ''':  						if (curParam > 9) {  							Step ();  							break;  						}    						l ["$" + curParam.ToString ()] = text.Substring (paramBegin' nextOffset - paramBegin);    						Step ();    						if (curParam == 1) // Second parameter begins now -- will be $+ then  							secondParamBegin = nextOffset;  						paramBegin = nextOffset;    						curParam++;  						break;  					default:  						SkipParameterText ();  						break;  				}
Magic Number,D_Parser.Parser,DDocParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,Parameters,The following statement contains a magic number: curParam > 1 && curParam < 9
Magic Number,D_Parser.Parser,DDocParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,SkipParameterText,The following statement contains a magic number: switch (Peek ()) {  				case '(':  					SkipParentheses ();  					break;  				case '"':  				case '\'':  					SkipString ();  					break;  				case '<':  					Read ();  					if (Peek () == '!' &&  					    nextOffset + 2 < text.Length &&  					    text [nextOffset + 1] == '-' && text [nextOffset + 2] == '-') {  						Step (); // !  						Step (); // -  						Step (); // -  						SkipHtmlComment ();  					} else  						SkipParameterText ();  					break;  				case '\0':  				case ')':  					break;  				default:  					Step ();  					break;  			}
Magic Number,D_Parser.Parser,DDocParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,SkipParameterText,The following statement contains a magic number: switch (Peek ()) {  				case '(':  					SkipParentheses ();  					break;  				case '"':  				case '\'':  					SkipString ();  					break;  				case '<':  					Read ();  					if (Peek () == '!' &&  					    nextOffset + 2 < text.Length &&  					    text [nextOffset + 1] == '-' && text [nextOffset + 2] == '-') {  						Step (); // !  						Step (); // -  						Step (); // -  						SkipHtmlComment ();  					} else  						SkipParameterText ();  					break;  				case '\0':  				case ')':  					break;  				default:  					Step ();  					break;  			}
Magic Number,D_Parser.Refactoring,SortImportsRefactoring,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Refactoring\SortImportsRefactoring.cs,ResortImports,The following statement contains a magic number: importsToSort.Count < 2
Magic Number,D_Parser.Refactoring,SortImportsRefactoring,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Refactoring\SortImportsRefactoring.cs,CalculateImportsToSort,The following statement contains a magic number: importsToSort.Count < 2
Magic Number,D_Parser.Resolver.ASTScanner,NameScan,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\NameScan.cs,GetMatches,The following statement contains a magic number: stackSize >= 7
Magic Number,D_Parser.Resolver,DTypeToCodeVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\DTypeToCodeVisitor.cs,VisitDTuple,The following statement contains a magic number: sb.Length = sb.Length - 2;
Magic Number,D_Parser.Resolver,MixinAnalysis,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\MixinAnalysis.cs,CheckAndPushAnalysisStack,The following statement contains a magic number: stmtsBeingAnalysed.Count > 5
Magic Number,D_Parser.Resolver,ResultComparer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ResultComparer.cs,IsPrimitiveTypeImplicitlyConvertible,The following statement contains a magic number: return fromType == toType || ImplicitConvertabilityTable.Contains((fromType << 8) + toType);
Magic Number,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The following statement contains a magic number: switch(te.Keyword)  			{  				case "":  				case null:  					return null;  					  				case "hasMember":  					bool ret = false;  					var optionsBackup = ctxt.ContextIndependentOptions;  					ctxt.ContextIndependentOptions = ResolutionOptions.IgnoreAllProtectionAttributes;  					  					AbstractType t;  					var pfa = ExpressionTypeEvaluation.prepareMemberTraitExpression(ctxt' te' out t' evaluationState);  					  					if(pfa != null && t != null)  					{  						t.NonStaticAccess = true;  						ignoreErrors = true;  						var res = ExpressionTypeEvaluation.EvaluateType(pfa' ctxt' false);  						ret = res != null;  						ignoreErrors = false;  					}  					ctxt.ContextIndependentOptions = optionsBackup;  					return new PrimitiveValue(ret);  					  					  				case "identifier":  					if(te.Arguments!=null && te.Arguments.Length == 1)  						return new ArrayValue(GetStringLiteralType()' te.Arguments[0].ToString());  					break;  					  					  				case "getMember":  					pfa = ExpressionTypeEvaluation.prepareMemberTraitExpression(ctxt' te' out t' evaluationState);  					  					if(pfa == null ||t == null)  						break;  					  					var vs = EvalPostfixAccessExpression(this' ctxt' pfa't' ValueProvider:evaluationState);  					if(vs == null || vs.Count == 0)  						return null;  					return vs[0];  					  					  				case "getOverloads":  					optionsBackup = ctxt.ContextIndependentOptions;  					ctxt.ContextIndependentOptions = ResolutionOptions.IgnoreAllProtectionAttributes;    					pfa = ExpressionTypeEvaluation.prepareMemberTraitExpression(ctxt' te' out t' evaluationState);    					if (pfa != null && t != null)  						vs = EvalPostfixAccessExpression(this' ctxt' pfa' t);  					else  						vs = null;  					  					ctxt.ContextIndependentOptions = optionsBackup;  					  					return new TypeValue(new DTuple(vs));  					  					  				case "getProtection":  					optionsBackup = ctxt.ContextIndependentOptions;  					ctxt.ContextIndependentOptions = ResolutionOptions.IgnoreAllProtectionAttributes;  					  					var prot = "public";  					  					if(te.Arguments == null || te.Arguments.Length != 1 || te.Arguments[0] == null)  						EvalError(te' "First trait argument must be a symbol identifier");  					else  					{  						t = ExpressionTypeEvaluation.ResolveTraitArgument(ctxt'te.Arguments[0]);  						  						if(t is DSymbol)  						{  							var dn = (t as DSymbol).Definition;  							  							if(dn.ContainsAnyAttribute(DTokens.Private))  								prot = "private";  							else if(dn.ContainsAnyAttribute(DTokens.Protected))  								prot = "protected";  							else if(dn.ContainsAnyAttribute(DTokens.Package))  								prot = "package";  							else if(dn.ContainsAnyAttribute(DTokens.Export))  								prot = "export";  						}  						else  							EvalError(te' "First argument must evaluate to an existing code symbol");  					}  					  					ctxt.ContextIndependentOptions = optionsBackup;  					return new ArrayValue(GetStringLiteralType()' prot);  					  				case "getVirtualFunctions":  					break;  				case "getVirtualMethods":  					break;  				case "parent":  					break;  				case "classInstanceSize":  					break;  				case "allMembers":  					break;  				case "derivedMembers":  					break;  					  				case "isSame":  					ret = false;  					  					if(te.Arguments == null || te.Arguments.Length < 2)  					{  						EvalError(te' "isSame requires two arguments to compare");  					}  					else  					{  						t = ExpressionTypeEvaluation.ResolveTraitArgument(ctxt' te.Arguments[0]);  						  						if(t != null)  						{  							var t2 = ExpressionTypeEvaluation.ResolveTraitArgument(ctxt' te.Arguments[1]);  							  							if(t2 != null)  								ret = Resolver.ResultComparer.IsEqual(t't2);  						}  					}  					  					return new PrimitiveValue(ret);  					  				case "compiles":  					ret = false;  					  					if(te.Arguments != null){  						foreach(var arg in te.Arguments)  						{  							ret = arg == null || ExpressionTypeEvaluation.ResolveTraitArgument(ctxt' arg) != null;  							  							if(!ret)  								break;  						}  					}  						  					return new PrimitiveValue(ret);  			}
Magic Number,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,EvaluateType,The following statement contains a magic number: long cacheHashBias = tryReturnMethodReturnType ? 31 : 0;
Magic Number,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,prepareMemberTraitExpression,The following statement contains a magic number: te.Arguments != null && te.Arguments.Length == 2
Magic Number,D_Parser.Resolver.ExpressionSemantics,ArrayValue,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,The following statement contains a magic number: sb.Remove (sb.Length-2' 2);
Magic Number,D_Parser.Resolver.ExpressionSemantics,ArrayValue,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,The following statement contains a magic number: sb.Remove (sb.Length-2' 2);
Magic Number,D_Parser.Resolver.ExpressionSemantics,AssociativeArrayValue,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2);
Magic Number,D_Parser.Resolver.ExpressionSemantics,AssociativeArrayValue,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2);
Magic Number,D_Parser.Resolver.TypeResolution,ASTSearchHelper,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\ASTSearchHelper.cs,SearchRegionAt,The following statement contains a magic number: midIndex = (len % 2 + len) / 2;
Magic Number,D_Parser.Resolver.TypeResolution,ASTSearchHelper,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\ASTSearchHelper.cs,SearchRegionAt,The following statement contains a magic number: midIndex = (len % 2 + len) / 2;
Magic Number,D_Parser.Resolver.TypeResolution,ASTSearchHelper,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\ASTSearchHelper.cs,SearchRegionAt,The following statement contains a magic number: midIndex = (len % 2 + len) / 2;
Magic Number,D_Parser.Resolver.TypeResolution,ASTSearchHelper,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\ASTSearchHelper.cs,SearchRegionAt,The following statement contains a magic number: midIndex = (len % 2 + len) / 2;
Magic Number,D_Parser.Resolver.TypeResolution,DSymbolBaseTypeResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\DSymbolBaseTypeResolver.cs,HasntReachedResolutionStackPeak,The following statement contains a magic number: return stkC < 4;
Magic Number,D_Parser.Resolver.TypeResolution,ClassInterfaceResolver,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\ClassInterfaceResolver.cs,ResolveClassOrInterface,The following statement contains a magic number: bcStack > 6 || (instanceDeclaration != null && parsedClassInstanceDecls.Contains(instanceDeclaration))
Magic Number,D_Parser.Completion,CodeCompletion,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\CodeCompletion.cs,IsCompletionAllowed,The following statement contains a magic number: Editor.CaretOffset > 1 && Editor.ModuleCode[Editor.CaretOffset - 2] == enteredChar
Missing Default,D_Parser.Dom,BuiltInAtAttribute,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Attribute.cs,ToString,The following switch statement is missing a default case: switch (Kind) 			{ 				case BuiltInAttributes.Disable: 					return "@disable"; 				case BuiltInAttributes.Property: 					return "@property"; 				case BuiltInAttributes.Safe: 					return "@safe"; 				case BuiltInAttributes.System: 					return "@system";  				case BuiltInAttributes.Trusted:  					return "@trusted";  				case BuiltInAttributes.Nogc:  					return "@nogc";  			}
Missing Default,D_Parser.Dom.Statements,GotoStatement,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Dom\Statements\GotoStatement.cs,ToCode,The following switch statement is missing a default case: switch (StmtType)  			{  				case GotoStmtType.Identifier:  					return "goto " + LabelIdentifier + ';';  				case GotoStmtType.Default:  					return "goto default;";  				case GotoStmtType.Case:  					return "goto" + (CaseExpression == null ? "" : (' ' + CaseExpression.ToString())) + ';';  			}
Missing Default,D_Parser.Formatting,DFormattingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,EnforceBraceStyle,The following switch statement is missing a default case: switch (braceStyle) {  				case BraceStyle.DoNotChange:  					startIndent = endIndent = null;  					break;  				case BraceStyle.EndOfLineWithoutSpace:  					startIndent = "";  					endIndent = IsLineIsEmptyUpToEol(rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString;  					break;  				case BraceStyle.EndOfLine:  					int lastNonWs;  					var lastComments = GetCommentsBefore(lBrace' out lastNonWs);  					if(lastComments.Count != 0)  					{  						// delete old bracket  						AddChange(whitespaceStart' lbraceOffset - whitespaceStart + 1' "");  					  						lbraceOffset = whitespaceStart = lastNonWs + 1;  						startIndent = " {";  					} else {  						startIndent = " ";  					}  					endIndent = IsLineIsEmptyUpToEol(rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString;  					break;  				case BraceStyle.NextLine:  					startIndent = this.options.EolMarker + curIndent.IndentString;  					endIndent = IsLineIsEmptyUpToEol(rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString;  					break;  				case BraceStyle.NextLineShifted2:  				case BraceStyle.NextLineShifted:  					curIndent.Push(IndentType.Block);  					startIndent = this.options.EolMarker + curIndent.IndentString;  					endIndent = IsLineIsEmptyUpToEol(rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString;  					curIndent.Pop ();  					break;  			}
Missing Default,D_Parser.Formatting,DFormattingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,Visit,The following switch statement is missing a default case: switch(n.SpecialType)  			{  				case DMethod.MethodType.Destructor:  				case DMethod.MethodType.Constructor:  					nameLength = 4; // this  					break;  				case DMethod.MethodType.Normal:  					nameLength = n.Name.Length;  					break;  			}
Missing Default,D_Parser.Formatting,DFormattingVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,Visit,The following switch statement is missing a default case: switch(policy.MultiVariableDeclPlacement)  					{  						case NewLinePlacement.NewLine:  							curIndent.Push(IndentType.Continuation);  							FixIndentationForceNewLine(n.NameLocation);  							curIndent.Pop();  							break;  						case NewLinePlacement.SameLine:  							ForceSpacesBeforeRemoveNewLines(n.NameLocation' true);  							break;  					}
Missing Default,D_Parser.Misc,CompletionOptions,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\CompletionOptions.cs,Load,The following switch statement is missing a default case: switch (x.LocalName)  				{  					case "EnableResolutionCache":  						EnableResolutionCache = x.ReadString().ToLower() == "true";  					break;  					case "CompletionTimeout":  						int.TryParse(x.ReadString()' out CompletionTimeout);  						break;  					case "EnableUFCSCompletion":  						ShowUFCSItems = x.ReadString().ToLower() == "true";  						break;  					case "EnableDeclarationConstraints":  						EnableDeclarationConstraints = x.ReadString().ToLower() == "true";  						break;  					case "MixinAnalysis":  						DisableMixinAnalysis = x.ReadString().ToLower() != "true";  						break;  					case "CompletionSuggestionMode":  						EnableSuggestionMode = x.ReadString().ToLower() == "true";  						break;  					case "HideDeprecatedNodes":  						HideDeprecatedNodes = x.ReadString().ToLower() == "true";  						break;  					case "HideDisabledNodes":  						HideDisabledNodes = x.ReadString().ToLower() == "true";  						break;  					case "ShowStructMembersInStructInitOnly":  						ShowStructMembersInStructInitOnly = x.ReadString().ToLower() == "true";  						break;  				}
Missing Default,D_Parser.Misc,VersionIdEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\VersionIdEvaluation.cs,GetOSAndCPUVersions,The following switch statement is missing a default case: switch (OS)  			{  				case Platform.Windows:  					l.Add("Windows");  					l.Add(is64BitOS ? "Win64" : "Win32");  					break;  				case Platform.Linux:  					l.Add ("Posix");  					l.Add("linux");  					break;  				case Platform.Mac:  					l.Add("OSX");  						l.Add("darwin");  						l.Add ("Posix");  					break;  			}
Missing Default,D_Parser.Misc,ConsoleLogger,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Logger.cs,Log,The following switch statement is missing a default case: switch (lvl) {  			case LogLevel.Debug:  				Console.Write ("Debug: ");  				break;  			case LogLevel.Error:  				Console.Write ("Error: ");  				break;  			case LogLevel.Fatal:  				Console.Write ("Fatal error: ");  				break;  			case LogLevel.Info:  				Console.Write ("Info: ");  				break;  			case LogLevel.Warn:  				Console.Write ("Warning: ");  				break;  			}
Missing Default,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,TemplateArg,The following switch statement is missing a default case: switch((char)r.Read()) 			{ 				case 'T': 					return TypeDeclarationExpression.TryWrap(DTypeToTypeDeclVisitor.GenerateTypeDecl(Type())); 				case 'V': 					var t = Type(); // Where should the explicit type be used when there's already a value? 					return Value(); 				case 'S': 					return new StringLiteralExpression(LName()); 			}
Missing Default,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Type,The following switch statement is missing a default case: switch(type) 			{ 				case 'O': 					var t = Type(); 					t.Modifiers = new [] { DTokens.Shared }; 					return t; 				case 'x': 					t = Type(); 					t.Modifiers = new [] { DTokens.Const }; 					return t; 				case 'y': 					t = Type(); 					t.Modifiers = new [] { DTokens.Immutable }; 					return t; 				case 'N': 					switch(r.Read()) 					{ 						case 'g': 							t = Type(); 						t.Modifiers = new [] { DTokens.InOut }; 							return t; 						case 'e': // TypeNewArray ? 							Type(); 							return null; 					} 					break; 				case 'A': 					return new ArrayType(Type()); 				case 'G': 					var len = (int)Number(); 					return new ArrayType(Type()' len); 				case 'H': 					var keyType = Type(); 					t = Type(); 					return new AssocArrayType(t' keyType); 				case 'P': 					return new PointerType(Type()); 				case 'F': 				case 'U': 				case 'W': 				case 'V': 				case 'R': 					AbstractType ret; 					List<DAttribute> attrs; 					Dictionary<INode'AbstractType> pars; 					Function (out ret' out attrs' out pars' type); 						 					var dm = new DMethod { Attributes = attrs }; 					dm.Parameters.AddRange (pars.Keys); 					return new MemberSymbol(dm' ret' null); 				case 'C': 				case 'S': 				case 'E': 				case 'T': 				case 'I': 				return TypeDeclarationResolver.ResolveSingle (QualifiedName ()' ctxt); 				/* 					return new MemberSymbol(null'null' QualifiedName()); 				case 'C': 					return new ClassType(new DClassLike(DTokens.Class)' QualifiedName()' null); 				case 'S': 					return new StructType(new DClassLike(DTokens.Struct)' QualifiedName()); 				case 'E': 					return new EnumType(new DEnum()' null' QualifiedName()); 				case 'T': 					return new AliasedType(null' null' QualifiedName()); 				*/case 'D': 					Function(out ret' out attrs' out pars' type); 					var dgArgs = new List<AbstractType>(); 					 					foreach(var kv in pars) 						dgArgs.Add(new MemberSymbol(kv.Key as DNode' kv.Value' null)); 					 					return new DelegateType(ret'new DelegateDeclaration{ Parameters = pars.Keys.ToList() }' dgArgs); 				case 'v': return new PrimitiveType(DTokens.Void); 				case 'g': return new PrimitiveType(DTokens.Byte); 				case 'h': return new PrimitiveType(DTokens.Ubyte); 				case 's': return new PrimitiveType(DTokens.Short); 				case 't': return new PrimitiveType(DTokens.Ushort); 				case 'i': return new PrimitiveType(DTokens.Int); 				case 'k': return new PrimitiveType(DTokens.Uint); 				case 'l': return new PrimitiveType(DTokens.Long); 				case 'm': return new PrimitiveType(DTokens.Ulong); 				case 'f': return new PrimitiveType(DTokens.Float); 				case 'd': return new PrimitiveType(DTokens.Double); 				case 'e': return new PrimitiveType(DTokens.Real); 				case 'o': return new PrimitiveType(DTokens.Ifloat); 				case 'p': return new PrimitiveType(DTokens.Idouble); 				case 'j': return new PrimitiveType(DTokens.Ireal); 				case 'q': return new PrimitiveType(DTokens.Cfloat); 				case 'r': return new PrimitiveType(DTokens.Cdouble); 				case 'c': return new PrimitiveType(DTokens.Creal); 				case 'b': return new PrimitiveType(DTokens.Bool); 				case 'a': return new PrimitiveType(DTokens.Char); 				case 'u': return new PrimitiveType(DTokens.Wchar); 				case 'w': return new PrimitiveType(DTokens.Dchar); 				case 'n': return null; 				 				case 'B': 					len = (int)Number(); 					var items = new AbstractType[len]; 					var c = (char)r.Read(); 					for (int i = 0; i < len; i++) 					{ 						Argument(ref c' out items[i]); 					} 					 					return new DTuple(items); 			}
Missing Default,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Type,The following switch statement is missing a default case: switch(r.Read()) 					{ 						case 'g': 							t = Type(); 						t.Modifiers = new [] { DTokens.InOut }; 							return t; 						case 'e': // TypeNewArray ? 							Type(); 							return null; 					}
Missing Default,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Function,The following switch statement is missing a default case: switch(callConvention) 			{ 				case 'U': 					conv = "C"; 					break; 				case 'W': 					conv = "Windows"; 					break; 				case 'V': 					conv = "Pascal"; 					break; 				case 'R': 					conv = "C++"; 					break; 			}
Missing Default,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Function,The following switch statement is missing a default case: switch(r.Peek()) 					{ 						case 'a': 							r.Read(); 							nextChar = (char)r.Read(); 							attributes.Add(new Modifier(DTokens.Pure)); 							continue; 						case 'b': 							r.Read(); 							nextChar = (char)r.Read(); 							attributes.Add(new Modifier(DTokens.Nothrow)); 							continue; 						case 'c': 							r.Read(); 							nextChar = (char)r.Read(); 							attributes.Add(new Modifier(DTokens.Ref)); 							continue; 						case 'd': 							r.Read(); 							nextChar = (char)r.Read(); 							attributes.Add(new BuiltInAtAttribute(BuiltInAtAttribute.BuiltInAttributes.Property)); 							continue; 						case 'e': 							r.Read(); 							nextChar = (char)r.Read(); 							attributes.Add(new BuiltInAtAttribute(BuiltInAtAttribute.BuiltInAttributes.Trusted)); 							continue;  						case 'f':  							r.Read();  							nextChar = (char)r.Read();  							attributes.Add(new BuiltInAtAttribute(BuiltInAtAttribute.BuiltInAttributes.Safe));  							continue;  						case 'i':  							r.Read();  							nextChar = (char)r.Read();  							attributes.Add(new BuiltInAtAttribute(BuiltInAtAttribute.BuiltInAttributes.Nogc));  							continue;  						case 'j':  							r.Read();  							nextChar = (char)r.Read();  							attributes.Add(new Modifier(DTokens.Return));  							continue;  						case 'l':  							r.Read();  							nextChar = (char)r.Read();  							attributes.Add(new Modifier(DTokens.Scope));  							continue;  					}
Missing Default,D_Parser.Misc.Mangling,Demangler,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Argument,The following switch statement is missing a default case: switch (c) { 				case 'J': 					par.Attributes.Add (new Modifier (DTokens.Out)); 					break; 				case 'K': 					par.Attributes.Add (new Modifier (DTokens.Ref)); 					break; 				case 'L': 					par.Attributes.Add (new Modifier (DTokens.Lazy)); 					break; 				}
Missing Default,D_Parser.Parser.Implementations,DAttributesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DAttributesParser.cs,AtAttribute,The following switch statement is missing a default case: switch (la.Value)  				{  					case "safe":  						att = BuiltInAtAttribute.BuiltInAttributes.Safe;  						break;  					case "system":  						att = BuiltInAtAttribute.BuiltInAttributes.System;  						break;  					case "trusted":  						att = BuiltInAtAttribute.BuiltInAttributes.Trusted;  						break;  					case "property":  						att = BuiltInAtAttribute.BuiltInAttributes.Property;  						break;  					case "disable":  						att = BuiltInAtAttribute.BuiltInAttributes.Disable;  						break;  					case "nogc":  						att = BuiltInAtAttribute.BuiltInAttributes.Nogc;  						break;  				}
Missing Default,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,Declaration,The following switch statement is missing a default case: switch (laKind) 					{ 						case DTokens.Identifier: 							switch (Lexer.CurrentPeekToken.Kind) 							{ 								case DTokens.__EOF__: 								case DTokens.EOF: 								case DTokens.Semicolon: // enum E; 								case DTokens.Colon: // enum E : int {...} 								case DTokens.OpenCurlyBrace: // enum E {...} 									yield return parserParts.bodiedSymbolsParser.EnumDeclaration(Scope); 									yield break; 							} 							break;  						case DTokens.__EOF__: 						case DTokens.EOF:  						case DTokens.Semicolon: // enum; 						case DTokens.Colon: // enum : int {...} 						case DTokens.OpenCurlyBrace: // enum {...} 							yield return parserParts.bodiedSymbolsParser.EnumDeclaration(Scope); 							yield break; 					}
Missing Default,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,Declaration,The following switch statement is missing a default case: switch (Lexer.CurrentPeekToken.Kind) 							{ 								case DTokens.__EOF__: 								case DTokens.EOF: 								case DTokens.Semicolon: // enum E; 								case DTokens.Colon: // enum E : int {...} 								case DTokens.OpenCurlyBrace: // enum E {...} 									yield return parserParts.bodiedSymbolsParser.EnumDeclaration(Scope); 									yield break; 							}
Missing Default,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,IdentifierList,The following switch statement is missing a default case: switch (laKind) 			{ 				case DTokens.This: 				case DTokens.Super: 					Step(); 					td = new DTokenDeclaration(t.Kind) { Location = t.Location' EndLocation = t.EndLocation };  					if (!Expect(DTokens.Dot)) 						return td; 					break; 			}
Missing Default,D_Parser.Parser.Implementations,DDeclarationParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DDeclarationParser.cs,ApplyAttributes,The following switch statement is missing a default case: switch (mod.Value) 					{ 						case DTokens.Immutable: 						case DTokens.Const: 						case DTokens.InOut: 						case DTokens.Shared: 							attributesToAssign.Remove(attribute); 							AssignOrWrapTypeToNode(n' new MemberFunctionAttributeDecl(mod.Value)); 							break; 					}
Missing Default,D_Parser.Parser.Implementations,DModulesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DModulesParser.cs,AttributeBlock,The following switch statement is missing a default case: switch ((attr as Modifier).Token)  					{  						case DTokens.Final:  							continue;  					}
Missing Default,D_Parser.Parser.Implementations,DModulesParser,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Implementations\DModulesParser.cs,AttributeBlock,The following switch statement is missing a default case: switch ((attr as BuiltInAtAttribute).Kind)  					{  						case BuiltInAtAttribute.BuiltInAttributes.Safe:  						case BuiltInAtAttribute.BuiltInAttributes.System:  						case BuiltInAtAttribute.BuiltInAttributes.Trusted:  							continue;  					}
Missing Default,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,SkipCurrentBlock,The following switch statement is missing a default case: switch (nextChar) 				{  					// Handle line ends  					case '\r': 					case '\n': 						HandleLineEnd((char)nextChar); 						break;    					// Handle comments  					case '/': 						int peek = ReaderPeek(); 						if (peek == '/' || peek == '*' || peek == '+') 						{ 							ReadComment(); 							continue; 						} 						break;    					// handle string literals  					case 'r': 						int pk = ReaderPeek(); 						if (pk == '"') 						{ 							ReaderRead(); 							ReadVerbatimString('"'); 						} 						break; 					case '`': 						ReadVerbatimString(nextChar); 						break; 					case '"': 						ReadString(nextChar); 						break; 					case '\'': 						ReadChar(); 						break;  					case '{': 						braceCount++; 						continue; 					case '}': 						braceCount--; 						if (braceCount < 0) 						{ 							lookaheadToken = Token(laKind = DTokens.CloseCurlyBrace' Col - 1' Line); 							StartPeek(); 							Peek(); 							return; 						} 						break; 				}
Missing Default,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following switch statement is missing a default case: switch (ReaderPeek()) 							{ 								case '{': 									return ReadTokenStringLiteral_CurlyInit(); 								case '"'/* q"{{ ...}}   }}"*/: 									return ReadTokenStringLiteral_IdentInit(); 							}
Missing Default,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadTokenStringLiteral_IdentInit,The following switch statement is missing a default case: switch (ReaderPeek()) 				{  					case '\'':  					case '"':  					case '`': // TODO r" " missing  						tokenString.Append((char)ReaderRead());  						goto next; 				}
Missing Default,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadTokenStringLiteral_CurlyInit,The following switch statement is missing a default case: switch (tk.Kind) 				{ 					case DTokens.OpenCurlyBrace: 						bracketLevel++; 						break; 					case DTokens.CloseCurlyBrace: 						if (--bracketLevel < 1) 							continue; 						break; 				}
Missing Default,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,TokenStringParsing_AppendToken,The following switch statement is missing a default case: switch (tk.LiteralFormat) 					{ 						case LiteralFormat.CharLiteral: 							tokenString.Append('\'').Append(tk.LiteralValue).Append('\''); 							break; 						case LiteralFormat.None: 						case LiteralFormat.Scalar: 						case LiteralFormat.FloatingPoint: 							tokenString.Append(tk.LiteralValue); 							break; 						case LiteralFormat.StringLiteral: 							tokenString.Append('\"').Append(tk.LiteralValue).Append('\"'); 							break; 						case LiteralFormat.VerbatimStringLiteral:  							//TODO: More specific distinguishment between verbatim string types  							tokenString.Append('`').Append(tk.LiteralValue).Append('`'); 							break; 					}
Missing Default,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,TokenStringParsing_AppendLiteralSubFormat,The following switch statement is missing a default case: switch (tk.Subformat) 			{ 				case LiteralSubformat.Utf8: 					break; 				case LiteralSubformat.Utf16: 					sb.Append('w'); 					break; 				case LiteralSubformat.Utf32: 					sb.Append('d'); 					break;  					//TODO  			}
Missing Default,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,TryReadExplicitStringFormat,The following switch statement is missing a default case: switch ((char)this.ReaderPeek())  			{ 				case 'c': 					ReaderRead(); 					break; 				case 'd': 					subFmt = LiteralSubformat.Utf32; 					ReaderRead(); 					return; 				case 'w': 					subFmt = LiteralSubformat.Utf16; 					ReaderRead(); 					return; 			}
Missing Default,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek()) 					{ 						case '+': 							ReaderRead(); 							return Token(DTokens.Increment' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.PlusAssign' x' y); 					}
Missing Default,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek()) 					{ 						case '-': 							ReaderRead(); 							return Token(DTokens.Decrement' x' y); 						case '=': 							ReaderRead(); 							return Token(DTokens.MinusAssign' x' y); 						case '>': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y); 					}
Missing Default,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.DivAssign' x' y' 2); 					}
Missing Default,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.ModAssign' x' y' 2); 					}
Missing Default,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek()) 					{ 						case '&': 							ReaderRead(); 							return Token(DTokens.LogicalAnd' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseAndAssign' x' y' 2); 					}
Missing Default,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek()) 					{ 						case '|': 							ReaderRead(); 							return Token(DTokens.LogicalOr' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.BitwiseOrAssign' x' y' 2); 					}
Missing Default,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.XorAssign' x' y' 2); 						case '^': 							ReaderRead(); 							if (ReaderPeek() == '=') 							{ 								ReaderRead(); 								return Token(DTokens.PowAssign' x' y' 3); 							} 							return Token(DTokens.Pow' x' y' 2); 					}
Missing Default,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek()) 							{ 								case '=': 									ReaderRead(); 									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>': 									ReaderRead(); 									switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									} 									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}
Missing Default,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek()) 									{ 										case '=': 											ReaderRead(); 											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}
Missing Default,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.TildeAssign' x' y' 2); 					}
Missing Default,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek()) 					{ 						case '=': 							ReaderRead(); 							return Token(DTokens.Equal' x' y' 2); 						case '>': 							ReaderRead(); 							return Token(DTokens.GoesTo' x' y' 2); 					}
Missing Default,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek()) 					{ 						case '>': 							ReaderRead(); 							if (ReaderPeek() != -1) 							{ 								switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								} 							} 							return Token(DTokens.ShiftRight' x' y' 2); 						case '=': 							ReaderRead(); 							return Token(DTokens.GreaterEqual' x' y' 2); 					}
Missing Default,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch ((char)ReaderPeek()) 								{ 									case '=': 										ReaderRead(); 										return Token(DTokens.ShiftRightAssign' x' y' 3); 									case '>': 										ReaderRead(); 										if (ReaderPeek() != -1) 										{ 											switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											} 											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										} 										break; 								}
Missing Default,D_Parser.Parser,Lexer,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch ((char)ReaderPeek()) 											{ 												case '=': 													ReaderRead(); 													return Token(DTokens.TripleRightShiftAssign' x' y' 4); 											}
Missing Default,D_Parser.Refactoring,TypeReferenceFinder,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,Visit,The following switch statement is missing a default case: switch(CheckCondition(s.Condition)) 				{ 					case 1: 						if(s.ElseStatement != null) 							invalidConditionalCodeRegions.Add(s.ElseStatement); 						if (s.ScopedStatement != null) 							s.ScopedStatement.Accept(this); 						return; 					case -1: 						if(s.ScopedStatement != null) 							invalidConditionalCodeRegions.Add(s.ScopedStatement); 						if (s.ElseStatement != null) 							s.ElseStatement.Accept(this); 						return; 				}
Missing Default,D_Parser.Refactoring,TypeReferenceFinder,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,VisitAttributeMetaDeclarationBlock,The following switch statement is missing a default case: switch (CheckCondition(a.AttributeOrCondition)) 			{ 				case 1: 					if (a.OptionalElseBlock != null) 						invalidConditionalCodeRegions.Add(a.OptionalElseBlock); 					break; 				case -1: 					invalidConditionalCodeRegions.Add(a); 					break; 			}
Missing Default,D_Parser.Refactoring,TypeReferenceFinder,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,CheckNode,The following switch statement is missing a default case: switch (CheckCondition(n.Attributes)) 			{ 				case -1: 					invalidConditionalCodeRegions.Add(n); 					return false; 			}
Missing Default,D_Parser.Resolver.ASTScanner,AbstractVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.StatementHandler.cs,CanAddMemberOfType,The following switch statement is missing a default case: switch (dc.ClassType) { 				case DTokens.Class: 					return (vis & MemberFilter.Classes) != 0; 				case DTokens.Interface: 					return (vis & MemberFilter.Interfaces) != 0; 				case DTokens.Template: 					return (vis & MemberFilter.Templates) != 0; 				case DTokens.Struct: 				case DTokens.Union: 					return dc.IsAnonymous ? 							(vis & MemberFilter.Variables) != 0 :  							(vis & MemberFilter.StructsAndUnions) != 0; 				}
Missing Default,D_Parser.Resolver,DTypeToTypeDeclVisitor,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\DTypeToTypeDeclVisitor.cs,AcceptType,The following switch statement is missing a default case: switch (modifier)  					{  						case DTokens.Immutable:  						case DTokens.Const:  						case DTokens.InOut:  						case DTokens.Shared:  							td = new MemberFunctionAttributeDecl(modifier) { InnerType = td }; 							break;  					}
Missing Default,D_Parser.Resolver,StaticProperties,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,help_ReflectNonComplexType,The following switch statement is missing a default case: switch (pt.TypeToken) {  					case DTokens.Cfloat:  						return new DTokenDeclaration (DTokens.Float);  					case DTokens.Cdouble:  						return new DTokenDeclaration (DTokens.Double);  					case DTokens.Creal:  						return new DTokenDeclaration (DTokens.Real);  				}
Missing Default,D_Parser.Resolver,StaticProperties,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,help_ReflectResolvedNonComplexType,The following switch statement is missing a default case: switch (pt.TypeToken) {  					case DTokens.Cfloat:  						return new PrimitiveType (DTokens.Float);  					case DTokens.Cdouble:  						return new PrimitiveType (DTokens.Double);  					case DTokens.Creal:  						return new PrimitiveType (DTokens.Real);  				}
Missing Default,D_Parser.Resolver,StaticProperties,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,GetOwnerType,The following switch statement is missing a default case: switch (t)  			{  				case ArrayValue _:  				case ArrayType _:  					return PropOwnerType.Array;  				case AssociativeArrayValue _:  				case AssocArrayType _:  					return PropOwnerType.AssocArray;  				case DelegateValue _:  				case DelegateType _:  					return PropOwnerType.Delegate;  				case PrimitiveValue _:  				case PrimitiveType _:  				{  					var tk = t is PrimitiveType type ? type.TypeToken : (t as PrimitiveValue).BaseTypeToken;  					if (DTokensSemanticHelpers.IsBasicType_Integral(tk))  						return PropOwnerType.Integral;  					if (DTokensSemanticHelpers.IsBasicType_FloatingPoint(tk))  						return PropOwnerType.FloatingPoint;  					break;  				}  				case ClassType _:  				case InterfaceType _:  				case TemplateType _:  					return PropOwnerType.ClassLike;  				case StructType _:  					return PropOwnerType.Struct;  				case DTuple _:  				case TemplateParameterSymbol tps when (tps.Parameter is TemplateThisParameter parameter ?  					parameter.FollowParameter : tps.Parameter) is TemplateTupleParameter:  					return PropOwnerType.TypeTuple;  				case MemberSymbol symbol when symbol.Definition?.Parent is DClassLike ms && ms.ClassType == DTokens.Struct:  					return PropOwnerType.StructElement;  				case MemberSymbol symbol:  					return GetOwnerType(symbol.Base);  			}
Missing Default,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_BoolOp,The following switch statement is missing a default case: switch(x.OperatorToken)  					{  						case DTokens.GreaterThan: // greater' >  							relationIsTrue = a.Value > b.Value && (!cmpIm || a.ImaginaryPart > b.ImaginaryPart);  							break;  						case DTokens.GreaterEqual: // greater or equal' >=  							relationIsTrue = a.Value >= b.Value && a.ImaginaryPart >= b.ImaginaryPart;  							break;  						case DTokens.LessThan: // less' <  							relationIsTrue = a.Value < b.Value && (!cmpIm || a.ImaginaryPart < b.ImaginaryPart);  							break;  						case DTokens.LessEqual: // less or equal' <=  							relationIsTrue = a.Value <= b.Value && a.ImaginaryPart <= b.ImaginaryPart;  							break;  						case DTokens.Unordered: // unordered' !<>=  							relationIsTrue = unordered;  							break;  						case DTokens.LessOrGreater: // less or greater' <>  							relationIsTrue = (a.Value < b.Value || a.Value > b.Value) && (!cmpIm || (a.ImaginaryPart < b.ImaginaryPart || a.ImaginaryPart > b.ImaginaryPart));  							break;  						case DTokens.LessEqualOrGreater: // less' equal' or greater' <>=  							relationIsTrue = (a.Value < b.Value || a.Value >= b.Value) && (!cmpIm || (a.ImaginaryPart < b.ImaginaryPart || a.ImaginaryPart >= b.ImaginaryPart));  							break;  						case DTokens.UnorderedOrGreater: // unordered or greater' !<=  							relationIsTrue = unordered || (a.Value > b.Value && (!cmpIm || a.ImaginaryPart > b.ImaginaryPart));  							break;  						case DTokens.UnorderedGreaterOrEqual: // unordered' greater' or equal' !<  							relationIsTrue = unordered || (a.Value >= b.Value && a.ImaginaryPart >= b.ImaginaryPart);  							break;  						case DTokens.UnorderedOrLess: // unordered or less' !>=  							relationIsTrue = unordered || (a.Value < b.Value && (!cmpIm || a.ImaginaryPart < b.ImaginaryPart));  							break;  						case DTokens.UnorderedLessOrEqual: // unordered' less' or equal' !>  							relationIsTrue = unordered || (a.Value <= b.Value && a.ImaginaryPart <= b.ImaginaryPart);  							break;  						case DTokens.UnorderedOrEqual: // unordered or equal' !<>  							relationIsTrue = unordered || (a.Value == b.Value && a.ImaginaryPart == b.ImaginaryPart);  							break;  					}
Missing Default,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The following switch statement is missing a default case: switch(x.OperatorToken)  					{  						case DTokens.ShiftLeft:  							return (long)a.Value << (int)b.Value; // TODO: Handle the imaginary part  						case DTokens.ShiftRight:  							return (long)a.Value >> (int)b.Value;  						case DTokens.ShiftRightUnsigned: //TODO: Find out where's the difference between >> and >>>  							return (ulong)a.Value >> (int)(uint)b.Value;  					}
Missing Default,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The following switch statement is missing a default case: switch (op.OperatorToken)  					{  						case DTokens.Plus:  							return new PrimitiveValue(a.BaseTypeToken' a.Value + b.Value' a.ImaginaryPart + b.ImaginaryPart' a.Modifiers);  						case DTokens.Minus:  							return new PrimitiveValue(a.BaseTypeToken' a.Value - b.Value' a.ImaginaryPart - b.ImaginaryPart' a.Modifiers);  					}
Missing Default,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_EvalSpecToken,The following switch statement is missing a default case: switch (isExpression.TypeSpecializationToken) 			{ 				/* 				 * To handle semantic tokens like "return" or "super" it's just needed to  				 * look into the current resolver context - 				 * then' we'll be able to gather either the parent method or the currently scoped class definition. 				 */ 				case DTokens.Struct: 				case DTokens.Union: 				case DTokens.Class: 				case DTokens.Interface:                      if (r = typeToCheck is TemplateIntermediateType && 						((TemplateIntermediateType)typeToCheck).Definition.ClassType == isExpression.TypeSpecializationToken) 						res = typeToCheck; 					break;  				case DTokens.Enum: 					if (!(typeToCheck is EnumType)) 						break; 					{ 						var tr = (UserDefinedType)typeToCheck; 						r = true; 						res = tr.Base; 					} 					break;  				case DTokens.Function: 				case DTokens.Delegate: 					if (typeToCheck is DelegateType) 					{ 						var isFun = false; 						var dgr = (DelegateType)typeToCheck; 						if (!dgr.IsFunctionLiteral) 							r = isExpression.TypeSpecializationToken == ((isFun = dgr.IsFunction) ? DTokens.Function : DTokens.Delegate); 						// Must be a delegate otherwise 						else 							isFun = !(r = isExpression.TypeSpecializationToken == DTokens.Delegate);  						if (r) 						{ 							//TODO 							if (isFun) 							{ 								// TypeTuple of the function parameter types. For C- and D-style variadic functions' only the non-variadic parameters are included.  								// For typesafe variadic functions' the ... is ignored. 							} 							else 							{ 								// the function type of the delegate 							} 						} 					} 					else // Normal functions are also accepted as delegates 					{ 						r = isExpression.TypeSpecializationToken == DTokens.Delegate && 							typeToCheck is MemberSymbol && 							((DSymbol)typeToCheck).Definition is DMethod;  						//TODO: Alias handling' same as couple of lines above 					} 					break;  				case DTokens.Super: //TODO: Test this 					var dc = ASTSearchHelper.SearchClassLikeAt(ctxt.ScopedBlock' isExpression.Location) as DClassLike;  					if (dc != null) 					{ 						var udt = ClassInterfaceResolver.ResolveClassOrInterface(dc' ctxt' null' true) as ClassType;  						if (r = udt?.Base != null && ResultComparer.IsEqual(typeToCheck' udt.Base)) 						{ 							var l = new List<AbstractType>(); 							if (udt.Base != null) 								l.Add(udt.Base); 							if (udt.BaseInterfaces != null && udt.BaseInterfaces.Length != 0) 								l.AddRange(udt.BaseInterfaces);  							res = new DTuple(l); 						} 					} 					break;  				case DTokens.Const: 				case DTokens.Immutable: 				case DTokens.InOut: // TODO? 				case DTokens.Shared: 					if (r = typeToCheck.HasModifier(isExpression.TypeSpecializationToken)) 						res = typeToCheck; 					break;  				case DTokens.Return: // TODO: Test 					var dm = ASTSearchHelper.SearchBlockAt(ctxt.ScopedBlock' isExpression.Location) as DMethod;  					if (dm != null) 					{ 						var retType_ = DSymbolBaseTypeResolver.GetMethodReturnType(dm' ctxt);  						if (r = retType_ != null && ResultComparer.IsEqual(typeToCheck' retType_)) 							res = retType_; 					} 					break;  				case DTokens.__vector: 					if (typeToCheck is DSymbol)  					{  						var vd = (typeToCheck as DSymbol).Definition.Type as VectorDeclaration; 						if (vd != null)  						{  							r = true; 							if (vd.IdDeclaration != null) 								res = TypeDeclarationResolver.ResolveSingle(vd.IdDeclaration' ctxt); 						}  					} 					break;  				case DTokens.__parameters: // TODO  					break;  			}
Missing Default,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The following switch statement is missing a default case: switch(te.Keyword)  			{  				case "":  				case null:  					return null;  					  				case "hasMember":  					bool ret = false;  					var optionsBackup = ctxt.ContextIndependentOptions;  					ctxt.ContextIndependentOptions = ResolutionOptions.IgnoreAllProtectionAttributes;  					  					AbstractType t;  					var pfa = ExpressionTypeEvaluation.prepareMemberTraitExpression(ctxt' te' out t' evaluationState);  					  					if(pfa != null && t != null)  					{  						t.NonStaticAccess = true;  						ignoreErrors = true;  						var res = ExpressionTypeEvaluation.EvaluateType(pfa' ctxt' false);  						ret = res != null;  						ignoreErrors = false;  					}  					ctxt.ContextIndependentOptions = optionsBackup;  					return new PrimitiveValue(ret);  					  					  				case "identifier":  					if(te.Arguments!=null && te.Arguments.Length == 1)  						return new ArrayValue(GetStringLiteralType()' te.Arguments[0].ToString());  					break;  					  					  				case "getMember":  					pfa = ExpressionTypeEvaluation.prepareMemberTraitExpression(ctxt' te' out t' evaluationState);  					  					if(pfa == null ||t == null)  						break;  					  					var vs = EvalPostfixAccessExpression(this' ctxt' pfa't' ValueProvider:evaluationState);  					if(vs == null || vs.Count == 0)  						return null;  					return vs[0];  					  					  				case "getOverloads":  					optionsBackup = ctxt.ContextIndependentOptions;  					ctxt.ContextIndependentOptions = ResolutionOptions.IgnoreAllProtectionAttributes;    					pfa = ExpressionTypeEvaluation.prepareMemberTraitExpression(ctxt' te' out t' evaluationState);    					if (pfa != null && t != null)  						vs = EvalPostfixAccessExpression(this' ctxt' pfa' t);  					else  						vs = null;  					  					ctxt.ContextIndependentOptions = optionsBackup;  					  					return new TypeValue(new DTuple(vs));  					  					  				case "getProtection":  					optionsBackup = ctxt.ContextIndependentOptions;  					ctxt.ContextIndependentOptions = ResolutionOptions.IgnoreAllProtectionAttributes;  					  					var prot = "public";  					  					if(te.Arguments == null || te.Arguments.Length != 1 || te.Arguments[0] == null)  						EvalError(te' "First trait argument must be a symbol identifier");  					else  					{  						t = ExpressionTypeEvaluation.ResolveTraitArgument(ctxt'te.Arguments[0]);  						  						if(t is DSymbol)  						{  							var dn = (t as DSymbol).Definition;  							  							if(dn.ContainsAnyAttribute(DTokens.Private))  								prot = "private";  							else if(dn.ContainsAnyAttribute(DTokens.Protected))  								prot = "protected";  							else if(dn.ContainsAnyAttribute(DTokens.Package))  								prot = "package";  							else if(dn.ContainsAnyAttribute(DTokens.Export))  								prot = "export";  						}  						else  							EvalError(te' "First argument must evaluate to an existing code symbol");  					}  					  					ctxt.ContextIndependentOptions = optionsBackup;  					return new ArrayValue(GetStringLiteralType()' prot);  					  				case "getVirtualFunctions":  					break;  				case "getVirtualMethods":  					break;  				case "parent":  					break;  				case "classInstanceSize":  					break;  				case "allMembers":  					break;  				case "derivedMembers":  					break;  					  				case "isSame":  					ret = false;  					  					if(te.Arguments == null || te.Arguments.Length < 2)  					{  						EvalError(te' "isSame requires two arguments to compare");  					}  					else  					{  						t = ExpressionTypeEvaluation.ResolveTraitArgument(ctxt' te.Arguments[0]);  						  						if(t != null)  						{  							var t2 = ExpressionTypeEvaluation.ResolveTraitArgument(ctxt' te.Arguments[1]);  							  							if(t2 != null)  								ret = Resolver.ResultComparer.IsEqual(t't2);  						}  					}  					  					return new PrimitiveValue(ret);  					  				case "compiles":  					ret = false;  					  					if(te.Arguments != null){  						foreach(var arg in te.Arguments)  						{  							ret = arg == null || ExpressionTypeEvaluation.ResolveTraitArgument(ctxt' arg) != null;  							  							if(!ret)  								break;  						}  					}  						  					return new PrimitiveValue(ret);  			}
Missing Default,D_Parser.Resolver.ExpressionSemantics,Evaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The following switch statement is missing a default case: switch(te.Keyword)  						{  							case "isArithmetic":  								var pt = t as PrimitiveType;  								ret = pt != null && (  									DTokensSemanticHelpers.IsBasicType_Integral(pt.TypeToken) ||  									DTokensSemanticHelpers.IsBasicType_FloatingPoint(pt.TypeToken));  								break;  							case "isFloating":  								pt = t as PrimitiveType;  								ret = pt != null && DTokensSemanticHelpers.IsBasicType_FloatingPoint(pt.TypeToken);  								break;  							case "isIntegral":  								pt = t as PrimitiveType;  								ret = pt != null && DTokensSemanticHelpers.IsBasicType_Integral(pt.TypeToken);  								break;  							case "isScalar":  								pt = t as PrimitiveType;  								ret = pt != null && DTokensSemanticHelpers.IsBasicType(pt.TypeToken);  								break;  							case "isUnsigned":  								pt = t as PrimitiveType;  								ret = pt != null && DTokensSemanticHelpers.IsBasicType_Unsigned(pt.TypeToken);  								break;  									  							case "isAbstractClass":  								ret = t is ClassType && (t as ClassType).Definition.ContainsAnyAttribute(DTokens.Abstract);  								break;  							case "isFinalClass":  								ret = t is ClassType && (t as ClassType).Definition.ContainsAnyAttribute(DTokens.Final);  								break;  								  							case "isAssociativeArray":  								ret = t is AssocArrayType && !(t is ArrayType);  								break;  							case "isStaticArray":  								ret = t is ArrayType && (t as ArrayType).IsStaticArray;  								break;  						}
Missing Default,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,The following switch statement is missing a default case: switch (mod.Token)  									{  										case DTokens.Const:  										case DTokens.Immutable:  										case DTokens.Shared:  										case DTokens.Nothrow: // ?  										// not DTokens.Pure due to some mystical reasons  											skip = true;  											break;  									}
Missing Default,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,The following switch statement is missing a default case: switch (te.Keyword)  			{  				case "":  				case null:  					return null;    				case "identifier":  					return GetStringLiteralType();    				case "getMember":  					pfa = prepareMemberTraitExpression(te' out t);    					if (pfa == null || t == null)  						break;    					var vs = Evaluation.EvalPostfixAccessExpression(this' ctxt' pfa' t);  					if (vs == null || vs.Count == 0)  						return null;  					return vs[0];      				case "getOverloads":  					var optionsBackup = ctxt.ContextIndependentOptions;  					ctxt.ContextIndependentOptions = ResolutionOptions.IgnoreAllProtectionAttributes;    					pfa = prepareMemberTraitExpression(te' out t);    					if (pfa != null && t != null)  						vs = Evaluation.EvalPostfixAccessExpression(this' ctxt' pfa' t);  					else  						vs = null;    					ctxt.ContextIndependentOptions = optionsBackup;    					return new DTuple(vs);      				case "getProtection":  					return GetStringLiteralType();    				case "getVirtualFunctions":  					break;  				case "getVirtualMethods":  					break;  				case "parent":  					break;  				case "classInstanceSize":  					break;  				case "allMembers":  					break;  				case "derivedMembers":  					break;    				case "compiles":  						return new PrimitiveType(DTokens.Bool);  			}
Missing Default,D_Parser.Resolver.ExpressionSemantics,MathOperationEvaluation,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MathOperationEvaluation.cs,TryCalc,The following switch statement is missing a default case: switch (op)  					{  						case MathOp.Add:  							x = i1 + i2;  							break;  						case MathOp.Sub:  							x = i1 - i2;  							break;  						case MathOp.Mul:  							x = i1 * i2;  							break;  						case MathOp.Div:  							x = i1 / i2;  							break;    						case MathOp.Xor:  							x = i1 ^ i2;  							break;  						case MathOp.Or:  							x = i1 | i2;  							break;  						case MathOp.And:  							x = i1 & i2;  							break;    						case MathOp.AndAnd:  							break;  						case MathOp.OrOr:  							break;  					}
Missing Default,D_Parser.Resolver.ExpressionSemantics,PrimitiveValue,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,The following switch statement is missing a default case: switch (BaseTypeToken)  			{  				case DTokens.Void:  					return "void";  				case DTokens.Bool:  					return Value == 1M ? "true" : "false";  				case DTokens.Char:  				case DTokens.Wchar:  				case DTokens.Dchar:  					return Char.ConvertFromUtf32((int)Value);  			}
Missing Default,D_Parser.Completion,EditorData,D:\research\architectureSmells\repos\aBothe_D_Parser\DParser2\Completion\IEditorData.cs,GetLooseResolutionContext,The following switch statement is missing a default case: switch (att)  			{  				case LooseResolution.NodeResolutionAttempt.Normal:  					returnedCtxt = NormalContext;  					break;  				case LooseResolution.NodeResolutionAttempt.NoParameterOrTemplateDeduction:  					returnedCtxt = NoDeductionContext;  					break;  				case LooseResolution.NodeResolutionAttempt.RawSymbolLookup:  					returnedCtxt = RawContext;  					break;  			}
