Implementation smell,Namespace,Class,File,Method,Description
Long Method,D_Parser.Formatting,DFormattingVisitor,C:\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,VisitChildren,The method has 111 lines of code.
Long Method,D_Parser.Formatting.Indent,IndentEngine,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushNewLine,The method has 137 lines of code.
Long Method,D_Parser.Formatting.Indent,IndentEngine,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,Push,The method has 193 lines of code.
Long Method,D_Parser.Formatting.Indent,IndentStack,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,The method has 132 lines of code.
Long Method,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Type,The method has 115 lines of code.
Long Method,D_Parser.Resolver,StaticProperties,C:\repos\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,StaticProperties,The method has 170 lines of code.
Long Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The method has 120 lines of code.
Long Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalConcatenation,The method has 118 lines of code.
Long Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalMethodCall,The method has 204 lines of code.
Long Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The method has 264 lines of code.
Long Method,D_Parser.Resolver.TypeResolution,NodeMatchHandleVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,GetForeachIteratorType,The method has 109 lines of code.
Long Method,D_Parser.Resolver.TypeResolution,DResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,ResolveClassOrInterface,The method has 158 lines of code.
Long Method,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The method has 167 lines of code.
Long Method,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The method has 220 lines of code.
Long Method,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The method has 177 lines of code.
Long Method,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The method has 255 lines of code.
Long Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,DeclDef,The method has 183 lines of code.
Long Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Condition,The method has 114 lines of code.
Long Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Decl,The method has 117 lines of code.
Long Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,IsAssignExpression,The method has 134 lines of code.
Long Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,NewExpression,The method has 109 lines of code.
Long Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,PostfixExpression,The method has 138 lines of code.
Long Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,PrimaryExpression,The method has 337 lines of code.
Long Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Statement,The method has 391 lines of code.
Long Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmStatement,The method has 141 lines of code.
Long Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,TemplateParameter,The method has 109 lines of code.
Long Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,TemplateInstance,The method has 118 lines of code.
Complex Method,D_Parser.Completion.Providers,MethodOverrideCompletionProvider,C:\repos\aBothe_D_Parser\DParser2\Completion\MethodOverrideCompletionProvider.cs,GenerateOverridingMethodStub,Cyclomatic complexity of the method is 26
Complex Method,D_Parser.Completion.Providers,CtrlSpaceCompletionProvider,C:\repos\aBothe_D_Parser\DParser2\Completion\Providers\CtrlSpaceCompletionProvider.cs,BuildCompletionDataInternal,Cyclomatic complexity of the method is 21
Complex Method,D_Parser.Completion.Providers,ImportStatementCompletionProvider,C:\repos\aBothe_D_Parser\DParser2\Completion\Providers\ImportStatementCompletionProvider.cs,BuildCompletionDataInternal,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,C:\repos\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,AppendParameters,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Dom,DClassLike,C:\repos\aBothe_D_Parser\DParser2\Dom\Nodes\OtherNodeDefinitions.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Dom,DNode,C:\repos\aBothe_D_Parser\DParser2\Dom\Nodes\DNode.cs,ContainsPropertyAttribute,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Dom,DelegateDeclaration,C:\repos\aBothe_D_Parser\DParser2\Dom\DDeclarations.cs,ToString,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Dom,DefaultDepthFirstVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\DefaultDepthFirstVisitor.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Formatting,DFormattingVisitor,C:\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,GetCommentsBefore,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Formatting,DFormattingVisitor,C:\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,SearchLastNonWsChar,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Formatting,DFormattingVisitor,C:\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,VisitChildren,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Formatting,DFormattingVisitor,C:\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,Visit,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Formatting.Indent,IndentEngineWrapper,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CorrectIndent,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Formatting.Indent,IndentEngine,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushColon,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Formatting.Indent,IndentEngine,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushOpenSq,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Formatting.Indent,IndentEngine,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushOpenBrace,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Formatting.Indent,IndentEngine,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushCloseBrace,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Formatting.Indent,IndentEngine,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,Push,Cyclomatic complexity of the method is 18
Complex Method,D_Parser.Misc,VersionIdEvaluation,C:\repos\aBothe_D_Parser\DParser2\Misc\VersionIdEvaluation.cs,GetVersionIds,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Misc,GlobalParseCache,C:\repos\aBothe_D_Parser\DParser2\Misc\GlobalParseCache.cs,preparationTh,Cyclomatic complexity of the method is 16
Complex Method,D_Parser.Misc,GlobalParseCache,C:\repos\aBothe_D_Parser\DParser2\Misc\GlobalParseCache.cs,parseTh,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,QualifiedName,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,HexFloat,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Refactoring,SortImportsRefactoring,C:\repos\aBothe_D_Parser\DParser2\Refactoring\SortImportsRefactoring.cs,ResortImports,Cyclomatic complexity of the method is 15
Complex Method,D_Parser.Refactoring,SortImportsRefactoring,C:\repos\aBothe_D_Parser\DParser2\Refactoring\SortImportsRefactoring.cs,CalculateImportsToSort,Cyclomatic complexity of the method is 14
Complex Method,D_Parser.Refactoring,ImportDictComparer,C:\repos\aBothe_D_Parser\DParser2\Refactoring\SortImportsRefactoring.cs,Compare,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver,MixinAnalysis,C:\repos\aBothe_D_Parser\DParser2\Resolver\MixinAnalysis.cs,CheckAndPushAnalysisStack,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver,ResultComparer,C:\repos\aBothe_D_Parser\DParser2\Resolver\ResultComparer.cs,IsImplicitlyConvertible,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver,LooseResolution,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,SearchNodesByName,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Resolver,LooseResolution,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,LookupIdRawly,Cyclomatic complexity of the method is 13
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalConcatenation,Cyclomatic complexity of the method is 15
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_WithAliases,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalMethodCall,Cyclomatic complexity of the method is 13
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,TryHandleMethodArgumentTuple,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,SliceArray,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetConstructors,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,AccessArrayAtIndex,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,ResolveIdentifier,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.ASTScanner,AbstractVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,IterateThroughScopeLayers,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver.ASTScanner,AbstractVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,DeepScanClass,Cyclomatic complexity of the method is 13
Complex Method,D_Parser.Resolver.ASTScanner,AbstractVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,scanChildren,Cyclomatic complexity of the method is 14
Complex Method,D_Parser.Resolver.ASTScanner,AbstractVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,HandleAliasThisDeclarations,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Resolver.ASTScanner,AbstractVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,MatchesCompilationConditions,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.ASTScanner,AbstractVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,SearchAttributesForIsExprDecls,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Resolver.ASTScanner,AbstractVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,CanHandleNode,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.ResolutionHooks,bitfields,C:\repos\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\bitfields.cs,TryDeduce,Cyclomatic complexity of the method is 11
Complex Method,D_Parser.Resolver.ResolutionHooks,TupleHook,C:\repos\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\Tuple.cs,TryDeduce,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,Handle,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,Handle,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,Set,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,Handle,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,PreResolveTemplateArgs,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParamsAndFilterOverloads,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceOverloads,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParam,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Resolver.TypeResolution,SingleResolverVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,Visit,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Resolver.TypeResolution,NodeMatchHandleVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,GetForeachIteratorType,Cyclomatic complexity of the method is 13
Complex Method,D_Parser.Resolver.TypeResolution,DResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,ResolveClassOrInterface,Cyclomatic complexity of the method is 14
Complex Method,D_Parser.Resolver.TypeResolution,DResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,FilterOutByResultPriority,Cyclomatic complexity of the method is 12
Complex Method,D_Parser.Completion,ParameterInsightResolution,C:\repos\aBothe_D_Parser\DParser2\Completion\ParameterInsightResolution.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,D_Parser,DocumentHelper,C:\repos\aBothe_D_Parser\DParser2\Misc\DocumentHelper.cs,GetOffsetByRelativeLocation,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadIdent,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,GetCurrentAttributeSet,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,CheckForPostSemicolonComment,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Decl,Cyclomatic complexity of the method is 19
Complex Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,BasicType,Cyclomatic complexity of the method is 15
Complex Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Declarator,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,DeclaratorSuffixes,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Parameters,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Parameter,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,IsAssignExpression,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,NewExpression,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,PostfixExpression,Cyclomatic complexity of the method is 9
Complex Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,ForeachStatement,Cyclomatic complexity of the method is 8
Complex Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,FunctionBody,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,TemplateInstance,Cyclomatic complexity of the method is 10
Complex Method,D_Parser.Dom.Expressions,TemplateInstanceExpression,C:\repos\aBothe_D_Parser\DParser2\Dom\Expressions\TemplateInstanceExpression.cs,ToString,Cyclomatic complexity of the method is 9
Long Parameter List,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,C:\repos\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,AppendFormat,The method has 6 parameters. Parameters: content' sb' flags' r' g' b
Long Parameter List,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,C:\repos\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,GenTooltipSignature,The method has 5 parameters. Parameters: dn' templateParamCompletion' currentMethodParam' baseType' deducedType
Long Parameter List,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,C:\repos\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,S,The method has 6 parameters. Parameters: dm' sb' templArgs' curArg' baseType' deducedTypes
Long Parameter List,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,C:\repos\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,AttributesTypeAndName,The method has 5 parameters. Parameters: dn' sb' baseType' highlightTemplateParam' deducedTypes
Long Parameter List,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,HashEnum,The method has 5 parameters. Parameters: h' prime' l' visPred' mindOrder
Long Parameter List,D_Parser.Formatting,Formatter,C:\repos\aBothe_D_Parser\DParser2\Formatting\Formatter.cs,FormatCode,The method has 5 parameters. Parameters: code' ast' document' options' textStyle
Long Parameter List,D_Parser.Formatting.Indent,IndentEngineWrapper,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CorrectIndent,The method has 7 parameters. Parameters: code' startOffset' endOffset' documentReplace' options' textStyle' formatLastLine
Long Parameter List,D_Parser.Formatting.Indent,IndentStack,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,The method has 5 parameters. Parameters: inside' keyword' lineNr' nSpaces' indent
Long Parameter List,D_Parser.Misc,ParsingFinishedEventArgs,C:\repos\aBothe_D_Parser\DParser2\Misc\GlobalParseCache.cs,ParsingFinishedEventArgs,The method has 5 parameters. Parameters: dir' pack' duration' parseDuration' fileCount
Long Parameter List,D_Parser.Resolver,StaticProperties,C:\repos\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,ListProperties,The method has 5 parameters. Parameters: gen' ctxt' vis' t' isVariableInstance
Long Parameter List,D_Parser.Resolver,ConditionalCompilationFlags,C:\repos\aBothe_D_Parser\DParser2\Resolver\ConditionalCompilationFlags.cs,ConditionalCompilationFlags,The method has 5 parameters. Parameters: definedVersionIdentifiers' versionNumber' debug' definedDebugIdentifiers' debugLevel
Long Parameter List,D_Parser.Resolver,LooseResolution,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,SearchNodesByName,The method has 5 parameters. Parameters: idToFind' parseCacheContext' pcw' foundPackages' foundItems
Long Parameter List,D_Parser.Resolver.ExpressionSemantics.CTFE,FunctionEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\CTFE\FunctionEvaluation.cs,AssignCallArgumentsToIC,The method has 5 parameters. Parameters: mr' args' baseValueProvider' targetArgs' ctxt
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,HandleSingleMathOp,The method has 5 parameters. Parameters: x' l' r' m' UnorderedCheck
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalMethodCall,The method has 9 parameters. Parameters: baseExpression' baseValue' tix' ctxt' call' callArguments' delegateValue' returnBaseTypeOnly' ValueProvider
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,HandleDMethodOverload,The method has 9 parameters. Parameters: ctxt' eval' baseValue' callArguments' returnBaseTypeOnly' argTypeFilteredOverloads' hasHandledUfcsResultBefore' ms' untemplatedMethod
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,TryHandleMethodArgumentTuple,The method has 7 parameters. Parameters: ctxt' add' callArguments' dm' deducedTypeDict' currentParameter' currentArg
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,GetRawCallOverloads,The method has 5 parameters. Parameters: ctxt' call' baseExpression' baseValue' tix
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalPostfixAccessExpression,The method has 7 parameters. Parameters: vis' ctxt' acc' resultBase' EvalAndFilterOverloads' ResolveImmediateBaseType' ValueProvider
Long Parameter List,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetUnfilteredMethodOverloads_Helper,The method has 6 parameters. Parameters: foreExpression' ctxt' supExpression' l' staticOnly' ov
Long Parameter List,D_Parser.Resolver.ASTScanner,StatementHandler,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,StatementHandler,The method has 5 parameters. Parameters: parentNodeOfVisitedStmt' v' parms' caret' pushResolvedCurScope
Long Parameter List,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParams,The method has 6 parameters. Parameters: givenTemplateArguments' isMethodCall' ctxt' overload' tplNode' deducedTypes
Long Parameter List,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParam,The method has 5 parameters. Parameters: ctxt' overload' deducedTypes' argEnum' expectedParam
Long Parameter List,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,ResolveFurtherTypeIdentifier,The method has 5 parameters. Parameters: nextIdentifierHash' resultBases' ctxt' typeIdObject' ufcsItem
Long Parameter List,D_Parser.Resolver.TypeResolution,DResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,ResolveClassOrInterface,The method has 5 parameters. Parameters: dc' ctxt' instanceDeclaration' ResolveFirstBaseIdOnly' extraDeducedTemplateParams
Long Parameter List,D_Parser.Resolver.TypeResolution,UFCSResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\UFCSResolver.cs,TryResolveUFCS,The method has 5 parameters. Parameters: firstArgument' nameHash' nameLoc' ctxt' nameSr
Long Parameter List,D_Parser.Completion,ParameterInsightResolution,C:\repos\aBothe_D_Parser\DParser2\Completion\ParameterInsightResolution.cs,CalculateCurrentArgument,The method has 5 parameters. Parameters: nex' res' caretLocation' ctxt' resultBases
Long Parameter List,D_Parser.Completion,CtorScan,C:\repos\aBothe_D_Parser\DParser2\Completion\ParameterInsightResolution.cs,ScanForConstructors,The method has 5 parameters. Parameters: sr' scope' udt' _ctors' explicitCtorFound
Long Parameter List,D_Parser.Completion,MemberCompletionEnumeration,C:\repos\aBothe_D_Parser\DParser2\Completion\MemberCompletionEnumeration.cs,EnumAllAvailableMembers,The method has 6 parameters. Parameters: cdgen' ScopedBlock' Caret' CodeCache' VisibleMembers' compilationEnvironment
Long Parameter List,D_Parser.Completion,MemberCompletionEnumeration,C:\repos\aBothe_D_Parser\DParser2\Completion\MemberCompletionEnumeration.cs,EnumChildren,The method has 6 parameters. Parameters: cdgen' ctxt' block' isVarInstance' vis' publicImports
Long Parameter List,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Token,The method has 7 parameters. Parameters: kind' startLocation_Col' startLocation_Line' tokenLength' literalValue' literalFormat' literalSubFormat
Long Parameter List,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Token,The method has 9 parameters. Parameters: kind' startLocation_Col' startLocation_Line' endLocation_Col' endLocation_Line' literalValue' literalFormat' literalSubFormat' rawCode
Long Parameter List,D_Parser.Parser,Comment,C:\repos\aBothe_D_Parser\DParser2\Parser\DToken.cs,Comment,The method has 5 parameters. Parameters: commentType' comment' commentStartsLine' startPosition' endPosition
Long Parameter List,D_Parser.Parser,IncrementalParsing,C:\repos\aBothe_D_Parser\DParser2\Parser\IncrementalParsing.cs,UpdateBlockPartly,The method has 5 parameters. Parameters: bs' code' caretOffset' caretLocation' isInsideNonCodeSegment
Long Parameter List,D_Parser.Parser,IncrementalParsing,C:\repos\aBothe_D_Parser\DParser2\Parser\IncrementalParsing.cs,UpdateBlockPartly,The method has 5 parameters. Parameters: bn' code' caretOffset' caretLocation' isInsideNonCodeSegment
Long Parameter List,D_Parser.Parser,IncrementalParsingBase<T>,C:\repos\aBothe_D_Parser\DParser2\Parser\IncrementalParsing.cs,ParseIncrementally,The method has 5 parameters. Parameters: sr' code' caretOffset' caretLocation' isInsideNonCodeSegment
Long Parameter List,D_Parser.Parser,DDocParser,C:\repos\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,FindNextMacro,The method has 6 parameters. Parameters: text' startOffset' macroStart' length' macroName' macroParameters
Long Parameter List,D_Parser.Dom.Statements,OpCodeDescriptor,C:\repos\aBothe_D_Parser\DParser2\Dom\Statements\InstructionStatement.cs,OpCodeDescriptor,The method has 8 parameters. Parameters: opcode' name' description' validForms' incomplete' insSet' is32BitOnly' is64BitOnly
Long Identifier,D_Parser.Completion.Providers,MethodOverrideCompletionProvider,C:\repos\aBothe_D_Parser\DParser2\Completion\MethodOverrideCompletionProvider.cs,GenerateOverridingMethodStub,The length of the parameter generateExecuteSuperFunctionStmt is 32.
Long Identifier,D_Parser.Completion.Providers,PragmaCompletionProvider,C:\repos\aBothe_D_Parser\DParser2\Completion\Providers\AttributeCompletionProvider.cs,,The length of the parameter PragmaAttributeCompletionItems is 30.
Long Identifier,D_Parser.Completion.Providers,AttributeCompletionProvider,C:\repos\aBothe_D_Parser\DParser2\Completion\Providers\AttributeCompletionProvider.cs,,The length of the parameter ExternAttributeCompletionItems is 30.
Long Identifier,D_Parser.Completion.Providers,TraitsExpressionCompletionProvider,C:\repos\aBothe_D_Parser\DParser2\Completion\Providers\AttributeCompletionProvider.cs,,The length of the parameter TraitsExpressionCompletionItems is 31.
Long Identifier,D_Parser.Completion.Providers,CtrlSpaceCompletionProvider,C:\repos\aBothe_D_Parser\DParser2\Completion\Providers\CtrlSpaceCompletionProvider.cs,,The length of the parameter PropertyAttributeCompletionItems is 32.
Long Identifier,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,C:\repos\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,,The length of the parameter MaxTemplateConstraintExprLength is 31.
Long Identifier,D_Parser.Dom,DNode,C:\repos\aBothe_D_Parser\DParser2\Dom\Nodes\DNode.cs,ContainsPropertyAttribute,The length of the parameter userDefinedAttributeExpression is 30.
Long Identifier,D_Parser.Formatting,DFormattingOptions,C:\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingOptions.cs,,The length of the parameter KeepArgumentIndentOnSquareBracketOpen is 37.
Long Identifier,D_Parser.Misc,CompletionOptions,C:\repos\aBothe_D_Parser\DParser2\Misc\CompletionOptions.cs,,The length of the parameter ShowStructMembersInStructInitOnly is 33.
Long Identifier,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The length of the parameter includeFinalNonOverridingMethods is 32.
Long Identifier,D_Parser.Resolver.ASTScanner,ItemCheckParameters,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,,The length of the parameter dontHandleTemplateParamsInNodeScan is 34.
Long Identifier,D_Parser.Resolver.Templates,SpecializationOrdering,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\SpecializationOrdering.cs,FilterFromMostToLeastSpecialized,The length of the parameter lastEquallySpecializedOverloads is 31.
Long Identifier,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The length of the parameter paramTix_TemplateMatchPossibilities is 35.
Long Identifier,D_Parser.Completion,CodeCompletion,C:\repos\aBothe_D_Parser\DParser2\Completion\CodeCompletion.cs,GenerateCompletionData,The length of the parameter alreadyCheckedCompletionContext is 31.
Long Identifier,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,,The length of the parameter endedWhileBeingInNonCodeSequence is 32.
Long Statement,D_Parser.Completion.Providers,MethodOverrideCompletionProvider,C:\repos\aBothe_D_Parser\DParser2\Completion\MethodOverrideCompletionProvider.cs,BuildCompletionDataInternal,The length of the statement  "					CompletionDataGenerator.AddCodeGeneratingNodeItem(dm' GenerateOverridingMethodStub(dm' begunNode' !(t is InterfaceType))); " is 122.
Long Statement,D_Parser.Completion.Providers,CtrlSpaceCompletionProvider,C:\repos\aBothe_D_Parser\DParser2\Completion\Providers\CtrlSpaceCompletionProvider.cs,BuildCompletionDataInternal,The length of the statement  "				CompletionDataGenerator.AddTextItem("seg"'"The seg means load the segment number that the symbol is in. This is not relevant for flat model code. Instead' do a move from the relevant segment register."); " is 203.
Long Statement,D_Parser.Completion.Providers,MemberCompletionProvider,C:\repos\aBothe_D_Parser\DParser2\Completion\Providers\MemberCompletionProvider.cs,BuildCompletionDataInternal,The length of the statement  "			if (t == null) //TODO: Add after-space list creation when an unbound . (Dot) was entered which means to access the global scope " is 127.
Long Statement,D_Parser.Completion.Providers,MemberCompletionProvider,C:\repos\aBothe_D_Parser\DParser2\Completion\Providers\MemberCompletionProvider.cs,VisitTemplateParameterSymbol,The length of the statement  "				var tpp = tps.Parameter is TemplateThisParameter ? (tps.Parameter as TemplateThisParameter).FollowParameter : tps.Parameter; " is 124.
Long Statement,D_Parser.Completion.Providers,SelectiveImportCompletionProvider,C:\repos\aBothe_D_Parser\DParser2\Completion\Providers\SelectiveImportCompletionProvider.cs,BuildCompletionDataInternal,The length of the statement  "			var module = Editor.ParseCache.LookupModuleName(Editor.SyntaxTree' import.ModuleIdentifier.ToString(true)).FirstOrDefault(); " is 124.
Long Statement,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,C:\repos\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,GenTooltipSignature,The length of the statement  "				return GenTooltipSignature(aliasedSymbol == null || currentMethodParam >= 0 ? ds.Definition : aliasedSymbol.aliasDefinition' templateParamCompletion' currentMethodParam' DTypeToTypeDeclVisitor.GenerateTypeDecl(ds.Base)' new DeducedTypeDictionary(ds)); " is 251.
Long Statement,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,C:\repos\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,GenDelegateSignature,The length of the statement  "				S((dt.delegateTypeBase as FunctionLiteral).AnonymousMethod' sb' templArgs' curArg' DTypeToTypeDeclVisitor.GenerateTypeDecl(dt.ReturnType)); " is 139.
Long Statement,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,C:\repos\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,AppendParameters,The length of the statement  "				var isOpt = (this.SignatureFlags & TooltipSignatureFlags.NoDefaultParams) == 0 && parm is DVariable && (parm as DVariable).Initializer != null; " is 143.
Long Statement,D_Parser.Dom,DBlockNode,C:\repos\aBothe_D_Parser\DParser2\Dom\Nodes\DBlockNode.cs,GetMetaBlockStack,The length of the statement  "				if (lastSr != null && !(mindAttributeSections && lastSr is AttributeMetaDeclarationSection) && mb.Location < lastSr.Location && mb.EndLocation > lastSr.EndLocation) " is 164.
Long Statement,D_Parser.Dom,DBlockNode,C:\repos\aBothe_D_Parser\DParser2\Dom\Nodes\DBlockNode.cs,GetMetaBlockStack,The length of the statement  "				if (((takeBlockStartLocations && mb is IMetaDeclarationBlock) ? ((IMetaDeclarationBlock)mb).BlockStartLocation : mb.Location) <= Where && mb.EndLocation >= Where) { " is 164.
Long Statement,D_Parser.Dom,DVariable,C:\repos\aBothe_D_Parser\DParser2\Dom\Nodes\OtherNodeDefinitions.cs,ToString,The length of the statement  "			return (IsAlias ? "alias " : "") + base.ToString(Attributes' IncludePath) + (initializer && Initializer != null ? (" = " + Initializer.ToString()) : ""); " is 153.
Long Statement,D_Parser.Dom,TemplateValueParameter,C:\repos\aBothe_D_Parser\DParser2\Dom\TemplateParameters.cs,ToString,The length of the statement  "			return (Type != null ? (Type.ToString() + " ") : "") + Name/*+ (SpecializationExpression!=null?(":"+SpecializationExpression.ToString()):"")+ " is 141.
Long Statement,D_Parser.Dom,IdentifierDeclaration,C:\repos\aBothe_D_Parser\DParser2\Dom\DDeclarations.cs,ToString,The length of the statement  "			return (ModuleScoped ? "." : "") + (IncludesBase && InnerDeclaration != null ? (InnerDeclaration.ToString() + ".") : "") + Id; " is 126.
Long Statement,D_Parser.Dom,DTokenDeclaration,C:\repos\aBothe_D_Parser\DParser2\Dom\DDeclarations.cs,ToString,The length of the statement  "			return (IncludesBase && InnerDeclaration != null ? (InnerDeclaration.ToString() + '.') : "") + DTokens.GetTokenString(Token); " is 125.
Long Statement,D_Parser.Dom,MemberFunctionAttributeDecl,C:\repos\aBothe_D_Parser\DParser2\Dom\DDeclarations.cs,ToString,The length of the statement  "			return (IncludesBase && InnerDeclaration != null ? (InnerDeclaration.ToString() + " ") : "") + DTokens.GetTokenString(Modifier) + "(" + (InnerType != null ? InnerType.ToString() : "") + ")"; " is 190.
Long Statement,D_Parser.Dom,TypeOfDeclaration,C:\repos\aBothe_D_Parser\DParser2\Dom\DDeclarations.cs,ToString,The length of the statement  "			return (IncludesBase && InnerDeclaration != null ? (InnerDeclaration.ToString() + " ") : "") + "typeof(" + (Expression != null ? Expression.ToString() : "") + ")"; " is 163.
Long Statement,D_Parser.Dom,VectorDeclaration,C:\repos\aBothe_D_Parser\DParser2\Dom\DDeclarations.cs,ToString,The length of the statement  "			return (IncludesBase && InnerDeclaration != null ? (InnerDeclaration.ToString() + " ") : "") + "__vector(" + (Id != null ? Id.ToString() : "") + ")"; " is 149.
Long Statement,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitDTuple,The length of the statement  "				(o) => o is ISymbolValue ? (o as ISymbolValue).Accept(Instance) : o is AbstractType ? (o as AbstractType).Accept(Instance) : 0' true); " is 134.
Long Statement,D_Parser.Formatting,DFormattingVisitor,C:\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,EnforceBraceStyle,The length of the statement  "					endIndent = IsLineIsEmptyUpToEol(rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString; " is 122.
Long Statement,D_Parser.Formatting,DFormattingVisitor,C:\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,EnforceBraceStyle,The length of the statement  "					endIndent = IsLineIsEmptyUpToEol(rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString; " is 122.
Long Statement,D_Parser.Formatting,DFormattingVisitor,C:\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,EnforceBraceStyle,The length of the statement  "					endIndent = IsLineIsEmptyUpToEol(rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString; " is 122.
Long Statement,D_Parser.Formatting,DFormattingVisitor,C:\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,EnforceBraceStyle,The length of the statement  "					endIndent = IsLineIsEmptyUpToEol(rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString; " is 122.
Long Statement,D_Parser.Formatting,DFormattingVisitor,C:\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,FixStatementIndentation,The length of the statement  "			string indentString = nextStatementIndent == null ? (isEmpty ? "" : this.options.EolMarker) + this.curIndent.IndentString : nextStatementIndent; " is 144.
Long Statement,D_Parser.Formatting,DFormattingVisitor,C:\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,VisitBlock,The length of the statement  "			EnforceBraceStyle(policy.TypeBlockBraces' block.BlockStartLocation' block.EndLocation.Line' block.EndLocation.Column-1); " is 120.
Long Statement,D_Parser.Formatting,TextReplaceAction,C:\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,ToString,The length of the statement  "				return string.Format("[TextReplaceAction: Offset={0}' RemovalLength={1}' NewText={2}]"' Offset' RemovalLength' NewText); " is 120.
Long Statement,D_Parser.Formatting,FormattingIndentStack,C:\repos\aBothe_D_Parser\DParser2\Formatting\FormattingIndentStack.cs,Update,The length of the statement  "			indentString = new string('\t'' curIndent / options.TabSize) + new string(' '' curIndent % options.TabSize) + new string (' '' ExtraSpaces); " is 140.
Long Statement,D_Parser.Formatting.Indent,IndentEngineWrapper,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CorrectIndent,The length of the statement  "			var eng = new IndentEngine(options ?? DFormattingOptions.CreateDStandard()' textStyle.TabsToSpaces' textStyle.IndentSize' textStyle.KeepAlignmentSpaces); " is 153.
Long Statement,D_Parser.Formatting.Indent,IndentEngineWrapper,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CorrectIndent,The length of the statement  "						replaceActions.Add(new DFormattingVisitor.TextReplaceAction(eng.Position - eng.LineOffset' originalIndent' eng.ThisLineIndent)); " is 128.
Long Statement,D_Parser.Formatting.Indent,IndentEngineWrapper,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CorrectIndent,The length of the statement  "					replaceActions.Add(new DFormattingVisitor.TextReplaceAction(eng.Position - eng.LineOffset' originalIndent' eng.ThisLineIndent)); " is 128.
Long Statement,D_Parser.Formatting.Indent,IndentEngine,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushAccGrave,The length of the statement  "			if ((inside & (Inside.PreProcessor | Inside.Comment | Inside.CharLiteral | Inside.StringLiteral | Inside.VerbatimString)) != 0) " is 127.
Long Statement,D_Parser.Formatting.Indent,IndentStack,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,The length of the statement  "						((inside != Inside.SquareBracketList || ie.Options.KeepArgumentIndentOnSquareBracketOpen) && stack[sp].inside == Inside.ParenList)) { " is 133.
Long Statement,D_Parser.Formatting.Indent,Node,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,ToString,The length of the statement  "				return string.Format ("[Node: inside={0}' keyword={1}' indent={2}' nSpaces={3}' lineNr={4}]"' inside' DTokens.GetTokenString(keyword)' indent' nSpaces' lineNr); " is 160.
Long Statement,D_Parser.Misc,GlobalParseCache,C:\repos\aBothe_D_Parser\DParser2\Misc\GlobalParseCache.cs,preparationTh,The length of the statement  "								throw new InvalidOperationException ("Race-condition during parse process: There must be two or more parse tasks active!"); " is 123.
Long Statement,D_Parser.Misc,GlobalParseCache,C:\repos\aBothe_D_Parser\DParser2\Misc\GlobalParseCache.cs,noticeFinish,The length of the statement  "			var pf = new ParsingFinishedEventArgs (im.basePath' p.root' im.actualTimeNeeded' im.ActualParseTimeNeeded' im.totalFiles); " is 122.
Long Statement,D_Parser.Misc,GlobalParseCache,C:\repos\aBothe_D_Parser\DParser2\Misc\GlobalParseCache.cs,noticeFinish,The length of the statement  "					subtask.finishedHandler (pf); // Generic issue: The wrong statistics will be passed' if we fire the event for a task which was added some time afterwards " is 153.
Long Statement,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,RemoveNestedTemplateRefsFromQualifier,The length of the statement  "							(arg as TypeDeclarationExpression).Declaration = RemoveNestedTemplateRefsFromQualifier((arg as TypeDeclarationExpression).Declaration); " is 135.
Long Statement,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The length of the statement  "					return new IdentifierExpression(-Number()' LiteralFormat.Scalar' LiteralSubformat.Integer | LiteralSubformat.Imaginary); " is 120.
Long Statement,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,HexFloat,The length of the statement  "						return new PostfixExpression_Access{ AccessExpression = new IdentifierExpression("nan")' PostfixForeExpression = new TokenExpression(DTokens.Float) }; " is 150.
Long Statement,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,HexFloat,The length of the statement  "				var inf = new PostfixExpression_Access{ AccessExpression = new IdentifierExpression("infinity")' PostfixForeExpression = new TokenExpression(DTokens.Float) }; " is 158.
Long Statement,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,HexFloat,The length of the statement  "			return new IdentifierExpression(n' LiteralFormat.Scalar | ((Math.Truncate(n) == n) ? 0 : LiteralFormat.FloatingPoint)' LiteralSubformat.Double); " is 144.
Long Statement,D_Parser.Refactoring,ReferencesFinder,C:\repos\aBothe_D_Parser\DParser2\Refactoring\ReferencesFinder.cs,Visit,The length of the statement  "			var id = acc.AccessExpression is NewExpression ? (acc.AccessExpression as NewExpression).Type as IntermediateIdType : acc.AccessExpression as IntermediateIdType; " is 161.
Long Statement,D_Parser.Refactoring,TypeReferenceFinder,C:\repos\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,OnScopedBlockChanged,The length of the statement  "			foreach (var n in ItemEnumeration.EnumScopedBlockChildren(ctxt' MemberFilter.Types | MemberFilter.Enums | MemberFilter.TypeParameters | MemberFilter.Variables)) " is 160.
Long Statement,D_Parser.Refactoring,TypeReferenceFinder,C:\repos\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,Visit,The length of the statement  "			//TODO: If there is a type result' try to resolve x (or postfix-access expressions etc.) to find out whether it's overwritten by some local non-type " is 148.
Long Statement,D_Parser.Refactoring,ClassInterfaceDerivativeFinder,C:\repos\aBothe_D_Parser\DParser2\Refactoring\ClassInterfaceDerivativeFinder.cs,SearchForClassDerivatives,The length of the statement  "				throw new ArgumentException ("t is expected to be a class or an interface' not " + (t != null ? t.ToString () : "null")); " is 121.
Long Statement,D_Parser.Resolver,DTypeToCodeVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\DTypeToCodeVisitor.cs,AcceptType,The length of the statement  "					sb.Append(aliasTag.typeBase != null ? aliasTag.typeBase.ToString() : aliasTag.aliasDefinition.ToString(false' false)).Append('='); " is 130.
Long Statement,D_Parser.Resolver,DTypeToCodeVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\DTypeToCodeVisitor.cs,VisitTemplateParameterSymbol,The length of the statement  "				AcceptType(t.Base); //FIXME: It's not actually code but currently needed for correct ToString() representation in e.g. parameter insight " is 136.
Long Statement,D_Parser.Resolver,AssocArrayType,C:\repos\aBothe_D_Parser\DParser2\Resolver\DType.cs,Clone,The length of the statement  "			return new AssocArrayType(cloneBase && Base != null ? Base.Clone(true) : Base' cloneBase && KeyType != null ? KeyType.Clone(true) : KeyType); " is 141.
Long Statement,D_Parser.Resolver,DelegateCallSymbol,C:\repos\aBothe_D_Parser\DParser2\Resolver\DType.cs,Clone,The length of the statement  "			return new DelegateCallSymbol(cloneBase && Delegate != null ? Delegate.Clone(true) as DelegateType : Delegate' callExpression); " is 127.
Long Statement,D_Parser.Resolver,DelegateType,C:\repos\aBothe_D_Parser\DParser2\Resolver\DType.cs,Clone,The length of the statement  "				return new DelegateType (cloneBase && Base != null ? Base.Clone (true) : Base' delegateTypeBase as FunctionLiteral' Parameters); " is 128.
Long Statement,D_Parser.Resolver,DelegateType,C:\repos\aBothe_D_Parser\DParser2\Resolver\DType.cs,Clone,The length of the statement  "			return new DelegateType(cloneBase && Base != null ? Base.Clone(true) : Base' delegateTypeBase as DelegateDeclaration' Parameters); " is 130.
Long Statement,D_Parser.Resolver,AliasedType,C:\repos\aBothe_D_Parser\DParser2\Resolver\DType.cs,Clone,The length of the statement  "			return new AliasedType(Definition' cloneBase && Base != null ? Base.Clone(true) : Base' DeducedTypes) { Modifier = Modifier }; " is 126.
Long Statement,D_Parser.Resolver,ClassType,C:\repos\aBothe_D_Parser\DParser2\Resolver\DType.cs,Clone,The length of the statement  "			return new ClassType(Definition' cloneBase && Base != null ? Base.Clone(true) as TemplateIntermediateType : Base as TemplateIntermediateType' BaseInterfaces' DeducedTypes) { Modifier = Modifier }; " is 196.
Long Statement,D_Parser.Resolver,MemberSymbol,C:\repos\aBothe_D_Parser\DParser2\Resolver\DType.cs,Clone,The length of the statement  "			return new MemberSymbol(Definition' cloneBase && Base != null ? Base.Clone(true) : Base' DeducedTypes) { Modifier = Modifier }; " is 127.
Long Statement,D_Parser.Resolver,TemplateParameterSymbol,C:\repos\aBothe_D_Parser\DParser2\Resolver\DType.cs,ToString,The length of the statement  "			return "<"+(Parameter == null ? "(unknown)" : Parameter.Name)+">"+(ParameterValue!=null ? ParameterValue.ToString() : (Base==null ? "" : Base.ToString())); " is 155.
Long Statement,D_Parser.Resolver,TemplateParameterSymbol,C:\repos\aBothe_D_Parser\DParser2\Resolver\DType.cs,Clone,The length of the statement  "			return new TemplateParameterSymbol(Parameter' ParameterValue ?? (cloneBase && Base != null ? Base.Clone(true) : Base) as ISemantic) { Modifier = Modifier }; " is 156.
Long Statement,D_Parser.Resolver,ModuleSymbol,C:\repos\aBothe_D_Parser\DParser2\Resolver\DType.cs,Clone,The length of the statement  "			return new ModuleSymbol(Definition' cloneBase && Base != null ? Base.Clone(true) as PackageSymbol : Base as PackageSymbol) { Modifier = Modifier }; " is 147.
Long Statement,D_Parser.Resolver,StaticProperties,C:\repos\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,GetLookedUpType,The length of the statement  "				(tps.Parameter is TemplateThisParameter ? (tps.Parameter as TemplateThisParameter).FollowParameter : tps.Parameter) is TemplateTupleParameter) " is 142.
Long Statement,D_Parser.Resolver,StaticProperties,C:\repos\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,TryEvalPropertyType,The length of the statement  "			if (props.TryGetValue(propName' out prop) || (Properties.TryGetValue(GetOwnerType(t)' out props) && props.TryGetValue(propName' out prop))) " is 139.
Long Statement,D_Parser.Resolver,StaticProperties,C:\repos\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,TryEvalPropertyValue,The length of the statement  "			if (props.TryGetValue(propName' out prop) || (Properties.TryGetValue(GetOwnerType(baseSymbol)' out props) && props.TryGetValue(propName' out prop))) " is 148.
Long Statement,D_Parser.Resolver,ResolutionContext,C:\repos\aBothe_D_Parser\DParser2\Resolver\ResolutionContext.cs,Push,The length of the statement  "			return Push(DResolver.SearchBlockAt(editor.SyntaxTree' editor.CaretLocation) ?? editor.SyntaxTree' editor.CaretLocation); " is 121.
Long Statement,D_Parser.Resolver,ConditionalCompilationFlags,C:\repos\aBothe_D_Parser\DParser2\Resolver\ConditionalCompilationFlags.cs,IsMatching,The length of the statement  "			return !Evaluation.IsFalseZeroOrNull(v); //TODO: Just because the expression evaluation isn't working properly currently' let it return true to have it e.g. in the completion list " is 179.
Long Statement,D_Parser.Resolver,CacheEntryDict,C:\repos\aBothe_D_Parser\DParser2\Resolver\Caching\ResolutionCache.cs,GetTemplateParamHash,The length of the statement  "				var h = ctxt.ScopedBlock == null ? 1 : Resolver.TypeResolution.DResolver.SearchBlockAt(ctxt.ScopedBlock' ctxt.CurrentContext.Caret).Accept(hashVis); " is 148.
Long Statement,D_Parser.Resolver,LooseResolution,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,ResolveTypeLoosely,The length of the statement  "					ctxt.CurrentContext.ContextDependentOptions |= ResolutionOptions.ReturnMethodReferencesOnly | ResolutionOptions.DontResolveAliases; " is 131.
Long Statement,D_Parser.Resolver,LooseResolution,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,ResolveTypeLoosely,The length of the statement  "					ctxt.CurrentContext.ContextDependentOptions |= ResolutionOptions.ReturnMethodReferencesOnly | ResolutionOptions.DontResolveAliases; " is 131.
Long Statement,D_Parser.Resolver,LooseResolution,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,ResolveTypeLoosely,The length of the statement  "						ret = AmbiguousType.Get(ExpressionTypeEvaluation.GetOverloads(o as IdentifierExpression' ctxt' deduceParameters: false)); " is 121.
Long Statement,D_Parser.Resolver,LooseResolution,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\LooseResolution.cs,SearchNodesByName,The length of the statement  "			ctxt.ContextIndependentOptions = ResolutionOptions.DontResolveBaseTypes | ResolutionOptions.NoTemplateParameterDeduction; " is 121.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,TryDoCTFEOrGetValueRefs,The length of the statement  "			return r != null ? r.Accept(new CTFEOrValueRefsVisitor(ValueProvider' idOrTemplateInstance' ImplicitlyExecute' executionArguments)) : null; " is 139.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The length of the statement  "			return TryDoCTFEOrGetValueRefs(AmbiguousType.Get(ExpressionTypeEvaluation.GetOverloads(tix' ctxt))' tix' ImplicitlyExecute); " is 124.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_BoolOp,The length of the statement  "							relationIsTrue = (a.Value < b.Value || a.Value > b.Value) && (!cmpIm || (a.ImaginaryPart < b.ImaginaryPart || a.ImaginaryPart > b.ImaginaryPart)); " is 146.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_BoolOp,The length of the statement  "							relationIsTrue = (a.Value < b.Value || a.Value >= b.Value) && (!cmpIm || (a.ImaginaryPart < b.ImaginaryPart || a.ImaginaryPart >= b.ImaginaryPart)); " is 148.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The length of the statement  "				EvalError(x' "Left value must evaluate to a constant scalar value. Operator overloads aren't supported yet"' new[]{lValue}); " is 124.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The length of the statement  "				if (x.RightOperand is OperatorBasedExpression && !(x.RightOperand is AssignExpression)) //TODO: This must be true only if it's a math expression' so not an assign expression etc. " is 178.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The length of the statement  "				return HandleSingleMathOp(x' l' TryGetValue(rValue ?? (x.RightOperand != null ? x.RightOperand.Accept(this) : null))' mult); " is 124.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalConcatenation,The length of the statement  "			// Notable: If one element is of the value type of the array' the element is added (either at the front or at the back) to the array " is 132.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalConcatenation,The length of the statement  "				EvalError(x' "At least one operand must be an (non-associative) array. If so' the other operand must be of the array's element type."' catQueue.ToArray()); " is 155.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalConcatenation,The length of the statement  "					EvalError(x' "Element with type " + (e.RepresentedType != null ? e.RepresentedType.ToCode() : "") + " doesn't fit into array with type "+lastArrayType.ToCode()' catQueue.ToArray()); " is 181.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,HandleSingleMathOp,The length of the statement  "					return PrimitiveValue.CreateNaNValue(pl.IsNaN ? pl.BaseTypeToken : pr.BaseTypeToken' pl.IsNaN ? pl.Modifier : pr.Modifier); " is 123.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,HandleSingleMathOp,The length of the statement  "					return PrimitiveValue.CreateNaNValue(pl.IsNaN ? pl.BaseTypeToken : pr.BaseTypeToken' pl.IsNaN ? pl.Modifier : pr.Modifier); " is 123.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_WithAliases,The length of the statement  "			var expectedTemplateParams = new TemplateParameter[isExpression.TemplateParameterList == null  ? 1 : (isExpression.TemplateParameterList.Length + 1)]; " is 150.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_WithAliases,The length of the statement  "					tpl_params[isExpression.ArtificialFirstSpecParam] = new TemplateParameterSymbol(isExpression.ArtificialFirstSpecParam' r.Item2); " is 128.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_EvalSpecToken,The length of the statement  "								// TypeTuple of the function parameter types. For C- and D-style variadic functions' only the non-variadic parameters are included.  " is 131.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The length of the statement  "			var assertVal = x.AssignExpressions.Length > 0 && x.AssignExpressions[0] != null ? x.AssignExpressions[0].Accept(this) as ISymbolValue : null; " is 142.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The length of the statement  "			return new AssociativeArrayValue(new AssocArrayType(elements[0].Value.RepresentedType' elements[0].Key.RepresentedType)' elements); " is 131.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The length of the statement  "				(ctxt.Options & ResolutionOptions.DontResolveBaseTypes | ResolutionOptions.ReturnMethodReferencesOnly) != 0 ? null : TypeDeclarationResolver.GetMethodReturnType (x.AnonymousMethod' ctxt)' " is 187.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The length of the statement  "			var argTypeFilteredOverloads = EvalMethodCall(baseExpression' baseValue' tix' ctxt' call' out callArguments' out delegValue' returnBaseTypeOnly' ValueProvider); " is 160.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalMethodCall,The length of the statement  "			bool requireStaticItems = true; //TODO: What if there's an opCall and a foreign method at the same time? - and then this variable would be bullshit " is 147.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalMethodCall,The length of the statement  "					HandleDMethodOverload(ctxt' ValueProvider != null' baseValue' callArguments' returnBaseTypeOnly' argTypeFilteredOverloads' ref hasHandledUfcsResultBefore'  " is 154.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,HandleDMethodOverload,The length of the statement  "			else if (!isUfcs && hasHandledUfcsResultBefore) // In the rare case of having a ufcs result occuring _after_ a normal member result' remove the initial arg again " is 161.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,TryHandleMethodArgumentTuple,The length of the statement  "				var nextExpectedParameter = DResolver.StripMemberSymbols(TypeDeclarationResolver.ResolveSingle(dm.Parameters[currentParameter + 1].Type' ctxt)); " is 144.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,TryHandleMethodArgumentTuple,The length of the statement  "						if (currentArg >= callArguments.Count || !ResultComparer.IsImplicitlyConvertible(callArguments[currentArg++]' AbstractType.Get(item)' ctxt)) " is 140.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,GetRawCallOverloads,The length of the statement  "				// Explicitly don't resolve the methods' return types - it'll be done after filtering to e.g. resolve template types to the deduced one " is 135.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,GetRawCallOverloads,The length of the statement  "					baseExpression = ExpressionTypeEvaluation.GetResolvedConstructorOverloads((TokenExpression)call.PostfixForeExpression' ctxt); " is 125.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalPostfixAccessExpression,The length of the statement  "			var baseExpression = resultBase ?? (acc.PostfixForeExpression != null ? acc.PostfixForeExpression.Accept(vis) as ISemantic : null); " is 131.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalPostfixAccessExpression,The length of the statement  "				// Do not deduce and filter if superior expression is a method call since call arguments' types also count as template arguments! " is 129.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,EvalPostfixAccessExpression,The length of the statement  "				return new[] { (R)new Evaluation(ValueProvider).TryDoCTFEOrGetValueRefs(AmbiguousType.Get(overloads)' acc.AccessExpression) }; " is 126.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,SliceArray,The length of the statement  "				EvalError(lower != -1 ? sl.LowerBoundExpression : sl.UpperBoundExpression' "Boundary expression must base an integral type"); " is 125.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,SliceArray,The length of the statement  "				EvalError(sl.LowerBoundExpression' "Lower boundary must be smaller than " + len); return new NullValue(ar.RepresentedType); " is 123.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,SliceArray,The length of the statement  "				EvalError(sl.UpperBoundExpression' "Upper boundary must be greater than " + lower); return new NullValue(ar.RepresentedType); " is 125.
Long Statement,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,SliceArray,The length of the statement  "				EvalError(sl.UpperBoundExpression' "Upper boundary must be smaller than " + len); return new NullValue(ar.RepresentedType); " is 123.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,EvaluateType,The length of the statement  "			if (!(t is TemplateParameterSymbol) || !ctxt.DeducedTypesInHierarchy.Any((tps) => tps.Parameter == (t as TemplateParameterSymbol).Parameter)) // Don't allow caching parameters that affect the caching context. " is 208.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,The length of the statement  "			return Evaluation.EvalMethodCall(baseExpression' null' tix' ctxt' call' out callArgs' out delegValue' !ctxt.Options.HasFlag(ResolutionOptions.ReturnMethodReferencesOnly)); " is 171.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetRawCallOverloads,The length of the statement  "				// Explicitly don't resolve the methods' return types - it'll be done after filtering to e.g. resolve template types to the deduced one " is 135.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetAccessedOverloads,The length of the statement  "			return Evaluation.EvalPostfixAccessExpression<AbstractType>(new ExpressionTypeEvaluation(ctxt)' ctxt' acc' resultBase' DeducePostfixTemplateParams); " is 148.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetResolvedConstructorOverloads,The length of the statement  "					return D_Parser.Resolver.TypeResolution.TypeDeclarationResolver.HandleNodeMatches(GetConstructors(classRef)' ctxt' classRef' tk); " is 129.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetConstructors,The length of the statement  "					yield return new DMethod(DMethod.MethodType.Constructor) { Name = DMethod.ConstructorIdentifier' Parent = ct.Definition' Description = "Default constructor for " + ct.Name }; " is 174.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,The length of the statement  "			return x.TrueCaseExpression != null ? x.TrueCaseExpression.Accept(this) : (x.FalseCaseExpression != null ? x.FalseCaseExpression.Accept(this) : null); " is 150.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,The length of the statement  "			return TypeDeclarationResolver.ResolveSingle(new IdentifierDeclaration(uat.AccessIdentifierHash) { EndLocation = uat.EndLocation' InnerDeclaration = uat.Type }' ctxt); " is 167.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,AccessArrayAtIndex,The length of the statement  "						foreExpression = DResolver.StripMemberSymbols(TypeDeclarationResolver.HandleNodeMatch(aliasThis' ctxt' foreExpression)); " is 120.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,AccessArrayAtIndex,The length of the statement  "					foreExpression = TryPretendMethodExecution (AmbiguousType.Get (overloads)' x' indexArgs.Count != 0 ? indexArgs.ToArray () : null); " is 130.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,AccessArrayAtIndex,The length of the statement  "					arg_i += indexArgs.Count; //TODO: Only increment by the amount of actually used args for filtering out the respective method overload. " is 134.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,ResolveIdentifier,The length of the statement  "			if (hasBaseValue || (ctxt.Options & ResolutionOptions.DontResolveBaseClasses | ResolutionOptions.DontResolveBaseTypes) != 0) { " is 126.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetOverloads,The length of the statement  "				Trace.WriteLine(string.Format("Finished resolving base type {0} => {1}. {2} ms."' (id as ITypeDeclaration).InnerDeclaration' resultBases' sw.ElapsedMilliseconds)); " is 163.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,The length of the statement  "				(ctxt.Options & ResolutionOptions.DontResolveBaseTypes | ResolutionOptions.ReturnMethodReferencesOnly) != 0 ? null : TypeDeclarationResolver.GetMethodReturnType(x.AnonymousMethod' ctxt)' " is 186.
Long Statement,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,The length of the statement  "			return TypeDeclarationResolver.ResolveSingle(new IdentifierDeclaration("TypeInfo") { InnerDeclaration = new IdentifierDeclaration("object") }' ctxt); " is 149.
Long Statement,D_Parser.Resolver.ExpressionSemantics,StandardValueProvider,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ISymbolValueProvider.cs,GetLocal,The length of the statement  "			var res = ExpressionTypeEvaluation.GetOverloads(id ?? new IdentifierExpression(LocalName)' ResolutionContext' null' false); " is 123.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,DeepScanClass,The length of the statement  "				takeStaticChildrenOnly = (udt == null || !udt.NonStaticAccess) && ctxt.ScopedBlock is DMethod && (ctxt.ScopedBlock as DMethod).IsStatic " is 135.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,VisitStatementHierarchy,The length of the statement  "			return dm != null && (s = dm.GetSubBlockAt (caret)) != null && s.Accept (new StatementHandler (dm' this' parms' caret)); " is 120.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,HandleAliasThisDeclarations,The length of the statement  "			if (aliasThisDefsBeingParsed.TryGetValue (tit.Definition' out alreadyParsedAliasThis) && alreadyParsedAliasThis == aliasDef) " is 124.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,HandleAliasThisDeclarations,The length of the statement  "				aliasedSymbolOverloads = DResolver.StripMemberSymbols(DResolver.StripMemberSymbols(TypeDeclarationResolver.ResolveSingle(aliasDef.Type' ctxt))); " is 144.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,MatchesCompilationConditions,The length of the statement  "						res = neg != null ? !ctxt.CurrentContext.MatchesDeclarationEnvironment(neg) : ctxt.CurrentContext.MatchesDeclarationEnvironment(cond); " is 134.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,CanHandleNode,The length of the statement  "			if((ctxt.Options & ResolutionOptions.IgnoreAllProtectionAttributes) != ResolutionOptions.IgnoreAllProtectionAttributes){ " is 120.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,CanHandleNode,The length of the statement  "				if((CanShowMember(dn' ctxt.ScopedBlock) || (parms.isBaseClass && !parms.isMixinAst)) && ((!parms.takeStaticChildrenOnly && (!parms.publicImportsOnly || !parms.isBaseClass)) || IsConstOrStatic(dn))) " is 197.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,CanHandleNode,The length of the statement  "			if (dm3 != null && !(dm3.SpecialType == DMethod.MethodType.Normal || dm3.SpecialType == DMethod.MethodType.Delegate || dm3.NameHash != 0)) " is 138.
Long Statement,D_Parser.Resolver.ASTScanner,AbstractVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,IsConstOrStatic,The length of the statement  "			return dn != null && (dn.IsStatic || (dv != null && (dv.IsConst || dv.IsAlias))); // Aliases are always static - it only depends on their base types then " is 153.
Long Statement,D_Parser.Resolver.ASTScanner,StatementHandler,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,VisitImport,The length of the statement  "				var thisModuleName = (ctxt.ScopedBlock != null && (mod = ctxt.ScopedBlock.NodeRoot as DModule) != null) ? mod.ModuleName : string.Empty; " is 136.
Long Statement,D_Parser.Resolver.ASTScanner,StatementHandler,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,VisitImport,The length of the statement  "				foreach (var module in ctxt.ParseCache.LookupModuleName(scopedModule' moduleName)) //TODO: Only take the first module? Notify the user about ambigous module names? " is 163.
Long Statement,D_Parser.Resolver.ResolutionHooks,bitfields,C:\repos\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\bitfields.cs,TryDeduce,The length of the statement  "								sb.Append("@property @safe ").Append(templateParamName).Append(' ').Append(name).AppendLine("() pure nothrow const {}"); " is 120.
Long Statement,D_Parser.Resolver.ResolutionHooks,bitfields,C:\repos\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\bitfields.cs,TryDeduce,The length of the statement  "								sb.Append("@property @safe void ").Append(name).AppendLine("(").Append(templateParamName).AppendLine(" v) pure nothrow {}"); " is 124.
Long Statement,D_Parser.Resolver.ResolutionHooks,bitfields,C:\repos\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\bitfields.cs,TryDeduce,The length of the statement  "								sb.Append("enum ").Append(templateParamName).Append(" ").Append(name).Append("_min = cast(").Append(templateParamName).AppendLine(") 0;"); " is 138.
Long Statement,D_Parser.Resolver.ResolutionHooks,bitfields,C:\repos\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\bitfields.cs,TryDeduce,The length of the statement  "								sb.Append("enum ").Append(templateParamName).Append(" ").Append(name).Append("_max = cast(").Append(templateParamName).AppendLine(") 0;"); " is 138.
Long Statement,D_Parser.Resolver.ResolutionHooks,TupleHook,C:\repos\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\Tuple.cs,TryDeduce,The length of the statement  "				tupleStruct.Add(new DVariable { NameHash = DVariable.AliasThisIdentifierHash' IsAlias = true' IsAliasThis = true' Type = new IdentifierDeclaration(tupleName) }); " is 161.
Long Statement,D_Parser.Resolver.ResolutionHooks,autoimplement,C:\repos\aBothe_D_Parser\DParser2\Resolver\ResolutionHooks\Hooks\autoimplement.cs,TryDeduce,The length of the statement  "			return new ClassType(cls.Definition' baseClass as ClassType' baseClass is InterfaceType ? new[] {baseClass as InterfaceType} : null' ds.DeducedTypes); " is 150.
Long Statement,D_Parser.Resolver.Templates,SpecializationOrdering,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\SpecializationOrdering.cs,IsMoreSpecialized,The length of the statement  "				IsMoreSpecialized(((TemplateThisParameter)t1).FollowParameter' ((TemplateThisParameter)t2).FollowParameter' t1_dummyParameterList)) " is 131.
Long Statement,D_Parser.Resolver.Templates,SpecializationOrdering,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\SpecializationOrdering.cs,IsMoreSpecialized,The length of the statement  "				// It's not needed to test both expressions for equality because they actually were equal to the given template instance argument " is 129.
Long Statement,D_Parser.Resolver.Templates,SpecializationOrdering,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\SpecializationOrdering.cs,IsMoreSpecialized,The length of the statement  "			else if (t1.Specialization == null) // Return false if t2 is more specialized or if t1 as well as t2 are not specialized " is 120.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,Handle,The length of the statement  "			//TODO: Handle __FILE__ and __LINE__ correctly - so don't evaluate them at the template declaration but at the point of instantiation " is 133.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,TryAssignDefaultType,The length of the statement  "			using (ctxt.Push(DResolver.SearchBlockAt(ctxt.ScopedBlock.NodeRoot as IBlockNode' p.Default.Location)' p.Default.Location)) " is 123.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The length of the statement  "				var physicalParentType = TypeDeclarationResolver.HandleNodeMatch(deducee.Definition.Parent' ctxt' null' id.InnerDeclaration); " is 125.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The length of the statement  "			 * Therefore' it's needed to manually resolve the identifier' and look out for aliases or such unprecise aliases..confusing as s**t! " is 131.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The length of the statement  "			 * If the param tix id is part of the template param list' the behaviour is currently undefined! - so instantly return false' I'll leave it as TODO/FIXME " is 152.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The length of the statement  "				if (tixBasedArgumentType != null && CheckForTixIdentifierEquality(paramTix_TemplateMatchPossibilities' tixBasedArgumentType.Definition)) " is 136.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,ResolveTemplateInstanceId,The length of the statement  "			 * When having a cascaded tix as parameter' it uses the left-most part (i.e. the inner most) of the typedeclaration construct. " is 125.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,ResolveTemplateInstanceId,The length of the statement  "			ctxt.CurrentContext.ContextDependentOptions = ResolutionOptions.DontResolveBaseClasses | ResolutionOptions.DontResolveBaseTypes; " is 128.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The length of the statement  "				if (id != null && id.IsIdentifier && Contains (id.ValueStringHash)) { // Match int[5] into T[n]'n - after deduction' n will be 5 " is 128.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The length of the statement  "					// If an expression (the usual case) has been passed as argument' evaluate its value' otherwise is its type already resolved. " is 125.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The length of the statement  "					var finalArg = argumentArrayType is ArrayType ? (ISemantic)new PrimitiveValue ((argumentArrayType as ArrayType).FixedLength) : argumentArrayType.KeyType; " is 153.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The length of the statement  "					// Just test for equality of the argument and parameter expression' e.g. if both param and arg are 123' the result will be true. " is 128.
Long Statement,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The length of the statement  "					result = SymbolValueComparer.IsEqual (Evaluation.EvaluateValue (arrayDeclToCheckAgainst.KeyExpression' ctxt)' new PrimitiveValue ((argumentArrayType as ArrayType).FixedLength)); " is 177.
Long Statement,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,TryGetImplicitProperty,The length of the statement  "			var matchingChild = TypeDeclarationResolver.ResolveFurtherTypeIdentifier( template.NameHash' template' ctxt' null' false); " is 122.
Long Statement,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceEponymousTemplate,The length of the statement  "				ExpressionTypeEvaluation.EvaluateType(def.Initializer' ctxt)' ept.DeducedTypes); //ept; //ExpressionTypeEvaluation.EvaluateType (ept.Definition.Initializer' ctxt); " is 163.
Long Statement,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceOverloads,The length of the statement  "				var hook = D_Parser.Resolver.ResolutionHooks.HookRegistry.TryDeduce(overload' givenTemplateArguments' out ignoreOtherOverloads); " is 128.
Long Statement,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParam,The length of the statement  "			// There might be too few args - but that doesn't mean that it's not correct - it's only required that all parameters got satisfied with a type " is 143.
Long Statement,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,ResolveFurtherTypeIdentifier,The length of the statement  "							r.AddRange(UFCSResolver.TryResolveUFCS(b' nextIdentifierHash' ctxt.ScopedBlock != udt.Definition && typeIdObject != null ? typeIdObject.Location : ctxt.ScopedBlock.BlockStartLocation' ctxt' typeIdObject)); " is 205.
Long Statement,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,ResolveFurtherTypeIdentifier,The length of the statement  "						r.AddRange(UFCSResolver.TryResolveUFCS (b' nextIdentifierHash' typeIdObject != null ? typeIdObject.Location : ctxt.ScopedBlock.BlockStartLocation' ctxt' typeIdObject)); " is 168.
Long Statement,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,TryPostDeduceAliasDefinition,The length of the statement  "					b = AmbiguousType.Get(TemplateInstanceHandler.DeduceParamsAndFilterOverloads(bases' typeBase as TemplateInstanceExpression' ctxt' false)); " is 138.
Long Statement,D_Parser.Resolver.TypeResolution,SingleResolverVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,Visit,The length of the statement  "						// D Magic: One might access tuple items directly in the pseudo array declaration - so stuff like Tup[0] i; becomes e.g. int i; " is 127.
Long Statement,D_Parser.Resolver.TypeResolution,SingleResolverVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,Visit,The length of the statement  "							ctxt.LogError (ad' "TypeTuple only consists of " + (dtup.Items != null ? dtup.Items.Length : 0) + " items. Can't access item at index " + fixedArrayLength); " is 156.
Long Statement,D_Parser.Resolver.TypeResolution,NodeMatchHandleVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,CanResolveBase,The length of the statement  "						(!(m.Type is IdentifierDeclaration) || (m.Type as IdentifierDeclaration).IdHash != m.NameHash || m.Type.InnerDeclaration != null); // pretty rough and incomplete SO prevention hack " is 180.
Long Statement,D_Parser.Resolver.TypeResolution,NodeMatchHandleVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,GetForeachIteratorType,The length of the statement  "				loc = new CodeLocation(loc.Column-1' loc.Line); // SearchStmtDeeplyAt only checks '<' EndLocation' we may need to have '<=' though due to completion offsets. " is 157.
Long Statement,D_Parser.Resolver.TypeResolution,NodeMatchHandleVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,GetForeachIteratorType,The length of the statement  "				var curStmt = curMethod != null ? DResolver.SearchStatementDeeplyAt(curMethod.GetSubBlockAt(ctxt.CurrentContext.Caret)' loc) : null; " is 132.
Long Statement,D_Parser.Resolver.TypeResolution,NodeMatchHandleVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,GetForeachIteratorType,The length of the statement  "							return keyIsSearched ? TypeDeclarationResolver.ResolveSingle(new IdentifierDeclaration("size_t")' ctxt' false /* Generally' size_t isn't templated or such..so for performance' step through additional filtering */) : (aggregateType as PointerType).Base; " is 252.
Long Statement,D_Parser.Resolver.TypeResolution,NodeMatchHandleVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,Visit,The length of the statement  "				return new EponymousTemplateType(ep' new ReadOnlyCollection<TemplateParameterSymbol>(new List<TemplateParameterSymbol>(GetInvisibleTypeParameters(ep)))); " is 153.
Long Statement,D_Parser.Resolver.TypeResolution,NodeMatchHandleVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,Visit,The length of the statement  "						bt = AmbiguousType.Get(ResolveFurtherTypeIdentifier(importSymbolNode.Type.ToString(false).GetHashCode()' bt' ctxt' importSymbolNode.Type)); " is 139.
Long Statement,D_Parser.Resolver.TypeResolution,DResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,ResolveObjectClass,The length of the statement  "			using (ctxt.Push(ctxt.ScopedBlock == null ? null : ctxt.ScopedBlock.NodeRoot)) //TODO: understand why we're passing null" is 120.
Long Statement,D_Parser.Resolver.TypeResolution,DResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,ResolveClassOrInterface,The length of the statement  "				// Pop a context frame as we still need to resolve the template instance expression args in the place where the expression occurs' not the instantiated class' location" is 167.
Long Statement,D_Parser.Resolver.TypeResolution,DResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,ResolveClassOrInterface,The length of the statement  "				return isClass ? new ClassType(dc' dc.NameHash != ObjectNameHash ? ResolveObjectClass(ctxt) : null' null' deducedTypes) :" is 121.
Long Statement,D_Parser.Resolver.TypeResolution,DResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,ResolveClassOrInterface,The length of the statement  "						if (type == null || (type is IdentifierDeclaration && (type as IdentifierDeclaration).IdHash == dc.NameHash) || dc.NodeRoot == dc)" is 130.
Long Statement,D_Parser.Resolver.TypeResolution,DResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,ResolveClassOrInterface,The length of the statement  "								ctxt.LogError(new ResolutionError(dc' "The base " + (r is ClassType ? "class" : "template") + " name must preceed base interfaces"));" is 133.
Long Statement,D_Parser.Resolver.TypeResolution,DResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,SearchBlockAt,The length of the statement  "					return SearchBlockAt(subItem' Where); // For e.g. nested nested methods inside anonymous class declarations that occur furtherly inside a method." is 145.
Long Statement,D_Parser.Resolver.TypeResolution,DResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,GetResultMember,The length of the statement  "					(!(aliasTag.aliasDefinition is ImportSymbolAlias) || // Only if the import symbol alias definition was selected' go to its base" is 127.
Long Statement,D_Parser.Resolver.TypeResolution,DResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,StripMemberSymbols,The length of the statement  "				// auto o = new Class(); -- o will be MemberSymbol and its base type will be a MemberSymbol either (i.e. the constructor reference)" is 131.
Long Statement,D_Parser.Resolver.TypeResolution,DResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,StripMemberSymbols,The length of the statement  "				if(ds is MemberSymbol && (ds as DSymbol).Definition is DMethod && (ds as DSymbol).NameHash == DMethod.ConstructorIdentifierHash)" is 128.
Long Statement,D_Parser.Resolver.TypeResolution,OpDispatchResolution,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\OpDispatchResolution.cs,TryResolveFurtherIdViaOpDispatch,The length of the statement  "				ctxt.CurrentContext.ContextDependentOptions = opt; // Mainly required for not resolving opDispatch's return type' as this will be performed later on in higher levels " is 165.
Long Statement,D_Parser.Completion,ParameterInsightResolution,C:\repos\aBothe_D_Parser\DParser2\Completion\ParameterInsightResolution.cs,Visit,The length of the statement  "			res.ResolvedTypesOrMethods = ExpressionTypeEvaluation.GetUnfilteredMethodOverloads(call.PostfixForeExpression' ctxt' call); " is 123.
Long Statement,D_Parser.Completion,ParameterInsightResolution,C:\repos\aBothe_D_Parser\DParser2\Completion\ParameterInsightResolution.cs,Visit,The length of the statement  "			var ov = TypeDeclarationResolver.ResolveFurtherTypeIdentifier(ExpressionTypeEvaluation.OpSliceIdHash' b' ctxt' x' false); " is 121.
Long Statement,D_Parser.Completion,MemberCompletionEnumeration,C:\repos\aBothe_D_Parser\DParser2\Completion\MemberCompletionEnumeration.cs,PreCheckItem,The length of the statement  "			return isVarInst || !(n is DMethod || dv != null || n is TemplateParameter.Node) ||	(n as DNode).IsStatic || n is DEnumValue ||	(dv != null && (dv.IsConst || dv.IsAlias)); " is 171.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,C:\repos\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,VisitAttribute,The length of the statement  "			if (a.ContentHash == DTokens.IncompleteIdHash || ((c = a.LiteralContent as string) != null && c.EndsWith(DTokens.IncompleteId))) { " is 130.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,C:\repos\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The length of the statement  "				const MemberFilter BaseAsmFlags = MemberFilter.Classes | MemberFilter.StructsAndUnions | MemberFilter.Enums | MemberFilter.Methods | MemberFilter.TypeParameters | MemberFilter.Types | MemberFilter.Variables; " is 207.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,C:\repos\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The length of the statement  "					prv = new CtrlSpaceCompletionProvider(cdgen' scopedBlock' BaseAsmFlags | MemberFilter.x86Registers | MemberFilter.x64Registers | MemberFilter.Labels); " is 150.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,C:\repos\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The length of the statement  "					prv = new CtrlSpaceCompletionProvider (cdgen' scopedBlock' shownKeywords.Count == 0 ? MemberFilter.All | MemberFilter.ExpressionKeywords : shownKeywords.Peek()); " is 161.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,C:\repos\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The length of the statement  "					// When typing a dot without anything following' trigger completion and show types' methods and vars that are located in the module & import scope " is 146.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,C:\repos\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The length of the statement  "					prv = new CtrlSpaceCompletionProvider (cdgen' scopedBlock' MemberFilter.Methods | MemberFilter.Types | MemberFilter.Variables | MemberFilter.TypeParameters ); " is 158.
Long Statement,D_Parser.Completion,CompletionProviderVisitor,C:\repos\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The length of the statement  "				prv = new CtrlSpaceCompletionProvider(cdgen' scopedBlock' MemberFilter.Types | MemberFilter.ExpressionKeywords | MemberFilter.StatementBlockKeywords); " is 150.
Long Statement,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The length of the statement  "								return Token(DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue(numString' 16)' /*numString'*/ LiteralFormat.Scalar); " is 136.
Long Statement,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The length of the statement  "										literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString(3) + " by Alexander Bothe"; " is 134.
Long Statement,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadTokenStringLiteral_IdentInit,The length of the statement  "			return Token(DTokens.Literal' x' y' Col' Line' tokenString.ToString().Trim()' LiteralFormat.VerbatimStringLiteral' subFmt); " is 123.
Long Statement,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadTokenStringLiteral_CurlyInit,The length of the statement  "			return Token(DTokens.Literal' x' y' Col' Line' tokenString.ToString().Trim()' LiteralFormat.VerbatimStringLiteral' subFmt); " is 123.
Long Statement,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadIdent,The length of the statement  "							OnError(Line' Col' "Unicode escape sequences in identifiers cannot be used to represent characters that are invalid in identifiers"); " is 133.
Long Statement,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadIdent,The length of the statement  "							OnError(Line' Col' "Unicode escape sequences in identifiers cannot be used to represent characters that are invalid in identifiers"); " is 133.
Long Statement,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The length of the statement  "				if (NumBase == 10 || (ch != '.' && NumBase == 0)) // Only allow further digits for 10-based integers' not for binary or hex values " is 130.
Long Statement,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadString,The length of the statement  "			return Token(DTokens.Literal' x' y' Col' Line' /*originalValue.ToString()'*/ sb.ToString()' LiteralFormat.StringLiteral' subFmt); " is 129.
Long Statement,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadVerbatimString,The length of the statement  "			return Token(DTokens.Literal' x' y' Col' Line' /*originalValue.ToString()'*/ sb.ToString()' LiteralFormat.VerbatimStringLiteral' subFmt); " is 137.
Long Statement,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadChar,The length of the statement  "			return Token(DTokens.Literal' x' y' Col' Line' string.IsNullOrEmpty(surrogatePair) ? (object)chValue : surrogatePair' LiteralFormat.CharLiteral' surrogatePair == null ? LiteralSubformat.Utf8 : LiteralSubformat.Utf16' escapeSequence); " is 233.
Long Statement,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadMultiLineComment,The length of the statement  "							Comments.Add(new Comment(commentType' scCurWord.ToString().Trim(ch' ' '' '\t'' '\r'' '\n'' isNestingComment ? '+' : '*')' st.Column < 2' st' new CodeLocation(Col' Line))); " is 171.
Long Statement,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadSpecialTokenSequence,The length of the statement  "					nextToken = Next(); //ISSUE: Successive #line tokens will be skipped here - perhaps detect if there's a special token following? " is 128.
Long Statement,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,OnError,The length of the statement  "				LexerErrors.Add(new ParserError(false' message' CurrentToken != null ? CurrentToken.Kind : -1' new CodeLocation(col' line))); " is 125.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,PushAttribute,The length of the statement  "			// If attr would change the accessability of an item' remove all previously found (so the most near attribute that's next to the item is significant) " is 149.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,GetCurrentAttributeSet,The length of the statement  "				// ISSUE: Theoretically' when having two identically written but semantically different UDA attributes' the first one will become overridden. " is 141.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,AttributeBlock,The length of the statement  "			 * Also' pop them from the declarationAttributes stack on to the block attributes so they will be assigned to all child items later on. " is 134.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,AttributeBlock,The length of the statement  "				metaDeclBlock = new AttributeMetaDeclarationBlock(DeclarationAttributes.ToArray()) { BlockStartLocation = la.Location }; " is 120.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Condition,The length of the statement  "								SemErr(DTokens.Version' "Can't handle " + t.LiteralValue.ToString() + " as version constraint; taking ulong.max instead"); " is 122.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,ImportDeclaration,The length of the statement  "			var importStatement = new ImportStatement { Attributes = GetCurrentAttributeSet_Array()' Location=t.Location' IsStatic = isStatic' IsPublic = isPublic }; " is 153.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,ImportBindings,The length of the statement  "						importBindings.SelectedSymbols.Add (new ImportStatement.ImportBinding (new IdentifierDeclaration (DTokens.IncompleteIdHash)' symbolAlias)); " is 139.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,AliasDeclaration,The length of the statement  "				(Lexer.CurrentPeekToken.Kind == OpenParenthesis && OverPeekBrackets(OpenParenthesis) && Lexer.CurrentPeekToken.Kind == Assign))) " is 128.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,AliasDeclaration,The length of the statement  "			foreach(var n in Decl(Scope' laKind != Identifier || Lexer.CurrentPeekToken.Kind != OpenParenthesis ? null : new Modifier(DTokens.Alias)' true)) " is 144.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Decl,The length of the statement  "			    laKind == (Identifier) && (DeclarationAttributes.Count > 0 || Lexer.CurrentPeekToken.Kind == OpenParenthesis))) { // public auto var=0; // const foo(...) {}  " is 156.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Declarator,The length of the statement  "							(ad == null || !(ad.KeyExpression is TokenExpression) || (ad.KeyExpression as TokenExpression).Token != DTokens.Incomplete)) // 'string[|' " is 138.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,OldCStyleFunctionPointer,The length of the statement  "			//SynErr(OpenParenthesis'"C-style function pointers are deprecated. Use the function() syntax instead."); // Only deprecated in D2 " is 130.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Declarator2,The length of the statement  "				if (AllowWeakTypeParsing && (td == null||(t.Kind==OpenParenthesis && laKind==CloseParenthesis) /* -- means if an argumentless function call has been made' return null because this would be an expression */|| laKind!=CloseParenthesis)) " is 234.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Parameters,The length of the statement  "			// It's not specified in the official D syntax spec' but we treat id-only typed anonymous parameters as non-typed id-full parameters " is 132.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Parameter,The length of the statement  "			while ((IsParamModifier(laKind) && laKind != InOut) || (IsMemberFunctionAttribute(laKind) && Lexer.CurrentPeekToken.Kind != OpenParenthesis)) " is 141.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,IsAssignExpression,The length of the statement  "					if (IsBasicType (Lexer.CurrentPeekToken) && !(Lexer.CurrentPeekToken.Kind == DTokens.Identifier || Lexer.CurrentPeekToken.Kind == DTokens.Dot)) { " is 145.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,IsAssignExpression,The length of the statement  "			// Addition: If a times token ('*') follows an identifier list' we can assume that we have a declaration and NOT an expression! " is 127.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,IsAssignExpression,The length of the statement  "			// Example: *a=b is an expression; a*=b is not possible (and a Multiply-Assign-Expression) - instead something like A* a should be taken... " is 139.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,AndExpression,The length of the statement  "			// Note: Since we ignored all kinds of CmpExpressions in AndAndExpression()' we have to take CmpExpression instead of ShiftExpression here! " is 139.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,PostfixExpression,The length of the statement  "						laKind == CloseParenthesis && Lexer.CurrentPeekToken == dotToken) // Also take it as a type declaration if there's nothing following (see Expression Resolving) " is 159.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,PostfixExpression,The length of the statement  "						var peid = t.Kind == Increment ? (PostfixExpression)new PostfixExpression_Increment() : new PostfixExpression_Decrement(); " is 122.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,PrimaryExpression,The length of the statement  "					return new PostfixExpression_Access{ PostfixForeExpression = dot' AccessExpression = new TokenExpression(DTokens.Incomplete) }; " is 127.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,PrimaryExpression,The length of the statement  "						return new IdentifierExpression(sb.ToString()' t.LiteralFormat' t.Subformat) { Location = startLoc' EndLocation = t.EndLocation }; " is 130.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,PrimaryExpression,The length of the statement  "					//else if (t.LiteralFormat == LiteralFormat.CharLiteral)return new IdentifierExpression(t.LiteralValue) { LiteralFormat=t.LiteralFormat'Location = startLoc' EndLocation = t.EndLocation }; " is 187.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,PrimaryExpression,The length of the statement  "					return new IdentifierExpression(t.LiteralValue' t.LiteralFormat' t.Subformat' t.RawCodeRepresentation) { Location = startLoc' EndLocation = t.EndLocation }; " is 156.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,PrimaryExpression,The length of the statement  "					if (Scope != null && !AllowWeakTypeParsing) // HACK -- not only on AllowWeakTypeParsing! But apparently' this stuff may be parsed twice' so force-skip results of the first attempt although this is a rather stupid solution " is 221.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,PrimaryExpression,The length of the statement  "										AccessExpression = IsEOF ? new TokenExpression(Incomplete) as IExpression : new IdentifierExpression(t.Value) { Location = t.Location' EndLocation = t.EndLocation }' " is 165.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,IfCondition,The length of the statement  "				(Peek(1).Kind == Assign || Lexer.CurrentPeekToken.Kind == CloseParenthesis)) || // if(a * b * c) is an expression' if(a * b = 123) may be a pointer variable " is 156.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,ForeachStatement,The length of the statement  "				else if (laKind == (Identifier) && (Lexer.CurrentPeekToken.Kind == (Semicolon) || Lexer.CurrentPeekToken.Kind == Comma)) " is 120.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmStatement,The length of the statement  "						l.Add(new LabeledStatement() { Location = la.Location' Parent = s' Identifier = la.Value' EndLocation = Peek(1).EndLocation }); " is 127.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmStatement,The length of the statement  "							l.Add(new AsmStatement.InstructionStatement() { Location = la.Location' Parent = s' Operation = AsmStatement.InstructionStatement.OpCode.__UNKNOWN__ }); " is 152.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmUnaryExpression,The length of the statement  "							return new PostfixExpression_Access() { PostfixForeExpression = ParseAsmExpression(Scope' Parent)' AccessExpression = new IdentifierExpression("seg") }; " is 152.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmUnaryExpression,The length of the statement  "							return new PostfixExpression_Access() { PostfixForeExpression = ParseAsmExpression(Scope' Parent)' AccessExpression = new IdentifierExpression("offsetof") }; " is 157.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmPrimaryExpression,The length of the statement  "					return new IdentifierExpression(t.LiteralValue' t.LiteralFormat' t.Subformat) { Location = t.Location' EndLocation = t.EndLocation }; " is 133.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmPrimaryExpression,The length of the statement  "									var ex = new AsmRegisterExpression() { Location = t.Location' EndLocation = t.EndLocation' Register = string.Intern(reg) }; " is 123.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmPrimaryExpression,The length of the statement  "									return new UnaryExpression_SegmentBase() { RegisterExpression = ex' UnaryExpression = ParseAsmExpression(Scope' Parent) }; " is 122.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmPrimaryExpression,The length of the statement  "									return new AsmRegisterExpression() { Location = t.Location' EndLocation = t.EndLocation' Register = string.Intern(reg) }; " is 121.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmPrimaryExpression,The length of the statement  "								outer = new PostfixExpression_Access() { AccessExpression = new IdentifierExpression(t.Value)' PostfixForeExpression = outer }; " is 127.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,FunctionBody,The length of the statement  "			// Although there can be in&out constraints' there doesn't have to be a direct body definition. Used on abstract class/interface methods. " is 137.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,FunctionBody,The length of the statement  "			par.EndLocation = IsEOF && t.Kind != DTokens.CloseCurlyBrace ? la.Location : par.Body != null ? par.Body.EndLocation : t.EndLocation; " is 133.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,TemplateParameter,The length of the statement  "			else if (laKind == (Identifier) && (Lexer.CurrentPeekToken.Kind == (Colon) || Lexer.CurrentPeekToken.Kind == (Assign) || Lexer.CurrentPeekToken.Kind == (Comma) || Lexer.CurrentPeekToken.Kind == (CloseParenthesis))) " is 214.
Long Statement,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,TemplateInstance,The length of the statement  "			td = new TemplateInstanceExpression(mod != DTokens.INVALID ? new MemberFunctionAttributeDecl(mod) { InnerType = td } : td) { " is 124.
Long Statement,D_Parser.Parser,DTokens,C:\repos\aBothe_D_Parser\DParser2\Parser\DTokens.cs,GetDescription,The length of the statement  "					return "Disables a declaration\nA reference to a declaration marked with the @disable attribute causes a compile time error\n\nThis can be used to explicitly disallow certain operations \nor overloads at compile time \nrather than relying on generating a runtime error."; " is 271.
Long Statement,D_Parser.Parser,DTokens,C:\repos\aBothe_D_Parser\DParser2\Parser\DTokens.cs,GetDescription,The length of the statement  "					return "Property functions \ncan be called without parentheses (hence acting like properties).\n\nstruct S {\n  int m_x;\n  @property {\n    int x() { return m_x; }\n    int x(int newx) { return m_x = newx; }\n  }\n}\n\nvoid foo() {\n  S s;\n  s.x = 3;   // calls s.x(int)\n  bar(s.x);  // calls bar(s.x())\n}"; " is 311.
Long Statement,D_Parser.Parser,DTokens,C:\repos\aBothe_D_Parser\DParser2\Parser\DTokens.cs,GetDescription,The length of the statement  "					return "Safe functions\n\nThe following operations are not allowed in safe functions:\n\n- No casting from a pointer type to any type other than void*.\n- No casting from any non-pointer type to a pointer type.\n- No modification of pointer values.\n- Cannot access unions that have pointers or references overlapping with other types.\n- Calling any system functions.\n- No catching of exceptions that are not derived from class Exception.\n- No inline assembler.\n- No explicit casting of mutable objects to immutable.\n- No explicit casting of immutable objects to mutable.\n- No explicit casting of thread local objects to shared.\n- No explicit casting of shared objects to thread local.\n- No taking the address of a local variable or function parameter.\n- Cannot access __gshared variables.\n- Functions nested inside safe functions default to being safe functions.\n\nSafe functions are covariant with trusted or system functions."; " is 941.
Long Statement,D_Parser.Parser,DTokens,C:\repos\aBothe_D_Parser\DParser2\Parser\DTokens.cs,GetDescription,The length of the statement  "					return "System functions \nare functions not marked with @safe or @trusted and are not nested inside @safe functions\n\nSystem functions may be marked with the @system attribute.\n \nA function being system does not mean it actually is unsafe' it just means that the compiler is unable to verify that it cannot exhibit undefined behavior.\n\nSystem functions are not covariant with trusted or safe functions."; " is 410.
Long Statement,D_Parser.Parser,DTokens,C:\repos\aBothe_D_Parser\DParser2\Parser\DTokens.cs,GetDescription,The length of the statement  "					return "Trusted functions\n\n- Are marked with the @trusted attribute'\n- Are guaranteed by the programmer to not exhibit \n  any undefined behavior if called by a safe function'\n- May call safe' trusted' or system functions'\n- Are covariant with safe or system functions"; " is 275.
Long Statement,D_Parser.Parser,DTokens,C:\repos\aBothe_D_Parser\DParser2\Parser\DTokens.cs,GetDescription,The length of the statement  "                    return "switch(a)\n{\n   case 1:\n      foo();\n      break;\n   case 2:\n      bar();\n      break;\n   default:\n      break;\n}"; " is 132.
Long Statement,D_Parser.Parser,IncrementalParsingBase<T>,C:\repos\aBothe_D_Parser\DParser2\Parser\IncrementalParsing.cs,ParseIncrementally,The length of the statement  "				var startOff = startLoc.Line > 1 ? DocumentHelper.GetOffsetByRelativeLocation(code' caretLocation' caretOffset' startLoc) : 0; " is 126.
Long Statement,D_Parser.Parser,IncrementalParsingBase<T>,C:\repos\aBothe_D_Parser\DParser2\Parser\IncrementalParsing.cs,ParseIncrementally,The length of the statement  "					// Update the actual tempBlock as well as methods/other blocks' end location that just appeared while parsing the code incrementally' " is 133.
Long Statement,D_Parser.Parser,BlockStmtIncrParsing,C:\repos\aBothe_D_Parser\DParser2\Parser\IncrementalParsing.cs,PrepareParsing,The length of the statement  "				tempParentBlock.Attributes = finalParentMethod.Attributes; // assign given attributes to the temporary block for allowing the completion to check whether static or non-static items may be shown " is 193.
Long Statement,D_Parser.Dom.Statements,CaseStatement,C:\repos\aBothe_D_Parser\DParser2\Dom\Statements\SwitchStatement.cs,ToCode,The length of the statement  "				var ret = "case " + ArgumentList.ToString() + ':' + (IsCaseRange ? (" .. case " + LastExpression.ToString() + ':') : "") + Environment.NewLine; " is 143.
Long Statement,D_Parser.Dom.Expressions,OperatorBasedExpression,C:\repos\aBothe_D_Parser\DParser2\Dom\Expressions\OperatorBasedExpression.cs,ToString,The length of the statement  "			return LeftOperand.ToString() + DTokens.GetTokenString(OperatorToken) + (RightOperand != null ? RightOperand.ToString() : ""); " is 126.
Long Statement,D_Parser.Dom.Expressions,SliceArgument,C:\repos\aBothe_D_Parser\DParser2\Dom\Expressions\PostfixExpression_ArrayAccess.cs,ToString,The length of the statement  "				return LowerBoundExpression.ToString () + ".." + (UpperBoundExpression != null ? UpperBoundExpression.ToString () : string.Empty); " is 130.
Complex Conditional,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,C:\repos\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,GenTooltipSignature,The conditional expression  "currentMethodParam >= 0 && !templateParamCompletion && ds.Definition is DVariable && ds.Base != null"  is complex.
Complex Conditional,D_Parser.Dom,DBlockNode,C:\repos\aBothe_D_Parser\DParser2\Dom\Nodes\DBlockNode.cs,GetMetaBlockStack,The conditional expression  "lastSr != null && !(mindAttributeSections && lastSr is AttributeMetaDeclarationSection) && mb.Location < lastSr.Location && mb.EndLocation > lastSr.EndLocation"  is complex.
Complex Conditional,D_Parser.Formatting,DFormattingVisitor,C:\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,GetCommentsBefore,The conditional expression  "c == ' ' || c == '\t' || c=='\r' || c == '\n'"  is complex.
Complex Conditional,D_Parser.Formatting,DFormattingVisitor,C:\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,ForceSpacesAfterRemoveLines,The conditional expression  "i < document.TextLength && (IsSpacing (c = document[i]) || c == '\r' || c == '\n')"  is complex.
Complex Conditional,D_Parser.Formatting,DFormattingVisitor,C:\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,VisitChildren,The conditional expression  "mbStack.Count == 0 || (mb.Location > (peekMb = mbStack.Peek()).Location &&   					                          mb.EndLocation < peekMb.EndLocation &&   					                          !(peekMb is AttributeMetaDeclarationSection))"  is complex.
Complex Conditional,D_Parser.Formatting.Indent,IndentEngineWrapper,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CorrectIndent,The conditional expression  "code.Peek() == -1 || (formatLastLine && n != '\r' && n != '\n')"  is complex.
Complex Conditional,D_Parser.Formatting.Indent,IndentEngine,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushNewLine,The conditional expression  "keyword == DTokens.Case || keyword == DTokens.Default || !canBeLabel || inside == Inside.Empty"  is complex.
Complex Conditional,D_Parser.Formatting.Indent,IndentEngine,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,PushNewLine,The conditional expression  "(stack.PeekInside(0) == Inside.Block && stack.PeekKeyword == DTokens.Enum)   						||(inside == Inside.FoldedStatement || inside == Inside.SquareBracketList)"  is complex.
Complex Conditional,D_Parser.Formatting.Indent,IndentStack,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,The conditional expression  "(stack [sp].inside & Inside.FoldedBlockOrCase) != 0 ||  						// If there's myFoo( \n { \n' keep the ( indent + 1 tab  						// If there's myFoo( \n [ \n' keep the ( indent only if ie.Options.KeepArgumentIndentOnSquareBracketOpen says so.  						((inside != Inside.SquareBracketList || ie.Options.KeepArgumentIndentOnSquareBracketOpen) && stack[sp].inside == Inside.ParenList)"  is complex.
Complex Conditional,D_Parser.Refactoring,TypeReferenceFinder,C:\repos\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,CheckCondition,The conditional expression  "c == null ||  				c is StaticIfCondition ||   				(c is NegatedDeclarationCondition && (c as NegatedDeclarationCondition).FirstCondition is NegatedDeclarationCondition)"  is complex.
Complex Conditional,D_Parser.Resolver,DTypeToTypeDeclVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\DTypeToTypeDeclVisitor.cs,VisitDSymbol,The conditional expression  "def != null && def != (def = def.Parent as DNode) &&  				def != null && !(def is DModule)"  is complex.
Complex Conditional,D_Parser.Resolver,ResultComparer,C:\repos\aBothe_D_Parser\DParser2\Resolver\ResultComparer.cs,IsImplicitlyConvertible,The conditional expression  "!isVariable &&  				resToCheck is ArrayType &&  				targetType is PointerType && ((targetType = (targetType as PointerType).Base) is PrimitiveType) &&  				DTokens.IsBasicType_Character((targetType as PrimitiveType).TypeToken)"  is complex.
Complex Conditional,D_Parser.Resolver,StaticProperties,C:\repos\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,GetOwnerType,The conditional expression  "t is InstanceValue || t is ClassType || t is InterfaceType || t is TemplateType"  is complex.
Complex Conditional,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,mult,The conditional expression  "(a.Value!=0 && b.Value == 0) || (a.ImaginaryPart!=0 && b.ImaginaryPart==0)"  is complex.
Complex Conditional,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,mult,The conditional expression  "(a.Value!=0 && b.Value == 0) || (a.ImaginaryPart!=0 && b.ImaginaryPart==0)"  is complex.
Complex Conditional,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,GetConstructors,The conditional expression  "dv != null &&  							!dv.IsStatic &&  							!dv.IsAlias &&  							!dv.IsConst"  is complex.
Complex Conditional,D_Parser.Resolver.ASTScanner,AbstractVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,DeepScanClass,The conditional expression  "resolveBaseClassIfRequired && udt.Base == null &&   						(type == DTokens.Class ||type == DTokens.Interface)"  is complex.
Complex Conditional,D_Parser.Resolver.ASTScanner,AbstractVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,CanHandleNode,The conditional expression  "(CanShowMember(dn' ctxt.ScopedBlock) || (parms.isBaseClass && !parms.isMixinAst)) && ((!parms.takeStaticChildrenOnly && (!parms.publicImportsOnly || !parms.isBaseClass)) || IsConstOrStatic(dn))"  is complex.
Complex Conditional,D_Parser.Resolver.ASTScanner,AbstractVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,CanHandleNode,The conditional expression  "dm3 != null && !(dm3.SpecialType == DMethod.MethodType.Normal || dm3.SpecialType == DMethod.MethodType.Delegate || dm3.NameHash != 0)"  is complex.
Complex Conditional,D_Parser.Resolver.ASTScanner,StatementHandler,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,Visit,The conditional expression  "dv.Initializer != null &&  					(caretInsensitive || (dv.Initializer.Location > Caret && dv.Initializer.EndLocation < Caret))"  is complex.
Complex Conditional,D_Parser.Resolver.ASTScanner,StatementHandler,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,VisitSubStatements,The conditional expression  "!(ignoreBounds || caretInsensitive) &&   					(stmtContainer.Location > Caret || stmtContainer.EndLocation < Caret)"  is complex.
Complex Conditional,D_Parser.Resolver.ASTScanner,StatementHandler,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,Visit,The conditional expression  "s.Location < Caret &&   					(s.ScopedStatement == null || s.ScopedStatement.EndLocation >= Caret) &&   					s.ForeachTypeList != null"  is complex.
Complex Conditional,D_Parser.Resolver.Templates,SpecializationOrdering,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\SpecializationOrdering.cs,IsMoreSpecialized,The conditional expression  "dn1 == null || dn1.TemplateParameters == null || dn2 == null || dn2.TemplateParameters == null"  is complex.
Complex Conditional,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The conditional expression  "(arrayDeclToCheckAgainst.ClampsEmpty == (at == null)) &&  				(at == null || !at.IsStaticArray || arrayDeclToCheckAgainst.KeyExpression == null)"  is complex.
Complex Conditional,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The conditional expression  "(d.Parameters == null || d.Parameters.Count == 0) &&  					dr_decl.Parameters == null || dr_decl.Parameters.Count == 0"  is complex.
Complex Conditional,D_Parser.Resolver.Templates,TemplateParameterDeduction,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateAliasParameterDeduction.cs,HandleDecl,The conditional expression  "(dn.Attributes == null || dn.Attributes.Count == 0) &&  							(dn_arg.Attributes == null || dn_arg.Attributes.Count == 0)"  is complex.
Complex Conditional,D_Parser.Resolver.TypeResolution,TypeDeclarationResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,TryPostDeduceAliasDefinition,The conditional expression  "typeBase != null &&  				b != null &&   				b.Tag<AliasTag>(AliasTag.Id) != null &&   				(ctxt.Options & ResolutionOptions.DontResolveAliases) == 0"  is complex.
Complex Conditional,D_Parser.Resolver.TypeResolution,NodeMatchHandleVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,Visit,The conditional expression  "CanResolveBase(tpn) && ttp != null && (ttp.Default != null || ttp.Specialization != null)"  is complex.
Complex Conditional,D_Parser.Resolver.TypeResolution,DResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,ResolveClassOrInterface,The conditional expression  "type == null || (type is IdentifierDeclaration && (type as IdentifierDeclaration).IdHash == dc.NameHash) || dc.NodeRoot == dc"  is complex.
Complex Conditional,D_Parser.Resolver.TypeResolution,DResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,GetResultMember,The conditional expression  "aliasTag != null &&  					(!(aliasTag.aliasDefinition is ImportSymbolAlias) || // Only if the import symbol alias definition was selected' go to its base 					(aliasTag.typeBase != null && aliasTag.aliasDefinition.NameLocation != aliasTag.typeBase.Location))"  is complex.
Complex Conditional,D_Parser.Resolver.TypeResolution,ScopedObjectVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,VisitTemplateParameter,The conditional expression  "tp.NameHash != 0 && 					caret.Line == nl.Line && 					caret.Column >= nl.Column && 					(name = tp.Name) != null && 					caret.Column <= nl.Column + name.Length"  is complex.
Complex Conditional,D_Parser.Resolver.TypeResolution,ScopedObjectVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,VisitDNode,The conditional expression  "n.NameHash != 0 && 					caret.Line == nl.Line && 					caret.Column >= nl.Column && 					(name = n.Name) != null && 					caret.Column <= nl.Column + name.Length"  is complex.
Complex Conditional,D_Parser.Resolver.TypeResolution,UFCSResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\UFCSResolver.cs,PreCheckItem,The conditional expression  "(nameFilterHash != 0 && n.NameHash != nameFilterHash) || (!(n is ImportSymbolNode) && !(n.Parent is DModule))"  is complex.
Complex Conditional,D_Parser.Completion,CompletionProviderVisitor,C:\repos\aBothe_D_Parser\DParser2\Completion\Providers\CompletionProviderVisitor.cs,Visit,The conditional expression  "!halt && n.NameHash == 0 &&   				(n.ContainsAttribute (DTokens.Auto) || DParser.ContainsStorageClass(n.Attributes) != Modifier.Empty)"  is complex.
Complex Conditional,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,AliasDeclaration,The conditional expression  "(laKind == Identifier && Lexer.CurrentPeekToken.Kind == This) ||  				(laKind == This && Lexer.CurrentPeekToken.Kind == Assign)"  is complex.
Complex Conditional,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,AliasDeclaration,The conditional expression  "laKind == Identifier && (Lexer.CurrentPeekToken.Kind == Assign ||   				(Lexer.CurrentPeekToken.Kind == OpenParenthesis && OverPeekBrackets(OpenParenthesis) && Lexer.CurrentPeekToken.Kind == Assign))"  is complex.
Complex Conditional,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Decl,The conditional expression  "(StorageClass != Modifier.Empty &&  			    laKind == (Identifier) && (DeclarationAttributes.Count > 0 || Lexer.CurrentPeekToken.Kind == OpenParenthesis))"  is complex.
Complex Conditional,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Decl,The conditional expression  "isAlias && (laKind == DTokens.This || laKind == DTokens.Super) && Lexer.CurrentPeekToken.Kind != DTokens.Dot"  is complex.
Complex Conditional,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Decl,The conditional expression  "tix.Arguments == null || tix.Arguments.Length == 0 ||  					    (tix.Arguments [tix.Arguments.Length - 1] is TokenExpression &&  					    (tix.Arguments [tix.Arguments.Length - 1] as TokenExpression).Token == DTokens.INVALID)"  is complex.
Complex Conditional,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Declarator,The conditional expression  "(tokDecl == null || tokDecl.Token != DTokens.Incomplete) && // 'T!|' or similar  							(ad == null || !(ad.KeyExpression is TokenExpression) || (ad.KeyExpression as TokenExpression).Token != DTokens.Incomplete)"  is complex.
Complex Conditional,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Declarator2,The conditional expression  "AllowWeakTypeParsing && (td == null||(t.Kind==OpenParenthesis && laKind==CloseParenthesis) /* -- means if an argumentless function call has been made' return null because this would be an expression */|| laKind!=CloseParenthesis)"  is complex.
Complex Conditional,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Parameter,The conditional expression  "(IsParamModifier(laKind) && laKind != InOut) || (IsMemberFunctionAttribute(laKind) && Lexer.CurrentPeekToken.Kind != OpenParenthesis)"  is complex.
Complex Conditional,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,PostfixExpression,The conditional expression  "(laKind == DTokens.Identifier && Peek(1).Kind != Not && Peek(1).Kind != OpenParenthesis) || IsEOF"  is complex.
Complex Conditional,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,PrimaryExpression,The conditional expression  "laKind == Identifier && (Lexer.CurrentPeekToken.Kind == CloseParenthesis || Lexer.CurrentPeekToken.Kind == Equal  						    || Lexer.CurrentPeekToken.Kind == Colon)"  is complex.
Complex Conditional,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,IfCondition,The conditional expression  "tp != null && ((laKind == Identifier &&  				(Peek(1).Kind == Assign || Lexer.CurrentPeekToken.Kind == CloseParenthesis)) || // if(a * b * c) is an expression' if(a * b = 123) may be a pointer variable  				(IsEOF && tp.InnerDeclaration == null))"  is complex.
Complex Conditional,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Statement,The conditional expression  "laKind != Case && laKind != Default && laKind != CloseCurlyBrace && !IsEOF"  is complex.
Complex Conditional,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Statement,The conditional expression  "laKind != Case && laKind != Default && laKind != CloseCurlyBrace && !IsEOF"  is complex.
Complex Conditional,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Statement,The conditional expression  "ds.Declarations != null &&   						ds.Declarations.Length == 1 &&   						!(ds.Declarations[0] is DVariable) &&  						!AllowWeakTypeParsing"  is complex.
Complex Conditional,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Statement,The conditional expression  "IsClassLike(laKind) || (IsBasicType(laKind) && Lexer.CurrentPeekToken.Kind != Dot) || IsModifier(laKind)"  is complex.
Complex Conditional,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmStatement,The conditional expression  "!Expect(CloseCurlyBrace) && (t.Kind == OpenCurlyBrace || t.Kind == Semicolon) && IsEOF"  is complex.
Complex Conditional,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,EnumValue,The conditional expression  "laKind == Identifier && (  				Lexer.CurrentPeekToken.Kind == Assign ||  				Lexer.CurrentPeekToken.Kind == Comma ||  				Lexer.CurrentPeekToken.Kind == CloseCurlyBrace)"  is complex.
Complex Conditional,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,FunctionBody,The conditional expression  "(laKind == In && par.In == null) ||  				(laKind == Out && par.Out == null)"  is complex.
Complex Conditional,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,TemplateParameter,The conditional expression  "laKind == (Identifier) && (Lexer.CurrentPeekToken.Kind == (Colon) || Lexer.CurrentPeekToken.Kind == (Assign) || Lexer.CurrentPeekToken.Kind == (Comma) || Lexer.CurrentPeekToken.Kind == (CloseParenthesis))"  is complex.
Complex Conditional,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,TraitsExpression,The conditional expression  "td != null && (laKind == Comma || laKind == CloseParenthesis || IsEOF)"  is complex.
Complex Conditional,D_Parser.Parser,DDocParser,C:\repos\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,SkipParameterText,The conditional expression  "Peek () == '!' &&  					    nextOffset + 2 < text.Length &&  					    text [nextOffset + 1] == '-' && text [nextOffset + 2] == '-'"  is complex.
Virtual Method Call from Constructor,D_Parser.Resolver,StaticProperties,C:\repos\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,StaticProperties,The constructor "StaticProperties" calls a virtual method "Accept".
Empty Catch Block,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,IsFalseZeroOrNull,The method has an empty catch block.
Empty Catch Block,D_Parser.Resolver.ExpressionSemantics,MathOperationEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MathOperationEvaluation.cs,ToBool,The method has an empty catch block.
Empty Catch Block,D_Parser.Resolver.ExpressionSemantics,MathOperationEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MathOperationEvaluation.cs,ToDouble,The method has an empty catch block.
Empty Catch Block,D_Parser.Resolver.ExpressionSemantics,MathOperationEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MathOperationEvaluation.cs,ToLong,The method has an empty catch block.
Empty Catch Block,D_Parser.Resolver.TypeResolution,TemplateInstanceHandler,C:\repos\aBothe_D_Parser\DParser2\Resolver\Templates\TemplateInstanceHandler.cs,DeduceParamsAndFilterOverloads,The method has an empty catch block.
Empty Catch Block,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,DeclDef,The method has an empty catch block.
Magic Number,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,C:\repos\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,AppendFormat,The following statement contains a magic number: if ((flags & FormatFlags.Color) != 0)  			{  				sb.Append(string.Format(" color='#{0:x2}{1:x2}{2:x2}'"'  					(int)(r * 255.0)' (int)(g * 255.0)' (int)(b * 255.0)));  			}
Magic Number,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,C:\repos\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,AppendFormat,The following statement contains a magic number: if ((flags & FormatFlags.Color) != 0)  			{  				sb.Append(string.Format(" color='#{0:x2}{1:x2}{2:x2}'"'  					(int)(r * 255.0)' (int)(g * 255.0)' (int)(b * 255.0)));  			}
Magic Number,D_Parser.Completion.ToolTips,NodeTooltipRepresentationGen,C:\repos\aBothe_D_Parser\DParser2\Completion\NodeTooltipRepresentationGen.cs,AppendFormat,The following statement contains a magic number: if ((flags & FormatFlags.Color) != 0)  			{  				sb.Append(string.Format(" color='#{0:x2}{1:x2}{2:x2}'"'  					(int)(r * 255.0)' (int)(g * 255.0)' (int)(b * 255.0)));  			}
Magic Number,D_Parser.Dom,DClassLike,C:\repos\aBothe_D_Parser\DParser2\Dom\Nodes\OtherNodeDefinitions.cs,ToString,The following statement contains a magic number: if (BaseClasses.Count > 0)  			{  				sb.Append(':');  				foreach (var c in BaseClasses)  					sb.Append(c.ToString()).Append("' ");  				sb.Remove(sb.Length - 2' 2);  			}
Magic Number,D_Parser.Dom,DClassLike,C:\repos\aBothe_D_Parser\DParser2\Dom\Nodes\OtherNodeDefinitions.cs,ToString,The following statement contains a magic number: if (BaseClasses.Count > 0)  			{  				sb.Append(':');  				foreach (var c in BaseClasses)  					sb.Append(c.ToString()).Append("' ");  				sb.Remove(sb.Length - 2' 2);  			}
Magic Number,D_Parser.Dom,CodeLocation,C:\repos\aBothe_D_Parser\DParser2\Dom\CodeLocation.cs,GetHashCode,The following statement contains a magic number: return unchecked(87 * Column.GetHashCode() ^ Line.GetHashCode());
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return unchecked(100003 * Visit(n as DVariable));
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: long h = 100019 * VisitDNode (n);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1000037;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitBlockNode,The following statement contains a magic number: const long prime = 1000117;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1000039;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return unchecked(1000081 * VisitBlockNode(n));
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1000099;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return unchecked(1000133 * n.Mixin.Accept(this));
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return unchecked(1000231 * Visit((DVariable)ep));
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1000249;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1000253;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1000273;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: const long prime = 1000151;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: return 1000159;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: return unchecked(1000171 * VisitAttribute((Modifier)attr));
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: return 1000183 * (long)a.Kind;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: const long prime = 1000187;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: return 1000193 * ((long)a.VersionNumber + (long)a.VersionIdHash);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: return 1000199 * ((long)a.DebugLevel + (long)a.DebugIdHash);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: const long prime = 1000211;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttribute,The following statement contains a magic number: return unchecked(1000213 * a.FirstCondition.Accept(this));
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000289;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000291;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitImport,The following statement contains a magic number: return 1000303;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitImport,The following statement contains a magic number: return 1000313;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitImport,The following statement contains a magic number: return 1000333;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000357;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000367;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000381;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000393;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000397;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000403;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000409;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000423;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000427;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000429;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000453;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000457;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000507;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000537;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000541;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000547;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000577;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000579;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000589;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000609;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000619;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000621;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000639;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000651;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000667;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000679;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000691;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000697;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000721;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000723;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000763;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000777;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1000793;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitMixinStatement,The following statement contains a magic number: return 1000829;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1000847;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression (x' 1000849);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1000859;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1000861);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1000889);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1000907);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1000919);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1000921);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1000931);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1000969;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1000973);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1000981;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: Hash (ref h' prime' x.Not ? 2 : 1);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1000999);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1001003);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1001017);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1001023);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitOpBasedExpression(x' 1001027);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression(x' 1001041);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression(x' 1001069);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression(x' 1001081);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression(x' 1001087);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression(x' 1001089);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression(x' 1001093);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression(x' 1001107);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression(x' 1001123);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001153;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001159;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001173;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitSimpleUnaryExpression(x' 1001177);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001191;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001197;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitPostfixExpression(x' 1001219);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitPostfixExpression(x' 1001237);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001267;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001279;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001303;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001311;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001321 + (long)x.Token >> 8;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001321 + (long)x.Token >> 8;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001323 + x.Declaration.Accept(this);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001327;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001347;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001353;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001369;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001381;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001387;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001389;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001401;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001411;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001431;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001447;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001459;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001467;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001491;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001501 * x.Register.GetHashCode();
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1001527;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001531;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001549;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001551;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001563;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitTypeDeclaration(td' 1001569);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001587;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001593;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1001621;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return VisitTypeDeclaration(td' 1001629);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitPrimitiveType,The following statement contains a magic number: const long prime = 1001659;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitPointerType,The following statement contains a magic number: return VisitDerivedType (t' 1001669);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitArrayType,The following statement contains a magic number: const long prime = 1001683;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAssocArrayType,The following statement contains a magic number: const long prime = 1001687;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitDelegateCallSymbol,The following statement contains a magic number: const long prime = 1001713;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitDelegateType,The following statement contains a magic number: const long prime = 1001723;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAliasedType,The following statement contains a magic number: return VisitMemberSymbol(t' 1001743);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitEnumType,The following statement contains a magic number: return VisitUserDefinedType (t' 1001783);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitStructType,The following statement contains a magic number: return VisitTemplateIntermediaryType (t' 1001797);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitUnionType,The following statement contains a magic number: return VisitTemplateIntermediaryType (t' 1001801);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitClassType,The following statement contains a magic number: return VisitTemplateIntermediaryType (t' 1001807);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitInterfaceType,The following statement contains a magic number: return VisitTemplateIntermediaryType (t' 1001809);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitTemplateType,The following statement contains a magic number: return VisitTemplateIntermediaryType (t' 1001821);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitMixinTemplateType,The following statement contains a magic number: return VisitTemplateIntermediaryType (t' 1001831);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitEponymousTemplateType,The following statement contains a magic number: return VisitUserDefinedType (t' 1001839);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitStaticProperty,The following statement contains a magic number: return VisitMemberSymbol(t' 1001911);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitMemberSymbol,The following statement contains a magic number: return VisitDSymbol (t' 1001933);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitTemplateParameterSymbol,The following statement contains a magic number: const long prime = 1001941;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitArrayAccessSymbol,The following statement contains a magic number: return VisitDerivedType(t' 1001947);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitModuleSymbol,The following statement contains a magic number: return VisitDSymbol(t' 1001953);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitPackageSymbol,The following statement contains a magic number: const long prime = 1001977;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitDTuple,The following statement contains a magic number: const long prime = 1001981;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitUnknownType,The following statement contains a magic number: return VisitAbstractType(t' 1001983);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAmbigousType,The following statement contains a magic number: const long prime = 1001989;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitMetaDeclarationBlock,The following statement contains a magic number: return 1002017;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttributeMetaDeclarationBlock,The following statement contains a magic number: return 1002049;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttributeMetaDeclarationSection,The following statement contains a magic number: return 1002061;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitElseMetaDeclarationBlock,The following statement contains a magic number: return 1002073;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitElseMetaDeclarationSection,The following statement contains a magic number: return 1002151;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitElseMetaDeclaration,The following statement contains a magic number: return 1002077;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAttributeMetaDeclaration,The following statement contains a magic number: return 1002083;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitTemplateParameter,The following statement contains a magic number: const long prime = 1002091;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1002101;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1002109;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1002121;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: const long prime = 1002143;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,Visit,The following statement contains a magic number: return 1002149 * VisitTemplateParameter(tp);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitErrorValue,The following statement contains a magic number: const long prime = 1002173;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitPrimitiveValue,The following statement contains a magic number: const long prime = 1002191;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitVoidValue,The following statement contains a magic number: return VisitExpressionValue (v' 1002227);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitArrayValue,The following statement contains a magic number: const long prime = 1002241;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitAssociativeArrayValue,The following statement contains a magic number: const long prime = 1002247;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitDelegateValue,The following statement contains a magic number: const long prime = 1002257;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitNullValue,The following statement contains a magic number: return VisitExpressionValue (v' 1002259);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitTypeOverloadValue,The following statement contains a magic number: const long prime = 1002263;
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitVariableValue,The following statement contains a magic number: return VisitReferenceValue(v' 1002289);
Magic Number,D_Parser.Dom.Visitors,AstElementHashingVisitor,C:\repos\aBothe_D_Parser\DParser2\Dom\Visitors\AstElementHashingVisitor.cs,VisitTypeValue,The following statement contains a magic number: return VisitExpressionValue (v' 1002299);
Magic Number,D_Parser.Formatting,DFormattingVisitor,C:\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,Visit,The following statement contains a magic number: switch(n.SpecialType)  			{  				case DMethod.MethodType.Destructor:  				case DMethod.MethodType.Constructor:  					nameLength = 4; // this  					break;  				case DMethod.MethodType.Normal:  					nameLength = n.Name.Length;  					break;  			}
Magic Number,D_Parser.Formatting,TextDocument,C:\repos\aBothe_D_Parser\DParser2\Formatting\DocumentAdapter.cs,ToLocation,The following statement contains a magic number: if(offset < text.Length/2)  			{  				for(int i = 1; i < lines.Length; i++)  				{  					if(lines[i] > offset)  						return new CodeLocation(offset - lines[i-1] + 1' i);  				}  				return new CodeLocation(offset - lines[lines.Length-1] + 1' lines.Length);  			}  			else  			{  				for(int i = lines.Length-1; i > 0; i--)  				{  					if(lines[i] < offset)  						return new CodeLocation(offset - lines[i] + 1' i+1);  				}  				return new CodeLocation(offset + 1' 1);  			}
Magic Number,D_Parser.Formatting.Indent,IndentEngineWrapper,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngineWrapper.cs,CalculateIndent,The following statement contains a magic number: if(line < 2)  				return string.Empty;
Magic Number,D_Parser.Formatting.Indent,IndentEngine,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,WordIsKeyword,The following statement contains a magic number: var kw = DTokens.GetTokenID(linebuf.ToString (wordStart' Math.Min (linebuf.Length - wordStart' 15)));
Magic Number,D_Parser.Formatting.Indent,IndentEngine,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,Push,The following statement contains a magic number: switch (c) {  			case '#':  				PushHash (inside);  				lastChar = '#';  				break;  			case '/':  				PushSlash (inside);  				break;  			case '\\':  				PushBackSlash (inside);  				break;  			case '+':  			case '*':  				PushStar (inside'c);  				break;  			case '`':  				PushAccGrave(inside);  				break;  			case '"':  				PushQuote (inside);  				break;  			case '\'':  				PushSQuote (inside);  				break;  			case ':':  				PushColon (inside);  				break;  			case ';':  				PushSemicolon (inside);  				break;  			case '[':  				PushOpenSq (inside);  				break;  			case ']':  				PushCloseSq (inside);  				break;  			case '(':  				PushOpenParen (inside);  				break;  			case ')':  				PushCloseParen (inside);  				break;  			case '{':  				PushOpenBrace (inside);  				break;  			case '}':  				PushCloseBrace (inside);  				break;  			case '\r':  				CheckForParentList ();  				PushNewLine (inside);  				lastChar = c;  				return;  			case '\n':  				CheckForParentList ();  				  				if (lastChar == '\r') {  					cursor++;  				} else {  					PushNewLine (inside);  				}  				lastChar = c;  				return;  				case 'e': // If there's an 'else'' look if there has been a if-else backup stack prepared  					//KNOWN ISSUE: Reset this backup stack if there's anything else than an 'else' following the recently closed if-stmt;   					// Anyway this shouldn't be noticed that often as there can't be a stand-alone 'else' dangling around somewhere.   					if (linebuf.Length > 2 && linebuf.ToString (linebuf.Length - 3' 3) == "els") {  						var backup = stack.PeekIfElseBackupStack;  						stack.PeekIfElseBackupStack = null;  						if (backup != null && backup.Count > 0) {  							keyword = DTokens.Else;  							inside = Inside.FoldedStatement;  							stack = backup;  							stack.Pop ();  							var newIndent = stack.PeekIndent (0);				  							if (curIndent != newIndent) {  								curIndent = newIndent;  								needsReindent = true;  							}  						}  					}  					break;  			default:  				break;  			}
Magic Number,D_Parser.Formatting.Indent,IndentEngine,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,Push,The following statement contains a magic number: switch (c) {  			case '#':  				PushHash (inside);  				lastChar = '#';  				break;  			case '/':  				PushSlash (inside);  				break;  			case '\\':  				PushBackSlash (inside);  				break;  			case '+':  			case '*':  				PushStar (inside'c);  				break;  			case '`':  				PushAccGrave(inside);  				break;  			case '"':  				PushQuote (inside);  				break;  			case '\'':  				PushSQuote (inside);  				break;  			case ':':  				PushColon (inside);  				break;  			case ';':  				PushSemicolon (inside);  				break;  			case '[':  				PushOpenSq (inside);  				break;  			case ']':  				PushCloseSq (inside);  				break;  			case '(':  				PushOpenParen (inside);  				break;  			case ')':  				PushCloseParen (inside);  				break;  			case '{':  				PushOpenBrace (inside);  				break;  			case '}':  				PushCloseBrace (inside);  				break;  			case '\r':  				CheckForParentList ();  				PushNewLine (inside);  				lastChar = c;  				return;  			case '\n':  				CheckForParentList ();  				  				if (lastChar == '\r') {  					cursor++;  				} else {  					PushNewLine (inside);  				}  				lastChar = c;  				return;  				case 'e': // If there's an 'else'' look if there has been a if-else backup stack prepared  					//KNOWN ISSUE: Reset this backup stack if there's anything else than an 'else' following the recently closed if-stmt;   					// Anyway this shouldn't be noticed that often as there can't be a stand-alone 'else' dangling around somewhere.   					if (linebuf.Length > 2 && linebuf.ToString (linebuf.Length - 3' 3) == "els") {  						var backup = stack.PeekIfElseBackupStack;  						stack.PeekIfElseBackupStack = null;  						if (backup != null && backup.Count > 0) {  							keyword = DTokens.Else;  							inside = Inside.FoldedStatement;  							stack = backup;  							stack.Pop ();  							var newIndent = stack.PeekIndent (0);				  							if (curIndent != newIndent) {  								curIndent = newIndent;  								needsReindent = true;  							}  						}  					}  					break;  			default:  				break;  			}
Magic Number,D_Parser.Formatting.Indent,IndentEngine,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentEngine.cs,Push,The following statement contains a magic number: switch (c) {  			case '#':  				PushHash (inside);  				lastChar = '#';  				break;  			case '/':  				PushSlash (inside);  				break;  			case '\\':  				PushBackSlash (inside);  				break;  			case '+':  			case '*':  				PushStar (inside'c);  				break;  			case '`':  				PushAccGrave(inside);  				break;  			case '"':  				PushQuote (inside);  				break;  			case '\'':  				PushSQuote (inside);  				break;  			case ':':  				PushColon (inside);  				break;  			case ';':  				PushSemicolon (inside);  				break;  			case '[':  				PushOpenSq (inside);  				break;  			case ']':  				PushCloseSq (inside);  				break;  			case '(':  				PushOpenParen (inside);  				break;  			case ')':  				PushCloseParen (inside);  				break;  			case '{':  				PushOpenBrace (inside);  				break;  			case '}':  				PushCloseBrace (inside);  				break;  			case '\r':  				CheckForParentList ();  				PushNewLine (inside);  				lastChar = c;  				return;  			case '\n':  				CheckForParentList ();  				  				if (lastChar == '\r') {  					cursor++;  				} else {  					PushNewLine (inside);  				}  				lastChar = c;  				return;  				case 'e': // If there's an 'else'' look if there has been a if-else backup stack prepared  					//KNOWN ISSUE: Reset this backup stack if there's anything else than an 'else' following the recently closed if-stmt;   					// Anyway this shouldn't be noticed that often as there can't be a stand-alone 'else' dangling around somewhere.   					if (linebuf.Length > 2 && linebuf.ToString (linebuf.Length - 3' 3) == "els") {  						var backup = stack.PeekIfElseBackupStack;  						stack.PeekIfElseBackupStack = null;  						if (backup != null && backup.Count > 0) {  							keyword = DTokens.Else;  							inside = Inside.FoldedStatement;  							stack = backup;  							stack.Pop ();  							var newIndent = stack.PeekIndent (0);				  							if (curIndent != newIndent) {  								curIndent = newIndent;  								needsReindent = true;  							}  						}  					}  					break;  			default:  				break;  			}
Magic Number,D_Parser.Formatting.Indent,IndentStack,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,The following statement contains a magic number: if (size == stack.Length)  				Array.Resize <Node> (ref stack' 2 * size);
Magic Number,D_Parser.Formatting.Indent,IndentStack,C:\repos\aBothe_D_Parser\DParser2\Formatting\Indent\IndentStack.cs,Push,The following statement contains a magic number: if (size == stack.Length)  				Array.Resize <Node> (ref stack' 2 * size);
Magic Number,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The following statement contains a magic number: switch(p)  			{  				case 'n':  					r.Read();  					return new TokenExpression(DTokens.Null);  				case 'N':  					r.Read();  					return new IdentifierExpression(-Number()' LiteralFormat.Scalar' LiteralSubformat.Integer);  				case 'i':  					r.Read();  					return new IdentifierExpression(-Number()' LiteralFormat.Scalar' LiteralSubformat.Integer | LiteralSubformat.Imaginary);  				case 'e': // HexFloat  					r.Read();  					return HexFloat();  				case 'c': // Complex  					r.Read();  					var re = HexFloat();  					r.Read(); // Skip further c  					var im = HexFloat();  					//TODO  					return re;  				case 'H':  				case 'A':  				case 'S':  					r.Read();  					var n = (int)Number();  					var xx = new List<IExpression>();  					for(int i = n; i > 0; i--)  						xx.Add(Value());  					  					if(p == 'S')  					{  						var inits = new List<StructMemberInitializer>(xx.Count);  						  						for(int i = n-1; i >= 0; i--)  							inits.Add(new StructMemberInitializer{Value = xx[i]});  						  						return new StructInitializer{MemberInitializers = inits.ToArray()};  					}  					  					if(p == 'H' || PeekIsValue) // We've got an AA  					{  						for(int i = n; i > 0; i--)  							xx.Add(Value());  						  						var kv = new List<KeyValuePair<IExpression'IExpression>>(n);  						  						for(int i = (n*2) - 1; i > 0; i-=2)  							kv.Add(new KeyValuePair<IExpression'IExpression>(xx[i-1]'xx[i]));  						  						return new AssocArrayExpression{ Elements = kv };  					}  					return new ArrayLiteralExpression(xx);  				case 'a':  				case 'w':  				case 'd':  					r.Read();  					var len = (int)Number();  					sb.Clear();  					  					for(;len > 0; len--)  						sb.Append((char)(Lexer.GetHexNumber((char)r.Read()) << 4 + Lexer.GetHexNumber((char)r.Read())));  					  					return new IdentifierExpression(sb.ToString()'   					                                LiteralFormat.StringLiteral' p == 'a' ?   					                                	LiteralSubformat.Utf8 : (p == 'w' ?   					                                    LiteralSubformat.Utf16 :   					                                                         LiteralSubformat.Utf32));  			}
Magic Number,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The following statement contains a magic number: switch(p)  			{  				case 'n':  					r.Read();  					return new TokenExpression(DTokens.Null);  				case 'N':  					r.Read();  					return new IdentifierExpression(-Number()' LiteralFormat.Scalar' LiteralSubformat.Integer);  				case 'i':  					r.Read();  					return new IdentifierExpression(-Number()' LiteralFormat.Scalar' LiteralSubformat.Integer | LiteralSubformat.Imaginary);  				case 'e': // HexFloat  					r.Read();  					return HexFloat();  				case 'c': // Complex  					r.Read();  					var re = HexFloat();  					r.Read(); // Skip further c  					var im = HexFloat();  					//TODO  					return re;  				case 'H':  				case 'A':  				case 'S':  					r.Read();  					var n = (int)Number();  					var xx = new List<IExpression>();  					for(int i = n; i > 0; i--)  						xx.Add(Value());  					  					if(p == 'S')  					{  						var inits = new List<StructMemberInitializer>(xx.Count);  						  						for(int i = n-1; i >= 0; i--)  							inits.Add(new StructMemberInitializer{Value = xx[i]});  						  						return new StructInitializer{MemberInitializers = inits.ToArray()};  					}  					  					if(p == 'H' || PeekIsValue) // We've got an AA  					{  						for(int i = n; i > 0; i--)  							xx.Add(Value());  						  						var kv = new List<KeyValuePair<IExpression'IExpression>>(n);  						  						for(int i = (n*2) - 1; i > 0; i-=2)  							kv.Add(new KeyValuePair<IExpression'IExpression>(xx[i-1]'xx[i]));  						  						return new AssocArrayExpression{ Elements = kv };  					}  					return new ArrayLiteralExpression(xx);  				case 'a':  				case 'w':  				case 'd':  					r.Read();  					var len = (int)Number();  					sb.Clear();  					  					for(;len > 0; len--)  						sb.Append((char)(Lexer.GetHexNumber((char)r.Read()) << 4 + Lexer.GetHexNumber((char)r.Read())));  					  					return new IdentifierExpression(sb.ToString()'   					                                LiteralFormat.StringLiteral' p == 'a' ?   					                                	LiteralSubformat.Utf8 : (p == 'w' ?   					                                    LiteralSubformat.Utf16 :   					                                                         LiteralSubformat.Utf32));  			}
Magic Number,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The following statement contains a magic number: switch(p)  			{  				case 'n':  					r.Read();  					return new TokenExpression(DTokens.Null);  				case 'N':  					r.Read();  					return new IdentifierExpression(-Number()' LiteralFormat.Scalar' LiteralSubformat.Integer);  				case 'i':  					r.Read();  					return new IdentifierExpression(-Number()' LiteralFormat.Scalar' LiteralSubformat.Integer | LiteralSubformat.Imaginary);  				case 'e': // HexFloat  					r.Read();  					return HexFloat();  				case 'c': // Complex  					r.Read();  					var re = HexFloat();  					r.Read(); // Skip further c  					var im = HexFloat();  					//TODO  					return re;  				case 'H':  				case 'A':  				case 'S':  					r.Read();  					var n = (int)Number();  					var xx = new List<IExpression>();  					for(int i = n; i > 0; i--)  						xx.Add(Value());  					  					if(p == 'S')  					{  						var inits = new List<StructMemberInitializer>(xx.Count);  						  						for(int i = n-1; i >= 0; i--)  							inits.Add(new StructMemberInitializer{Value = xx[i]});  						  						return new StructInitializer{MemberInitializers = inits.ToArray()};  					}  					  					if(p == 'H' || PeekIsValue) // We've got an AA  					{  						for(int i = n; i > 0; i--)  							xx.Add(Value());  						  						var kv = new List<KeyValuePair<IExpression'IExpression>>(n);  						  						for(int i = (n*2) - 1; i > 0; i-=2)  							kv.Add(new KeyValuePair<IExpression'IExpression>(xx[i-1]'xx[i]));  						  						return new AssocArrayExpression{ Elements = kv };  					}  					return new ArrayLiteralExpression(xx);  				case 'a':  				case 'w':  				case 'd':  					r.Read();  					var len = (int)Number();  					sb.Clear();  					  					for(;len > 0; len--)  						sb.Append((char)(Lexer.GetHexNumber((char)r.Read()) << 4 + Lexer.GetHexNumber((char)r.Read())));  					  					return new IdentifierExpression(sb.ToString()'   					                                LiteralFormat.StringLiteral' p == 'a' ?   					                                	LiteralSubformat.Utf8 : (p == 'w' ?   					                                    LiteralSubformat.Utf16 :   					                                                         LiteralSubformat.Utf32));  			}
Magic Number,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The following statement contains a magic number: if(Lexer.IsLegalDigit(p' 10))  				return new IdentifierExpression(Number()' LiteralFormat.Scalar' LiteralSubformat.Integer);
Magic Number,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,HexFloat,The following statement contains a magic number: if(r.Peek() == 'P')  			{  				r.Read();  				var exp = Exponent();  				n *= (decimal)Math.Pow(10' exp);  			}
Magic Number,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,HexDigits,The following statement contains a magic number: return Lexer.ParseFloatValue(sb' 16);
Magic Number,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Number,The following statement contains a magic number: return Lexer.ParseFloatValue(sb' 10);
Magic Number,D_Parser.Refactoring,SortImportsRefactoring,C:\repos\aBothe_D_Parser\DParser2\Refactoring\SortImportsRefactoring.cs,ResortImports,The following statement contains a magic number: if (importsToSort.Count < 2)  				return;
Magic Number,D_Parser.Refactoring,SortImportsRefactoring,C:\repos\aBothe_D_Parser\DParser2\Refactoring\SortImportsRefactoring.cs,CalculateImportsToSort,The following statement contains a magic number: if (importsToSort.Count < 2)  				return new List<KeyValuePair<List<DAttribute>'List<ImportStatement>>>();
Magic Number,D_Parser.Resolver,MixinAnalysis,C:\repos\aBothe_D_Parser\DParser2\Resolver\MixinAnalysis.cs,CheckAndPushAnalysisStack,The following statement contains a magic number: if(stmtsBeingAnalysed.Count != 0)  			{  				if(stmtsBeingAnalysed.Count > 5)  					return null;    				/*  				 * Only accept mixins that are located somewhere BEFORE the mixin that is the last inserted one in the stack.  				 * Also make sure mx and the peek mixin do have the same module root!  				 */  				var nr = mx.ParentNode != null ? mx.ParentNode.NodeRoot : null;  				foreach(var pk in stmtsBeingAnalysed)  				{  					if(nr == pk.ParentNode.NodeRoot)  					{  						if(mx == pk || mx.Location >= pk.Location)  							return null;  						break;  					}  				}  			}
Magic Number,D_Parser.Resolver,ResultComparer,C:\repos\aBothe_D_Parser\DParser2\Resolver\ResultComparer.cs,IsPrimitiveTypeImplicitlyConvertible,The following statement contains a magic number: return fromType == toType || ImplicitConvertabilityTable.Contains((fromType << 8) + toType);
Magic Number,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The following statement contains a magic number: if (x is XorExpression)  			{  				return HandleSingleMathOp(x' l'r' (a'b)=> {  					if(ev.EnsureIntegralType(x.LeftOperand'a) && ev.EnsureIntegralType(x.RightOperand'b))  						return (long)a.Value ^ (long)b.Value;  					return 0L;  				});  			}  			else if (x is OrExpression)  			{  				return HandleSingleMathOp(x' l' r' (a' b) => {  					if(ev.EnsureIntegralType(x.LeftOperand'a) && ev.EnsureIntegralType(x.RightOperand'b))  						return (long)a.Value | (long)b.Value;                    	return 0L;  				});  			}  			else if (x is AndExpression)  			{  				return HandleSingleMathOp(x' l' r' (a' b) => {  					if(ev.EnsureIntegralType(x.LeftOperand'a) && ev.EnsureIntegralType(x.RightOperand'b))  												return (long)a.Value & (long)b.Value;  				                          	return 0L;  				});  			}  			else if (x is ShiftExpression)   				return HandleSingleMathOp(x' l' r' (a' b) => {  					if(!ev.EnsureIntegralType(x.LeftOperand' a) || !ev.EnsureIntegralType(x.RightOperand' b))  				                          		return 0L;  					if (b.Value < 0 || b.Value > 31){  						ev.EvalError(x' "Shift operand must be between 0 and 31"' new[]{b});  						return 0m;  					}    					switch(x.OperatorToken)  					{  						case DTokens.ShiftLeft:  							return (long)a.Value << (int)b.Value; // TODO: Handle the imaginary part  						case DTokens.ShiftRight:  							return (long)a.Value >> (int)b.Value;  						case DTokens.ShiftRightUnsigned: //TODO: Find out where's the difference between >> and >>>  							return (ulong)a.Value >> (int)(uint)b.Value;  					}    					ev.EvalError(x' "Invalid token for shift expression"' new[]{l'r});  					return 0m;  				});  			else if (x is AddExpression)  				return HandleSingleMathOp(x' l' r' (a' b' op) =>  				{  					switch (op.OperatorToken)  					{  						case DTokens.Plus:  							return new PrimitiveValue(a.BaseTypeToken' a.Value + b.Value' a.ImaginaryPart + b.ImaginaryPart' a.Modifier);  						case DTokens.Minus:  							return new PrimitiveValue(a.BaseTypeToken' a.Value - b.Value' a.ImaginaryPart - b.ImaginaryPart' a.Modifier);  					}    					ev.EvalError(op' "Invalid token for add/sub expression"' new[]{l'r});  					return null;  				});
Magic Number,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The following statement contains a magic number: switch(te.Keyword)  			{  				case "":  				case null:  					return null;  					  				case "hasMember":  					bool ret = false;  					var optionsBackup = ctxt.ContextIndependentOptions;  					ctxt.ContextIndependentOptions = ResolutionOptions.IgnoreAllProtectionAttributes;  					  					AbstractType t;  					var pfa = ExpressionTypeEvaluation.prepareMemberTraitExpression(ctxt' te' out t' ValueProvider);  					  					if(pfa != null && t != null)  					{  						t.NonStaticAccess = true;  						ignoreErrors = true;  						var res = ExpressionTypeEvaluation.EvaluateType(pfa' ctxt' false);  						ret = res != null;  						ignoreErrors = false;  					}  					ctxt.ContextIndependentOptions = optionsBackup;  					return new PrimitiveValue(ret);  					  					  				case "identifier":  					if(te.Arguments!=null && te.Arguments.Length == 1)  						return new ArrayValue(GetStringType()' te.Arguments[0].ToString());  					break;  					  					  				case "getMember":  					pfa = ExpressionTypeEvaluation.prepareMemberTraitExpression(ctxt' te' out t' ValueProvider);  					  					if(pfa == null ||t == null)  						break;  					  					var vs = EvalPostfixAccessExpression(this' ctxt' pfa't' ValueProvider:ValueProvider);  					if(vs == null || vs.Length == 0)  						return null;  					return vs[0];  					  					  				case "getOverloads":  					optionsBackup = ctxt.ContextIndependentOptions;  					ctxt.ContextIndependentOptions = ResolutionOptions.IgnoreAllProtectionAttributes;    					pfa = ExpressionTypeEvaluation.prepareMemberTraitExpression(ctxt' te' out t' ValueProvider);    					if (pfa != null && t != null)  						vs = EvalPostfixAccessExpression(this' ctxt' pfa' t);  					else  						vs = null;  					  					ctxt.ContextIndependentOptions = optionsBackup;  					  					return new TypeValue(new DTuple(vs));  					  					  				case "getProtection":  					optionsBackup = ctxt.ContextIndependentOptions;  					ctxt.ContextIndependentOptions = ResolutionOptions.IgnoreAllProtectionAttributes;  					  					var prot = "public";  					  					if(te.Arguments == null || te.Arguments.Length != 1 || te.Arguments[0] == null)  						EvalError(te' "First trait argument must be a symbol identifier");  					else  					{  						t = ExpressionTypeEvaluation.ResolveTraitArgument(ctxt'te.Arguments[0]);  						  						if(t is DSymbol)  						{  							var dn = (t as DSymbol).Definition;  							  							if(dn.ContainsAttribute(DTokens.Private))  								prot = "private";  							else if(dn.ContainsAttribute(DTokens.Protected))  								prot = "protected";  							else if(dn.ContainsAttribute(DTokens.Package))  								prot = "package";  							else if(dn.ContainsAttribute(DTokens.Export))  								prot = "export";  						}  						else  							EvalError(te' "First argument must evaluate to an existing code symbol");  					}  					  					ctxt.ContextIndependentOptions = optionsBackup;  					return new ArrayValue(GetStringType()' prot);					  					  				case "getVirtualFunctions":  					break;  				case "getVirtualMethods":  					break;  				case "parent":  					break;  				case "classInstanceSize":  					break;  				case "allMembers":  					break;  				case "derivedMembers":  					break;  					  				case "isSame":  					ret = false;  					  					if(te.Arguments == null || te.Arguments.Length < 2)  					{  						EvalError(te' "isSame requires two arguments to compare");  					}  					else  					{  						t = ExpressionTypeEvaluation.ResolveTraitArgument(ctxt' te.Arguments[0]);  						  						if(t != null)  						{  							var t2 = ExpressionTypeEvaluation.ResolveTraitArgument(ctxt' te.Arguments[1]);  							  							if(t2 != null)  								ret = Resolver.ResultComparer.IsEqual(t't2);  						}  					}  					  					return new PrimitiveValue(ret);  					  				case "compiles":  					ret = false;  					  					if(te.Arguments != null){  						foreach(var arg in te.Arguments)  						{  							ret = arg == null || ExpressionTypeEvaluation.ResolveTraitArgument(ctxt' arg) != null;  							  							if(!ret)  								break;  						}  					}  						  					return new PrimitiveValue(ret);  			}
Magic Number,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,EvaluateType,The following statement contains a magic number: long cacheHashBias = tryReturnMethodReturnType ? 31 : 0;
Magic Number,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,prepareMemberTraitExpression,The following statement contains a magic number: if (te.Arguments != null && te.Arguments.Length == 2)  			{  				var tEx = te.Arguments[0];  				t = DResolver.StripMemberSymbols(ResolveTraitArgument(ctxt' tEx));    				if (t == null)  					ctxt.LogError(te' "First argument didn't resolve to a type");  				else if (te.Arguments[1].AssignExpression != null)  				{  					var litEx = te.Arguments[1].AssignExpression;  					var v = vp != null ? Evaluation.EvaluateValue(litEx' vp) : Evaluation.EvaluateValue(litEx' ctxt);  					  					if (v is ArrayValue && (v as ArrayValue).IsString)  					{  						var av = v as ArrayValue;    						// Mock up a postfix_access expression to ensure static properties & ufcs methods are checked either  						return new PostfixExpression_Access  						{  							PostfixForeExpression = tEx.AssignExpression ?? new TypeDeclarationExpression(tEx.Type)'  							AccessExpression = new IdentifierExpression(av.StringValue)  							{  								Location = litEx.Location'  								EndLocation = litEx.EndLocation  							}'  							EndLocation = litEx.EndLocation  						};  					}  					else  						ctxt.LogError(litEx' "Second traits argument must evaluate to a string literal");  				}  				else  					ctxt.LogError(te' "Second traits argument must be an expression");  			}
Magic Number,D_Parser.Resolver.ExpressionSemantics,ArrayValue,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,The following statement contains a magic number: if (elements != null) {  				foreach (var e in elements)  					if (e == null)  						sb.Append ("[null]' ");  					else  						sb.Append (e.ToCode ()).Append ("' ");  				if (elements.Length > 0)  					sb.Remove (sb.Length-2' 2);  			}
Magic Number,D_Parser.Resolver.ExpressionSemantics,ArrayValue,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,The following statement contains a magic number: if (elements != null) {  				foreach (var e in elements)  					if (e == null)  						sb.Append ("[null]' ");  					else  						sb.Append (e.ToCode ()).Append ("' ");  				if (elements.Length > 0)  					sb.Remove (sb.Length-2' 2);  			}
Magic Number,D_Parser.Resolver.ExpressionSemantics,AssociativeArrayValue,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,The following statement contains a magic number: if (Elements != null) {  				foreach (var e in Elements) {  					sb.Append (e.Key == null ? "[null]" : e.Key.ToCode ()).Append (':');  					sb.Append (e.Value == null ? "[null]" : e.Value.ToCode ()).Append ("' ");  				}  				sb.Remove (sb.Length - 2' 2);  			}
Magic Number,D_Parser.Resolver.ExpressionSemantics,AssociativeArrayValue,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,The following statement contains a magic number: if (Elements != null) {  				foreach (var e in Elements) {  					sb.Append (e.Key == null ? "[null]" : e.Key.ToCode ()).Append (':');  					sb.Append (e.Value == null ? "[null]" : e.Value.ToCode ()).Append ("' ");  				}  				sb.Remove (sb.Length - 2' 2);  			}
Magic Number,D_Parser.Resolver.ASTScanner,NameScan,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\NameScan.cs,SearchAndResolve,The following statement contains a magic number: if(stackSize++ < 7)  				scan.IterateThroughScopeLayers(caret);
Magic Number,D_Parser.Resolver.TypeResolution,NodeMatchHandleVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\TypeDeclarationResolver.cs,CanResolveBase,The following statement contains a magic number: return ((ctxt.Options & ResolutionOptions.DontResolveBaseTypes) != ResolutionOptions.DontResolveBaseTypes) &&  						stkC < 4 &&   						(!(m.Type is IdentifierDeclaration) || (m.Type as IdentifierDeclaration).IdHash != m.NameHash || m.Type.InnerDeclaration != null);
Magic Number,D_Parser.Resolver.TypeResolution,DResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,ResolveClassOrInterface,The following statement contains a magic number: if (bcStack > 6 || (instanceDeclaration != null && parsedClassInstanceDecls.Contains(instanceDeclaration))) 			{ 				return isClass ? new ClassType(dc' null) as TemplateIntermediateType : new InterfaceType(dc); 			}
Magic Number,D_Parser.Resolver.TypeResolution,DResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,SearchRegionAt,The following statement contains a magic number: while (len > 0) 			{ 				midIndex = (len % 2 + len) / 2;  				// Take an element from the middle 				if ((midElement = childGetter(start + midIndex - 1)) == null) 					break;  				// If 'Where' is beyond its start location 				if (Where >= midElement.Location) 				{ 					start += midIndex;  					// If we've reached the (temporary) goal' break immediately 					if (Where <= midElement.EndLocation) 						break; 					// If it's the last tested element and if the caret is beyond the end location'  					// return the Parent instead the last tested child 					else if (midIndex == len) 					{ 						midElement = default(SR); 						break; 					} 				} 				else if (midIndex == len) 				{ 					midElement = default(SR); 					break; 				}  				len -= midIndex; 			}
Magic Number,D_Parser.Resolver.TypeResolution,DResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,SearchRegionAt,The following statement contains a magic number: while (len > 0) 			{ 				midIndex = (len % 2 + len) / 2;  				// Take an element from the middle 				if ((midElement = childGetter(start + midIndex - 1)) == null) 					break;  				// If 'Where' is beyond its start location 				if (Where >= midElement.Location) 				{ 					start += midIndex;  					// If we've reached the (temporary) goal' break immediately 					if (Where <= midElement.EndLocation) 						break; 					// If it's the last tested element and if the caret is beyond the end location'  					// return the Parent instead the last tested child 					else if (midIndex == len) 					{ 						midElement = default(SR); 						break; 					} 				} 				else if (midIndex == len) 				{ 					midElement = default(SR); 					break; 				}  				len -= midIndex; 			}
Magic Number,D_Parser.Resolver.TypeResolution,DResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,SearchRegionAt,The following statement contains a magic number: while (len > 0) 			{ 				midIndex = (len % 2 + len) / 2;  				// Take an element from the middle 				if ((midElement = children[start + midIndex - 1]) == null) 					break;  				// If 'Where' is beyond its start location 				if (Where > midElement.Location) 				{ 					start += midIndex;  					// If we've reached the (temporary) goal' break immediately 					if (Where < midElement.EndLocation) 						break; 					// If it's the last tested element and if the caret is beyond the end location'  					// return the Parent instead the last tested child 					else if (midIndex == len) 					{ 						midElement = default(SR); 						break; 					} 				} 				else if (midIndex == len) 				{ 					midElement = default(SR); 					break; 				}  				len -= midIndex; 			}
Magic Number,D_Parser.Resolver.TypeResolution,DResolver,C:\repos\aBothe_D_Parser\DParser2\Resolver\TypeResolution\Resolver.cs,SearchRegionAt,The following statement contains a magic number: while (len > 0) 			{ 				midIndex = (len % 2 + len) / 2;  				// Take an element from the middle 				if ((midElement = children[start + midIndex - 1]) == null) 					break;  				// If 'Where' is beyond its start location 				if (Where > midElement.Location) 				{ 					start += midIndex;  					// If we've reached the (temporary) goal' break immediately 					if (Where < midElement.EndLocation) 						break; 					// If it's the last tested element and if the caret is beyond the end location'  					// return the Parent instead the last tested child 					else if (midIndex == len) 					{ 						midElement = default(SR); 						break; 					} 				} 				else if (midIndex == len) 				{ 					midElement = default(SR); 					break; 				}  				len -= midIndex; 			}
Magic Number,D_Parser.Completion,CodeCompletion,C:\repos\aBothe_D_Parser\DParser2\Completion\CodeCompletion.cs,IsCompletionAllowed,The following statement contains a magic number: if (Editor.CaretOffset > 0)  			{  				if (Editor.CaretLocation.Line == 1 && Editor.ModuleCode.Length > 0 && Editor.ModuleCode[0] == '#')  					return false;    				if (enteredChar == '.' || enteredChar == '_')  				{  					// Don't complete on a double/multi-dot  					if (Editor.CaretOffset > 1 && Editor.ModuleCode[Editor.CaretOffset - 2] == enteredChar)   						// ISSUE: When a dot was typed' off-1 is the dot position'   						// if a letter was typed' off-1 is the char before the typed letter..  						return false;  				}  				// If typing a begun identifier' return immediately  				else if ((Lexer.IsIdentifierPart(enteredChar) || enteredChar == '\0') &&  					Lexer.IsIdentifierPart(Editor.ModuleCode[Editor.CaretOffset - 1]))  					return false;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: while ((nextChar = ReaderRead()) != -1)  			{  				DToken token;    				switch (nextChar)  				{  					case ' ':  					case '\t':  						continue;  					case '\r':  					case '\n':  						if (hadLineEnd)  						{  							// second line end before getting to a token  							// -> here was a blank line  							//specialTracker.AddEndOfLine(new Location(Col' Line));  						}  						HandleLineEnd((char)nextChar);  						hadLineEnd = true;  						continue;  					case '/':  						int peek = ReaderPeek();  						if (peek == '/' || peek == '*' || peek == '+')  						{  							ReadComment();  							continue;  						}  						else  						{  							token = ReadOperator('/');  						}  						break;  					case 'r':  						peek = ReaderPeek();  						if (peek == '"')  						{  							ReaderRead();  							token = ReadVerbatimString(peek);  							break;  						}  						else  							goto default;  					case '`':  						token = ReadVerbatimString(nextChar);  						break;  					case '"':  						token = ReadString(nextChar);  						break;  					case '\\':  						// http://digitalmars.com/d/1.0/lex.html#EscapeSequence  						// - It's actually deprecated' but parse such literals anyway  						string surr = "";  						x = Col - 1;  						y = Line;  						var lit = ReadEscapeSequence(out ch' out surr);  						token = Token(DTokens.Literal' x' y' lit.Length + 1' lit/*' ch.ToString()*/' LiteralFormat.StringLiteral);  						token.RawCodeRepresentation = ch.ToString();  						OnError(y' x' "Escape sequence strings are deprecated!");  						break;  					case '\'':  						token = ReadChar();  						break;  					case '@':  						token = Token(DTokens.At' Col-1' Line' 1);  						break;  					case '#':  						if ((token = ReadSpecialTokenSequence()) != null)  							break;  						continue;  					default:  						ch = (char)nextChar;    						if (ch == 'x')  						{  							peek = ReaderPeek();  							if (peek == '"') // HexString  							{  								ReaderRead(); // Skip the "    								var numString = new StringBuilder();    								while ((next = ReaderRead()) != -1)  								{  									ch = (char)next;    									if (IsHex(ch))  										numString.Append(ch);  									else if (!Char.IsWhiteSpace(ch))  										break;  								}    								return Token(DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue(numString' 16)' /*numString'*/ LiteralFormat.Scalar);  							}  						}  						else if (ch == 'q') // Token strings  						{  							switch (ReaderPeek())  							{  								case '{':  									return ReadTokenStringLiteral_CurlyInit();  								case '"'/* q"{{ ...}}   }}"*/:  									return ReadTokenStringLiteral_IdentInit();  							}  						}    						if (IsLetter(ch) || ch == '\\')  						{  							x = Col - 1; // Col was incremented above' but we want the start of the identifier  							y = Line;  							bool canBeKeyword;  							var s = ReadIdent(ch' out canBeKeyword);  							if (canBeKeyword)  							{  								// A micro-optimization..  								if (s.Length >= 8 && s[0] == '_' && s[1] == '_')  								{  									LiteralFormat literalFormat = 0;  									var subFormat = LiteralSubformat.Utf8;  									object literalValue = null;    									// Fill in static string surrogates directly  									if (s == "__VENDOR__")  									{  										literalFormat = LiteralFormat.StringLiteral;  										literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString(3) + " by Alexander Bothe";  									}  									else if (s == "__VERSION__")  									{  										subFormat = LiteralSubformat.Integer;  										var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly().GetName().Version;  										literalFormat = LiteralFormat.Scalar;  										literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  									}    									if (literalFormat != 0)  										return Token(DTokens.Literal' x' y' s.Length'  											literalValue'  											//literalValue is string ? (string)literalValue : literalValue.ToString()'  											literalFormat'  											subFormat);  								}    								byte key;  								if(DTokens.Keywords_Lookup.TryGetValue(s'out key))  									return Token(key' x' y' s.Length);  							}  							return Token(DTokens.Identifier' x' y' s);  						}  						else if (IsDigit(ch))  							token = ReadDigit(ch' Col - 1);  						else  							token = ReadOperator(ch);  						break;  				}    				// try error recovery (token = null -> continue with next char)  				if (token != null)  				{  					//token.prev = base.curToken;  					return token;  				}  				else  				{  					OnError(Line' Col' "Invalid character");  					//StopLexing();  					break;  				}  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: while ((nextChar = ReaderRead()) != -1)  			{  				DToken token;    				switch (nextChar)  				{  					case ' ':  					case '\t':  						continue;  					case '\r':  					case '\n':  						if (hadLineEnd)  						{  							// second line end before getting to a token  							// -> here was a blank line  							//specialTracker.AddEndOfLine(new Location(Col' Line));  						}  						HandleLineEnd((char)nextChar);  						hadLineEnd = true;  						continue;  					case '/':  						int peek = ReaderPeek();  						if (peek == '/' || peek == '*' || peek == '+')  						{  							ReadComment();  							continue;  						}  						else  						{  							token = ReadOperator('/');  						}  						break;  					case 'r':  						peek = ReaderPeek();  						if (peek == '"')  						{  							ReaderRead();  							token = ReadVerbatimString(peek);  							break;  						}  						else  							goto default;  					case '`':  						token = ReadVerbatimString(nextChar);  						break;  					case '"':  						token = ReadString(nextChar);  						break;  					case '\\':  						// http://digitalmars.com/d/1.0/lex.html#EscapeSequence  						// - It's actually deprecated' but parse such literals anyway  						string surr = "";  						x = Col - 1;  						y = Line;  						var lit = ReadEscapeSequence(out ch' out surr);  						token = Token(DTokens.Literal' x' y' lit.Length + 1' lit/*' ch.ToString()*/' LiteralFormat.StringLiteral);  						token.RawCodeRepresentation = ch.ToString();  						OnError(y' x' "Escape sequence strings are deprecated!");  						break;  					case '\'':  						token = ReadChar();  						break;  					case '@':  						token = Token(DTokens.At' Col-1' Line' 1);  						break;  					case '#':  						if ((token = ReadSpecialTokenSequence()) != null)  							break;  						continue;  					default:  						ch = (char)nextChar;    						if (ch == 'x')  						{  							peek = ReaderPeek();  							if (peek == '"') // HexString  							{  								ReaderRead(); // Skip the "    								var numString = new StringBuilder();    								while ((next = ReaderRead()) != -1)  								{  									ch = (char)next;    									if (IsHex(ch))  										numString.Append(ch);  									else if (!Char.IsWhiteSpace(ch))  										break;  								}    								return Token(DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue(numString' 16)' /*numString'*/ LiteralFormat.Scalar);  							}  						}  						else if (ch == 'q') // Token strings  						{  							switch (ReaderPeek())  							{  								case '{':  									return ReadTokenStringLiteral_CurlyInit();  								case '"'/* q"{{ ...}}   }}"*/:  									return ReadTokenStringLiteral_IdentInit();  							}  						}    						if (IsLetter(ch) || ch == '\\')  						{  							x = Col - 1; // Col was incremented above' but we want the start of the identifier  							y = Line;  							bool canBeKeyword;  							var s = ReadIdent(ch' out canBeKeyword);  							if (canBeKeyword)  							{  								// A micro-optimization..  								if (s.Length >= 8 && s[0] == '_' && s[1] == '_')  								{  									LiteralFormat literalFormat = 0;  									var subFormat = LiteralSubformat.Utf8;  									object literalValue = null;    									// Fill in static string surrogates directly  									if (s == "__VENDOR__")  									{  										literalFormat = LiteralFormat.StringLiteral;  										literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString(3) + " by Alexander Bothe";  									}  									else if (s == "__VERSION__")  									{  										subFormat = LiteralSubformat.Integer;  										var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly().GetName().Version;  										literalFormat = LiteralFormat.Scalar;  										literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  									}    									if (literalFormat != 0)  										return Token(DTokens.Literal' x' y' s.Length'  											literalValue'  											//literalValue is string ? (string)literalValue : literalValue.ToString()'  											literalFormat'  											subFormat);  								}    								byte key;  								if(DTokens.Keywords_Lookup.TryGetValue(s'out key))  									return Token(key' x' y' s.Length);  							}  							return Token(DTokens.Identifier' x' y' s);  						}  						else if (IsDigit(ch))  							token = ReadDigit(ch' Col - 1);  						else  							token = ReadOperator(ch);  						break;  				}    				// try error recovery (token = null -> continue with next char)  				if (token != null)  				{  					//token.prev = base.curToken;  					return token;  				}  				else  				{  					OnError(Line' Col' "Invalid character");  					//StopLexing();  					break;  				}  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: while ((nextChar = ReaderRead()) != -1)  			{  				DToken token;    				switch (nextChar)  				{  					case ' ':  					case '\t':  						continue;  					case '\r':  					case '\n':  						if (hadLineEnd)  						{  							// second line end before getting to a token  							// -> here was a blank line  							//specialTracker.AddEndOfLine(new Location(Col' Line));  						}  						HandleLineEnd((char)nextChar);  						hadLineEnd = true;  						continue;  					case '/':  						int peek = ReaderPeek();  						if (peek == '/' || peek == '*' || peek == '+')  						{  							ReadComment();  							continue;  						}  						else  						{  							token = ReadOperator('/');  						}  						break;  					case 'r':  						peek = ReaderPeek();  						if (peek == '"')  						{  							ReaderRead();  							token = ReadVerbatimString(peek);  							break;  						}  						else  							goto default;  					case '`':  						token = ReadVerbatimString(nextChar);  						break;  					case '"':  						token = ReadString(nextChar);  						break;  					case '\\':  						// http://digitalmars.com/d/1.0/lex.html#EscapeSequence  						// - It's actually deprecated' but parse such literals anyway  						string surr = "";  						x = Col - 1;  						y = Line;  						var lit = ReadEscapeSequence(out ch' out surr);  						token = Token(DTokens.Literal' x' y' lit.Length + 1' lit/*' ch.ToString()*/' LiteralFormat.StringLiteral);  						token.RawCodeRepresentation = ch.ToString();  						OnError(y' x' "Escape sequence strings are deprecated!");  						break;  					case '\'':  						token = ReadChar();  						break;  					case '@':  						token = Token(DTokens.At' Col-1' Line' 1);  						break;  					case '#':  						if ((token = ReadSpecialTokenSequence()) != null)  							break;  						continue;  					default:  						ch = (char)nextChar;    						if (ch == 'x')  						{  							peek = ReaderPeek();  							if (peek == '"') // HexString  							{  								ReaderRead(); // Skip the "    								var numString = new StringBuilder();    								while ((next = ReaderRead()) != -1)  								{  									ch = (char)next;    									if (IsHex(ch))  										numString.Append(ch);  									else if (!Char.IsWhiteSpace(ch))  										break;  								}    								return Token(DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue(numString' 16)' /*numString'*/ LiteralFormat.Scalar);  							}  						}  						else if (ch == 'q') // Token strings  						{  							switch (ReaderPeek())  							{  								case '{':  									return ReadTokenStringLiteral_CurlyInit();  								case '"'/* q"{{ ...}}   }}"*/:  									return ReadTokenStringLiteral_IdentInit();  							}  						}    						if (IsLetter(ch) || ch == '\\')  						{  							x = Col - 1; // Col was incremented above' but we want the start of the identifier  							y = Line;  							bool canBeKeyword;  							var s = ReadIdent(ch' out canBeKeyword);  							if (canBeKeyword)  							{  								// A micro-optimization..  								if (s.Length >= 8 && s[0] == '_' && s[1] == '_')  								{  									LiteralFormat literalFormat = 0;  									var subFormat = LiteralSubformat.Utf8;  									object literalValue = null;    									// Fill in static string surrogates directly  									if (s == "__VENDOR__")  									{  										literalFormat = LiteralFormat.StringLiteral;  										literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString(3) + " by Alexander Bothe";  									}  									else if (s == "__VERSION__")  									{  										subFormat = LiteralSubformat.Integer;  										var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly().GetName().Version;  										literalFormat = LiteralFormat.Scalar;  										literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  									}    									if (literalFormat != 0)  										return Token(DTokens.Literal' x' y' s.Length'  											literalValue'  											//literalValue is string ? (string)literalValue : literalValue.ToString()'  											literalFormat'  											subFormat);  								}    								byte key;  								if(DTokens.Keywords_Lookup.TryGetValue(s'out key))  									return Token(key' x' y' s.Length);  							}  							return Token(DTokens.Identifier' x' y' s);  						}  						else if (IsDigit(ch))  							token = ReadDigit(ch' Col - 1);  						else  							token = ReadOperator(ch);  						break;  				}    				// try error recovery (token = null -> continue with next char)  				if (token != null)  				{  					//token.prev = base.curToken;  					return token;  				}  				else  				{  					OnError(Line' Col' "Invalid character");  					//StopLexing();  					break;  				}  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following statement contains a magic number: while ((nextChar = ReaderRead()) != -1)  			{  				DToken token;    				switch (nextChar)  				{  					case ' ':  					case '\t':  						continue;  					case '\r':  					case '\n':  						if (hadLineEnd)  						{  							// second line end before getting to a token  							// -> here was a blank line  							//specialTracker.AddEndOfLine(new Location(Col' Line));  						}  						HandleLineEnd((char)nextChar);  						hadLineEnd = true;  						continue;  					case '/':  						int peek = ReaderPeek();  						if (peek == '/' || peek == '*' || peek == '+')  						{  							ReadComment();  							continue;  						}  						else  						{  							token = ReadOperator('/');  						}  						break;  					case 'r':  						peek = ReaderPeek();  						if (peek == '"')  						{  							ReaderRead();  							token = ReadVerbatimString(peek);  							break;  						}  						else  							goto default;  					case '`':  						token = ReadVerbatimString(nextChar);  						break;  					case '"':  						token = ReadString(nextChar);  						break;  					case '\\':  						// http://digitalmars.com/d/1.0/lex.html#EscapeSequence  						// - It's actually deprecated' but parse such literals anyway  						string surr = "";  						x = Col - 1;  						y = Line;  						var lit = ReadEscapeSequence(out ch' out surr);  						token = Token(DTokens.Literal' x' y' lit.Length + 1' lit/*' ch.ToString()*/' LiteralFormat.StringLiteral);  						token.RawCodeRepresentation = ch.ToString();  						OnError(y' x' "Escape sequence strings are deprecated!");  						break;  					case '\'':  						token = ReadChar();  						break;  					case '@':  						token = Token(DTokens.At' Col-1' Line' 1);  						break;  					case '#':  						if ((token = ReadSpecialTokenSequence()) != null)  							break;  						continue;  					default:  						ch = (char)nextChar;    						if (ch == 'x')  						{  							peek = ReaderPeek();  							if (peek == '"') // HexString  							{  								ReaderRead(); // Skip the "    								var numString = new StringBuilder();    								while ((next = ReaderRead()) != -1)  								{  									ch = (char)next;    									if (IsHex(ch))  										numString.Append(ch);  									else if (!Char.IsWhiteSpace(ch))  										break;  								}    								return Token(DTokens.Literal' Col - 1' Line' numString.Length + 1' ParseFloatValue(numString' 16)' /*numString'*/ LiteralFormat.Scalar);  							}  						}  						else if (ch == 'q') // Token strings  						{  							switch (ReaderPeek())  							{  								case '{':  									return ReadTokenStringLiteral_CurlyInit();  								case '"'/* q"{{ ...}}   }}"*/:  									return ReadTokenStringLiteral_IdentInit();  							}  						}    						if (IsLetter(ch) || ch == '\\')  						{  							x = Col - 1; // Col was incremented above' but we want the start of the identifier  							y = Line;  							bool canBeKeyword;  							var s = ReadIdent(ch' out canBeKeyword);  							if (canBeKeyword)  							{  								// A micro-optimization..  								if (s.Length >= 8 && s[0] == '_' && s[1] == '_')  								{  									LiteralFormat literalFormat = 0;  									var subFormat = LiteralSubformat.Utf8;  									object literalValue = null;    									// Fill in static string surrogates directly  									if (s == "__VENDOR__")  									{  										literalFormat = LiteralFormat.StringLiteral;  										literalValue = "D Parser v" + System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString(3) + " by Alexander Bothe";  									}  									else if (s == "__VERSION__")  									{  										subFormat = LiteralSubformat.Integer;  										var lexerVersion = System.Reflection.Assembly.GetExecutingAssembly().GetName().Version;  										literalFormat = LiteralFormat.Scalar;  										literalValue = lexerVersion.Major * 1000 + lexerVersion.Minor;  									}    									if (literalFormat != 0)  										return Token(DTokens.Literal' x' y' s.Length'  											literalValue'  											//literalValue is string ? (string)literalValue : literalValue.ToString()'  											literalFormat'  											subFormat);  								}    								byte key;  								if(DTokens.Keywords_Lookup.TryGetValue(s'out key))  									return Token(key' x' y' s.Length);  							}  							return Token(DTokens.Identifier' x' y' s);  						}  						else if (IsDigit(ch))  							token = ReadDigit(ch' Col - 1);  						else  							token = ReadOperator(ch);  						break;  				}    				// try error recovery (token = null -> continue with next char)  				if (token != null)  				{  					//token.prev = base.curToken;  					return token;  				}  				else  				{  					OnError(Line' Col' "Invalid character");  					//StopLexing();  					break;  				}  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked  			{ // prevent exception when ReaderPeek() = -1 is cast to char  				int y = Line;  				sb.Length = 0;  				sb.Append(ch);  				//string prefix = null;  				string expSuffix = "";  				string suffix = null;  				int exponent = 0;    				bool HasDot = false;  				LiteralSubformat subFmt = 0;  				bool isFloat = false;  				bool isImaginary = false;  				//bool isUnsigned = false;  				//bool isLong = false;  				int NumBase = 0; // Set it to 0 initially - it'll be set to another value later for sure    				char peek = (char)ReaderPeek();    				// At first' check pre-comma values  				if (ch == '0')  				{  					if (peek == 'x' || peek == 'X') // Hex values  					{  						//prefix = "0x";  						ReaderRead(); // skip 'x'  						sb.Length = 0; // Remove '0' from 0x prefix from the stringvalue  						NumBase = 16;    						peek = (char)ReaderPeek();  						while (IsHex(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					else if (peek == 'b' || peek == 'B') // Bin values  					{  						//prefix = "0b";  						ReaderRead(); // skip 'b'  						sb.Length = 0;  						NumBase = 2;    						peek = (char)ReaderPeek();  						while (IsBin(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					// Oct values have been removed in dmd 2.053  					/*else if (IsOct(peek) || peek == '_') // Oct values  					{  						NumBase = 8;  						prefix = "0";  						sb.Length = 0;    						while (IsOct(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}*/  					else  						NumBase = 10; // Enables pre-comma parsing .. in this case we'd 000 literals or something like that  				}    				if (NumBase == 10 || (ch != '.' && NumBase == 0)) // Only allow further digits for 10-based integers' not for binary or hex values  				{  					NumBase = 10;  					while (IsDigit(peek) || peek == '_')  					{  						if (peek != '_')  							sb.Append((char)ReaderRead());  						else ReaderRead();  						peek = (char)ReaderPeek();  					}  				}    				#region Read digits that occur after a comma  				DToken nextToken = null; // if we accidently read a 'dot'  				bool AllowSuffixes = true;  				if ((NumBase == 0 && ch == '.') || peek == '.')  				{  					if (ch != '.') ReaderRead();  					else  					{  						NumBase = 10;  						sb.Length = 0;  						sb.Append('0');  					}  					peek = (char)ReaderPeek();  					if (!IsLegalDigit(peek' NumBase))  					{  						if (peek == '.')  						{  							ReaderRead();  							nextToken = Token(DTokens.DoubleDot' Col - 1' Line' 2);  						}  						else if (IsIdentifierPart(peek))  							nextToken = Token(DTokens.Dot' Col - 1' Line' 1);    						AllowSuffixes = false;  					}  					else  					{  						HasDot = true;  						sb.Append('.');    						do  						{  							if (peek == '_')  								ReaderRead();  							else  								sb.Append((char)ReaderRead());  							peek = (char)ReaderPeek();  						}  						while (IsLegalDigit(peek' NumBase));  					}  				}  				#endregion    				#region Exponents  				if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E'))  				{ // read exponent  					string suff = peek.ToString();  					ReaderRead();  					peek = (char)ReaderPeek();    					if (peek == '-' || peek == '+')  						expSuffix += (char)ReaderRead();  					peek = (char)ReaderPeek();  					while ((peek >= '0' && peek<='9') || peek == '_')  					{ // read exponent value  						if (peek == '_')  							ReaderRead();  						else  							expSuffix += (char)ReaderRead();  						peek = (char)ReaderPeek();  					}    					// Exponents just can be decimal integers  					int.TryParse(expSuffix'out exponent);  					expSuffix = suff + expSuffix;  					peek = (char)ReaderPeek();  				}  				#endregion    				#region Suffixes  				if (!HasDot)  				{  				unsigned:  					if (peek == 'u' || peek == 'U')  					{  						ReaderRead();  						suffix += "u";  						subFmt |= LiteralSubformat.Unsigned;  						//isUnsigned = true;  						peek = (char)ReaderPeek();  					}    					if (peek == 'L')  					{  						subFmt |= LiteralSubformat.Long;  						ReaderRead();  						suffix += "L";  						//isLong = true;  						peek = (char)ReaderPeek();  						if (!subFmt.HasFlag(LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  							goto unsigned;  					}  				}    				if (HasDot || AllowSuffixes)  				{  					if (peek == 'f' || peek == 'F')  					{ // float value  						ReaderRead();  						suffix += "f";  						isFloat = true;  						subFmt |= LiteralSubformat.Float;  						peek = (char)ReaderPeek();  					}  					else if (peek == 'L')  					{ // real value  						ReaderRead();  						//isLong = true;  						suffix += 'L';  						subFmt |= LiteralSubformat.Real;  						peek = (char)ReaderPeek();  					}  				}    				if (peek == 'i')  				{ // imaginary value  					ReaderRead();  					suffix += "i";    					subFmt |= LiteralSubformat.Imaginary;  					isImaginary = true;  				}  				#endregion    				#region Parse the digit string  				var num = ParseFloatValue(sb' NumBase);    				if (exponent != 0)  				{  					try{  						num *= (decimal)Math.Pow(NumBase == 16 ? 2 : 10' exponent);  					}  					catch(OverflowException)  					{  						num = decimal.MaxValue;  						//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  						//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  					}  				}  				#endregion    				var token = Token(DTokens.Literal' x' y' Col-x/*stringValue.Length*/' num'/* stringValue'*/  					HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar'  					subFmt);    				if (token != null)  					token.next = nextToken;    				return token;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked  			{ // prevent exception when ReaderPeek() = -1 is cast to char  				int y = Line;  				sb.Length = 0;  				sb.Append(ch);  				//string prefix = null;  				string expSuffix = "";  				string suffix = null;  				int exponent = 0;    				bool HasDot = false;  				LiteralSubformat subFmt = 0;  				bool isFloat = false;  				bool isImaginary = false;  				//bool isUnsigned = false;  				//bool isLong = false;  				int NumBase = 0; // Set it to 0 initially - it'll be set to another value later for sure    				char peek = (char)ReaderPeek();    				// At first' check pre-comma values  				if (ch == '0')  				{  					if (peek == 'x' || peek == 'X') // Hex values  					{  						//prefix = "0x";  						ReaderRead(); // skip 'x'  						sb.Length = 0; // Remove '0' from 0x prefix from the stringvalue  						NumBase = 16;    						peek = (char)ReaderPeek();  						while (IsHex(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					else if (peek == 'b' || peek == 'B') // Bin values  					{  						//prefix = "0b";  						ReaderRead(); // skip 'b'  						sb.Length = 0;  						NumBase = 2;    						peek = (char)ReaderPeek();  						while (IsBin(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					// Oct values have been removed in dmd 2.053  					/*else if (IsOct(peek) || peek == '_') // Oct values  					{  						NumBase = 8;  						prefix = "0";  						sb.Length = 0;    						while (IsOct(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}*/  					else  						NumBase = 10; // Enables pre-comma parsing .. in this case we'd 000 literals or something like that  				}    				if (NumBase == 10 || (ch != '.' && NumBase == 0)) // Only allow further digits for 10-based integers' not for binary or hex values  				{  					NumBase = 10;  					while (IsDigit(peek) || peek == '_')  					{  						if (peek != '_')  							sb.Append((char)ReaderRead());  						else ReaderRead();  						peek = (char)ReaderPeek();  					}  				}    				#region Read digits that occur after a comma  				DToken nextToken = null; // if we accidently read a 'dot'  				bool AllowSuffixes = true;  				if ((NumBase == 0 && ch == '.') || peek == '.')  				{  					if (ch != '.') ReaderRead();  					else  					{  						NumBase = 10;  						sb.Length = 0;  						sb.Append('0');  					}  					peek = (char)ReaderPeek();  					if (!IsLegalDigit(peek' NumBase))  					{  						if (peek == '.')  						{  							ReaderRead();  							nextToken = Token(DTokens.DoubleDot' Col - 1' Line' 2);  						}  						else if (IsIdentifierPart(peek))  							nextToken = Token(DTokens.Dot' Col - 1' Line' 1);    						AllowSuffixes = false;  					}  					else  					{  						HasDot = true;  						sb.Append('.');    						do  						{  							if (peek == '_')  								ReaderRead();  							else  								sb.Append((char)ReaderRead());  							peek = (char)ReaderPeek();  						}  						while (IsLegalDigit(peek' NumBase));  					}  				}  				#endregion    				#region Exponents  				if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E'))  				{ // read exponent  					string suff = peek.ToString();  					ReaderRead();  					peek = (char)ReaderPeek();    					if (peek == '-' || peek == '+')  						expSuffix += (char)ReaderRead();  					peek = (char)ReaderPeek();  					while ((peek >= '0' && peek<='9') || peek == '_')  					{ // read exponent value  						if (peek == '_')  							ReaderRead();  						else  							expSuffix += (char)ReaderRead();  						peek = (char)ReaderPeek();  					}    					// Exponents just can be decimal integers  					int.TryParse(expSuffix'out exponent);  					expSuffix = suff + expSuffix;  					peek = (char)ReaderPeek();  				}  				#endregion    				#region Suffixes  				if (!HasDot)  				{  				unsigned:  					if (peek == 'u' || peek == 'U')  					{  						ReaderRead();  						suffix += "u";  						subFmt |= LiteralSubformat.Unsigned;  						//isUnsigned = true;  						peek = (char)ReaderPeek();  					}    					if (peek == 'L')  					{  						subFmt |= LiteralSubformat.Long;  						ReaderRead();  						suffix += "L";  						//isLong = true;  						peek = (char)ReaderPeek();  						if (!subFmt.HasFlag(LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  							goto unsigned;  					}  				}    				if (HasDot || AllowSuffixes)  				{  					if (peek == 'f' || peek == 'F')  					{ // float value  						ReaderRead();  						suffix += "f";  						isFloat = true;  						subFmt |= LiteralSubformat.Float;  						peek = (char)ReaderPeek();  					}  					else if (peek == 'L')  					{ // real value  						ReaderRead();  						//isLong = true;  						suffix += 'L';  						subFmt |= LiteralSubformat.Real;  						peek = (char)ReaderPeek();  					}  				}    				if (peek == 'i')  				{ // imaginary value  					ReaderRead();  					suffix += "i";    					subFmt |= LiteralSubformat.Imaginary;  					isImaginary = true;  				}  				#endregion    				#region Parse the digit string  				var num = ParseFloatValue(sb' NumBase);    				if (exponent != 0)  				{  					try{  						num *= (decimal)Math.Pow(NumBase == 16 ? 2 : 10' exponent);  					}  					catch(OverflowException)  					{  						num = decimal.MaxValue;  						//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  						//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  					}  				}  				#endregion    				var token = Token(DTokens.Literal' x' y' Col-x/*stringValue.Length*/' num'/* stringValue'*/  					HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar'  					subFmt);    				if (token != null)  					token.next = nextToken;    				return token;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked  			{ // prevent exception when ReaderPeek() = -1 is cast to char  				int y = Line;  				sb.Length = 0;  				sb.Append(ch);  				//string prefix = null;  				string expSuffix = "";  				string suffix = null;  				int exponent = 0;    				bool HasDot = false;  				LiteralSubformat subFmt = 0;  				bool isFloat = false;  				bool isImaginary = false;  				//bool isUnsigned = false;  				//bool isLong = false;  				int NumBase = 0; // Set it to 0 initially - it'll be set to another value later for sure    				char peek = (char)ReaderPeek();    				// At first' check pre-comma values  				if (ch == '0')  				{  					if (peek == 'x' || peek == 'X') // Hex values  					{  						//prefix = "0x";  						ReaderRead(); // skip 'x'  						sb.Length = 0; // Remove '0' from 0x prefix from the stringvalue  						NumBase = 16;    						peek = (char)ReaderPeek();  						while (IsHex(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					else if (peek == 'b' || peek == 'B') // Bin values  					{  						//prefix = "0b";  						ReaderRead(); // skip 'b'  						sb.Length = 0;  						NumBase = 2;    						peek = (char)ReaderPeek();  						while (IsBin(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					// Oct values have been removed in dmd 2.053  					/*else if (IsOct(peek) || peek == '_') // Oct values  					{  						NumBase = 8;  						prefix = "0";  						sb.Length = 0;    						while (IsOct(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}*/  					else  						NumBase = 10; // Enables pre-comma parsing .. in this case we'd 000 literals or something like that  				}    				if (NumBase == 10 || (ch != '.' && NumBase == 0)) // Only allow further digits for 10-based integers' not for binary or hex values  				{  					NumBase = 10;  					while (IsDigit(peek) || peek == '_')  					{  						if (peek != '_')  							sb.Append((char)ReaderRead());  						else ReaderRead();  						peek = (char)ReaderPeek();  					}  				}    				#region Read digits that occur after a comma  				DToken nextToken = null; // if we accidently read a 'dot'  				bool AllowSuffixes = true;  				if ((NumBase == 0 && ch == '.') || peek == '.')  				{  					if (ch != '.') ReaderRead();  					else  					{  						NumBase = 10;  						sb.Length = 0;  						sb.Append('0');  					}  					peek = (char)ReaderPeek();  					if (!IsLegalDigit(peek' NumBase))  					{  						if (peek == '.')  						{  							ReaderRead();  							nextToken = Token(DTokens.DoubleDot' Col - 1' Line' 2);  						}  						else if (IsIdentifierPart(peek))  							nextToken = Token(DTokens.Dot' Col - 1' Line' 1);    						AllowSuffixes = false;  					}  					else  					{  						HasDot = true;  						sb.Append('.');    						do  						{  							if (peek == '_')  								ReaderRead();  							else  								sb.Append((char)ReaderRead());  							peek = (char)ReaderPeek();  						}  						while (IsLegalDigit(peek' NumBase));  					}  				}  				#endregion    				#region Exponents  				if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E'))  				{ // read exponent  					string suff = peek.ToString();  					ReaderRead();  					peek = (char)ReaderPeek();    					if (peek == '-' || peek == '+')  						expSuffix += (char)ReaderRead();  					peek = (char)ReaderPeek();  					while ((peek >= '0' && peek<='9') || peek == '_')  					{ // read exponent value  						if (peek == '_')  							ReaderRead();  						else  							expSuffix += (char)ReaderRead();  						peek = (char)ReaderPeek();  					}    					// Exponents just can be decimal integers  					int.TryParse(expSuffix'out exponent);  					expSuffix = suff + expSuffix;  					peek = (char)ReaderPeek();  				}  				#endregion    				#region Suffixes  				if (!HasDot)  				{  				unsigned:  					if (peek == 'u' || peek == 'U')  					{  						ReaderRead();  						suffix += "u";  						subFmt |= LiteralSubformat.Unsigned;  						//isUnsigned = true;  						peek = (char)ReaderPeek();  					}    					if (peek == 'L')  					{  						subFmt |= LiteralSubformat.Long;  						ReaderRead();  						suffix += "L";  						//isLong = true;  						peek = (char)ReaderPeek();  						if (!subFmt.HasFlag(LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  							goto unsigned;  					}  				}    				if (HasDot || AllowSuffixes)  				{  					if (peek == 'f' || peek == 'F')  					{ // float value  						ReaderRead();  						suffix += "f";  						isFloat = true;  						subFmt |= LiteralSubformat.Float;  						peek = (char)ReaderPeek();  					}  					else if (peek == 'L')  					{ // real value  						ReaderRead();  						//isLong = true;  						suffix += 'L';  						subFmt |= LiteralSubformat.Real;  						peek = (char)ReaderPeek();  					}  				}    				if (peek == 'i')  				{ // imaginary value  					ReaderRead();  					suffix += "i";    					subFmt |= LiteralSubformat.Imaginary;  					isImaginary = true;  				}  				#endregion    				#region Parse the digit string  				var num = ParseFloatValue(sb' NumBase);    				if (exponent != 0)  				{  					try{  						num *= (decimal)Math.Pow(NumBase == 16 ? 2 : 10' exponent);  					}  					catch(OverflowException)  					{  						num = decimal.MaxValue;  						//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  						//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  					}  				}  				#endregion    				var token = Token(DTokens.Literal' x' y' Col-x/*stringValue.Length*/' num'/* stringValue'*/  					HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar'  					subFmt);    				if (token != null)  					token.next = nextToken;    				return token;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked  			{ // prevent exception when ReaderPeek() = -1 is cast to char  				int y = Line;  				sb.Length = 0;  				sb.Append(ch);  				//string prefix = null;  				string expSuffix = "";  				string suffix = null;  				int exponent = 0;    				bool HasDot = false;  				LiteralSubformat subFmt = 0;  				bool isFloat = false;  				bool isImaginary = false;  				//bool isUnsigned = false;  				//bool isLong = false;  				int NumBase = 0; // Set it to 0 initially - it'll be set to another value later for sure    				char peek = (char)ReaderPeek();    				// At first' check pre-comma values  				if (ch == '0')  				{  					if (peek == 'x' || peek == 'X') // Hex values  					{  						//prefix = "0x";  						ReaderRead(); // skip 'x'  						sb.Length = 0; // Remove '0' from 0x prefix from the stringvalue  						NumBase = 16;    						peek = (char)ReaderPeek();  						while (IsHex(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					else if (peek == 'b' || peek == 'B') // Bin values  					{  						//prefix = "0b";  						ReaderRead(); // skip 'b'  						sb.Length = 0;  						NumBase = 2;    						peek = (char)ReaderPeek();  						while (IsBin(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					// Oct values have been removed in dmd 2.053  					/*else if (IsOct(peek) || peek == '_') // Oct values  					{  						NumBase = 8;  						prefix = "0";  						sb.Length = 0;    						while (IsOct(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}*/  					else  						NumBase = 10; // Enables pre-comma parsing .. in this case we'd 000 literals or something like that  				}    				if (NumBase == 10 || (ch != '.' && NumBase == 0)) // Only allow further digits for 10-based integers' not for binary or hex values  				{  					NumBase = 10;  					while (IsDigit(peek) || peek == '_')  					{  						if (peek != '_')  							sb.Append((char)ReaderRead());  						else ReaderRead();  						peek = (char)ReaderPeek();  					}  				}    				#region Read digits that occur after a comma  				DToken nextToken = null; // if we accidently read a 'dot'  				bool AllowSuffixes = true;  				if ((NumBase == 0 && ch == '.') || peek == '.')  				{  					if (ch != '.') ReaderRead();  					else  					{  						NumBase = 10;  						sb.Length = 0;  						sb.Append('0');  					}  					peek = (char)ReaderPeek();  					if (!IsLegalDigit(peek' NumBase))  					{  						if (peek == '.')  						{  							ReaderRead();  							nextToken = Token(DTokens.DoubleDot' Col - 1' Line' 2);  						}  						else if (IsIdentifierPart(peek))  							nextToken = Token(DTokens.Dot' Col - 1' Line' 1);    						AllowSuffixes = false;  					}  					else  					{  						HasDot = true;  						sb.Append('.');    						do  						{  							if (peek == '_')  								ReaderRead();  							else  								sb.Append((char)ReaderRead());  							peek = (char)ReaderPeek();  						}  						while (IsLegalDigit(peek' NumBase));  					}  				}  				#endregion    				#region Exponents  				if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E'))  				{ // read exponent  					string suff = peek.ToString();  					ReaderRead();  					peek = (char)ReaderPeek();    					if (peek == '-' || peek == '+')  						expSuffix += (char)ReaderRead();  					peek = (char)ReaderPeek();  					while ((peek >= '0' && peek<='9') || peek == '_')  					{ // read exponent value  						if (peek == '_')  							ReaderRead();  						else  							expSuffix += (char)ReaderRead();  						peek = (char)ReaderPeek();  					}    					// Exponents just can be decimal integers  					int.TryParse(expSuffix'out exponent);  					expSuffix = suff + expSuffix;  					peek = (char)ReaderPeek();  				}  				#endregion    				#region Suffixes  				if (!HasDot)  				{  				unsigned:  					if (peek == 'u' || peek == 'U')  					{  						ReaderRead();  						suffix += "u";  						subFmt |= LiteralSubformat.Unsigned;  						//isUnsigned = true;  						peek = (char)ReaderPeek();  					}    					if (peek == 'L')  					{  						subFmt |= LiteralSubformat.Long;  						ReaderRead();  						suffix += "L";  						//isLong = true;  						peek = (char)ReaderPeek();  						if (!subFmt.HasFlag(LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  							goto unsigned;  					}  				}    				if (HasDot || AllowSuffixes)  				{  					if (peek == 'f' || peek == 'F')  					{ // float value  						ReaderRead();  						suffix += "f";  						isFloat = true;  						subFmt |= LiteralSubformat.Float;  						peek = (char)ReaderPeek();  					}  					else if (peek == 'L')  					{ // real value  						ReaderRead();  						//isLong = true;  						suffix += 'L';  						subFmt |= LiteralSubformat.Real;  						peek = (char)ReaderPeek();  					}  				}    				if (peek == 'i')  				{ // imaginary value  					ReaderRead();  					suffix += "i";    					subFmt |= LiteralSubformat.Imaginary;  					isImaginary = true;  				}  				#endregion    				#region Parse the digit string  				var num = ParseFloatValue(sb' NumBase);    				if (exponent != 0)  				{  					try{  						num *= (decimal)Math.Pow(NumBase == 16 ? 2 : 10' exponent);  					}  					catch(OverflowException)  					{  						num = decimal.MaxValue;  						//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  						//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  					}  				}  				#endregion    				var token = Token(DTokens.Literal' x' y' Col-x/*stringValue.Length*/' num'/* stringValue'*/  					HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar'  					subFmt);    				if (token != null)  					token.next = nextToken;    				return token;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked  			{ // prevent exception when ReaderPeek() = -1 is cast to char  				int y = Line;  				sb.Length = 0;  				sb.Append(ch);  				//string prefix = null;  				string expSuffix = "";  				string suffix = null;  				int exponent = 0;    				bool HasDot = false;  				LiteralSubformat subFmt = 0;  				bool isFloat = false;  				bool isImaginary = false;  				//bool isUnsigned = false;  				//bool isLong = false;  				int NumBase = 0; // Set it to 0 initially - it'll be set to another value later for sure    				char peek = (char)ReaderPeek();    				// At first' check pre-comma values  				if (ch == '0')  				{  					if (peek == 'x' || peek == 'X') // Hex values  					{  						//prefix = "0x";  						ReaderRead(); // skip 'x'  						sb.Length = 0; // Remove '0' from 0x prefix from the stringvalue  						NumBase = 16;    						peek = (char)ReaderPeek();  						while (IsHex(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					else if (peek == 'b' || peek == 'B') // Bin values  					{  						//prefix = "0b";  						ReaderRead(); // skip 'b'  						sb.Length = 0;  						NumBase = 2;    						peek = (char)ReaderPeek();  						while (IsBin(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					// Oct values have been removed in dmd 2.053  					/*else if (IsOct(peek) || peek == '_') // Oct values  					{  						NumBase = 8;  						prefix = "0";  						sb.Length = 0;    						while (IsOct(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}*/  					else  						NumBase = 10; // Enables pre-comma parsing .. in this case we'd 000 literals or something like that  				}    				if (NumBase == 10 || (ch != '.' && NumBase == 0)) // Only allow further digits for 10-based integers' not for binary or hex values  				{  					NumBase = 10;  					while (IsDigit(peek) || peek == '_')  					{  						if (peek != '_')  							sb.Append((char)ReaderRead());  						else ReaderRead();  						peek = (char)ReaderPeek();  					}  				}    				#region Read digits that occur after a comma  				DToken nextToken = null; // if we accidently read a 'dot'  				bool AllowSuffixes = true;  				if ((NumBase == 0 && ch == '.') || peek == '.')  				{  					if (ch != '.') ReaderRead();  					else  					{  						NumBase = 10;  						sb.Length = 0;  						sb.Append('0');  					}  					peek = (char)ReaderPeek();  					if (!IsLegalDigit(peek' NumBase))  					{  						if (peek == '.')  						{  							ReaderRead();  							nextToken = Token(DTokens.DoubleDot' Col - 1' Line' 2);  						}  						else if (IsIdentifierPart(peek))  							nextToken = Token(DTokens.Dot' Col - 1' Line' 1);    						AllowSuffixes = false;  					}  					else  					{  						HasDot = true;  						sb.Append('.');    						do  						{  							if (peek == '_')  								ReaderRead();  							else  								sb.Append((char)ReaderRead());  							peek = (char)ReaderPeek();  						}  						while (IsLegalDigit(peek' NumBase));  					}  				}  				#endregion    				#region Exponents  				if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E'))  				{ // read exponent  					string suff = peek.ToString();  					ReaderRead();  					peek = (char)ReaderPeek();    					if (peek == '-' || peek == '+')  						expSuffix += (char)ReaderRead();  					peek = (char)ReaderPeek();  					while ((peek >= '0' && peek<='9') || peek == '_')  					{ // read exponent value  						if (peek == '_')  							ReaderRead();  						else  							expSuffix += (char)ReaderRead();  						peek = (char)ReaderPeek();  					}    					// Exponents just can be decimal integers  					int.TryParse(expSuffix'out exponent);  					expSuffix = suff + expSuffix;  					peek = (char)ReaderPeek();  				}  				#endregion    				#region Suffixes  				if (!HasDot)  				{  				unsigned:  					if (peek == 'u' || peek == 'U')  					{  						ReaderRead();  						suffix += "u";  						subFmt |= LiteralSubformat.Unsigned;  						//isUnsigned = true;  						peek = (char)ReaderPeek();  					}    					if (peek == 'L')  					{  						subFmt |= LiteralSubformat.Long;  						ReaderRead();  						suffix += "L";  						//isLong = true;  						peek = (char)ReaderPeek();  						if (!subFmt.HasFlag(LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  							goto unsigned;  					}  				}    				if (HasDot || AllowSuffixes)  				{  					if (peek == 'f' || peek == 'F')  					{ // float value  						ReaderRead();  						suffix += "f";  						isFloat = true;  						subFmt |= LiteralSubformat.Float;  						peek = (char)ReaderPeek();  					}  					else if (peek == 'L')  					{ // real value  						ReaderRead();  						//isLong = true;  						suffix += 'L';  						subFmt |= LiteralSubformat.Real;  						peek = (char)ReaderPeek();  					}  				}    				if (peek == 'i')  				{ // imaginary value  					ReaderRead();  					suffix += "i";    					subFmt |= LiteralSubformat.Imaginary;  					isImaginary = true;  				}  				#endregion    				#region Parse the digit string  				var num = ParseFloatValue(sb' NumBase);    				if (exponent != 0)  				{  					try{  						num *= (decimal)Math.Pow(NumBase == 16 ? 2 : 10' exponent);  					}  					catch(OverflowException)  					{  						num = decimal.MaxValue;  						//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  						//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  					}  				}  				#endregion    				var token = Token(DTokens.Literal' x' y' Col-x/*stringValue.Length*/' num'/* stringValue'*/  					HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar'  					subFmt);    				if (token != null)  					token.next = nextToken;    				return token;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked  			{ // prevent exception when ReaderPeek() = -1 is cast to char  				int y = Line;  				sb.Length = 0;  				sb.Append(ch);  				//string prefix = null;  				string expSuffix = "";  				string suffix = null;  				int exponent = 0;    				bool HasDot = false;  				LiteralSubformat subFmt = 0;  				bool isFloat = false;  				bool isImaginary = false;  				//bool isUnsigned = false;  				//bool isLong = false;  				int NumBase = 0; // Set it to 0 initially - it'll be set to another value later for sure    				char peek = (char)ReaderPeek();    				// At first' check pre-comma values  				if (ch == '0')  				{  					if (peek == 'x' || peek == 'X') // Hex values  					{  						//prefix = "0x";  						ReaderRead(); // skip 'x'  						sb.Length = 0; // Remove '0' from 0x prefix from the stringvalue  						NumBase = 16;    						peek = (char)ReaderPeek();  						while (IsHex(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					else if (peek == 'b' || peek == 'B') // Bin values  					{  						//prefix = "0b";  						ReaderRead(); // skip 'b'  						sb.Length = 0;  						NumBase = 2;    						peek = (char)ReaderPeek();  						while (IsBin(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					// Oct values have been removed in dmd 2.053  					/*else if (IsOct(peek) || peek == '_') // Oct values  					{  						NumBase = 8;  						prefix = "0";  						sb.Length = 0;    						while (IsOct(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}*/  					else  						NumBase = 10; // Enables pre-comma parsing .. in this case we'd 000 literals or something like that  				}    				if (NumBase == 10 || (ch != '.' && NumBase == 0)) // Only allow further digits for 10-based integers' not for binary or hex values  				{  					NumBase = 10;  					while (IsDigit(peek) || peek == '_')  					{  						if (peek != '_')  							sb.Append((char)ReaderRead());  						else ReaderRead();  						peek = (char)ReaderPeek();  					}  				}    				#region Read digits that occur after a comma  				DToken nextToken = null; // if we accidently read a 'dot'  				bool AllowSuffixes = true;  				if ((NumBase == 0 && ch == '.') || peek == '.')  				{  					if (ch != '.') ReaderRead();  					else  					{  						NumBase = 10;  						sb.Length = 0;  						sb.Append('0');  					}  					peek = (char)ReaderPeek();  					if (!IsLegalDigit(peek' NumBase))  					{  						if (peek == '.')  						{  							ReaderRead();  							nextToken = Token(DTokens.DoubleDot' Col - 1' Line' 2);  						}  						else if (IsIdentifierPart(peek))  							nextToken = Token(DTokens.Dot' Col - 1' Line' 1);    						AllowSuffixes = false;  					}  					else  					{  						HasDot = true;  						sb.Append('.');    						do  						{  							if (peek == '_')  								ReaderRead();  							else  								sb.Append((char)ReaderRead());  							peek = (char)ReaderPeek();  						}  						while (IsLegalDigit(peek' NumBase));  					}  				}  				#endregion    				#region Exponents  				if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E'))  				{ // read exponent  					string suff = peek.ToString();  					ReaderRead();  					peek = (char)ReaderPeek();    					if (peek == '-' || peek == '+')  						expSuffix += (char)ReaderRead();  					peek = (char)ReaderPeek();  					while ((peek >= '0' && peek<='9') || peek == '_')  					{ // read exponent value  						if (peek == '_')  							ReaderRead();  						else  							expSuffix += (char)ReaderRead();  						peek = (char)ReaderPeek();  					}    					// Exponents just can be decimal integers  					int.TryParse(expSuffix'out exponent);  					expSuffix = suff + expSuffix;  					peek = (char)ReaderPeek();  				}  				#endregion    				#region Suffixes  				if (!HasDot)  				{  				unsigned:  					if (peek == 'u' || peek == 'U')  					{  						ReaderRead();  						suffix += "u";  						subFmt |= LiteralSubformat.Unsigned;  						//isUnsigned = true;  						peek = (char)ReaderPeek();  					}    					if (peek == 'L')  					{  						subFmt |= LiteralSubformat.Long;  						ReaderRead();  						suffix += "L";  						//isLong = true;  						peek = (char)ReaderPeek();  						if (!subFmt.HasFlag(LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  							goto unsigned;  					}  				}    				if (HasDot || AllowSuffixes)  				{  					if (peek == 'f' || peek == 'F')  					{ // float value  						ReaderRead();  						suffix += "f";  						isFloat = true;  						subFmt |= LiteralSubformat.Float;  						peek = (char)ReaderPeek();  					}  					else if (peek == 'L')  					{ // real value  						ReaderRead();  						//isLong = true;  						suffix += 'L';  						subFmt |= LiteralSubformat.Real;  						peek = (char)ReaderPeek();  					}  				}    				if (peek == 'i')  				{ // imaginary value  					ReaderRead();  					suffix += "i";    					subFmt |= LiteralSubformat.Imaginary;  					isImaginary = true;  				}  				#endregion    				#region Parse the digit string  				var num = ParseFloatValue(sb' NumBase);    				if (exponent != 0)  				{  					try{  						num *= (decimal)Math.Pow(NumBase == 16 ? 2 : 10' exponent);  					}  					catch(OverflowException)  					{  						num = decimal.MaxValue;  						//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  						//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  					}  				}  				#endregion    				var token = Token(DTokens.Literal' x' y' Col-x/*stringValue.Length*/' num'/* stringValue'*/  					HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar'  					subFmt);    				if (token != null)  					token.next = nextToken;    				return token;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked  			{ // prevent exception when ReaderPeek() = -1 is cast to char  				int y = Line;  				sb.Length = 0;  				sb.Append(ch);  				//string prefix = null;  				string expSuffix = "";  				string suffix = null;  				int exponent = 0;    				bool HasDot = false;  				LiteralSubformat subFmt = 0;  				bool isFloat = false;  				bool isImaginary = false;  				//bool isUnsigned = false;  				//bool isLong = false;  				int NumBase = 0; // Set it to 0 initially - it'll be set to another value later for sure    				char peek = (char)ReaderPeek();    				// At first' check pre-comma values  				if (ch == '0')  				{  					if (peek == 'x' || peek == 'X') // Hex values  					{  						//prefix = "0x";  						ReaderRead(); // skip 'x'  						sb.Length = 0; // Remove '0' from 0x prefix from the stringvalue  						NumBase = 16;    						peek = (char)ReaderPeek();  						while (IsHex(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					else if (peek == 'b' || peek == 'B') // Bin values  					{  						//prefix = "0b";  						ReaderRead(); // skip 'b'  						sb.Length = 0;  						NumBase = 2;    						peek = (char)ReaderPeek();  						while (IsBin(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					// Oct values have been removed in dmd 2.053  					/*else if (IsOct(peek) || peek == '_') // Oct values  					{  						NumBase = 8;  						prefix = "0";  						sb.Length = 0;    						while (IsOct(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}*/  					else  						NumBase = 10; // Enables pre-comma parsing .. in this case we'd 000 literals or something like that  				}    				if (NumBase == 10 || (ch != '.' && NumBase == 0)) // Only allow further digits for 10-based integers' not for binary or hex values  				{  					NumBase = 10;  					while (IsDigit(peek) || peek == '_')  					{  						if (peek != '_')  							sb.Append((char)ReaderRead());  						else ReaderRead();  						peek = (char)ReaderPeek();  					}  				}    				#region Read digits that occur after a comma  				DToken nextToken = null; // if we accidently read a 'dot'  				bool AllowSuffixes = true;  				if ((NumBase == 0 && ch == '.') || peek == '.')  				{  					if (ch != '.') ReaderRead();  					else  					{  						NumBase = 10;  						sb.Length = 0;  						sb.Append('0');  					}  					peek = (char)ReaderPeek();  					if (!IsLegalDigit(peek' NumBase))  					{  						if (peek == '.')  						{  							ReaderRead();  							nextToken = Token(DTokens.DoubleDot' Col - 1' Line' 2);  						}  						else if (IsIdentifierPart(peek))  							nextToken = Token(DTokens.Dot' Col - 1' Line' 1);    						AllowSuffixes = false;  					}  					else  					{  						HasDot = true;  						sb.Append('.');    						do  						{  							if (peek == '_')  								ReaderRead();  							else  								sb.Append((char)ReaderRead());  							peek = (char)ReaderPeek();  						}  						while (IsLegalDigit(peek' NumBase));  					}  				}  				#endregion    				#region Exponents  				if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E'))  				{ // read exponent  					string suff = peek.ToString();  					ReaderRead();  					peek = (char)ReaderPeek();    					if (peek == '-' || peek == '+')  						expSuffix += (char)ReaderRead();  					peek = (char)ReaderPeek();  					while ((peek >= '0' && peek<='9') || peek == '_')  					{ // read exponent value  						if (peek == '_')  							ReaderRead();  						else  							expSuffix += (char)ReaderRead();  						peek = (char)ReaderPeek();  					}    					// Exponents just can be decimal integers  					int.TryParse(expSuffix'out exponent);  					expSuffix = suff + expSuffix;  					peek = (char)ReaderPeek();  				}  				#endregion    				#region Suffixes  				if (!HasDot)  				{  				unsigned:  					if (peek == 'u' || peek == 'U')  					{  						ReaderRead();  						suffix += "u";  						subFmt |= LiteralSubformat.Unsigned;  						//isUnsigned = true;  						peek = (char)ReaderPeek();  					}    					if (peek == 'L')  					{  						subFmt |= LiteralSubformat.Long;  						ReaderRead();  						suffix += "L";  						//isLong = true;  						peek = (char)ReaderPeek();  						if (!subFmt.HasFlag(LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  							goto unsigned;  					}  				}    				if (HasDot || AllowSuffixes)  				{  					if (peek == 'f' || peek == 'F')  					{ // float value  						ReaderRead();  						suffix += "f";  						isFloat = true;  						subFmt |= LiteralSubformat.Float;  						peek = (char)ReaderPeek();  					}  					else if (peek == 'L')  					{ // real value  						ReaderRead();  						//isLong = true;  						suffix += 'L';  						subFmt |= LiteralSubformat.Real;  						peek = (char)ReaderPeek();  					}  				}    				if (peek == 'i')  				{ // imaginary value  					ReaderRead();  					suffix += "i";    					subFmt |= LiteralSubformat.Imaginary;  					isImaginary = true;  				}  				#endregion    				#region Parse the digit string  				var num = ParseFloatValue(sb' NumBase);    				if (exponent != 0)  				{  					try{  						num *= (decimal)Math.Pow(NumBase == 16 ? 2 : 10' exponent);  					}  					catch(OverflowException)  					{  						num = decimal.MaxValue;  						//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  						//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  					}  				}  				#endregion    				var token = Token(DTokens.Literal' x' y' Col-x/*stringValue.Length*/' num'/* stringValue'*/  					HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar'  					subFmt);    				if (token != null)  					token.next = nextToken;    				return token;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked  			{ // prevent exception when ReaderPeek() = -1 is cast to char  				int y = Line;  				sb.Length = 0;  				sb.Append(ch);  				//string prefix = null;  				string expSuffix = "";  				string suffix = null;  				int exponent = 0;    				bool HasDot = false;  				LiteralSubformat subFmt = 0;  				bool isFloat = false;  				bool isImaginary = false;  				//bool isUnsigned = false;  				//bool isLong = false;  				int NumBase = 0; // Set it to 0 initially - it'll be set to another value later for sure    				char peek = (char)ReaderPeek();    				// At first' check pre-comma values  				if (ch == '0')  				{  					if (peek == 'x' || peek == 'X') // Hex values  					{  						//prefix = "0x";  						ReaderRead(); // skip 'x'  						sb.Length = 0; // Remove '0' from 0x prefix from the stringvalue  						NumBase = 16;    						peek = (char)ReaderPeek();  						while (IsHex(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					else if (peek == 'b' || peek == 'B') // Bin values  					{  						//prefix = "0b";  						ReaderRead(); // skip 'b'  						sb.Length = 0;  						NumBase = 2;    						peek = (char)ReaderPeek();  						while (IsBin(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					// Oct values have been removed in dmd 2.053  					/*else if (IsOct(peek) || peek == '_') // Oct values  					{  						NumBase = 8;  						prefix = "0";  						sb.Length = 0;    						while (IsOct(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}*/  					else  						NumBase = 10; // Enables pre-comma parsing .. in this case we'd 000 literals or something like that  				}    				if (NumBase == 10 || (ch != '.' && NumBase == 0)) // Only allow further digits for 10-based integers' not for binary or hex values  				{  					NumBase = 10;  					while (IsDigit(peek) || peek == '_')  					{  						if (peek != '_')  							sb.Append((char)ReaderRead());  						else ReaderRead();  						peek = (char)ReaderPeek();  					}  				}    				#region Read digits that occur after a comma  				DToken nextToken = null; // if we accidently read a 'dot'  				bool AllowSuffixes = true;  				if ((NumBase == 0 && ch == '.') || peek == '.')  				{  					if (ch != '.') ReaderRead();  					else  					{  						NumBase = 10;  						sb.Length = 0;  						sb.Append('0');  					}  					peek = (char)ReaderPeek();  					if (!IsLegalDigit(peek' NumBase))  					{  						if (peek == '.')  						{  							ReaderRead();  							nextToken = Token(DTokens.DoubleDot' Col - 1' Line' 2);  						}  						else if (IsIdentifierPart(peek))  							nextToken = Token(DTokens.Dot' Col - 1' Line' 1);    						AllowSuffixes = false;  					}  					else  					{  						HasDot = true;  						sb.Append('.');    						do  						{  							if (peek == '_')  								ReaderRead();  							else  								sb.Append((char)ReaderRead());  							peek = (char)ReaderPeek();  						}  						while (IsLegalDigit(peek' NumBase));  					}  				}  				#endregion    				#region Exponents  				if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E'))  				{ // read exponent  					string suff = peek.ToString();  					ReaderRead();  					peek = (char)ReaderPeek();    					if (peek == '-' || peek == '+')  						expSuffix += (char)ReaderRead();  					peek = (char)ReaderPeek();  					while ((peek >= '0' && peek<='9') || peek == '_')  					{ // read exponent value  						if (peek == '_')  							ReaderRead();  						else  							expSuffix += (char)ReaderRead();  						peek = (char)ReaderPeek();  					}    					// Exponents just can be decimal integers  					int.TryParse(expSuffix'out exponent);  					expSuffix = suff + expSuffix;  					peek = (char)ReaderPeek();  				}  				#endregion    				#region Suffixes  				if (!HasDot)  				{  				unsigned:  					if (peek == 'u' || peek == 'U')  					{  						ReaderRead();  						suffix += "u";  						subFmt |= LiteralSubformat.Unsigned;  						//isUnsigned = true;  						peek = (char)ReaderPeek();  					}    					if (peek == 'L')  					{  						subFmt |= LiteralSubformat.Long;  						ReaderRead();  						suffix += "L";  						//isLong = true;  						peek = (char)ReaderPeek();  						if (!subFmt.HasFlag(LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  							goto unsigned;  					}  				}    				if (HasDot || AllowSuffixes)  				{  					if (peek == 'f' || peek == 'F')  					{ // float value  						ReaderRead();  						suffix += "f";  						isFloat = true;  						subFmt |= LiteralSubformat.Float;  						peek = (char)ReaderPeek();  					}  					else if (peek == 'L')  					{ // real value  						ReaderRead();  						//isLong = true;  						suffix += 'L';  						subFmt |= LiteralSubformat.Real;  						peek = (char)ReaderPeek();  					}  				}    				if (peek == 'i')  				{ // imaginary value  					ReaderRead();  					suffix += "i";    					subFmt |= LiteralSubformat.Imaginary;  					isImaginary = true;  				}  				#endregion    				#region Parse the digit string  				var num = ParseFloatValue(sb' NumBase);    				if (exponent != 0)  				{  					try{  						num *= (decimal)Math.Pow(NumBase == 16 ? 2 : 10' exponent);  					}  					catch(OverflowException)  					{  						num = decimal.MaxValue;  						//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  						//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  					}  				}  				#endregion    				var token = Token(DTokens.Literal' x' y' Col-x/*stringValue.Length*/' num'/* stringValue'*/  					HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar'  					subFmt);    				if (token != null)  					token.next = nextToken;    				return token;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked  			{ // prevent exception when ReaderPeek() = -1 is cast to char  				int y = Line;  				sb.Length = 0;  				sb.Append(ch);  				//string prefix = null;  				string expSuffix = "";  				string suffix = null;  				int exponent = 0;    				bool HasDot = false;  				LiteralSubformat subFmt = 0;  				bool isFloat = false;  				bool isImaginary = false;  				//bool isUnsigned = false;  				//bool isLong = false;  				int NumBase = 0; // Set it to 0 initially - it'll be set to another value later for sure    				char peek = (char)ReaderPeek();    				// At first' check pre-comma values  				if (ch == '0')  				{  					if (peek == 'x' || peek == 'X') // Hex values  					{  						//prefix = "0x";  						ReaderRead(); // skip 'x'  						sb.Length = 0; // Remove '0' from 0x prefix from the stringvalue  						NumBase = 16;    						peek = (char)ReaderPeek();  						while (IsHex(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					else if (peek == 'b' || peek == 'B') // Bin values  					{  						//prefix = "0b";  						ReaderRead(); // skip 'b'  						sb.Length = 0;  						NumBase = 2;    						peek = (char)ReaderPeek();  						while (IsBin(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					// Oct values have been removed in dmd 2.053  					/*else if (IsOct(peek) || peek == '_') // Oct values  					{  						NumBase = 8;  						prefix = "0";  						sb.Length = 0;    						while (IsOct(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}*/  					else  						NumBase = 10; // Enables pre-comma parsing .. in this case we'd 000 literals or something like that  				}    				if (NumBase == 10 || (ch != '.' && NumBase == 0)) // Only allow further digits for 10-based integers' not for binary or hex values  				{  					NumBase = 10;  					while (IsDigit(peek) || peek == '_')  					{  						if (peek != '_')  							sb.Append((char)ReaderRead());  						else ReaderRead();  						peek = (char)ReaderPeek();  					}  				}    				#region Read digits that occur after a comma  				DToken nextToken = null; // if we accidently read a 'dot'  				bool AllowSuffixes = true;  				if ((NumBase == 0 && ch == '.') || peek == '.')  				{  					if (ch != '.') ReaderRead();  					else  					{  						NumBase = 10;  						sb.Length = 0;  						sb.Append('0');  					}  					peek = (char)ReaderPeek();  					if (!IsLegalDigit(peek' NumBase))  					{  						if (peek == '.')  						{  							ReaderRead();  							nextToken = Token(DTokens.DoubleDot' Col - 1' Line' 2);  						}  						else if (IsIdentifierPart(peek))  							nextToken = Token(DTokens.Dot' Col - 1' Line' 1);    						AllowSuffixes = false;  					}  					else  					{  						HasDot = true;  						sb.Append('.');    						do  						{  							if (peek == '_')  								ReaderRead();  							else  								sb.Append((char)ReaderRead());  							peek = (char)ReaderPeek();  						}  						while (IsLegalDigit(peek' NumBase));  					}  				}  				#endregion    				#region Exponents  				if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E'))  				{ // read exponent  					string suff = peek.ToString();  					ReaderRead();  					peek = (char)ReaderPeek();    					if (peek == '-' || peek == '+')  						expSuffix += (char)ReaderRead();  					peek = (char)ReaderPeek();  					while ((peek >= '0' && peek<='9') || peek == '_')  					{ // read exponent value  						if (peek == '_')  							ReaderRead();  						else  							expSuffix += (char)ReaderRead();  						peek = (char)ReaderPeek();  					}    					// Exponents just can be decimal integers  					int.TryParse(expSuffix'out exponent);  					expSuffix = suff + expSuffix;  					peek = (char)ReaderPeek();  				}  				#endregion    				#region Suffixes  				if (!HasDot)  				{  				unsigned:  					if (peek == 'u' || peek == 'U')  					{  						ReaderRead();  						suffix += "u";  						subFmt |= LiteralSubformat.Unsigned;  						//isUnsigned = true;  						peek = (char)ReaderPeek();  					}    					if (peek == 'L')  					{  						subFmt |= LiteralSubformat.Long;  						ReaderRead();  						suffix += "L";  						//isLong = true;  						peek = (char)ReaderPeek();  						if (!subFmt.HasFlag(LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  							goto unsigned;  					}  				}    				if (HasDot || AllowSuffixes)  				{  					if (peek == 'f' || peek == 'F')  					{ // float value  						ReaderRead();  						suffix += "f";  						isFloat = true;  						subFmt |= LiteralSubformat.Float;  						peek = (char)ReaderPeek();  					}  					else if (peek == 'L')  					{ // real value  						ReaderRead();  						//isLong = true;  						suffix += 'L';  						subFmt |= LiteralSubformat.Real;  						peek = (char)ReaderPeek();  					}  				}    				if (peek == 'i')  				{ // imaginary value  					ReaderRead();  					suffix += "i";    					subFmt |= LiteralSubformat.Imaginary;  					isImaginary = true;  				}  				#endregion    				#region Parse the digit string  				var num = ParseFloatValue(sb' NumBase);    				if (exponent != 0)  				{  					try{  						num *= (decimal)Math.Pow(NumBase == 16 ? 2 : 10' exponent);  					}  					catch(OverflowException)  					{  						num = decimal.MaxValue;  						//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  						//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  					}  				}  				#endregion    				var token = Token(DTokens.Literal' x' y' Col-x/*stringValue.Length*/' num'/* stringValue'*/  					HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar'  					subFmt);    				if (token != null)  					token.next = nextToken;    				return token;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked  			{ // prevent exception when ReaderPeek() = -1 is cast to char  				int y = Line;  				sb.Length = 0;  				sb.Append(ch);  				//string prefix = null;  				string expSuffix = "";  				string suffix = null;  				int exponent = 0;    				bool HasDot = false;  				LiteralSubformat subFmt = 0;  				bool isFloat = false;  				bool isImaginary = false;  				//bool isUnsigned = false;  				//bool isLong = false;  				int NumBase = 0; // Set it to 0 initially - it'll be set to another value later for sure    				char peek = (char)ReaderPeek();    				// At first' check pre-comma values  				if (ch == '0')  				{  					if (peek == 'x' || peek == 'X') // Hex values  					{  						//prefix = "0x";  						ReaderRead(); // skip 'x'  						sb.Length = 0; // Remove '0' from 0x prefix from the stringvalue  						NumBase = 16;    						peek = (char)ReaderPeek();  						while (IsHex(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					else if (peek == 'b' || peek == 'B') // Bin values  					{  						//prefix = "0b";  						ReaderRead(); // skip 'b'  						sb.Length = 0;  						NumBase = 2;    						peek = (char)ReaderPeek();  						while (IsBin(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					// Oct values have been removed in dmd 2.053  					/*else if (IsOct(peek) || peek == '_') // Oct values  					{  						NumBase = 8;  						prefix = "0";  						sb.Length = 0;    						while (IsOct(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}*/  					else  						NumBase = 10; // Enables pre-comma parsing .. in this case we'd 000 literals or something like that  				}    				if (NumBase == 10 || (ch != '.' && NumBase == 0)) // Only allow further digits for 10-based integers' not for binary or hex values  				{  					NumBase = 10;  					while (IsDigit(peek) || peek == '_')  					{  						if (peek != '_')  							sb.Append((char)ReaderRead());  						else ReaderRead();  						peek = (char)ReaderPeek();  					}  				}    				#region Read digits that occur after a comma  				DToken nextToken = null; // if we accidently read a 'dot'  				bool AllowSuffixes = true;  				if ((NumBase == 0 && ch == '.') || peek == '.')  				{  					if (ch != '.') ReaderRead();  					else  					{  						NumBase = 10;  						sb.Length = 0;  						sb.Append('0');  					}  					peek = (char)ReaderPeek();  					if (!IsLegalDigit(peek' NumBase))  					{  						if (peek == '.')  						{  							ReaderRead();  							nextToken = Token(DTokens.DoubleDot' Col - 1' Line' 2);  						}  						else if (IsIdentifierPart(peek))  							nextToken = Token(DTokens.Dot' Col - 1' Line' 1);    						AllowSuffixes = false;  					}  					else  					{  						HasDot = true;  						sb.Append('.');    						do  						{  							if (peek == '_')  								ReaderRead();  							else  								sb.Append((char)ReaderRead());  							peek = (char)ReaderPeek();  						}  						while (IsLegalDigit(peek' NumBase));  					}  				}  				#endregion    				#region Exponents  				if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E'))  				{ // read exponent  					string suff = peek.ToString();  					ReaderRead();  					peek = (char)ReaderPeek();    					if (peek == '-' || peek == '+')  						expSuffix += (char)ReaderRead();  					peek = (char)ReaderPeek();  					while ((peek >= '0' && peek<='9') || peek == '_')  					{ // read exponent value  						if (peek == '_')  							ReaderRead();  						else  							expSuffix += (char)ReaderRead();  						peek = (char)ReaderPeek();  					}    					// Exponents just can be decimal integers  					int.TryParse(expSuffix'out exponent);  					expSuffix = suff + expSuffix;  					peek = (char)ReaderPeek();  				}  				#endregion    				#region Suffixes  				if (!HasDot)  				{  				unsigned:  					if (peek == 'u' || peek == 'U')  					{  						ReaderRead();  						suffix += "u";  						subFmt |= LiteralSubformat.Unsigned;  						//isUnsigned = true;  						peek = (char)ReaderPeek();  					}    					if (peek == 'L')  					{  						subFmt |= LiteralSubformat.Long;  						ReaderRead();  						suffix += "L";  						//isLong = true;  						peek = (char)ReaderPeek();  						if (!subFmt.HasFlag(LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  							goto unsigned;  					}  				}    				if (HasDot || AllowSuffixes)  				{  					if (peek == 'f' || peek == 'F')  					{ // float value  						ReaderRead();  						suffix += "f";  						isFloat = true;  						subFmt |= LiteralSubformat.Float;  						peek = (char)ReaderPeek();  					}  					else if (peek == 'L')  					{ // real value  						ReaderRead();  						//isLong = true;  						suffix += 'L';  						subFmt |= LiteralSubformat.Real;  						peek = (char)ReaderPeek();  					}  				}    				if (peek == 'i')  				{ // imaginary value  					ReaderRead();  					suffix += "i";    					subFmt |= LiteralSubformat.Imaginary;  					isImaginary = true;  				}  				#endregion    				#region Parse the digit string  				var num = ParseFloatValue(sb' NumBase);    				if (exponent != 0)  				{  					try{  						num *= (decimal)Math.Pow(NumBase == 16 ? 2 : 10' exponent);  					}  					catch(OverflowException)  					{  						num = decimal.MaxValue;  						//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  						//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  					}  				}  				#endregion    				var token = Token(DTokens.Literal' x' y' Col-x/*stringValue.Length*/' num'/* stringValue'*/  					HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar'  					subFmt);    				if (token != null)  					token.next = nextToken;    				return token;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadDigit,The following statement contains a magic number: unchecked  			{ // prevent exception when ReaderPeek() = -1 is cast to char  				int y = Line;  				sb.Length = 0;  				sb.Append(ch);  				//string prefix = null;  				string expSuffix = "";  				string suffix = null;  				int exponent = 0;    				bool HasDot = false;  				LiteralSubformat subFmt = 0;  				bool isFloat = false;  				bool isImaginary = false;  				//bool isUnsigned = false;  				//bool isLong = false;  				int NumBase = 0; // Set it to 0 initially - it'll be set to another value later for sure    				char peek = (char)ReaderPeek();    				// At first' check pre-comma values  				if (ch == '0')  				{  					if (peek == 'x' || peek == 'X') // Hex values  					{  						//prefix = "0x";  						ReaderRead(); // skip 'x'  						sb.Length = 0; // Remove '0' from 0x prefix from the stringvalue  						NumBase = 16;    						peek = (char)ReaderPeek();  						while (IsHex(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					else if (peek == 'b' || peek == 'B') // Bin values  					{  						//prefix = "0b";  						ReaderRead(); // skip 'b'  						sb.Length = 0;  						NumBase = 2;    						peek = (char)ReaderPeek();  						while (IsBin(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}  					// Oct values have been removed in dmd 2.053  					/*else if (IsOct(peek) || peek == '_') // Oct values  					{  						NumBase = 8;  						prefix = "0";  						sb.Length = 0;    						while (IsOct(peek) || peek == '_')  						{  							if (peek != '_')  								sb.Append((char)ReaderRead());  							else ReaderRead();  							peek = (char)ReaderPeek();  						}  					}*/  					else  						NumBase = 10; // Enables pre-comma parsing .. in this case we'd 000 literals or something like that  				}    				if (NumBase == 10 || (ch != '.' && NumBase == 0)) // Only allow further digits for 10-based integers' not for binary or hex values  				{  					NumBase = 10;  					while (IsDigit(peek) || peek == '_')  					{  						if (peek != '_')  							sb.Append((char)ReaderRead());  						else ReaderRead();  						peek = (char)ReaderPeek();  					}  				}    				#region Read digits that occur after a comma  				DToken nextToken = null; // if we accidently read a 'dot'  				bool AllowSuffixes = true;  				if ((NumBase == 0 && ch == '.') || peek == '.')  				{  					if (ch != '.') ReaderRead();  					else  					{  						NumBase = 10;  						sb.Length = 0;  						sb.Append('0');  					}  					peek = (char)ReaderPeek();  					if (!IsLegalDigit(peek' NumBase))  					{  						if (peek == '.')  						{  							ReaderRead();  							nextToken = Token(DTokens.DoubleDot' Col - 1' Line' 2);  						}  						else if (IsIdentifierPart(peek))  							nextToken = Token(DTokens.Dot' Col - 1' Line' 1);    						AllowSuffixes = false;  					}  					else  					{  						HasDot = true;  						sb.Append('.');    						do  						{  							if (peek == '_')  								ReaderRead();  							else  								sb.Append((char)ReaderRead());  							peek = (char)ReaderPeek();  						}  						while (IsLegalDigit(peek' NumBase));  					}  				}  				#endregion    				#region Exponents  				if ((NumBase == 16) ? (peek == 'p' || peek == 'P') : (peek == 'e' || peek == 'E'))  				{ // read exponent  					string suff = peek.ToString();  					ReaderRead();  					peek = (char)ReaderPeek();    					if (peek == '-' || peek == '+')  						expSuffix += (char)ReaderRead();  					peek = (char)ReaderPeek();  					while ((peek >= '0' && peek<='9') || peek == '_')  					{ // read exponent value  						if (peek == '_')  							ReaderRead();  						else  							expSuffix += (char)ReaderRead();  						peek = (char)ReaderPeek();  					}    					// Exponents just can be decimal integers  					int.TryParse(expSuffix'out exponent);  					expSuffix = suff + expSuffix;  					peek = (char)ReaderPeek();  				}  				#endregion    				#region Suffixes  				if (!HasDot)  				{  				unsigned:  					if (peek == 'u' || peek == 'U')  					{  						ReaderRead();  						suffix += "u";  						subFmt |= LiteralSubformat.Unsigned;  						//isUnsigned = true;  						peek = (char)ReaderPeek();  					}    					if (peek == 'L')  					{  						subFmt |= LiteralSubformat.Long;  						ReaderRead();  						suffix += "L";  						//isLong = true;  						peek = (char)ReaderPeek();  						if (!subFmt.HasFlag(LiteralSubformat.Unsigned) && (peek == 'u' || peek == 'U'))  							goto unsigned;  					}  				}    				if (HasDot || AllowSuffixes)  				{  					if (peek == 'f' || peek == 'F')  					{ // float value  						ReaderRead();  						suffix += "f";  						isFloat = true;  						subFmt |= LiteralSubformat.Float;  						peek = (char)ReaderPeek();  					}  					else if (peek == 'L')  					{ // real value  						ReaderRead();  						//isLong = true;  						suffix += 'L';  						subFmt |= LiteralSubformat.Real;  						peek = (char)ReaderPeek();  					}  				}    				if (peek == 'i')  				{ // imaginary value  					ReaderRead();  					suffix += "i";    					subFmt |= LiteralSubformat.Imaginary;  					isImaginary = true;  				}  				#endregion    				#region Parse the digit string  				var num = ParseFloatValue(sb' NumBase);    				if (exponent != 0)  				{  					try{  						num *= (decimal)Math.Pow(NumBase == 16 ? 2 : 10' exponent);  					}  					catch(OverflowException)  					{  						num = decimal.MaxValue;  						//HACK: Don't register these exceptions. The user will notice the issues at least when compiling stuff.  						//LexerErrors.Add(new ParserError(false' "Too huge exponent"' DTokens.Literal' new CodeLocation(x'y)));  					}  				}  				#endregion    				var token = Token(DTokens.Literal' x' y' Col-x/*stringValue.Length*/' num'/* stringValue'*/  					HasDot || isFloat || isImaginary ? (LiteralFormat.FloatingPoint | LiteralFormat.Scalar) : LiteralFormat.Scalar'  					subFmt);    				if (token != null)  					token.next = nextToken;    				return token;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadVerbatimString,The following statement contains a magic number: int x = Col - 2;
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: switch (c)  			{  				case '\'':  					ch = '\'';  					break;  				case '\"':  					ch = '\"';  					break;  				case '?':  					ch = '?';  					return "\\?"; // Literal question mark  				case '\\':  					ch = '\\';  					break;  				/*case '0':  					ch = '\0';  					break;*/  				case 'a':  					ch = '\a'; // Bell (alert)  					break;  				case 'b':  					ch = '\b'; // Backspace  					break;  				case 'f':  					ch = '\f'; // Formfeed  					break;  				case 'n':  					ch = '\n';  					break;  				case 'r':  					ch = '\r';  					break;  				case 't':  					ch = '\t';  					break;  				case 'v':  					ch = '\v'; // Vertical tab  					break;  				case 'u':  				case 'x':  					// 16 bit unicode character  					c = (char)ReaderRead();  					number = GetHexNumber(c);  					escapeSequenceBuffer[curPos++] = c;    					if (number < 0)  					{  						OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' c));  					}  					for (int i = 0; i < 3; ++i)  					{  						if (IsHex((char)ReaderPeek()))  						{  							c = (char)ReaderRead();  							int idx = GetHexNumber(c);  							escapeSequenceBuffer[curPos++] = c;  							number = 16 * number + idx;  						}  						else  						{  							break;  						}  					}  					ch = (char)number;  					break;  				case 'U':  					// 32 bit unicode character  					number = 0;  					for (int i = 0; i < 8; ++i)  					{  						if (IsHex((char)ReaderPeek()))  						{  							c = (char)ReaderRead();  							int idx = GetHexNumber(c);  							escapeSequenceBuffer[curPos++] = c;  							number = 16 * number + idx;  						}  						else  						{  							OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' (char)ReaderPeek()));  							break;  						}  					}  					if (number > 0xffff)  					{  						ch = '\0';  						surrogatePair = char.ConvertFromUtf32(number);  					}  					else  					{  						ch = (char)number;  					}  					break;    				// NamedCharacterEntities  				case '&':  					string charEntity = "";    					while (true)  					{  						nextChar = ReaderRead();    						if (nextChar < 0)  						{  							OnError(Line' Col - 1' "EOF reached within named char entity");  							ch = '\0';  							return string.Empty;  						}    						c = (char)nextChar;    						if (c == ';')  							break;    						if (IsIdentifierPart(c))  							charEntity += c;  						else  						{  							OnError(Line' Col - 1' "Unexpected character found in named char entity: " + c);  							ch = '\0';  							return string.Empty;  						}  					}    					if (string.IsNullOrEmpty(charEntity))  					{  						OnError(Line' Col - 1' "Empty named character entities not allowed");  						ch = '\0';  						return string.Empty;  					}    					//TODO: Performance improvement  					//var ret=System.Web.HttpUtility.HtmlDecode("&"+charEntity+";");    					ch = '#';//ret[0];    					return "&" + charEntity + ";";  				default:    					// Max 3 following octal digits  					if (IsOct(c))  					{  						// Parse+Convert oct to dec integer  						int oct = GetHexNumber(c);    						for (int i = 0; i < 2; ++i)  						{  							if (IsOct((char)ReaderPeek()))  							{  								c = (char)ReaderRead();  								escapeSequenceBuffer[curPos++] = c;    								int idx = GetHexNumber(c);  								oct = 8 * oct + idx;  							}  							else  								break;  						}    						// Convert integer to character  						if (oct > 0xffff)  						{  							ch = '\0';  							surrogatePair = char.ConvertFromUtf32(oct);  						}  						else  						{  							ch = (char)oct;  						}    					}  					else  					{  						OnError(Line' Col' String.Format("Unexpected escape sequence : {0}"' c));  						ch = '\0';  					}  					break;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: switch (c)  			{  				case '\'':  					ch = '\'';  					break;  				case '\"':  					ch = '\"';  					break;  				case '?':  					ch = '?';  					return "\\?"; // Literal question mark  				case '\\':  					ch = '\\';  					break;  				/*case '0':  					ch = '\0';  					break;*/  				case 'a':  					ch = '\a'; // Bell (alert)  					break;  				case 'b':  					ch = '\b'; // Backspace  					break;  				case 'f':  					ch = '\f'; // Formfeed  					break;  				case 'n':  					ch = '\n';  					break;  				case 'r':  					ch = '\r';  					break;  				case 't':  					ch = '\t';  					break;  				case 'v':  					ch = '\v'; // Vertical tab  					break;  				case 'u':  				case 'x':  					// 16 bit unicode character  					c = (char)ReaderRead();  					number = GetHexNumber(c);  					escapeSequenceBuffer[curPos++] = c;    					if (number < 0)  					{  						OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' c));  					}  					for (int i = 0; i < 3; ++i)  					{  						if (IsHex((char)ReaderPeek()))  						{  							c = (char)ReaderRead();  							int idx = GetHexNumber(c);  							escapeSequenceBuffer[curPos++] = c;  							number = 16 * number + idx;  						}  						else  						{  							break;  						}  					}  					ch = (char)number;  					break;  				case 'U':  					// 32 bit unicode character  					number = 0;  					for (int i = 0; i < 8; ++i)  					{  						if (IsHex((char)ReaderPeek()))  						{  							c = (char)ReaderRead();  							int idx = GetHexNumber(c);  							escapeSequenceBuffer[curPos++] = c;  							number = 16 * number + idx;  						}  						else  						{  							OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' (char)ReaderPeek()));  							break;  						}  					}  					if (number > 0xffff)  					{  						ch = '\0';  						surrogatePair = char.ConvertFromUtf32(number);  					}  					else  					{  						ch = (char)number;  					}  					break;    				// NamedCharacterEntities  				case '&':  					string charEntity = "";    					while (true)  					{  						nextChar = ReaderRead();    						if (nextChar < 0)  						{  							OnError(Line' Col - 1' "EOF reached within named char entity");  							ch = '\0';  							return string.Empty;  						}    						c = (char)nextChar;    						if (c == ';')  							break;    						if (IsIdentifierPart(c))  							charEntity += c;  						else  						{  							OnError(Line' Col - 1' "Unexpected character found in named char entity: " + c);  							ch = '\0';  							return string.Empty;  						}  					}    					if (string.IsNullOrEmpty(charEntity))  					{  						OnError(Line' Col - 1' "Empty named character entities not allowed");  						ch = '\0';  						return string.Empty;  					}    					//TODO: Performance improvement  					//var ret=System.Web.HttpUtility.HtmlDecode("&"+charEntity+";");    					ch = '#';//ret[0];    					return "&" + charEntity + ";";  				default:    					// Max 3 following octal digits  					if (IsOct(c))  					{  						// Parse+Convert oct to dec integer  						int oct = GetHexNumber(c);    						for (int i = 0; i < 2; ++i)  						{  							if (IsOct((char)ReaderPeek()))  							{  								c = (char)ReaderRead();  								escapeSequenceBuffer[curPos++] = c;    								int idx = GetHexNumber(c);  								oct = 8 * oct + idx;  							}  							else  								break;  						}    						// Convert integer to character  						if (oct > 0xffff)  						{  							ch = '\0';  							surrogatePair = char.ConvertFromUtf32(oct);  						}  						else  						{  							ch = (char)oct;  						}    					}  					else  					{  						OnError(Line' Col' String.Format("Unexpected escape sequence : {0}"' c));  						ch = '\0';  					}  					break;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: switch (c)  			{  				case '\'':  					ch = '\'';  					break;  				case '\"':  					ch = '\"';  					break;  				case '?':  					ch = '?';  					return "\\?"; // Literal question mark  				case '\\':  					ch = '\\';  					break;  				/*case '0':  					ch = '\0';  					break;*/  				case 'a':  					ch = '\a'; // Bell (alert)  					break;  				case 'b':  					ch = '\b'; // Backspace  					break;  				case 'f':  					ch = '\f'; // Formfeed  					break;  				case 'n':  					ch = '\n';  					break;  				case 'r':  					ch = '\r';  					break;  				case 't':  					ch = '\t';  					break;  				case 'v':  					ch = '\v'; // Vertical tab  					break;  				case 'u':  				case 'x':  					// 16 bit unicode character  					c = (char)ReaderRead();  					number = GetHexNumber(c);  					escapeSequenceBuffer[curPos++] = c;    					if (number < 0)  					{  						OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' c));  					}  					for (int i = 0; i < 3; ++i)  					{  						if (IsHex((char)ReaderPeek()))  						{  							c = (char)ReaderRead();  							int idx = GetHexNumber(c);  							escapeSequenceBuffer[curPos++] = c;  							number = 16 * number + idx;  						}  						else  						{  							break;  						}  					}  					ch = (char)number;  					break;  				case 'U':  					// 32 bit unicode character  					number = 0;  					for (int i = 0; i < 8; ++i)  					{  						if (IsHex((char)ReaderPeek()))  						{  							c = (char)ReaderRead();  							int idx = GetHexNumber(c);  							escapeSequenceBuffer[curPos++] = c;  							number = 16 * number + idx;  						}  						else  						{  							OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' (char)ReaderPeek()));  							break;  						}  					}  					if (number > 0xffff)  					{  						ch = '\0';  						surrogatePair = char.ConvertFromUtf32(number);  					}  					else  					{  						ch = (char)number;  					}  					break;    				// NamedCharacterEntities  				case '&':  					string charEntity = "";    					while (true)  					{  						nextChar = ReaderRead();    						if (nextChar < 0)  						{  							OnError(Line' Col - 1' "EOF reached within named char entity");  							ch = '\0';  							return string.Empty;  						}    						c = (char)nextChar;    						if (c == ';')  							break;    						if (IsIdentifierPart(c))  							charEntity += c;  						else  						{  							OnError(Line' Col - 1' "Unexpected character found in named char entity: " + c);  							ch = '\0';  							return string.Empty;  						}  					}    					if (string.IsNullOrEmpty(charEntity))  					{  						OnError(Line' Col - 1' "Empty named character entities not allowed");  						ch = '\0';  						return string.Empty;  					}    					//TODO: Performance improvement  					//var ret=System.Web.HttpUtility.HtmlDecode("&"+charEntity+";");    					ch = '#';//ret[0];    					return "&" + charEntity + ";";  				default:    					// Max 3 following octal digits  					if (IsOct(c))  					{  						// Parse+Convert oct to dec integer  						int oct = GetHexNumber(c);    						for (int i = 0; i < 2; ++i)  						{  							if (IsOct((char)ReaderPeek()))  							{  								c = (char)ReaderRead();  								escapeSequenceBuffer[curPos++] = c;    								int idx = GetHexNumber(c);  								oct = 8 * oct + idx;  							}  							else  								break;  						}    						// Convert integer to character  						if (oct > 0xffff)  						{  							ch = '\0';  							surrogatePair = char.ConvertFromUtf32(oct);  						}  						else  						{  							ch = (char)oct;  						}    					}  					else  					{  						OnError(Line' Col' String.Format("Unexpected escape sequence : {0}"' c));  						ch = '\0';  					}  					break;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: switch (c)  			{  				case '\'':  					ch = '\'';  					break;  				case '\"':  					ch = '\"';  					break;  				case '?':  					ch = '?';  					return "\\?"; // Literal question mark  				case '\\':  					ch = '\\';  					break;  				/*case '0':  					ch = '\0';  					break;*/  				case 'a':  					ch = '\a'; // Bell (alert)  					break;  				case 'b':  					ch = '\b'; // Backspace  					break;  				case 'f':  					ch = '\f'; // Formfeed  					break;  				case 'n':  					ch = '\n';  					break;  				case 'r':  					ch = '\r';  					break;  				case 't':  					ch = '\t';  					break;  				case 'v':  					ch = '\v'; // Vertical tab  					break;  				case 'u':  				case 'x':  					// 16 bit unicode character  					c = (char)ReaderRead();  					number = GetHexNumber(c);  					escapeSequenceBuffer[curPos++] = c;    					if (number < 0)  					{  						OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' c));  					}  					for (int i = 0; i < 3; ++i)  					{  						if (IsHex((char)ReaderPeek()))  						{  							c = (char)ReaderRead();  							int idx = GetHexNumber(c);  							escapeSequenceBuffer[curPos++] = c;  							number = 16 * number + idx;  						}  						else  						{  							break;  						}  					}  					ch = (char)number;  					break;  				case 'U':  					// 32 bit unicode character  					number = 0;  					for (int i = 0; i < 8; ++i)  					{  						if (IsHex((char)ReaderPeek()))  						{  							c = (char)ReaderRead();  							int idx = GetHexNumber(c);  							escapeSequenceBuffer[curPos++] = c;  							number = 16 * number + idx;  						}  						else  						{  							OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' (char)ReaderPeek()));  							break;  						}  					}  					if (number > 0xffff)  					{  						ch = '\0';  						surrogatePair = char.ConvertFromUtf32(number);  					}  					else  					{  						ch = (char)number;  					}  					break;    				// NamedCharacterEntities  				case '&':  					string charEntity = "";    					while (true)  					{  						nextChar = ReaderRead();    						if (nextChar < 0)  						{  							OnError(Line' Col - 1' "EOF reached within named char entity");  							ch = '\0';  							return string.Empty;  						}    						c = (char)nextChar;    						if (c == ';')  							break;    						if (IsIdentifierPart(c))  							charEntity += c;  						else  						{  							OnError(Line' Col - 1' "Unexpected character found in named char entity: " + c);  							ch = '\0';  							return string.Empty;  						}  					}    					if (string.IsNullOrEmpty(charEntity))  					{  						OnError(Line' Col - 1' "Empty named character entities not allowed");  						ch = '\0';  						return string.Empty;  					}    					//TODO: Performance improvement  					//var ret=System.Web.HttpUtility.HtmlDecode("&"+charEntity+";");    					ch = '#';//ret[0];    					return "&" + charEntity + ";";  				default:    					// Max 3 following octal digits  					if (IsOct(c))  					{  						// Parse+Convert oct to dec integer  						int oct = GetHexNumber(c);    						for (int i = 0; i < 2; ++i)  						{  							if (IsOct((char)ReaderPeek()))  							{  								c = (char)ReaderRead();  								escapeSequenceBuffer[curPos++] = c;    								int idx = GetHexNumber(c);  								oct = 8 * oct + idx;  							}  							else  								break;  						}    						// Convert integer to character  						if (oct > 0xffff)  						{  							ch = '\0';  							surrogatePair = char.ConvertFromUtf32(oct);  						}  						else  						{  							ch = (char)oct;  						}    					}  					else  					{  						OnError(Line' Col' String.Format("Unexpected escape sequence : {0}"' c));  						ch = '\0';  					}  					break;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: switch (c)  			{  				case '\'':  					ch = '\'';  					break;  				case '\"':  					ch = '\"';  					break;  				case '?':  					ch = '?';  					return "\\?"; // Literal question mark  				case '\\':  					ch = '\\';  					break;  				/*case '0':  					ch = '\0';  					break;*/  				case 'a':  					ch = '\a'; // Bell (alert)  					break;  				case 'b':  					ch = '\b'; // Backspace  					break;  				case 'f':  					ch = '\f'; // Formfeed  					break;  				case 'n':  					ch = '\n';  					break;  				case 'r':  					ch = '\r';  					break;  				case 't':  					ch = '\t';  					break;  				case 'v':  					ch = '\v'; // Vertical tab  					break;  				case 'u':  				case 'x':  					// 16 bit unicode character  					c = (char)ReaderRead();  					number = GetHexNumber(c);  					escapeSequenceBuffer[curPos++] = c;    					if (number < 0)  					{  						OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' c));  					}  					for (int i = 0; i < 3; ++i)  					{  						if (IsHex((char)ReaderPeek()))  						{  							c = (char)ReaderRead();  							int idx = GetHexNumber(c);  							escapeSequenceBuffer[curPos++] = c;  							number = 16 * number + idx;  						}  						else  						{  							break;  						}  					}  					ch = (char)number;  					break;  				case 'U':  					// 32 bit unicode character  					number = 0;  					for (int i = 0; i < 8; ++i)  					{  						if (IsHex((char)ReaderPeek()))  						{  							c = (char)ReaderRead();  							int idx = GetHexNumber(c);  							escapeSequenceBuffer[curPos++] = c;  							number = 16 * number + idx;  						}  						else  						{  							OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' (char)ReaderPeek()));  							break;  						}  					}  					if (number > 0xffff)  					{  						ch = '\0';  						surrogatePair = char.ConvertFromUtf32(number);  					}  					else  					{  						ch = (char)number;  					}  					break;    				// NamedCharacterEntities  				case '&':  					string charEntity = "";    					while (true)  					{  						nextChar = ReaderRead();    						if (nextChar < 0)  						{  							OnError(Line' Col - 1' "EOF reached within named char entity");  							ch = '\0';  							return string.Empty;  						}    						c = (char)nextChar;    						if (c == ';')  							break;    						if (IsIdentifierPart(c))  							charEntity += c;  						else  						{  							OnError(Line' Col - 1' "Unexpected character found in named char entity: " + c);  							ch = '\0';  							return string.Empty;  						}  					}    					if (string.IsNullOrEmpty(charEntity))  					{  						OnError(Line' Col - 1' "Empty named character entities not allowed");  						ch = '\0';  						return string.Empty;  					}    					//TODO: Performance improvement  					//var ret=System.Web.HttpUtility.HtmlDecode("&"+charEntity+";");    					ch = '#';//ret[0];    					return "&" + charEntity + ";";  				default:    					// Max 3 following octal digits  					if (IsOct(c))  					{  						// Parse+Convert oct to dec integer  						int oct = GetHexNumber(c);    						for (int i = 0; i < 2; ++i)  						{  							if (IsOct((char)ReaderPeek()))  							{  								c = (char)ReaderRead();  								escapeSequenceBuffer[curPos++] = c;    								int idx = GetHexNumber(c);  								oct = 8 * oct + idx;  							}  							else  								break;  						}    						// Convert integer to character  						if (oct > 0xffff)  						{  							ch = '\0';  							surrogatePair = char.ConvertFromUtf32(oct);  						}  						else  						{  							ch = (char)oct;  						}    					}  					else  					{  						OnError(Line' Col' String.Format("Unexpected escape sequence : {0}"' c));  						ch = '\0';  					}  					break;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadEscapeSequence,The following statement contains a magic number: switch (c)  			{  				case '\'':  					ch = '\'';  					break;  				case '\"':  					ch = '\"';  					break;  				case '?':  					ch = '?';  					return "\\?"; // Literal question mark  				case '\\':  					ch = '\\';  					break;  				/*case '0':  					ch = '\0';  					break;*/  				case 'a':  					ch = '\a'; // Bell (alert)  					break;  				case 'b':  					ch = '\b'; // Backspace  					break;  				case 'f':  					ch = '\f'; // Formfeed  					break;  				case 'n':  					ch = '\n';  					break;  				case 'r':  					ch = '\r';  					break;  				case 't':  					ch = '\t';  					break;  				case 'v':  					ch = '\v'; // Vertical tab  					break;  				case 'u':  				case 'x':  					// 16 bit unicode character  					c = (char)ReaderRead();  					number = GetHexNumber(c);  					escapeSequenceBuffer[curPos++] = c;    					if (number < 0)  					{  						OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' c));  					}  					for (int i = 0; i < 3; ++i)  					{  						if (IsHex((char)ReaderPeek()))  						{  							c = (char)ReaderRead();  							int idx = GetHexNumber(c);  							escapeSequenceBuffer[curPos++] = c;  							number = 16 * number + idx;  						}  						else  						{  							break;  						}  					}  					ch = (char)number;  					break;  				case 'U':  					// 32 bit unicode character  					number = 0;  					for (int i = 0; i < 8; ++i)  					{  						if (IsHex((char)ReaderPeek()))  						{  							c = (char)ReaderRead();  							int idx = GetHexNumber(c);  							escapeSequenceBuffer[curPos++] = c;  							number = 16 * number + idx;  						}  						else  						{  							OnError(Line' Col - 1' String.Format("Invalid char in literal : {0}"' (char)ReaderPeek()));  							break;  						}  					}  					if (number > 0xffff)  					{  						ch = '\0';  						surrogatePair = char.ConvertFromUtf32(number);  					}  					else  					{  						ch = (char)number;  					}  					break;    				// NamedCharacterEntities  				case '&':  					string charEntity = "";    					while (true)  					{  						nextChar = ReaderRead();    						if (nextChar < 0)  						{  							OnError(Line' Col - 1' "EOF reached within named char entity");  							ch = '\0';  							return string.Empty;  						}    						c = (char)nextChar;    						if (c == ';')  							break;    						if (IsIdentifierPart(c))  							charEntity += c;  						else  						{  							OnError(Line' Col - 1' "Unexpected character found in named char entity: " + c);  							ch = '\0';  							return string.Empty;  						}  					}    					if (string.IsNullOrEmpty(charEntity))  					{  						OnError(Line' Col - 1' "Empty named character entities not allowed");  						ch = '\0';  						return string.Empty;  					}    					//TODO: Performance improvement  					//var ret=System.Web.HttpUtility.HtmlDecode("&"+charEntity+";");    					ch = '#';//ret[0];    					return "&" + charEntity + ";";  				default:    					// Max 3 following octal digits  					if (IsOct(c))  					{  						// Parse+Convert oct to dec integer  						int oct = GetHexNumber(c);    						for (int i = 0; i < 2; ++i)  						{  							if (IsOct((char)ReaderPeek()))  							{  								c = (char)ReaderRead();  								escapeSequenceBuffer[curPos++] = c;    								int idx = GetHexNumber(c);  								oct = 8 * oct + idx;  							}  							else  								break;  						}    						// Convert integer to character  						if (oct > 0xffff)  						{  							ch = '\0';  							surrogatePair = char.ConvertFromUtf32(oct);  						}  						else  						{  							ch = (char)oct;  						}    					}  					else  					{  						OnError(Line' Col' String.Format("Unexpected escape sequence : {0}"' c));  						ch = '\0';  					}  					break;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadChar,The following statement contains a magic number: if (ch == '\\')  			{  				escapeSequence = ReadEscapeSequence(out chValue' out surrogatePair);  				if (surrogatePair != null)  				{  					// Although we'll pass back a string as literal value' it's originally handled as char literal!  				}  			}  			else if (ch == '\'')  			{  				return Token(DTokens.Literal' x' y' 2' char.MinValue' "''"' LiteralFormat.CharLiteral);  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following statement contains a magic number: switch (ch)  			{  				case '+':  					switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}  					return Token(DTokens.Plus' x' y);  				case '-':  					switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}  					return Token(DTokens.Minus' x' y);  				case '*':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TimesAssign' x' y' 2);  						default:  							break;  					}  					return Token(DTokens.Times' x' y);  				case '/':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}  					return Token(DTokens.Div' x' y);  				case '%':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}  					return Token(DTokens.Mod' x' y);  				case '&':  					switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseAnd' x' y);  				case '|':  					switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}  					return Token(DTokens.BitwiseOr' x' y);  				case '^':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}  					return Token(DTokens.Xor' x' y);  				case '!':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.NotEqual' x' y' 2); // !=    						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}  							return Token(DTokens.UnorderedGreaterOrEqual' x' y' 2); // !<    						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrLess' x' y' 3); // !>=  								default:  									break;  							}  							return Token(DTokens.UnorderedLessOrEqual' x' y' 2); // !>    					}  					return Token(DTokens.Not' x' y);  				case '~':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}  					return Token(DTokens.Tilde' x' y);  				case '=':  					switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}  					return Token(DTokens.Assign' x' y);  				case '<':  					switch (ReaderPeek())  					{  						case '<':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.ShiftLeftAssign' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.ShiftLeft' x' y' 2);  						case '>':  							ReaderRead();  							switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.LessEqualOrGreater' x' y' 3);  								default:  									break;  							}  							return Token(DTokens.LessOrGreater' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.LessEqual' x' y' 2);  					}  					return Token(DTokens.LessThan' x' y);  				case '>':  					switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}  					return Token(DTokens.GreaterThan' x' y);  				case '?':  					return Token(DTokens.Question' x' y);  				case '$':  					return Token(DTokens.Dollar' x' y);  				case ';':  					return Token(DTokens.Semicolon' x' y);  				case ':':  					return Token(DTokens.Colon' x' y);  				case ''':  					return Token(DTokens.Comma' x' y);  				case '.':  					// Prevent OverflowException when ReaderPeek returns -1  					int tmp = ReaderPeek();  					if (tmp > 0 && IsDigit((char)tmp))  						return ReadDigit('.'' Col - 1);  					else if (tmp == (int)'.')  					{  						ReaderRead();  						if ((char)ReaderPeek() == '.') // Triple dot  						{  							ReaderRead();  							return Token(DTokens.TripleDot' x' y' 3);  						}  						return Token(DTokens.DoubleDot' x' y' 2);  					}  					return Token(DTokens.Dot' x' y);  				case ')':  					return Token(DTokens.CloseParenthesis' x' y);  				case '(':  					return Token(DTokens.OpenParenthesis' x' y);  				case ']':  					return Token(DTokens.CloseSquareBracket' x' y);  				case '[':  					return Token(DTokens.OpenSquareBracket' x' y);  				case '}':  					return Token(DTokens.CloseCurlyBrace' x' y);  				case '{':  					return Token(DTokens.OpenCurlyBrace' x' y);  				default:  					return null;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadSingleLineComment,The following statement contains a magic number: int tagLen = ((commentType & Comment.Type.Documentation) != 0 ? 3 : 2);
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadSingleLineComment,The following statement contains a magic number: int tagLen = ((commentType & Comment.Type.Documentation) != 0 ? 3 : 2);
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadSingleLineComment,The following statement contains a magic number: if ((commentType &Comment.Type.Documentation) != 0 || !OnlyEnlistDDocComments)  				Comments.Add(new Comment(commentType' comm.TrimStart('/''' '''\t')' st.Column < 2' st' end));
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadMultiLineComment,The following statement contains a magic number: CodeLocation st = new CodeLocation(Col - ((commentType & Comment.Type.Documentation) != 0 ? 3 : 2)' Line);
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadMultiLineComment,The following statement contains a magic number: CodeLocation st = new CodeLocation(Col - ((commentType & Comment.Type.Documentation) != 0 ? 3 : 2)' Line);
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadMultiLineComment,The following statement contains a magic number: while ((nextChar = ReaderRead()) != -1)  			{    				char ch = (char)nextChar;    				// Catch deeper-nesting comments  				if (isNestingComment && ch == '/' && ReaderPeek() == '+')  				{  					nestedCommentDepth++;  					ReaderRead();  				}    				// End of multiline comment reached ?  				if ((isNestingComment ? ch == '+' : ch == '*') && ReaderPeek() == '/')  				{  					ReaderRead(); // Skip "*" or "+"    					if (nestedCommentDepth > 1)  						nestedCommentDepth--;  					else  					{  						if (commentType.HasFlag(Comment.Type.Documentation) || !OnlyEnlistDDocComments)  							Comments.Add(new Comment(commentType' scCurWord.ToString().Trim(ch' ' '' '\t'' '\r'' '\n'' isNestingComment ? '+' : '*')' st.Column < 2' st' new CodeLocation(Col' Line)));  						return;  					}  				}    				if (HandleLineEnd(ch))  				{  					scCurWord.AppendLine();  					hadLineEnd = true;  				}    				// Skip intial white spaces' leading + as well as *  				else if (hadLineEnd)  				{  					if (char.IsWhiteSpace(ch) || (isNestingComment ? ch == '+' : ch == '*'))  					{ }  					else  					{  						scCurWord.Append(ch);  						hadLineEnd = false;  					}  				}  				else  					scCurWord.Append(ch);  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadMultiLineComment,The following statement contains a magic number: if (commentType.HasFlag(Comment.Type.Documentation) || !OnlyEnlistDDocComments)  				Comments.Add(new Comment(commentType' scCurWord.ToString().Trim()' st.Column < 2' st' new CodeLocation(Col' Line)));
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,IsLegalDigit,The following statement contains a magic number: switch (NumBase)  			{  				case 2:  					return IsBin(d);  				case 10:  					return IsDigit(d);  				case 16:  					return IsHex(d);  				default:  					return false;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,IsLegalDigit,The following statement contains a magic number: switch (NumBase)  			{  				case 2:  					return IsBin(d);  				case 10:  					return IsDigit(d);  				case 16:  					return IsHex(d);  				default:  					return false;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,IsLegalDigit,The following statement contains a magic number: switch (NumBase)  			{  				case 2:  					return IsBin(d);  				case 10:  					return IsDigit(d);  				case 16:  					return IsHex(d);  				default:  					return false;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit)  			{  				case '0':  					return 0;  				case '1':  					return 1;  				case '2':  					return 2;  				case '3':  					return 3;  				case '4':  					return 4;  				case '5':  					return 5;  				case '6':  					return 6;  				case '7':  					return 7;  				case '8':  					return 8;  				case '9':  					return 9;  				case 'a':  				case 'A':  					return 10;  				case 'b':  				case 'B':  					return 11;  				case 'c':  				case 'C':  					return 12;  				case 'd':  				case 'D':  					return 13;  				case 'e':  				case 'E':  					return 14;  				case 'f':  				case 'F':  					return 15;  				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit)  			{  				case '0':  					return 0;  				case '1':  					return 1;  				case '2':  					return 2;  				case '3':  					return 3;  				case '4':  					return 4;  				case '5':  					return 5;  				case '6':  					return 6;  				case '7':  					return 7;  				case '8':  					return 8;  				case '9':  					return 9;  				case 'a':  				case 'A':  					return 10;  				case 'b':  				case 'B':  					return 11;  				case 'c':  				case 'C':  					return 12;  				case 'd':  				case 'D':  					return 13;  				case 'e':  				case 'E':  					return 14;  				case 'f':  				case 'F':  					return 15;  				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit)  			{  				case '0':  					return 0;  				case '1':  					return 1;  				case '2':  					return 2;  				case '3':  					return 3;  				case '4':  					return 4;  				case '5':  					return 5;  				case '6':  					return 6;  				case '7':  					return 7;  				case '8':  					return 8;  				case '9':  					return 9;  				case 'a':  				case 'A':  					return 10;  				case 'b':  				case 'B':  					return 11;  				case 'c':  				case 'C':  					return 12;  				case 'd':  				case 'D':  					return 13;  				case 'e':  				case 'E':  					return 14;  				case 'f':  				case 'F':  					return 15;  				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit)  			{  				case '0':  					return 0;  				case '1':  					return 1;  				case '2':  					return 2;  				case '3':  					return 3;  				case '4':  					return 4;  				case '5':  					return 5;  				case '6':  					return 6;  				case '7':  					return 7;  				case '8':  					return 8;  				case '9':  					return 9;  				case 'a':  				case 'A':  					return 10;  				case 'b':  				case 'B':  					return 11;  				case 'c':  				case 'C':  					return 12;  				case 'd':  				case 'D':  					return 13;  				case 'e':  				case 'E':  					return 14;  				case 'f':  				case 'F':  					return 15;  				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit)  			{  				case '0':  					return 0;  				case '1':  					return 1;  				case '2':  					return 2;  				case '3':  					return 3;  				case '4':  					return 4;  				case '5':  					return 5;  				case '6':  					return 6;  				case '7':  					return 7;  				case '8':  					return 8;  				case '9':  					return 9;  				case 'a':  				case 'A':  					return 10;  				case 'b':  				case 'B':  					return 11;  				case 'c':  				case 'C':  					return 12;  				case 'd':  				case 'D':  					return 13;  				case 'e':  				case 'E':  					return 14;  				case 'f':  				case 'F':  					return 15;  				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit)  			{  				case '0':  					return 0;  				case '1':  					return 1;  				case '2':  					return 2;  				case '3':  					return 3;  				case '4':  					return 4;  				case '5':  					return 5;  				case '6':  					return 6;  				case '7':  					return 7;  				case '8':  					return 8;  				case '9':  					return 9;  				case 'a':  				case 'A':  					return 10;  				case 'b':  				case 'B':  					return 11;  				case 'c':  				case 'C':  					return 12;  				case 'd':  				case 'D':  					return 13;  				case 'e':  				case 'E':  					return 14;  				case 'f':  				case 'F':  					return 15;  				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit)  			{  				case '0':  					return 0;  				case '1':  					return 1;  				case '2':  					return 2;  				case '3':  					return 3;  				case '4':  					return 4;  				case '5':  					return 5;  				case '6':  					return 6;  				case '7':  					return 7;  				case '8':  					return 8;  				case '9':  					return 9;  				case 'a':  				case 'A':  					return 10;  				case 'b':  				case 'B':  					return 11;  				case 'c':  				case 'C':  					return 12;  				case 'd':  				case 'D':  					return 13;  				case 'e':  				case 'E':  					return 14;  				case 'f':  				case 'F':  					return 15;  				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit)  			{  				case '0':  					return 0;  				case '1':  					return 1;  				case '2':  					return 2;  				case '3':  					return 3;  				case '4':  					return 4;  				case '5':  					return 5;  				case '6':  					return 6;  				case '7':  					return 7;  				case '8':  					return 8;  				case '9':  					return 9;  				case 'a':  				case 'A':  					return 10;  				case 'b':  				case 'B':  					return 11;  				case 'c':  				case 'C':  					return 12;  				case 'd':  				case 'D':  					return 13;  				case 'e':  				case 'E':  					return 14;  				case 'f':  				case 'F':  					return 15;  				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit)  			{  				case '0':  					return 0;  				case '1':  					return 1;  				case '2':  					return 2;  				case '3':  					return 3;  				case '4':  					return 4;  				case '5':  					return 5;  				case '6':  					return 6;  				case '7':  					return 7;  				case '8':  					return 8;  				case '9':  					return 9;  				case 'a':  				case 'A':  					return 10;  				case 'b':  				case 'B':  					return 11;  				case 'c':  				case 'C':  					return 12;  				case 'd':  				case 'D':  					return 13;  				case 'e':  				case 'E':  					return 14;  				case 'f':  				case 'F':  					return 15;  				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit)  			{  				case '0':  					return 0;  				case '1':  					return 1;  				case '2':  					return 2;  				case '3':  					return 3;  				case '4':  					return 4;  				case '5':  					return 5;  				case '6':  					return 6;  				case '7':  					return 7;  				case '8':  					return 8;  				case '9':  					return 9;  				case 'a':  				case 'A':  					return 10;  				case 'b':  				case 'B':  					return 11;  				case 'c':  				case 'C':  					return 12;  				case 'd':  				case 'D':  					return 13;  				case 'e':  				case 'E':  					return 14;  				case 'f':  				case 'F':  					return 15;  				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit)  			{  				case '0':  					return 0;  				case '1':  					return 1;  				case '2':  					return 2;  				case '3':  					return 3;  				case '4':  					return 4;  				case '5':  					return 5;  				case '6':  					return 6;  				case '7':  					return 7;  				case '8':  					return 8;  				case '9':  					return 9;  				case 'a':  				case 'A':  					return 10;  				case 'b':  				case 'B':  					return 11;  				case 'c':  				case 'C':  					return 12;  				case 'd':  				case 'D':  					return 13;  				case 'e':  				case 'E':  					return 14;  				case 'f':  				case 'F':  					return 15;  				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit)  			{  				case '0':  					return 0;  				case '1':  					return 1;  				case '2':  					return 2;  				case '3':  					return 3;  				case '4':  					return 4;  				case '5':  					return 5;  				case '6':  					return 6;  				case '7':  					return 7;  				case '8':  					return 8;  				case '9':  					return 9;  				case 'a':  				case 'A':  					return 10;  				case 'b':  				case 'B':  					return 11;  				case 'c':  				case 'C':  					return 12;  				case 'd':  				case 'D':  					return 13;  				case 'e':  				case 'E':  					return 14;  				case 'f':  				case 'F':  					return 15;  				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit)  			{  				case '0':  					return 0;  				case '1':  					return 1;  				case '2':  					return 2;  				case '3':  					return 3;  				case '4':  					return 4;  				case '5':  					return 5;  				case '6':  					return 6;  				case '7':  					return 7;  				case '8':  					return 8;  				case '9':  					return 9;  				case 'a':  				case 'A':  					return 10;  				case 'b':  				case 'B':  					return 11;  				case 'c':  				case 'C':  					return 12;  				case 'd':  				case 'D':  					return 13;  				case 'e':  				case 'E':  					return 14;  				case 'f':  				case 'F':  					return 15;  				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0;  			}
Magic Number,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,GetHexNumber,The following statement contains a magic number: switch (digit)  			{  				case '0':  					return 0;  				case '1':  					return 1;  				case '2':  					return 2;  				case '3':  					return 3;  				case '4':  					return 4;  				case '5':  					return 5;  				case '6':  					return 6;  				case '7':  					return 7;  				case '8':  					return 8;  				case '9':  					return 9;  				case 'a':  				case 'A':  					return 10;  				case 'b':  				case 'B':  					return 11;  				case 'c':  				case 'C':  					return 12;  				case 'd':  				case 'D':  					return 13;  				case 'e':  				case 'E':  					return 14;  				case 'f':  				case 'F':  					return 15;  				default:  					//errors.Error(line' col' String.Format("Invalid hex number '" + digit + "'"));  					return 0;  			}
Magic Number,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,GetComments,The following statement contains a magic number: if (sb.Length != 5 || sb.ToString().ToLowerInvariant() != "ditto")  				PreviousComment = sb;
Magic Number,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,CheckForPostSemicolonComment,The following statement contains a magic number: if (ret.Length == 5 && ret.ToString().ToLowerInvariant() == "ditto")  				return PreviousComment.ToString();
Magic Number,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,ParseAsmStatement,The following statement contains a magic number: while (!IsEOF && laKind != (CloseCurlyBrace))  			{  				bool retrying = false;  			Retry:  				bool noStatement = false;  				switch(laKind)  				{  					case Align:  					als = new AsmStatement.AlignStatement() { Location = la.Location' Parent = s };  					Step();  					als.ValueExpression = Expression(Scope);  					l.Add(als);  					Step();  					break;  					case DTokens.Identifier:  					var opCode = AsmStatement.InstructionStatement.OpCode.__UNKNOWN__;  					var dataType = AsmStatement.RawDataStatement.DataType.__UNKNOWN__;  					if (Peek(1).Kind == Colon)  					{  						l.Add(new LabeledStatement() { Location = la.Location' Parent = s' Identifier = la.Value' EndLocation = Peek(1).EndLocation });  						Step();  						Step();  						if (laKind == Semicolon)  							Step();  						continue;  					}    					if (AsmStatement.RawDataStatement.TryParseDataType(la.Value' out dataType))  						l.Add(new AsmStatement.RawDataStatement() { Location = la.Location' Parent = s' TypeOfData = dataType });  					else if (AsmStatement.InstructionStatement.TryParseOpCode(la.Value' out opCode))  						l.Add(new AsmStatement.InstructionStatement() { Location = la.Location' Parent = s' Operation = opCode });  					else switch (la.Value.ToLower())  					{  						case "pause":  							SynErr(Identifier' "Pause is not supported by dmd's assembler. Use `rep; nop;` instead to achieve the same effect.");  							break;  						case "even":  							als = new AsmStatement.AlignStatement() { Location = la.Location' Parent = s };  							als.ValueExpression = new IdentifierExpression(2) { Location = la.Location' EndLocation = la.EndLocation };  							l.Add(als);  							break;  						case "naked":  							noStatement = true;  							break;  						default:  							SynErr(Identifier' "Unknown op-code!");  							l.Add(new AsmStatement.InstructionStatement() { Location = la.Location' Parent = s' Operation = AsmStatement.InstructionStatement.OpCode.__UNKNOWN__ });  							break;  					}  					Step();  					  					if (noStatement && laKind != Semicolon)  						SynErr(Semicolon);  					var parentStatement = noStatement ? s : l[l.Count - 1];  					var args = new List<IExpression>();  					if (IsEOF)  						args.Add(new TokenExpression(Incomplete));  					else if (laKind != Semicolon)  					{  						while (true)  						{  							if (laKind == CloseCurlyBrace)  							{  								// This is required as a custom error message because  								// it would complain about finding an identifier instead.  								SynErr(Semicolon' "; expected' } found");  								break;  							}  							var e = ParseAsmExpression(Scope' parentStatement);  							if (e != null)  								args.Add(e);  							if (laKind == Comma)  							{  								Step();  								continue;  							}  							if (IsEOF)  								args.Add(new TokenExpression(Incomplete));  							if (!Expect(Semicolon))  							{  								while (laKind != Semicolon && laKind != CloseCurlyBrace && !IsEOF)  									Step();  								if (laKind == Semicolon)  									Step();  							}    							break;  						}  					}  					else  						Step();  					if (parentStatement is AsmStatement.InstructionStatement)  						((AsmStatement.InstructionStatement)parentStatement).Arguments = args.ToArray();  					else if (parentStatement is AsmStatement.RawDataStatement)  						((AsmStatement.RawDataStatement)parentStatement).Data = args.ToArray();  					break;  					case DTokens.Semicolon:  						Step();  						break;  					case DTokens.Literal:  						l.Add(new AsmStatement.RawDataStatement {   							Location = la.Location'   							Data = new[] { ParseAsmPrimaryExpression(Scope' Parent) }'  							EndLocation = t.EndLocation'   							Parent = Parent  						});    						Expect(DTokens.Semicolon);  						break;  					default:  					string val;  					if (!retrying && Keywords.TryGetValue(laKind' out val))  					{  						la.LiteralValue = val;  						la.Kind = Identifier;  						Lexer.laKind = Identifier;  						retrying = true;  						goto Retry;  					}  					else  					{  						noStatement = true;  						SynErr(Identifier);  						Step();  					}  					break;  				}    				if (!noStatement)  					l[l.Count - 1].EndLocation = t.Location;  			}
Magic Number,D_Parser.Parser,DDocParser,C:\repos\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,FindNextMacro,The following statement contains a magic number: var ddoc = new DDocParser { text = text' nextOffset = macroStart+2 };
Magic Number,D_Parser.Parser,DDocParser,C:\repos\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,Parameters,The following statement contains a magic number: while (!Finished) {  				switch(Peek())  				{  					case ''':  						if (curParam > 9) {  							Step ();  							break;  						}    						l ["$" + curParam.ToString ()] = text.Substring (paramBegin' nextOffset - paramBegin);    						Step ();    						if (curParam == 1) // Second parameter begins now -- will be $+ then  							secondParamBegin = nextOffset;  						paramBegin = nextOffset;    						curParam++;  						break;  					default:  						SkipParameterText ();  						break;  				}  			}
Magic Number,D_Parser.Parser,DDocParser,C:\repos\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,Parameters,The following statement contains a magic number: if(curParam > 1 && curParam < 9)  				l ["$" + curParam.ToString ()] = text.Substring (paramBegin' nextOffset - paramBegin);
Magic Number,D_Parser.Parser,DDocParser,C:\repos\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,SkipParameterText,The following statement contains a magic number: switch (Peek ()) {  				case '(':  					SkipParentheses ();  					break;  				case '"':  				case '\'':  					SkipString ();  					break;  				case '<':  					Read ();  					if (Peek () == '!' &&  					    nextOffset + 2 < text.Length &&  					    text [nextOffset + 1] == '-' && text [nextOffset + 2] == '-') {  						Step (); // !  						Step (); // -  						Step (); // -  						SkipHtmlComment ();  					} else  						SkipParameterText ();  					break;  				case '\0':  				case ')':  					break;  				default:  					Step ();  					break;  			}
Magic Number,D_Parser.Parser,DDocParser,C:\repos\aBothe_D_Parser\DParser2\Parser\DDocParser.cs,SkipParameterText,The following statement contains a magic number: switch (Peek ()) {  				case '(':  					SkipParentheses ();  					break;  				case '"':  				case '\'':  					SkipString ();  					break;  				case '<':  					Read ();  					if (Peek () == '!' &&  					    nextOffset + 2 < text.Length &&  					    text [nextOffset + 1] == '-' && text [nextOffset + 2] == '-') {  						Step (); // !  						Step (); // -  						Step (); // -  						SkipHtmlComment ();  					} else  						SkipParameterText ();  					break;  				case '\0':  				case ')':  					break;  				default:  					Step ();  					break;  			}
Magic Number,D_Parser.Dom.Statements,InstructionStatement,C:\repos\aBothe_D_Parser\DParser2\Dom\Statements\InstructionStatement.cs,InstructionStatement,The following statement contains a magic number: foreach (var mi in typeof(OpCode).GetMembers())  				{  					if (mi.MemberType == MemberTypes.Field && mi.Name != "value__")  					{  						string opCodeName = mi.Name;  						string opCodeDescription = "";  						bool invalid32Bit = false;  						bool invalid64Bit = false;  						bool incomplete = false;  						IS iset = IS.X86;  						var argumentForms = new List<AT[]>(16);    						foreach (var at in mi.GetCustomAttributes(false))  						{  							if (at is NameAttribute)  								opCodeName = ((NameAttribute)at).Name;  							else if (at is DescriptionAttribute)  								opCodeDescription = ((DescriptionAttribute)at).Description;  							else if (at is InstructionSetAttribute)  								iset = ((InstructionSetAttribute)at).Set;    							invalid32Bit |= at is Invalid32BitAttribute;  							invalid64Bit |= at is Invalid64BitAttribute;  							incomplete |= at is IncompleteAttribute;  						}    						opCodeName = string.Intern(opCodeName);  						if (!invalid32Bit || !invalid64Bit)  						{  							OpCode curOpCode = (OpCode)Enum.Parse(typeof(OpCode)' mi.Name);    							OpCodeMap.Add(opCodeName' new OpCodeDescriptor(curOpCode' opCodeName' opCodeDescription' argumentForms.ToArray()' incomplete' iset' invalid32Bit' invalid64Bit));  							OpCodeReverseMap.Add(curOpCode' opCodeName);  						}  					}  				}
Magic Number,D_Parser.Dom.Statements,RawDataStatement,C:\repos\aBothe_D_Parser\DParser2\Dom\Statements\RawDataStatement.cs,ToCode,The following statement contains a magic number: var sb = new StringBuilder(Data.Length * 4);
Magic Number,D_Parser.Dom.Statements,AlignStatement,C:\repos\aBothe_D_Parser\DParser2\Dom\Statements\AlignStatement.cs,ToCode,The following statement contains a magic number: if (ie != null && ie.Value.Equals(2))  					return "even";  				else  					return "align " + ValueExpression.ToString();
Magic Number,D_Parser.Dom.Expressions,ArrayLiteralExpression,C:\repos\aBothe_D_Parser\DParser2\Dom\Expressions\ArrayLiteralExpression.cs,ToString,The following statement contains a magic number: if (Elements != null)  				for (int i = 0; i < Elements.Count; i++)  				{  					s += Elements[i].ToString() + "' ";  					if (i == 100)  					{  						s += "...";  						break;  					}  				}
Missing Default,D_Parser.Dom,BuiltInAtAttribute,C:\repos\aBothe_D_Parser\DParser2\Dom\Attribute.cs,ToString,The following switch statement is missing a default case: switch (Kind)  			{  				case BuiltInAttributes.Disable:  					return "@disable";  				case BuiltInAttributes.Property:  					return "@property";  				case BuiltInAttributes.Safe:  					return "@safe";  				case BuiltInAttributes.System:  					return "@system";  				case BuiltInAttributes.Trusted:  					return "@trusted";  			}
Missing Default,D_Parser.Formatting,DFormattingVisitor,C:\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,EnforceBraceStyle,The following switch statement is missing a default case: switch (braceStyle) {  				case BraceStyle.DoNotChange:  					startIndent = endIndent = null;  					break;  				case BraceStyle.EndOfLineWithoutSpace:  					startIndent = "";  					endIndent = IsLineIsEmptyUpToEol(rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString;  					break;  				case BraceStyle.EndOfLine:  					int lastNonWs;  					var lastComments = GetCommentsBefore(lBrace' out lastNonWs);  					if(lastComments.Count != 0)  					{  						// delete old bracket  						AddChange(whitespaceStart' lbraceOffset - whitespaceStart + 1' "");  					  						lbraceOffset = whitespaceStart = lastNonWs + 1;  						startIndent = " {";  					} else {  						startIndent = " ";  					}  					endIndent = IsLineIsEmptyUpToEol(rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString;  					break;  				case BraceStyle.NextLine:  					startIndent = this.options.EolMarker + curIndent.IndentString;  					endIndent = IsLineIsEmptyUpToEol(rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString;  					break;  				case BraceStyle.NextLineShifted2:  				case BraceStyle.NextLineShifted:  					curIndent.Push(IndentType.Block);  					startIndent = this.options.EolMarker + curIndent.IndentString;  					endIndent = IsLineIsEmptyUpToEol(rbraceOffset) ? curIndent.IndentString : this.options.EolMarker + curIndent.IndentString;  					curIndent.Pop ();  					break;  			}
Missing Default,D_Parser.Formatting,DFormattingVisitor,C:\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,Visit,The following switch statement is missing a default case: switch(n.SpecialType)  			{  				case DMethod.MethodType.Destructor:  				case DMethod.MethodType.Constructor:  					nameLength = 4; // this  					break;  				case DMethod.MethodType.Normal:  					nameLength = n.Name.Length;  					break;  			}
Missing Default,D_Parser.Formatting,DFormattingVisitor,C:\repos\aBothe_D_Parser\DParser2\Formatting\DFormattingVisitor.cs,Visit,The following switch statement is missing a default case: switch(policy.MultiVariableDeclPlacement)  					{  						case NewLinePlacement.NewLine:  							curIndent.Push(IndentType.Continuation);  							FixIndentationForceNewLine(n.NameLocation);  							curIndent.Pop();  							break;  						case NewLinePlacement.SameLine:  							ForceSpacesBeforeRemoveNewLines(n.NameLocation' true);  							break;  					}
Missing Default,D_Parser.Misc,CompletionOptions,C:\repos\aBothe_D_Parser\DParser2\Misc\CompletionOptions.cs,Load,The following switch statement is missing a default case: switch (x.LocalName)  				{  					case "EnableResolutionCache":  						EnableResolutionCache = x.ReadString().ToLower() == "true";  					break;  					case "CompletionTimeout":  						int.TryParse(x.ReadString()' out CompletionTimeout);  						break;  					case "EnableUFCSCompletion":  						ShowUFCSItems = x.ReadString().ToLower() == "true";  						break;  					case "EnableDeclarationConstraints":  						EnableDeclarationConstraints = x.ReadString().ToLower() == "true";  						break;  					case "MixinAnalysis":  						DisableMixinAnalysis = x.ReadString().ToLower() != "true";  						break;  					case "CompletionSuggestionMode":  						EnableSuggestionMode = x.ReadString().ToLower() == "true";  						break;  					case "HideDeprecatedNodes":  						HideDeprecatedNodes = x.ReadString().ToLower() == "true";  						break;  					case "HideDisabledNodes":  						HideDisabledNodes = x.ReadString().ToLower() == "true";  						break;  					case "ShowStructMembersInStructInitOnly":  						ShowStructMembersInStructInitOnly = x.ReadString().ToLower() == "true";  						break;  				}
Missing Default,D_Parser.Misc,VersionIdEvaluation,C:\repos\aBothe_D_Parser\DParser2\Misc\VersionIdEvaluation.cs,GetOSAndCPUVersions,The following switch statement is missing a default case: switch (OS)  			{  				case Platform.Windows:  					l.Add("Windows");  					l.Add(is64BitOS ? "Win64" : "Win32");  					break;  				case Platform.Linux:  					l.Add ("Posix");  					l.Add("linux");  					break;  				case Platform.Mac:  					l.Add("OSX");  						l.Add("darwin");  						l.Add ("Posix");  					break;  			}
Missing Default,D_Parser.Misc,ConsoleLogger,C:\repos\aBothe_D_Parser\DParser2\Misc\Logger.cs,Log,The following switch statement is missing a default case: switch (lvl) {  			case LogLevel.Debug:  				Console.Write ("Debug: ");  				break;  			case LogLevel.Error:  				Console.Write ("Error: ");  				break;  			case LogLevel.Fatal:  				Console.Write ("Fatal error: ");  				break;  			case LogLevel.Info:  				Console.Write ("Info: ");  				break;  			case LogLevel.Warn:  				Console.Write ("Warning: ");  				break;  			}
Missing Default,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,TemplateArg,The following switch statement is missing a default case: switch((char)r.Read())  			{  				case 'T':  					return new TypeDeclarationExpression(DTypeToTypeDeclVisitor.GenerateTypeDecl(Type()));  				case 'V':  					var t = Type(); // Where should the explicit type be used when there's already a value?  					return Value();  				case 'S':  					return new IdentifierExpression(LName()'LiteralFormat.StringLiteral);  			}
Missing Default,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Type,The following switch statement is missing a default case: switch(type)  			{  				case 'O':  					var t = Type();  					t.Modifier = DTokens.Shared;  					return t;  				case 'x':  					t = Type();  					t.Modifier = DTokens.Const;  					return t;  				case 'y':  					t = Type();  					t.Modifier = DTokens.Immutable;  					return t;  				case 'N':  					switch(r.Read())  					{  						case 'g':  							t = Type();  							t.Modifier = DTokens.InOut;  							return t;  						case 'e': // TypeNewArray ?  							Type();  							return null;  					}  					break;  				case 'A':  					return new ArrayType(Type());  				case 'G':  					var len = (int)Number();  					return new ArrayType(Type()' len);  				case 'H':  					var keyType = Type();  					t = Type();  					return new AssocArrayType(t' keyType);  				case 'P':  					return new PointerType(Type());  				case 'F':  				case 'U':  				case 'W':  				case 'V':  				case 'R':  					AbstractType ret;  					List<DAttribute> attrs;  					Dictionary<INode'AbstractType> pars;  					Function (out ret' out attrs' out pars' type);  						  					var dm = new DMethod { Attributes = attrs };  					dm.Parameters.AddRange (pars.Keys);  					return new MemberSymbol(dm' ret' null);  				case 'C':  				case 'S':  				case 'E':  				case 'T':  				case 'I':  				return TypeDeclarationResolver.ResolveSingle (QualifiedName ()' ctxt);  				/*  					return new MemberSymbol(null'null' QualifiedName());  				case 'C':  					return new ClassType(new DClassLike(DTokens.Class)' QualifiedName()' null);  				case 'S':  					return new StructType(new DClassLike(DTokens.Struct)' QualifiedName());  				case 'E':  					return new EnumType(new DEnum()' null' QualifiedName());  				case 'T':  					return new AliasedType(null' null' QualifiedName());  				*/case 'D':  					Function(out ret' out attrs' out pars' type);  					var dgArgs = new List<AbstractType>();  					  					foreach(var kv in pars)  						dgArgs.Add(new MemberSymbol(kv.Key as DNode' kv.Value' null));  					  					return new DelegateType(ret'new DelegateDeclaration{ Parameters = pars.Keys.ToList() }' dgArgs);  				case 'v': return new PrimitiveType(DTokens.Void);  				case 'g': return new PrimitiveType(DTokens.Byte);  				case 'h': return new PrimitiveType(DTokens.Ubyte);  				case 's': return new PrimitiveType(DTokens.Short);  				case 't': return new PrimitiveType(DTokens.Ushort);  				case 'i': return new PrimitiveType(DTokens.Int);  				case 'k': return new PrimitiveType(DTokens.Uint);  				case 'l': return new PrimitiveType(DTokens.Long);  				case 'm': return new PrimitiveType(DTokens.Ulong);  				case 'f': return new PrimitiveType(DTokens.Float);  				case 'd': return new PrimitiveType(DTokens.Double);  				case 'e': return new PrimitiveType(DTokens.Real);  				case 'o': return new PrimitiveType(DTokens.Ifloat);  				case 'p': return new PrimitiveType(DTokens.Idouble);  				case 'j': return new PrimitiveType(DTokens.Ireal);  				case 'q': return new PrimitiveType(DTokens.Cfloat);  				case 'r': return new PrimitiveType(DTokens.Cdouble);  				case 'c': return new PrimitiveType(DTokens.Creal);  				case 'b': return new PrimitiveType(DTokens.Bool);  				case 'a': return new PrimitiveType(DTokens.Char);  				case 'u': return new PrimitiveType(DTokens.Wchar);  				case 'w': return new PrimitiveType(DTokens.Dchar);  				case 'n': return null;  				  				case 'B':  					len = (int)Number();  					var items = new AbstractType[len];  					var c = (char)r.Read();  					for (int i = 0; i < len; i++)  					{  						Argument(ref c' out items[i]);  					}  					  					return new DTuple(items);  			}
Missing Default,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Type,The following switch statement is missing a default case: switch(r.Read())  					{  						case 'g':  							t = Type();  							t.Modifier = DTokens.InOut;  							return t;  						case 'e': // TypeNewArray ?  							Type();  							return null;  					}
Missing Default,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Function,The following switch statement is missing a default case: switch(callConvention)  			{  				case 'U':  					conv = "C";  					break;  				case 'W':  					conv = "Windows";  					break;  				case 'V':  					conv = "Pascal";  					break;  				case 'R':  					conv = "C++";  					break;  			}
Missing Default,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Function,The following switch statement is missing a default case: switch(r.Peek())  					{  						case 'a':  							r.Read();  							nextChar = (char)r.Read();  							attributes.Add(new Modifier(DTokens.Pure));  							continue;  						case 'b':  							r.Read();  							nextChar = (char)r.Read();  							attributes.Add(new Modifier(DTokens.Nothrow));  							continue;  						case 'c':  							r.Read();  							nextChar = (char)r.Read();  							attributes.Add(new Modifier(DTokens.Ref));  							continue;  						case 'd':  							r.Read();  							nextChar = (char)r.Read();  							attributes.Add(new BuiltInAtAttribute(BuiltInAtAttribute.BuiltInAttributes.Property));  							continue;  						case 'e':  							r.Read();  							nextChar = (char)r.Read();  							attributes.Add(new BuiltInAtAttribute(BuiltInAtAttribute.BuiltInAttributes.Trusted));  							continue;  						case 'f':  							r.Read();  							nextChar = (char)r.Read();  							attributes.Add(new BuiltInAtAttribute(BuiltInAtAttribute.BuiltInAttributes.Safe));  							continue;  					}
Missing Default,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Argument,The following switch statement is missing a default case: switch (c) {  				case 'J':  					par.Attributes.Add (new Modifier (DTokens.Out));  					break;  				case 'K':  					par.Attributes.Add (new Modifier (DTokens.Ref));  					break;  				case 'L':  					par.Attributes.Add (new Modifier (DTokens.Lazy));  					break;  				}
Missing Default,D_Parser.Misc.Mangling,Demangler,C:\repos\aBothe_D_Parser\DParser2\Misc\Mangling\Demangler.cs,Value,The following switch statement is missing a default case: switch(p)  			{  				case 'n':  					r.Read();  					return new TokenExpression(DTokens.Null);  				case 'N':  					r.Read();  					return new IdentifierExpression(-Number()' LiteralFormat.Scalar' LiteralSubformat.Integer);  				case 'i':  					r.Read();  					return new IdentifierExpression(-Number()' LiteralFormat.Scalar' LiteralSubformat.Integer | LiteralSubformat.Imaginary);  				case 'e': // HexFloat  					r.Read();  					return HexFloat();  				case 'c': // Complex  					r.Read();  					var re = HexFloat();  					r.Read(); // Skip further c  					var im = HexFloat();  					//TODO  					return re;  				case 'H':  				case 'A':  				case 'S':  					r.Read();  					var n = (int)Number();  					var xx = new List<IExpression>();  					for(int i = n; i > 0; i--)  						xx.Add(Value());  					  					if(p == 'S')  					{  						var inits = new List<StructMemberInitializer>(xx.Count);  						  						for(int i = n-1; i >= 0; i--)  							inits.Add(new StructMemberInitializer{Value = xx[i]});  						  						return new StructInitializer{MemberInitializers = inits.ToArray()};  					}  					  					if(p == 'H' || PeekIsValue) // We've got an AA  					{  						for(int i = n; i > 0; i--)  							xx.Add(Value());  						  						var kv = new List<KeyValuePair<IExpression'IExpression>>(n);  						  						for(int i = (n*2) - 1; i > 0; i-=2)  							kv.Add(new KeyValuePair<IExpression'IExpression>(xx[i-1]'xx[i]));  						  						return new AssocArrayExpression{ Elements = kv };  					}  					return new ArrayLiteralExpression(xx);  				case 'a':  				case 'w':  				case 'd':  					r.Read();  					var len = (int)Number();  					sb.Clear();  					  					for(;len > 0; len--)  						sb.Append((char)(Lexer.GetHexNumber((char)r.Read()) << 4 + Lexer.GetHexNumber((char)r.Read())));  					  					return new IdentifierExpression(sb.ToString()'   					                                LiteralFormat.StringLiteral' p == 'a' ?   					                                	LiteralSubformat.Utf8 : (p == 'w' ?   					                                    LiteralSubformat.Utf16 :   					                                                         LiteralSubformat.Utf32));  			}
Missing Default,D_Parser.Refactoring,TypeReferenceFinder,C:\repos\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,Visit,The following switch statement is missing a default case: switch(CheckCondition(s.Condition))  				{  					case 1:  						if(s.ElseStatement != null)  							invalidConditionalCodeRegions.Add(s.ElseStatement);  						if (s.ScopedStatement != null)  							s.ScopedStatement.Accept(this);  						return;  					case -1:  						if(s.ScopedStatement != null)  							invalidConditionalCodeRegions.Add(s.ScopedStatement);  						if (s.ElseStatement != null)  							s.ElseStatement.Accept(this);  						return;  				}
Missing Default,D_Parser.Refactoring,TypeReferenceFinder,C:\repos\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,VisitAttributeMetaDeclarationBlock,The following switch statement is missing a default case: switch (CheckCondition(a.AttributeOrCondition))  			{  				case 1:  					if (a.OptionalElseBlock != null)  						invalidConditionalCodeRegions.Add(a.OptionalElseBlock);  					break;  				case -1:  					invalidConditionalCodeRegions.Add(a);  					break;  			}
Missing Default,D_Parser.Refactoring,TypeReferenceFinder,C:\repos\aBothe_D_Parser\DParser2\Refactoring\TypeReferenceFinder.cs,CheckNode,The following switch statement is missing a default case: switch (CheckCondition(n.Attributes))  			{  				case -1:  					invalidConditionalCodeRegions.Add(n);  					return false;  			}
Missing Default,D_Parser.Resolver,StaticProperties,C:\repos\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,help_ReflectNonComplexType,The following switch statement is missing a default case: switch (pt.TypeToken) {  					case DTokens.Cfloat:  						return new DTokenDeclaration (DTokens.Float);  					case DTokens.Cdouble:  						return new DTokenDeclaration (DTokens.Double);  					case DTokens.Creal:  						return new DTokenDeclaration (DTokens.Real);  				}
Missing Default,D_Parser.Resolver,StaticProperties,C:\repos\aBothe_D_Parser\DParser2\Resolver\StaticProperties.cs,help_ReflectResolvedNonComplexType,The following switch statement is missing a default case: switch (pt.TypeToken) {  					case DTokens.Cfloat:  						return new PrimitiveType (DTokens.Float);  					case DTokens.Cdouble:  						return new PrimitiveType (DTokens.Double);  					case DTokens.Creal:  						return new PrimitiveType (DTokens.Real);  				}
Missing Default,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_BoolOp,The following switch statement is missing a default case: switch(x.OperatorToken)  					{  						case DTokens.GreaterThan: // greater' >  							relationIsTrue = a.Value > b.Value && (!cmpIm || a.ImaginaryPart > b.ImaginaryPart);  							break;  						case DTokens.GreaterEqual: // greater or equal' >=  							relationIsTrue = a.Value >= b.Value && a.ImaginaryPart >= b.ImaginaryPart;  							break;  						case DTokens.LessThan: // less' <  							relationIsTrue = a.Value < b.Value && (!cmpIm || a.ImaginaryPart < b.ImaginaryPart);  							break;  						case DTokens.LessEqual: // less or equal' <=  							relationIsTrue = a.Value <= b.Value && a.ImaginaryPart <= b.ImaginaryPart;  							break;  						case DTokens.Unordered: // unordered' !<>=  							relationIsTrue = unordered;  							break;  						case DTokens.LessOrGreater: // less or greater' <>  							relationIsTrue = (a.Value < b.Value || a.Value > b.Value) && (!cmpIm || (a.ImaginaryPart < b.ImaginaryPart || a.ImaginaryPart > b.ImaginaryPart));  							break;  						case DTokens.LessEqualOrGreater: // less' equal' or greater' <>=  							relationIsTrue = (a.Value < b.Value || a.Value >= b.Value) && (!cmpIm || (a.ImaginaryPart < b.ImaginaryPart || a.ImaginaryPart >= b.ImaginaryPart));  							break;  						case DTokens.UnorderedOrGreater: // unordered or greater' !<=  							relationIsTrue = unordered || (a.Value > b.Value && (!cmpIm || a.ImaginaryPart > b.ImaginaryPart));  							break;  						case DTokens.UnorderedGreaterOrEqual: // unordered' greater' or equal' !<  							relationIsTrue = unordered || (a.Value >= b.Value && a.ImaginaryPart >= b.ImaginaryPart);  							break;  						case DTokens.UnorderedOrLess: // unordered or less' !>=  							relationIsTrue = unordered || (a.Value < b.Value && (!cmpIm || a.ImaginaryPart < b.ImaginaryPart));  							break;  						case DTokens.UnorderedLessOrEqual: // unordered' less' or equal' !>  							relationIsTrue = unordered || (a.Value <= b.Value && a.ImaginaryPart <= b.ImaginaryPart);  							break;  						case DTokens.UnorderedOrEqual: // unordered or equal' !<>  							relationIsTrue = unordered || (a.Value == b.Value && a.ImaginaryPart == b.ImaginaryPart);  							break;  					}
Missing Default,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The following switch statement is missing a default case: switch(x.OperatorToken)  					{  						case DTokens.ShiftLeft:  							return (long)a.Value << (int)b.Value; // TODO: Handle the imaginary part  						case DTokens.ShiftRight:  							return (long)a.Value >> (int)b.Value;  						case DTokens.ShiftRightUnsigned: //TODO: Find out where's the difference between >> and >>>  							return (ulong)a.Value >> (int)(uint)b.Value;  					}
Missing Default,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,E_MathOp,The following switch statement is missing a default case: switch (op.OperatorToken)  					{  						case DTokens.Plus:  							return new PrimitiveValue(a.BaseTypeToken' a.Value + b.Value' a.ImaginaryPart + b.ImaginaryPart' a.Modifier);  						case DTokens.Minus:  							return new PrimitiveValue(a.BaseTypeToken' a.Value - b.Value' a.ImaginaryPart - b.ImaginaryPart' a.Modifier);  					}
Missing Default,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,evalIsExpression_EvalSpecToken,The following switch statement is missing a default case: switch (isExpression.TypeSpecializationToken)  			{  				/*  				 * To handle semantic tokens like "return" or "super" it's just needed to   				 * look into the current resolver context -  				 * then' we'll be able to gather either the parent method or the currently scoped class definition.  				 */  				case DTokens.Struct:  				case DTokens.Union:  				case DTokens.Class:  				case DTokens.Interface:  					if (r = typeToCheck is UserDefinedType &&  						((TemplateIntermediateType)typeToCheck).Definition.ClassType == isExpression.TypeSpecializationToken)  						res = typeToCheck;  					break;    				case DTokens.Enum:  					if (!(typeToCheck is EnumType))  						break;  					{  						var tr = (UserDefinedType)typeToCheck;  						r = true;  						res = tr.Base;  					}  					break;    				case DTokens.Function:  				case DTokens.Delegate:  					if (typeToCheck is DelegateType)  					{  						var isFun = false;  						var dgr = (DelegateType)typeToCheck;  						if (!dgr.IsFunctionLiteral)  							r = isExpression.TypeSpecializationToken == ((isFun = dgr.IsFunction) ? DTokens.Function : DTokens.Delegate);  						// Must be a delegate otherwise  						else  							isFun = !(r = isExpression.TypeSpecializationToken == DTokens.Delegate);    						if (r)  						{  							//TODO  							if (isFun)  							{  								// TypeTuple of the function parameter types. For C- and D-style variadic functions' only the non-variadic parameters are included.   								// For typesafe variadic functions' the ... is ignored.  							}  							else  							{  								// the function type of the delegate  							}  						}  					}  					else // Normal functions are also accepted as delegates  					{  						r = isExpression.TypeSpecializationToken == DTokens.Delegate &&  							typeToCheck is MemberSymbol &&  							((DSymbol)typeToCheck).Definition is DMethod;    						//TODO: Alias handling' same as couple of lines above  					}  					break;    				case DTokens.Super: //TODO: Test this  					var dc = DResolver.SearchClassLikeAt(ctxt.ScopedBlock' isExpression.Location) as DClassLike;    					if (dc != null)  					{  						var udt = DResolver.ResolveClassOrInterface(dc' ctxt' null' true) as ClassType;    						if (r = udt.Base != null && ResultComparer.IsEqual(typeToCheck' udt.Base))  						{  							var l = new List<AbstractType>();  							if (udt.Base != null)  								l.Add(udt.Base);  							if (udt.BaseInterfaces != null && udt.BaseInterfaces.Length != 0)  								l.AddRange(udt.BaseInterfaces);    							res = new DTuple(l);  						}  					}  					break;    				case DTokens.Const:  				case DTokens.Immutable:  				case DTokens.InOut: // TODO?  				case DTokens.Shared:  					if (r = typeToCheck.Modifier == isExpression.TypeSpecializationToken)  						res = typeToCheck;  					break;    				case DTokens.Return: // TODO: Test  					var dm = DResolver.SearchBlockAt(ctxt.ScopedBlock' isExpression.Location) as DMethod;    					if (dm != null)  					{  						var retType_ = TypeDeclarationResolver.GetMethodReturnType(dm' ctxt);    						if (r = retType_ != null && ResultComparer.IsEqual(typeToCheck' retType_))  							res = retType_;  					}  					break;  			}
Missing Default,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The following switch statement is missing a default case: switch(te.Keyword)  			{  				case "":  				case null:  					return null;  					  				case "hasMember":  					bool ret = false;  					var optionsBackup = ctxt.ContextIndependentOptions;  					ctxt.ContextIndependentOptions = ResolutionOptions.IgnoreAllProtectionAttributes;  					  					AbstractType t;  					var pfa = ExpressionTypeEvaluation.prepareMemberTraitExpression(ctxt' te' out t' ValueProvider);  					  					if(pfa != null && t != null)  					{  						t.NonStaticAccess = true;  						ignoreErrors = true;  						var res = ExpressionTypeEvaluation.EvaluateType(pfa' ctxt' false);  						ret = res != null;  						ignoreErrors = false;  					}  					ctxt.ContextIndependentOptions = optionsBackup;  					return new PrimitiveValue(ret);  					  					  				case "identifier":  					if(te.Arguments!=null && te.Arguments.Length == 1)  						return new ArrayValue(GetStringType()' te.Arguments[0].ToString());  					break;  					  					  				case "getMember":  					pfa = ExpressionTypeEvaluation.prepareMemberTraitExpression(ctxt' te' out t' ValueProvider);  					  					if(pfa == null ||t == null)  						break;  					  					var vs = EvalPostfixAccessExpression(this' ctxt' pfa't' ValueProvider:ValueProvider);  					if(vs == null || vs.Length == 0)  						return null;  					return vs[0];  					  					  				case "getOverloads":  					optionsBackup = ctxt.ContextIndependentOptions;  					ctxt.ContextIndependentOptions = ResolutionOptions.IgnoreAllProtectionAttributes;    					pfa = ExpressionTypeEvaluation.prepareMemberTraitExpression(ctxt' te' out t' ValueProvider);    					if (pfa != null && t != null)  						vs = EvalPostfixAccessExpression(this' ctxt' pfa' t);  					else  						vs = null;  					  					ctxt.ContextIndependentOptions = optionsBackup;  					  					return new TypeValue(new DTuple(vs));  					  					  				case "getProtection":  					optionsBackup = ctxt.ContextIndependentOptions;  					ctxt.ContextIndependentOptions = ResolutionOptions.IgnoreAllProtectionAttributes;  					  					var prot = "public";  					  					if(te.Arguments == null || te.Arguments.Length != 1 || te.Arguments[0] == null)  						EvalError(te' "First trait argument must be a symbol identifier");  					else  					{  						t = ExpressionTypeEvaluation.ResolveTraitArgument(ctxt'te.Arguments[0]);  						  						if(t is DSymbol)  						{  							var dn = (t as DSymbol).Definition;  							  							if(dn.ContainsAttribute(DTokens.Private))  								prot = "private";  							else if(dn.ContainsAttribute(DTokens.Protected))  								prot = "protected";  							else if(dn.ContainsAttribute(DTokens.Package))  								prot = "package";  							else if(dn.ContainsAttribute(DTokens.Export))  								prot = "export";  						}  						else  							EvalError(te' "First argument must evaluate to an existing code symbol");  					}  					  					ctxt.ContextIndependentOptions = optionsBackup;  					return new ArrayValue(GetStringType()' prot);					  					  				case "getVirtualFunctions":  					break;  				case "getVirtualMethods":  					break;  				case "parent":  					break;  				case "classInstanceSize":  					break;  				case "allMembers":  					break;  				case "derivedMembers":  					break;  					  				case "isSame":  					ret = false;  					  					if(te.Arguments == null || te.Arguments.Length < 2)  					{  						EvalError(te' "isSame requires two arguments to compare");  					}  					else  					{  						t = ExpressionTypeEvaluation.ResolveTraitArgument(ctxt' te.Arguments[0]);  						  						if(t != null)  						{  							var t2 = ExpressionTypeEvaluation.ResolveTraitArgument(ctxt' te.Arguments[1]);  							  							if(t2 != null)  								ret = Resolver.ResultComparer.IsEqual(t't2);  						}  					}  					  					return new PrimitiveValue(ret);  					  				case "compiles":  					ret = false;  					  					if(te.Arguments != null){  						foreach(var arg in te.Arguments)  						{  							ret = arg == null || ExpressionTypeEvaluation.ResolveTraitArgument(ctxt' arg) != null;  							  							if(!ret)  								break;  						}  					}  						  					return new PrimitiveValue(ret);  			}
Missing Default,D_Parser.Resolver.ExpressionSemantics,Evaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\Evaluation.Identifiers.cs,Visit,The following switch statement is missing a default case: switch(te.Keyword)  						{  							case "isArithmetic":  								var pt = t as PrimitiveType;  								ret = pt != null && (  									DTokens.IsBasicType_Integral(pt.TypeToken) ||   									DTokens.IsBasicType_FloatingPoint(pt.TypeToken));  								break;  							case "isFloating":  								pt = t as PrimitiveType;  								ret = pt != null && DTokens.IsBasicType_FloatingPoint(pt.TypeToken);  								break;  							case "isIntegral":  								pt = t as PrimitiveType;  								ret = pt != null && DTokens.IsBasicType_Integral(pt.TypeToken);  								break;  							case "isScalar":  								pt = t as PrimitiveType;  								ret = pt != null && DTokens.IsBasicType(pt.TypeToken);  								break;  							case "isUnsigned":  								pt = t as PrimitiveType;  								ret = pt != null && DTokens.IsBasicType_Unsigned(pt.TypeToken);  								break;  									  							case "isAbstractClass":  								ret = t is ClassType && (t as ClassType).Definition.ContainsAttribute(DTokens.Abstract);  								break;  							case "isFinalClass":  								ret = t is ClassType && (t as ClassType).Definition.ContainsAttribute(DTokens.Final);  								break;  								  							case "isAssociativeArray":  								ret = t is AssocArrayType && !(t is ArrayType);  								break;  							case "isStaticArray":  								ret = t is ArrayType && (t as ArrayType).IsStaticArray;  								break;  						}
Missing Default,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,The following switch statement is missing a default case: switch (mod.Token)  									{  										case DTokens.Const:  										case DTokens.Immutable:  										case DTokens.Shared:  										case DTokens.Nothrow: // ?  										// not DTokens.Pure due to some mystical reasons  											skip = true;  											break;  									}
Missing Default,D_Parser.Resolver.ExpressionSemantics,ExpressionTypeEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionTypeEvaluation.cs,Visit,The following switch statement is missing a default case: switch (te.Keyword)  			{  				case "":  				case null:  					return null;    				case "identifier":  					return GetStringType();    				case "getMember":  					pfa = prepareMemberTraitExpression(te' out t);    					if (pfa == null || t == null)  						break;    					var vs = Evaluation.EvalPostfixAccessExpression(this' ctxt' pfa' t);  					if (vs == null || vs.Length == 0)  						return null;  					return vs[0];      				case "getOverloads":  					optionsBackup = ctxt.ContextIndependentOptions;  					ctxt.ContextIndependentOptions = ResolutionOptions.IgnoreAllProtectionAttributes;    					pfa = prepareMemberTraitExpression(te' out t);    					if (pfa != null && t != null)  						vs = Evaluation.EvalPostfixAccessExpression(this' ctxt' pfa' t);  					else  						vs = null;    					ctxt.ContextIndependentOptions = optionsBackup;    					return new DTuple(vs);      				case "getProtection":  					return GetStringType();    				case "getVirtualFunctions":  					break;  				case "getVirtualMethods":  					break;  				case "parent":  					break;  				case "classInstanceSize":  					break;  				case "allMembers":  					break;  				case "derivedMembers":  					break;    				case "compiles":  						return new PrimitiveType(DTokens.Bool);  			}
Missing Default,D_Parser.Resolver.ExpressionSemantics,MathOperationEvaluation,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\MathOperationEvaluation.cs,TryCalc,The following switch statement is missing a default case: switch (op)  					{  						case MathOp.Add:  							x = i1 + i2;  							break;  						case MathOp.Sub:  							x = i1 - i2;  							break;  						case MathOp.Mul:  							x = i1 * i2;  							break;  						case MathOp.Div:  							x = i1 / i2;  							break;    						case MathOp.Xor:  							x = i1 ^ i2;  							break;  						case MathOp.Or:  							x = i1 | i2;  							break;  						case MathOp.And:  							x = i1 & i2;  							break;    						case MathOp.AndAnd:  							break;  						case MathOp.OrOr:  							break;  					}
Missing Default,D_Parser.Resolver.ExpressionSemantics,PrimitiveValue,C:\repos\aBothe_D_Parser\DParser2\Resolver\ExpressionSemantics\ExpressionValues.cs,ToCode,The following switch statement is missing a default case: switch (BaseTypeToken)  			{  				case DTokens.Void:  					return "void";  				case DTokens.Bool:  					return Value == 1M ? "true" : "false";  				case DTokens.Char:  				case DTokens.Wchar:  				case DTokens.Dchar:  					return Char.ConvertFromUtf32((int)Value);  			}
Missing Default,D_Parser.Resolver.ASTScanner,AbstractVisitor,C:\repos\aBothe_D_Parser\DParser2\Resolver\ASTScanner\AbstractVisitor.cs,CanAddMemberOfType,The following switch statement is missing a default case: switch (dc.ClassType) {  				case DTokens.Class:  					return (vis & MemberFilter.Classes) != 0;  				case DTokens.Interface:  					return (vis & MemberFilter.Interfaces) != 0;  				case DTokens.Template:  					return (vis & MemberFilter.Templates) != 0;  				case DTokens.Struct:  				case DTokens.Union:  					return dc.IsAnonymous ?  							(vis & MemberFilter.Variables) != 0 :   							(vis & MemberFilter.StructsAndUnions) != 0;  				}
Missing Default,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,SkipCurrentBlock,The following switch statement is missing a default case: switch (nextChar)  				{  					// Handle line ends  					case '\r':  					case '\n':  						HandleLineEnd((char)nextChar);  						break;    					// Handle comments  					case '/':  						int peek = ReaderPeek();  						if (peek == '/' || peek == '*' || peek == '+')  						{  							ReadComment();  							continue;  						}  						break;    					// handle string literals  					case 'r':  						int pk = ReaderPeek();  						if (pk == '"')  						{  							ReaderRead();  							ReadVerbatimString('"');  						}  						break;  					case '`':  						ReadVerbatimString(nextChar);  						break;  					case '"':  						ReadString(nextChar);  						break;  					case '\'':  						ReadChar();  						break;    					case '{':  						braceCount++;  						continue;  					case '}':  						braceCount--;  						if (braceCount < 0)  						{  							lookaheadToken = Token(laKind = DTokens.CloseCurlyBrace' Col - 1' Line);  							StartPeek();  							Peek();  							return;  						}  						break;  				}
Missing Default,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,Next,The following switch statement is missing a default case: switch (ReaderPeek())  							{  								case '{':  									return ReadTokenStringLiteral_CurlyInit();  								case '"'/* q"{{ ...}}   }}"*/:  									return ReadTokenStringLiteral_IdentInit();  							}
Missing Default,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadTokenStringLiteral_IdentInit,The following switch statement is missing a default case: switch(ReaderPeek())  				{  				case '\'':  				case '"':  				case '`': // TODO r" " missing  					tokenString.Append((char)ReaderRead());  					goto next;  				}
Missing Default,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadTokenStringLiteral_CurlyInit,The following switch statement is missing a default case: switch (tk.Kind)  				{  					case DTokens.OpenCurlyBrace:  						bracketLevel++;  						break;  					case DTokens.CloseCurlyBrace:  						if (--bracketLevel < 1)  							continue;  						break;  				}
Missing Default,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,TokenStringParsing_AppendToken,The following switch statement is missing a default case: switch (tk.LiteralFormat)  					{  						case LiteralFormat.CharLiteral:  							tokenString.Append('\'').Append(tk.LiteralValue).Append('\'');  							break;  						case LiteralFormat.None:  						case LiteralFormat.Scalar:  						case LiteralFormat.FloatingPoint:  							tokenString.Append(tk.LiteralValue);  							break;  						case LiteralFormat.StringLiteral:  							tokenString.Append('\"').Append(tk.LiteralValue).Append('\"');  							break;  						case LiteralFormat.VerbatimStringLiteral:  							//TODO: More specific distinguishment between verbatim string types  							tokenString.Append('`').Append(tk.LiteralValue).Append('`');  							break;  					}
Missing Default,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,TokenStringParsing_AppendLiteralSubFormat,The following switch statement is missing a default case: switch (tk.Subformat)  			{  				case LiteralSubformat.Utf8:  					break;  				case LiteralSubformat.Utf16:  					sb.Append('w');  					break;  				case LiteralSubformat.Utf32:  					sb.Append('d');  					break;  					//TODO  			}
Missing Default,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,TryReadExplicitStringFormat,The following switch statement is missing a default case: switch ((char)this.ReaderPeek ()) {  				case 'c':  					ReaderRead ();  					break;  				case 'd':  					subFmt = LiteralSubformat.Utf32;  					ReaderRead ();  					return;  				case 'w':  					subFmt = LiteralSubformat.Utf16;  					ReaderRead ();  					return;  			}
Missing Default,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek())  					{  						case '+':  							ReaderRead();  							return Token(DTokens.Increment' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.PlusAssign' x' y);  					}
Missing Default,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek())  					{  						case '-':  							ReaderRead();  							return Token(DTokens.Decrement' x' y);  						case '=':  							ReaderRead();  							return Token(DTokens.MinusAssign' x' y);  						case '>':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y);  					}
Missing Default,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.DivAssign' x' y' 2);  					}
Missing Default,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.ModAssign' x' y' 2);  					}
Missing Default,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek())  					{  						case '&':  							ReaderRead();  							return Token(DTokens.LogicalAnd' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseAndAssign' x' y' 2);  					}
Missing Default,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek())  					{  						case '|':  							ReaderRead();  							return Token(DTokens.LogicalOr' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.BitwiseOrAssign' x' y' 2);  					}
Missing Default,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.XorAssign' x' y' 2);  						case '^':  							ReaderRead();  							if (ReaderPeek() == '=')  							{  								ReaderRead();  								return Token(DTokens.PowAssign' x' y' 3);  							}  							return Token(DTokens.Pow' x' y' 2);  					}
Missing Default,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek())  							{  								case '=':  									ReaderRead();  									return Token(DTokens.UnorderedOrGreater' x' y' 3); // !<=  								case '>':  									ReaderRead();  									switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}  									return Token(DTokens.UnorderedOrEqual' x' y' 3); // !<>  							}
Missing Default,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek())  									{  										case '=':  											ReaderRead();  											return Token(DTokens.Unordered' x' y' 4); // !<>=  									}
Missing Default,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.TildeAssign' x' y' 2);  					}
Missing Default,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek())  					{  						case '=':  							ReaderRead();  							return Token(DTokens.Equal' x' y' 2);  						case '>':  							ReaderRead();  							return Token(DTokens.GoesTo' x' y' 2);  					}
Missing Default,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch (ReaderPeek())  					{  						case '>':  							ReaderRead();  							if (ReaderPeek() != -1)  							{  								switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}  							}  							return Token(DTokens.ShiftRight' x' y' 2);  						case '=':  							ReaderRead();  							return Token(DTokens.GreaterEqual' x' y' 2);  					}
Missing Default,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch ((char)ReaderPeek())  								{  									case '=':  										ReaderRead();  										return Token(DTokens.ShiftRightAssign' x' y' 3);  									case '>':  										ReaderRead();  										if (ReaderPeek() != -1)  										{  											switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}  											return Token(DTokens.ShiftRightUnsigned' x' y' 3); // >>>  										}  										break;  								}
Missing Default,D_Parser.Parser,Lexer,C:\repos\aBothe_D_Parser\DParser2\Parser\Lexer.cs,ReadOperator,The following switch statement is missing a default case: switch ((char)ReaderPeek())  											{  												case '=':  													ReaderRead();  													return Token(DTokens.TripleRightShiftAssign' x' y' 4);  											}
Missing Default,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,AttributeBlock,The following switch statement is missing a default case: switch ((attr as Modifier).Token)  					{  						case DTokens.Virtual:  						case DTokens.Final:  							continue;  					}
Missing Default,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,AttributeBlock,The following switch statement is missing a default case: switch ((attr as BuiltInAtAttribute).Kind)  					{  						case BuiltInAtAttribute.BuiltInAttributes.Safe:  						case BuiltInAtAttribute.BuiltInAttributes.System:  						case BuiltInAtAttribute.BuiltInAttributes.Trusted:  							continue;  					}
Missing Default,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Declaration,The following switch statement is missing a default case: switch (laKind) {  						case Identifier:  							switch (Lexer.CurrentPeekToken.Kind) {  								case __EOF__:  								case EOF:  								case DTokens.Semicolon: // enum E;  								case DTokens.Colon: // enum E : int {...}  								case DTokens.OpenCurlyBrace: // enum E {...}  									yield return EnumDeclaration (Scope);  									yield break;  							}  							break;    						case __EOF__:  						case EOF:    						case DTokens.Semicolon: // enum;  						case DTokens.Colon: // enum : int {...}  						case DTokens.OpenCurlyBrace: // enum {...}  							yield return EnumDeclaration (Scope);  							yield break;  					}
Missing Default,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,Declaration,The following switch statement is missing a default case: switch (Lexer.CurrentPeekToken.Kind) {  								case __EOF__:  								case EOF:  								case DTokens.Semicolon: // enum E;  								case DTokens.Colon: // enum E : int {...}  								case DTokens.OpenCurlyBrace: // enum E {...}  									yield return EnumDeclaration (Scope);  									yield break;  							}
Missing Default,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,IdentifierList,The following switch statement is missing a default case: switch (laKind) {  				case DTokens.This:  				case DTokens.Super:  					Step ();  					td = new DTokenDeclaration (t.Kind) { Location = t.Location' EndLocation = t.EndLocation };    					if (!Expect (DTokens.Dot))  						return td;  					break;  			}
Missing Default,D_Parser.Parser,DParser,C:\repos\aBothe_D_Parser\DParser2\Parser\Parser.cs,AtAttribute,The following switch statement is missing a default case: switch (la.Value)  				{  					case "safe":  						att = BuiltInAtAttribute.BuiltInAttributes.Safe;  						break;  					case "system":  						att = BuiltInAtAttribute.BuiltInAttributes.System;  						break;  					case "trusted":  						att = BuiltInAtAttribute.BuiltInAttributes.Trusted;  						break;  					case "property":  						att = BuiltInAtAttribute.BuiltInAttributes.Property;  						break;  					case "disable":  						att = BuiltInAtAttribute.BuiltInAttributes.Disable;  						break;  				}
Missing Default,D_Parser.Dom.Statements,GotoStatement,C:\repos\aBothe_D_Parser\DParser2\Dom\Statements\GotoStatement.cs,ToCode,The following switch statement is missing a default case: switch (StmtType)  			{  				case GotoStmtType.Identifier:  					return "goto " + LabelIdentifier + ';';  				case GotoStmtType.Default:  					return "goto default;";  				case GotoStmtType.Case:  					return "goto" + (CaseExpression == null ? "" : (' ' + CaseExpression.ToString())) + ';';  			}
Missing Default,D_Parser.Dom.Expressions,IdentifierExpression,C:\repos\aBothe_D_Parser\DParser2\Dom\Expressions\IdentifierExpression.cs,ToString,The following switch statement is missing a default case: switch (Format)  			{  				case Parser.LiteralFormat.CharLiteral:  					return "'" + (EscapeStringHash != 0 ? ("\\"+Strings.TryGet(EscapeStringHash)) : Value ?? "") + "'";  				case Parser.LiteralFormat.StringLiteral:  					return "\"" + StringValue + "\"";  				case Parser.LiteralFormat.VerbatimStringLiteral:  					return "r\"" + StringValue + "\"";  				}
